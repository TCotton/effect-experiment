{"version":3,"sources":["../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Function.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Equivalence.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/GlobalValue.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Predicate.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/errors.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Utils.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Hash.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Equal.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Inspectable.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Pipeable.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/opCodes/effect.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/version.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/effectable.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/option.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/either.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Either.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/array.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Order.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Option.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Record.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Array.ts","../src/core/Nano.ts","../src/core/LanguageServicePluginOptions.ts","../src/core/TypeScriptApi.ts","../src/core/TypeScriptUtils.ts","../src/core/LSP.ts","../src/core/KeyBuilder.ts","../src/completions/contextSelfInClasses.ts","../src/core/TypeCheckerApi.ts","../src/core/TypeCheckerUtils.ts","../src/completions/durationInput.ts","../src/core/TypeParser.ts","../src/refactors/writeTagClassAccessors.ts","../src/codegens/accessors.ts","../src/codegens.ts","../src/completions/effectCodegensComment.ts","../src/completions/effectDataClasses.ts","../src/diagnostics/catchUnfailableEffect.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Chunk.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/hashMap/config.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/hashMap/bitwise.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/stack.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/hashMap/array.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/hashMap/node.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/hashMap.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/hashSet.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/HashSet.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/data.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/opCodes/cause.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/cause.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/singleShotGen.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/core.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Data.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/encoding/common.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/encoding/base64.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/encoding/base64Url.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Encoding.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Graph.ts","../src/diagnostics/classSelfMismatch.ts","../src/diagnostics/deterministicKeys.ts","../src/diagnostics/duplicatePackage.ts","../src/diagnostics/effectGenUsesAdapter.ts","../src/diagnostics/effectInVoidSuccess.ts","../src/diagnostics/floatingEffect.ts","../src/diagnostics/genericEffectServices.ts","../src/diagnostics/importFromBarrel.ts","../src/diagnostics/leakingRequirements.ts","../src/diagnostics/missedPipeableOpportunity.ts","../src/diagnostics/missingEffectContext.ts","../src/diagnostics/missingEffectError.ts","../src/diagnostics/missingEffectServiceDependency.ts","../src/diagnostics/missingReturnYieldStar.ts","../src/diagnostics/missingStarInYieldEffectGen.ts","../src/diagnostics/multipleEffectProvide.ts","../src/diagnostics/nonObjectEffectServiceType.ts","../src/diagnostics/outdatedEffectCodegen.ts","../src/diagnostics/overriddenSchemaConstructor.ts","../src/diagnostics/returnEffectInGen.ts","../src/diagnostics/scopeInLayerEffect.ts","../src/diagnostics/strictBooleanExpressions.ts","../src/diagnostics/strictEffectProvide.ts","../src/diagnostics/tryCatchInEffectGen.ts","../src/diagnostics/unnecessaryEffectGen.ts","../src/diagnostics/unnecessaryPipe.ts","../src/diagnostics/unnecessaryPipeChain.ts","../src/diagnostics/unsupportedServiceAccessors.ts","../src/diagnostics.ts","../src/completions/effectDiagnosticsComment.ts","../src/completions/effectJsdocComment.ts","../src/completions/effectSchemaSelfInClasses.ts","../src/completions/effectSelfInClasses.ts","../src/completions/fnFunctionStar.ts","../src/completions/genFunctionStar.ts","../src/completions/rpcMakeClasses.ts","../src/completions/schemaBrand.ts","../src/completions.ts","../src/core/AutoImport.ts","../src/completions/middlewareAutoImports.ts","../src/diagnostics/middlewareAutoImportQuickfixes.ts","../src/goto/effectRpcDefinition.ts","../src/goto.ts","../src/inlays/middlewareGenLike.ts","../src/quickinfo/dedupeJsDocs.ts","../src/quickinfo/effectTypeArgs.ts","../node_modules/.pnpm/pako@2.1.0/node_modules/pako/dist/pako.esm.mjs","../src/core/LayerGraph.ts","../src/quickinfo/layerInfo.ts","../src/quickinfo.ts","../src/refactors/asyncAwaitToFn.ts","../src/refactors/asyncAwaitToFnTryPromise.ts","../src/refactors/asyncAwaitToGen.ts","../src/refactors/asyncAwaitToGenTryPromise.ts","../src/refactors/effectGenToFn.ts","../src/refactors/functionToArrow.ts","../src/refactors/layerMagic.ts","../src/refactors/makeSchemaOpaque.ts","../src/refactors/makeSchemaOpaqueWithNs.ts","../src/refactors/pipeableToDatafirst.ts","../src/refactors/removeUnnecessaryEffectGen.ts","../src/refactors/toggleLazyConst.ts","../src/refactors/togglePipeStyle.ts","../src/refactors/toggleReturnTypeAnnotation.ts","../src/refactors/toggleTypeAnnotation.ts","../src/utils/SchemaGen.ts","../src/refactors/typeToEffectSchema.ts","../src/refactors/typeToEffectSchemaClass.ts","../src/refactors/wrapWithEffectGen.ts","../src/refactors/wrapWithPipe.ts","../src/refactors.ts","../src/renames/keyStrings.ts","../src/index.ts"],"sourcesContent":["/**\n * @since 2.0.0\n */\nimport type { TypeLambda } from \"./HKT.js\"\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface FunctionTypeLambda extends TypeLambda {\n  readonly type: (a: this[\"In\"]) => this[\"Target\"]\n}\n\n/**\n * Tests if a value is a `function`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isFunction = (input: unknown): input is Function => typeof input === \"function\"\n\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * You can pass either the arity of the uncurried function or a predicate\n * which determines if the function is being used in a data-first or\n * data-last style.\n *\n * **Example** (Using arity to determine data-first or data-last style)\n *\n * ```ts\n * import { dual, pipe } from \"effect/Function\"\n *\n * const sum = dual<\n *   (that: number) => (self: number) => number,\n *   (self: number, that: number) => number\n * >(2, (self, that) => self + that)\n *\n * console.log(sum(2, 3)) // 5\n * console.log(pipe(2, sum(3))) // 5\n * ```\n *\n * **Example** (Using call signatures to define the overloads)\n *\n * ```ts\n * import { dual, pipe } from \"effect/Function\"\n *\n * const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * console.log(sum(2, 3)) // 5\n * console.log(pipe(2, sum(3))) // 5\n * ```\n *\n * **Example** (Using a predicate to determine data-first or data-last style)\n *\n * ```ts\n * import { dual, pipe } from \"effect/Function\"\n *\n * const sum = dual<\n *   (that: number) => (self: number) => number,\n *   (self: number, that: number) => number\n * >(\n *   (args) => args.length === 2,\n *   (self, that) => self + that\n * )\n *\n * console.log(sum(2, 3)) // 5\n * console.log(pipe(2, sum(3))) // 5\n * ```\n *\n * @since 2.0.0\n */\nexport const dual: {\n  /**\n   * Creates a function that can be used in a data-last (aka `pipe`able) or\n   * data-first style.\n   *\n   * The first parameter to `dual` is either the arity of the uncurried function\n   * or a predicate that determines if the function is being used in a data-first\n   * or data-last style.\n   *\n   * Using the arity is the most common use case, but there are some cases where\n   * you may want to use a predicate. For example, if you have a function that\n   * takes an optional argument, you can use a predicate to determine if the\n   * function is being used in a data-first or data-last style.\n   *\n   * You can pass either the arity of the uncurried function or a predicate\n   * which determines if the function is being used in a data-first or\n   * data-last style.\n   *\n   * **Example** (Using arity to determine data-first or data-last style)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum = dual<\n   *   (that: number) => (self: number) => number,\n   *   (self: number, that: number) => number\n   * >(2, (self, that) => self + that)\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * **Example** (Using call signatures to define the overloads)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum: {\n   *   (that: number): (self: number) => number\n   *   (self: number, that: number): number\n   * } = dual(2, (self: number, that: number): number => self + that)\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * **Example** (Using a predicate to determine data-first or data-last style)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum = dual<\n   *   (that: number) => (self: number) => number,\n   *   (self: number, that: number) => number\n   * >(\n   *   (args) => args.length === 2,\n   *   (self, that) => self + that\n   * )\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(arity: Parameters<DataFirst>[\"length\"], body: DataFirst): DataLast & DataFirst\n  /**\n   * Creates a function that can be used in a data-last (aka `pipe`able) or\n   * data-first style.\n   *\n   * The first parameter to `dual` is either the arity of the uncurried function\n   * or a predicate that determines if the function is being used in a data-first\n   * or data-last style.\n   *\n   * Using the arity is the most common use case, but there are some cases where\n   * you may want to use a predicate. For example, if you have a function that\n   * takes an optional argument, you can use a predicate to determine if the\n   * function is being used in a data-first or data-last style.\n   *\n   * You can pass either the arity of the uncurried function or a predicate\n   * which determines if the function is being used in a data-first or\n   * data-last style.\n   *\n   * **Example** (Using arity to determine data-first or data-last style)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum = dual<\n   *   (that: number) => (self: number) => number,\n   *   (self: number, that: number) => number\n   * >(2, (self, that) => self + that)\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * **Example** (Using call signatures to define the overloads)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum: {\n   *   (that: number): (self: number) => number\n   *   (self: number, that: number): number\n   * } = dual(2, (self: number, that: number): number => self + that)\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * **Example** (Using a predicate to determine data-first or data-last style)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum = dual<\n   *   (that: number) => (self: number) => number,\n   *   (self: number, that: number) => number\n   * >(\n   *   (args) => args.length === 2,\n   *   (self, that) => self + that\n   * )\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(isDataFirst: (args: IArguments) => boolean, body: DataFirst): DataLast & DataFirst\n} = function(arity, body) {\n  if (typeof arity === \"function\") {\n    return function() {\n      if (arity(arguments)) {\n        // @ts-expect-error\n        return body.apply(this, arguments)\n      }\n      return ((self: any) => body(self, ...arguments)) as any\n    }\n  }\n\n  switch (arity) {\n    case 0:\n    case 1:\n      throw new RangeError(`Invalid arity ${arity}`)\n\n    case 2:\n      return function(a, b) {\n        if (arguments.length >= 2) {\n          return body(a, b)\n        }\n        return function(self: any) {\n          return body(self, a)\n        }\n      }\n\n    case 3:\n      return function(a, b, c) {\n        if (arguments.length >= 3) {\n          return body(a, b, c)\n        }\n        return function(self: any) {\n          return body(self, a, b)\n        }\n      }\n\n    case 4:\n      return function(a, b, c, d) {\n        if (arguments.length >= 4) {\n          return body(a, b, c, d)\n        }\n        return function(self: any) {\n          return body(self, a, b, c)\n        }\n      }\n\n    case 5:\n      return function(a, b, c, d, e) {\n        if (arguments.length >= 5) {\n          return body(a, b, c, d, e)\n        }\n        return function(self: any) {\n          return body(self, a, b, c, d)\n        }\n      }\n\n    default:\n      return function() {\n        if (arguments.length >= arity) {\n          // @ts-expect-error\n          return body.apply(this, arguments)\n        }\n        const args = arguments\n        return function(self: any) {\n          return body(self, ...args)\n        }\n      }\n  }\n}\n/**\n * Apply a function to given values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, apply } from \"effect/Function\"\n * import { length } from \"effect/String\"\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const apply = <A extends ReadonlyArray<unknown>>(...a: A) => <B>(self: (...a: A) => B): B => self(...a)\n\n/**\n * A lazy argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { LazyArg, constant } from \"effect/Function\"\n *\n * const constNull: LazyArg<null> = constant(null)\n * ```\n *\n * @since 2.0.0\n */\nexport interface LazyArg<A> {\n  (): A\n}\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { FunctionN } from \"effect/Function\"\n *\n * const sum: FunctionN<[number, number], number> = (a, b) => a + b\n * ```\n *\n * @since 2.0.0\n */\nexport interface FunctionN<A extends ReadonlyArray<unknown>, B> {\n  (...args: A): B\n}\n\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const identity = <A>(a: A): A => a\n\n/**\n * A function that ensures that the type of an expression matches some type,\n * without changing the resulting type of that expression.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { satisfies } from \"effect/Function\"\n *\n * const test1 = satisfies<number>()(5 as const)\n *     //^? const test: 5\n *     // @ts-expect-error\n * const test2 = satisfies<string>()(5)\n *     //^? Argument of type 'number' is not assignable to parameter of type 'string'\n *\n * assert.deepStrictEqual(satisfies<number>()(5), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const satisfies = <A>() => <B extends A>(b: B) => b\n\n/**\n * Casts the result to the specified type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeCoerce, identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n * ```\n *\n * @since 2.0.0\n */\nexport const unsafeCoerce: <A, B>(a: A) => B = identity as any\n\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constant } from \"effect/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n * ```\n *\n * @since 2.0.0\n */\nexport const constant = <A>(value: A): LazyArg<A> => () => value\n\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constTrue } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n * ```\n *\n * @since 2.0.0\n */\nexport const constTrue: LazyArg<boolean> = constant(true)\n\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constFalse } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const constFalse: LazyArg<boolean> = constant(false)\n\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constNull } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n * ```\n *\n * @since 2.0.0\n */\nexport const constNull: LazyArg<null> = constant(null)\n\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constUndefined } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n * ```\n *\n * @since 2.0.0\n */\nexport const constUndefined: LazyArg<undefined> = constant(undefined)\n\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constVoid } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n * ```\n *\n * @since 2.0.0\n */\nexport const constVoid: LazyArg<void> = constUndefined\n\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { flip } from \"effect/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n * ```\n *\n * @since 2.0.0\n */\nexport const flip = <A extends Array<unknown>, B extends Array<unknown>, C>(\n  f: (...a: A) => (...b: B) => C\n): (...b: B) => (...a: A) => C =>\n(...b) =>\n(...a) => f(...a)(...b)\n\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { compose } from \"effect/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n * ```\n *\n * @since 2.0.0\n */\nexport const compose: {\n  /**\n   * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n   * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { compose } from \"effect/Function\"\n   *\n   * const increment = (n: number) => n + 1;\n   * const square = (n: number) => n * n;\n   *\n   * assert.strictEqual(compose(increment, square)(2), 9);\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C\n  /**\n   * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n   * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { compose } from \"effect/Function\"\n   *\n   * const increment = (n: number) => n + 1;\n   * const square = (n: number) => n * n;\n   *\n   * assert.strictEqual(compose(increment, square)(2), 9);\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C\n} = dual(2, <A, B, C>(ab: (a: A) => B, bc: (b: B) => C): (a: A) => C => (a) => bc(ab(a)))\n\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly useful when it's necessary to specify that certain cases are impossible.\n *\n * @since 2.0.0\n */\nexport const absurd = <A>(_: never): A => {\n  throw new Error(\"Called `absurd` function which should be uncallable\")\n}\n\n/**\n * Creates a   version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { tupled } from \"effect/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n * ```\n *\n * @since 2.0.0\n */\nexport const tupled = <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): (a: A) => B => (a) => f(...a)\n\n/**\n * Inverse function of `tupled`\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { untupled } from \"effect/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n * ```\n *\n * @since 2.0.0\n */\nexport const untupled = <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B): (...a: A) => B => (...a) => f(a)\n\n/**\n * Pipes the value of an expression into a pipeline of functions.\n *\n * **Details**\n *\n * The `pipe` function is a utility that allows us to compose functions in a\n * readable and sequential manner. It takes the output of one function and\n * passes it as the input to the next function in the pipeline. This enables us\n * to build complex transformations by chaining multiple functions together.\n *\n * ```ts skip-type-checking\n * import { pipe } from \"effect\"\n *\n * const result = pipe(input, func1, func2, ..., funcN)\n * ```\n *\n * In this syntax, `input` is the initial value, and `func1`, `func2`, ...,\n * `funcN` are the functions to be applied in sequence. The result of each\n * function becomes the input for the next function, and the final result is\n * returned.\n *\n * Here's an illustration of how `pipe` works:\n *\n * ```\n * ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐    ┌────────┐\n * │ input │───►│ func1 │───►│ func2 │───►│  ...  │───►│ funcN │───►│ result │\n * └───────┘    └───────┘    └───────┘    └───────┘    └───────┘    └────────┘\n * ```\n *\n * It's important to note that functions passed to `pipe` must have a **single\n * argument** because they are only called with a single argument.\n *\n * **When to Use**\n *\n * This is useful in combination with data-last functions as a simulation of\n * methods:\n *\n * ```ts skip-type-checking\n * as.map(f).filter(g)\n * ```\n *\n * becomes:\n *\n * ```ts skip-type-checking\n * import { pipe, Array } from \"effect\"\n *\n * pipe(as, Array.map(f), Array.filter(g))\n * ```\n *\n * **Example** (Chaining Arithmetic Operations)\n *\n * ```ts\n * import { pipe } from \"effect\"\n *\n * // Define simple arithmetic operations\n * const increment = (x: number) => x + 1\n * const double = (x: number) => x * 2\n * const subtractTen = (x: number) => x - 10\n *\n * // Sequentially apply these operations using `pipe`\n * const result = pipe(5, increment, double, subtractTen)\n *\n * console.log(result)\n * // Output: 2\n * ```\n *\n * @since 2.0.0\n */\nexport function pipe<A>(a: A): A\nexport function pipe<A, B = never>(a: A, ab: (a: A) => B): B\nexport function pipe<A, B = never, C = never>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C\n): C\nexport function pipe<A, B = never, C = never, D = never>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D\n): D\nexport function pipe<A, B = never, C = never, D = never, E = never>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): E\nexport function pipe<A, B = never, C = never, D = never, E = never, F = never>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): F\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): G\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): H\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): I\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): J\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K\n): K\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L\n): L\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M\n): M\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N\n): N\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O\n): O\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P\n): P\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never,\n  Q = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q\n): Q\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never,\n  Q = never,\n  R = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R\n): R\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never,\n  Q = never,\n  R = never,\n  S = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S\n): S\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never,\n  Q = never,\n  R = never,\n  S = never,\n  T = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S,\n  st: (s: S) => T\n): T\nexport function pipe(\n  a: unknown,\n  ab?: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return a\n    case 2:\n      return ab!(a)\n    case 3:\n      return bc!(ab!(a))\n    case 4:\n      return cd!(bc!(ab!(a)))\n    case 5:\n      return de!(cd!(bc!(ab!(a))))\n    case 6:\n      return ef!(de!(cd!(bc!(ab!(a)))))\n    case 7:\n      return fg!(ef!(de!(cd!(bc!(ab!(a))))))\n    case 8:\n      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n    case 9:\n      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n    default: {\n      let ret = arguments[0]\n      for (let i = 1; i < arguments.length; i++) {\n        ret = arguments[i](ret)\n      }\n      return ret\n    }\n  }\n}\n\n/**\n * Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n *\n * See also [`pipe`](#pipe).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { flow } from \"effect/Function\"\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'), 6)\n * ```\n *\n * @since 2.0.0\n */\nexport function flow<A extends ReadonlyArray<unknown>, B = never>(\n  ab: (...a: A) => B\n): (...a: A) => B\nexport function flow<A extends ReadonlyArray<unknown>, B = never, C = never>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C\n): (...a: A) => C\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never\n>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D): (...a: A) => D\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): (...a: A) => E\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): (...a: A) => F\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): (...a: A) => G\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): (...a: A) => H\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): (...a: A) => I\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): (...a: A) => J\nexport function flow(\n  ab: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function,\n  ij?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return ab\n    case 2:\n      return function(this: unknown) {\n        return bc!(ab.apply(this, arguments))\n      }\n    case 3:\n      return function(this: unknown) {\n        return cd!(bc!(ab.apply(this, arguments)))\n      }\n    case 4:\n      return function(this: unknown) {\n        return de!(cd!(bc!(ab.apply(this, arguments))))\n      }\n    case 5:\n      return function(this: unknown) {\n        return ef!(de!(cd!(bc!(ab.apply(this, arguments)))))\n      }\n    case 6:\n      return function(this: unknown) {\n        return fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))\n      }\n    case 7:\n      return function(this: unknown) {\n        return gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))\n      }\n    case 8:\n      return function(this: unknown) {\n        return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))))\n      }\n    case 9:\n      return function(this: unknown) {\n        return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))))\n      }\n  }\n  return\n}\n\n/**\n * Type hole simulation.\n *\n * @since 2.0.0\n */\nexport const hole: <T>() => T = unsafeCoerce(absurd)\n\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { SK } from \"effect/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n * ```\n *\n * @since 2.0.0\n */\nexport const SK = <A, B>(_: A, b: B): B => b\n","/**\n * This module provides an implementation of the `Equivalence` type class, which defines a binary relation\n * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.\n * These properties are also known in mathematics as an \"equivalence relation\".\n *\n * @since 2.0.0\n */\nimport { dual } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\n\n/**\n * @category type class\n * @since 2.0.0\n */\nexport interface Equivalence<in A> {\n  (self: A, that: A): boolean\n}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface EquivalenceTypeLambda extends TypeLambda {\n  readonly type: Equivalence<this[\"Target\"]>\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <A>(isEquivalent: (self: A, that: A) => boolean): Equivalence<A> => (self: A, that: A): boolean =>\n  self === that || isEquivalent(self, that)\n\nconst isStrictEquivalent = (x: unknown, y: unknown) => x === y\n\n/**\n * Return an `Equivalence` that uses strict equality (===) to compare values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const strict: <A>() => Equivalence<A> = () => isStrictEquivalent\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const string: Equivalence<string> = strict()\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const number: Equivalence<number> = strict()\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const boolean: Equivalence<boolean> = strict()\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const bigint: Equivalence<bigint> = strict()\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const symbol: Equivalence<symbol> = strict()\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combine: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(that: Equivalence<A>): (self: Equivalence<A>) => Equivalence<A>\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(self: Equivalence<A>, that: Equivalence<A>): Equivalence<A>\n} = dual(2, <A>(self: Equivalence<A>, that: Equivalence<A>): Equivalence<A> => make((x, y) => self(x, y) && that(x, y)))\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineMany: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(collection: Iterable<Equivalence<A>>): (self: Equivalence<A>) => Equivalence<A>\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(self: Equivalence<A>, collection: Iterable<Equivalence<A>>): Equivalence<A>\n} = dual(2, <A>(self: Equivalence<A>, collection: Iterable<Equivalence<A>>): Equivalence<A> =>\n  make((x, y) => {\n    if (!self(x, y)) {\n      return false\n    }\n    for (const equivalence of collection) {\n      if (!equivalence(x, y)) {\n        return false\n      }\n    }\n    return true\n  }))\n\nconst isAlwaysEquivalent: Equivalence<unknown> = (_x, _y) => true\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineAll = <A>(collection: Iterable<Equivalence<A>>): Equivalence<A> =>\n  combineMany(isAlwaysEquivalent, collection)\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapInput: {\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <B, A>(f: (b: B) => A): (self: Equivalence<A>) => Equivalence<B>\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, B>(self: Equivalence<A>, f: (b: B) => A): Equivalence<B>\n} = dual(\n  2,\n  <A, B>(self: Equivalence<A>, f: (b: B) => A): Equivalence<B> => make((x, y) => self(f(x), f(y)))\n)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Date: Equivalence<Date> = mapInput(number, (date) => date.getTime())\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const product: {\n  <B>(that: Equivalence<B>): <A>(self: Equivalence<A>) => Equivalence<readonly [A, B]> // readonly because invariant\n  <A, B>(self: Equivalence<A>, that: Equivalence<B>): Equivalence<readonly [A, B]> // readonly because invariant\n} = dual(\n  2,\n  <A, B>(self: Equivalence<A>, that: Equivalence<B>): Equivalence<readonly [A, B]> =>\n    make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb))\n)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const all = <A>(collection: Iterable<Equivalence<A>>): Equivalence<ReadonlyArray<A>> => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length)\n\n    let collectionLength = 0\n    for (const equivalence of collection) {\n      if (collectionLength >= len) {\n        break\n      }\n      if (!equivalence(x[collectionLength], y[collectionLength])) {\n        return false\n      }\n      collectionLength++\n    }\n    return true\n  })\n}\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const productMany = <A>(\n  self: Equivalence<A>,\n  collection: Iterable<Equivalence<A>>\n): Equivalence<readonly [A, ...Array<A>]> /* readonly because invariant */ => {\n  const equivalence = all(collection)\n  return make((x, y) => !self(x[0], y[0]) ? false : equivalence(x.slice(1), y.slice(1)))\n}\n\n/**\n * Similar to `Promise.all` but operates on `Equivalence`s.\n *\n * ```ts skip-type-checking\n * [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>\n * ```\n *\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const tuple = <T extends ReadonlyArray<Equivalence<any>>>(\n  ...elements: T\n): Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence<infer A>] ? A : never }>> => all(elements) as any\n\n/**\n * Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const array = <A>(item: Equivalence<A>): Equivalence<ReadonlyArray<A>> =>\n  make((self, that) => {\n    if (self.length !== that.length) {\n      return false\n    }\n\n    for (let i = 0; i < self.length; i++) {\n      const isEq = item(self[i], that[i])\n      if (!isEq) {\n        return false\n      }\n    }\n\n    return true\n  })\n\n/**\n * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\n * by applying each `Equivalence` to the corresponding property of the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const struct = <R extends Record<string, Equivalence<any>>>(\n  fields: R\n): Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence<infer A>] ? A : never }> => {\n  const keys = Object.keys(fields)\n  return make((self, that) => {\n    for (const key of keys) {\n      if (!fields[key](self[key], that[key])) {\n        return false\n      }\n    }\n    return true\n  })\n}\n","/**\n * The `GlobalValue` module ensures that a single instance of a value is created globally,\n * even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)\n * or during hot-reloading in development environments like Next.js or Remix.\n *\n * It achieves this by using a versioned global store, identified by a unique `Symbol` tied to\n * the current version of the `effect` library. The store holds values that are keyed by an identifier,\n * allowing the reuse of previously computed instances across imports or reloads.\n *\n * This pattern is particularly useful in scenarios where frequent reloading can cause services or\n * single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.\n *\n * @since 2.0.0\n */\nconst globalStoreId = `effect/GlobalValue`\n\nlet globalStore: Map<unknown, any>\n\n/**\n * Retrieves or computes a global value associated with the given `id`. If the value for this `id`\n * has already been computed, it will be returned from the global store. If it does not exist yet,\n * the provided `compute` function will be executed to compute the value, store it, and then return it.\n *\n * This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments\n * like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused\n * thereafter.\n *\n * @example\n * ```ts\n * import { globalValue } from \"effect/GlobalValue\"\n *\n * // This cache will persist as long as the module is running,\n * // even if reloaded or imported elsewhere\n * const myCache = globalValue(\n *   Symbol.for(\"myCache\"),\n *   () => new WeakMap<object, number>()\n * )\n * ```\n *\n * @since 2.0.0\n */\nexport const globalValue = <A>(id: unknown, compute: () => A): A => {\n  if (!globalStore) {\n    // @ts-expect-error\n    globalThis[globalStoreId] ??= new Map()\n    // @ts-expect-error\n    globalStore = globalThis[globalStoreId] as Map<unknown, any>\n  }\n  if (!globalStore.has(id)) {\n    globalStore.set(id, compute())\n  }\n  return globalStore.get(id)!\n}\n","/**\n * This module provides a collection of functions for working with predicates and refinements.\n *\n * A `Predicate<A>` is a function that takes a value of type `A` and returns a boolean.\n * It is used to check if a value satisfies a certain condition.\n *\n * A `Refinement<A, B>` is a special type of predicate that not only checks a condition\n * but also provides a type guard, allowing TypeScript to narrow the type of the input\n * value from `A` to a more specific type `B` within a conditional block.\n *\n * The module includes:\n * - Basic predicates and refinements for common types (e.g., `isString`, `isNumber`).\n * - Combinators to create new predicates from existing ones (e.g., `and`, `or`, `not`).\n * - Advanced combinators for working with data structures (e.g., `tuple`, `struct`).\n * - Type-level utilities for inspecting predicate and refinement types.\n *\n * @since 2.0.0\n */\nimport { dual, isFunction as isFunction_ } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { TupleOf, TupleOfAtLeast } from \"./Types.js\"\n\n/**\n * Represents a function that takes a value of type `A` and returns `true` if the value\n * satisfies some condition, `false` otherwise.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n * import * as assert from \"node:assert\"\n *\n * const isEven: Predicate.Predicate<number> = (n) => n % 2 === 0\n *\n * assert.strictEqual(isEven(2), true)\n * assert.strictEqual(isEven(3), false)\n * ```\n *\n * @category models\n * @since 2.0.0\n */\nexport interface Predicate<in A> {\n  (a: A): boolean\n}\n\n/**\n * A `TypeLambda` for `Predicate`. This is used to support higher-kinded types\n * and allows `Predicate` to be used in generic contexts within the `effect` ecosystem.\n *\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface PredicateTypeLambda extends TypeLambda {\n  readonly type: Predicate<this[\"Target\"]>\n}\n\n/**\n * Represents a function that serves as a type guard.\n *\n * A `Refinement<A, B>` is a function that takes a value of type `A` and returns a\n * type predicate `a is B`, where `B` is a subtype of `A`. If the function returns\n * `true`, TypeScript will narrow the type of the input variable to `B`.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n * import * as assert from \"node:assert\"\n *\n * const isString: Predicate.Refinement<unknown, string> = (u): u is string => typeof u === \"string\"\n *\n * const value: unknown = \"hello\"\n *\n * if (isString(value)) {\n *   // value is now known to be a string\n *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n * }\n * ```\n *\n * @category models\n * @since 2.0.0\n */\nexport interface Refinement<in A, out B extends A> {\n  (a: A): a is B\n}\n\n/**\n * A namespace for type-level utilities for `Predicate`.\n *\n * @since 3.6.0\n * @category type-level\n */\nexport declare namespace Predicate {\n  /**\n   * Extracts the input type `A` from a `Predicate<A>`.\n   *\n   * @example\n   * ```ts\n   * import { type Predicate } from \"effect\"\n   *\n   * type T = Predicate.Predicate.In<Predicate.Predicate<string>> // T is string\n   * ```\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type In<T extends Any> = [T] extends [Predicate<infer _A>] ? _A : never\n  /**\n   * A type representing any `Predicate`.\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type Any = Predicate<never>\n}\n\n/**\n * A namespace for type-level utilities for `Refinement`.\n *\n * @since 3.6.0\n * @category type-level\n */\nexport declare namespace Refinement {\n  /**\n   * Extracts the input type `A` from a `Refinement<A, B>`.\n   *\n   * @example\n   * ```ts\n   * import { type Predicate } from \"effect\"\n   *\n   * type IsString = Predicate.Refinement<unknown, string>\n   * type T = Predicate.Refinement.In<IsString> // T is unknown\n   * ```\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type In<T extends Any> = [T] extends [Refinement<infer _A, infer _>] ? _A : never\n  /**\n   * Extracts the output (refined) type `B` from a `Refinement<A, B>`.\n   *\n   * @example\n   * ```ts\n   * import { type Predicate } from \"effect\"\n   *\n   * type IsString = Predicate.Refinement<unknown, string>\n   * type T = Predicate.Refinement.Out<IsString> // T is string\n   * ```\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type Out<T extends Any> = [T] extends [Refinement<infer _, infer _B>] ? _B : never\n  /**\n   * A type representing any `Refinement`.\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type Any = Refinement<any, any>\n}\n\n/**\n * Transforms a `Predicate<A>` into a `Predicate<B>` by applying a function `(b: B) => A`\n * to the input before passing it to the predicate. This is also known as \"contramap\" or\n * \"pre-composition\".\n *\n * @example\n * ```ts\n * import { Predicate, Number } from \"effect\"\n * import * as assert from \"node:assert\"\n *\n * // A predicate on numbers\n * const isPositive: Predicate.Predicate<number> = Number.greaterThan(0)\n *\n * // A function from `string` to `number`\n * const stringLength = (s: string): number => s.length\n *\n * // Create a new predicate on strings by mapping the input\n * const hasPositiveLength = Predicate.mapInput(isPositive, stringLength)\n *\n * assert.strictEqual(hasPositiveLength(\"hello\"), true)\n * assert.strictEqual(hasPositiveLength(\"\"), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const mapInput: {\n  /**\n   * Transforms a `Predicate<A>` into a `Predicate<B>` by applying a function `(b: B) => A`\n   * to the input before passing it to the predicate. This is also known as \"contramap\" or\n   * \"pre-composition\".\n   *\n   * @example\n   * ```ts\n   * import { Predicate, Number } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * // A predicate on numbers\n   * const isPositive: Predicate.Predicate<number> = Number.greaterThan(0)\n   *\n   * // A function from `string` to `number`\n   * const stringLength = (s: string): number => s.length\n   *\n   * // Create a new predicate on strings by mapping the input\n   * const hasPositiveLength = Predicate.mapInput(isPositive, stringLength)\n   *\n   * assert.strictEqual(hasPositiveLength(\"hello\"), true)\n   * assert.strictEqual(hasPositiveLength(\"\"), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>\n  /**\n   * Transforms a `Predicate<A>` into a `Predicate<B>` by applying a function `(b: B) => A`\n   * to the input before passing it to the predicate. This is also known as \"contramap\" or\n   * \"pre-composition\".\n   *\n   * @example\n   * ```ts\n   * import { Predicate, Number } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * // A predicate on numbers\n   * const isPositive: Predicate.Predicate<number> = Number.greaterThan(0)\n   *\n   * // A function from `string` to `number`\n   * const stringLength = (s: string): number => s.length\n   *\n   * // Create a new predicate on strings by mapping the input\n   * const hasPositiveLength = Predicate.mapInput(isPositive, stringLength)\n   *\n   * assert.strictEqual(hasPositiveLength(\"hello\"), true)\n   * assert.strictEqual(hasPositiveLength(\"\"), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>\n} = dual(2, <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B> => (b) => self(f(b)))\n\n/**\n * A refinement that checks if a `ReadonlyArray<T>` is a tuple with exactly `N` elements.\n * If the check is successful, the type is narrowed to `TupleOf<N, T>`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTupleOf } from \"effect/Predicate\"\n *\n * const isTupleOf3 = isTupleOf(3)\n *\n * assert.strictEqual(isTupleOf3([1, 2, 3]), true);\n * assert.strictEqual(isTupleOf3([1, 2]), false);\n *\n * const arr: number[] = [1, 2, 3];\n * if (isTupleOf(arr, 3)) {\n *   // The type of arr is now [number, number, number]\n *   const [a, b, c] = arr;\n *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n * }\n * ```\n *\n * @category guards\n * @since 3.3.0\n */\nexport const isTupleOf: {\n  /**\n   * A refinement that checks if a `ReadonlyArray<T>` is a tuple with exactly `N` elements.\n   * If the check is successful, the type is narrowed to `TupleOf<N, T>`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTupleOf } from \"effect/Predicate\"\n   *\n   * const isTupleOf3 = isTupleOf(3)\n   *\n   * assert.strictEqual(isTupleOf3([1, 2, 3]), true);\n   * assert.strictEqual(isTupleOf3([1, 2]), false);\n   *\n   * const arr: number[] = [1, 2, 3];\n   * if (isTupleOf(arr, 3)) {\n   *   // The type of arr is now [number, number, number]\n   *   const [a, b, c] = arr;\n   *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 3.3.0\n   */\n  <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>\n  /**\n   * A refinement that checks if a `ReadonlyArray<T>` is a tuple with exactly `N` elements.\n   * If the check is successful, the type is narrowed to `TupleOf<N, T>`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTupleOf } from \"effect/Predicate\"\n   *\n   * const isTupleOf3 = isTupleOf(3)\n   *\n   * assert.strictEqual(isTupleOf3([1, 2, 3]), true);\n   * assert.strictEqual(isTupleOf3([1, 2]), false);\n   *\n   * const arr: number[] = [1, 2, 3];\n   * if (isTupleOf(arr, 3)) {\n   *   // The type of arr is now [number, number, number]\n   *   const [a, b, c] = arr;\n   *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 3.3.0\n   */\n  <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>\n} = dual(2, <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T> => self.length === n)\n\n/**\n * A refinement that checks if a `ReadonlyArray<T>` is a tuple with at least `N` elements.\n * If the check is successful, the type is narrowed to `TupleOfAtLeast<N, T>`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTupleOfAtLeast } from \"effect/Predicate\"\n *\n * const isTupleOfAtLeast3 = isTupleOfAtLeast(3)\n *\n * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3]), true);\n * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3, 4]), true);\n * assert.strictEqual(isTupleOfAtLeast3([1, 2]), false);\n *\n * const arr: number[] = [1, 2, 3, 4];\n * if (isTupleOfAtLeast(arr, 3)) {\n *   // The type of arr is now [number, number, number, ...number[]]\n *   const [a, b, c] = arr;\n *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n * }\n * ```\n *\n * @category guards\n * @since 3.3.0\n */\nexport const isTupleOfAtLeast: {\n  /**\n   * A refinement that checks if a `ReadonlyArray<T>` is a tuple with at least `N` elements.\n   * If the check is successful, the type is narrowed to `TupleOfAtLeast<N, T>`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTupleOfAtLeast } from \"effect/Predicate\"\n   *\n   * const isTupleOfAtLeast3 = isTupleOfAtLeast(3)\n   *\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3]), true);\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3, 4]), true);\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2]), false);\n   *\n   * const arr: number[] = [1, 2, 3, 4];\n   * if (isTupleOfAtLeast(arr, 3)) {\n   *   // The type of arr is now [number, number, number, ...number[]]\n   *   const [a, b, c] = arr;\n   *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 3.3.0\n   */\n  <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>\n  /**\n   * A refinement that checks if a `ReadonlyArray<T>` is a tuple with at least `N` elements.\n   * If the check is successful, the type is narrowed to `TupleOfAtLeast<N, T>`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTupleOfAtLeast } from \"effect/Predicate\"\n   *\n   * const isTupleOfAtLeast3 = isTupleOfAtLeast(3)\n   *\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3]), true);\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3, 4]), true);\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2]), false);\n   *\n   * const arr: number[] = [1, 2, 3, 4];\n   * if (isTupleOfAtLeast(arr, 3)) {\n   *   // The type of arr is now [number, number, number, ...number[]]\n   *   const [a, b, c] = arr;\n   *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 3.3.0\n   */\n  <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>\n} = dual(2, <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T> => self.length >= n)\n\n/**\n * A predicate that checks if a value is \"truthy\" in JavaScript.\n * Fails for `false`, `0`, `-0`, `0n`, `\"\"`, `null`, `undefined`, and `NaN`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTruthy } from \"effect/Predicate\"\n *\n * assert.strictEqual(isTruthy(1), true)\n * assert.strictEqual(isTruthy(\"hello\"), true)\n * assert.strictEqual(isTruthy({}), true)\n *\n * assert.strictEqual(isTruthy(0), false)\n * assert.strictEqual(isTruthy(\"\"), false)\n * assert.strictEqual(isTruthy(null), false)\n * assert.strictEqual(isTruthy(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isTruthy = (input: unknown) => !!input\n\n/**\n * A refinement that checks if a value is a `Set`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isSet } from \"effect/Predicate\"\n *\n * assert.strictEqual(isSet(new Set([1, 2])), true)\n * assert.strictEqual(isSet(new Set()), true)\n *\n * assert.strictEqual(isSet({}), false)\n * assert.strictEqual(isSet([1, 2]), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSet = (input: unknown): input is Set<unknown> => input instanceof Set\n\n/**\n * A refinement that checks if a value is a `Map`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isMap } from \"effect/Predicate\"\n *\n * assert.strictEqual(isMap(new Map()), true)\n *\n * assert.strictEqual(isMap({}), false)\n * assert.strictEqual(isMap(new Set()), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isMap = (input: unknown): input is Map<unknown, unknown> => input instanceof Map\n\n/**\n * A refinement that checks if a value is a `string`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isString } from \"effect/Predicate\"\n *\n * assert.strictEqual(isString(\"hello\"), true)\n * assert.strictEqual(isString(\"\"), true)\n *\n * assert.strictEqual(isString(123), false)\n * assert.strictEqual(isString(null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isString = (input: unknown): input is string => typeof input === \"string\"\n\n/**\n * A refinement that checks if a value is a `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNumber } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNumber(123), true)\n * assert.strictEqual(isNumber(0), true)\n * assert.strictEqual(isNumber(-1.5), true)\n * assert.strictEqual(isNumber(NaN), true)\n *\n * assert.strictEqual(isNumber(\"123\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNumber = (input: unknown): input is number => typeof input === \"number\"\n\n/**\n * A refinement that checks if a value is a `boolean`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isBoolean } from \"effect/Predicate\"\n *\n * assert.strictEqual(isBoolean(true), true)\n * assert.strictEqual(isBoolean(false), true)\n *\n * assert.strictEqual(isBoolean(\"true\"), false)\n * assert.strictEqual(isBoolean(0), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBoolean = (input: unknown): input is boolean => typeof input === \"boolean\"\n\n/**\n * A refinement that checks if a value is a `bigint`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isBigInt } from \"effect/Predicate\"\n *\n * assert.strictEqual(isBigInt(1n), true)\n *\n * assert.strictEqual(isBigInt(1), false)\n * assert.strictEqual(isBigInt(\"1\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBigInt = (input: unknown): input is bigint => typeof input === \"bigint\"\n\n/**\n * A refinement that checks if a value is a `symbol`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isSymbol } from \"effect/Predicate\"\n *\n * assert.strictEqual(isSymbol(Symbol.for(\"a\")), true)\n *\n * assert.strictEqual(isSymbol(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSymbol = (input: unknown): input is symbol => typeof input === \"symbol\"\n\n// TODO: make public\n/**\n * A refinement that checks if a value is a valid `PropertyKey` (a `string`, `number`, or `symbol`).\n * @internal\n */\nexport const isPropertyKey = (u: unknown): u is PropertyKey => isString(u) || isNumber(u) || isSymbol(u)\n\n/**\n * A refinement that checks if a value is a `Function`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.strictEqual(isFunction(() => {}), true)\n * assert.strictEqual(isFunction(isFunction), true)\n *\n * assert.strictEqual(isFunction(\"function\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isFunction: (input: unknown) => input is Function = isFunction_\n\n/**\n * A refinement that checks if a value is `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUndefined } from \"effect/Predicate\"\n *\n * assert.strictEqual(isUndefined(undefined), true)\n *\n * assert.strictEqual(isUndefined(null), false)\n * assert.strictEqual(isUndefined(\"undefined\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUndefined = (input: unknown): input is undefined => input === undefined\n\n/**\n * A refinement that checks if a value is not `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotUndefined } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNotUndefined(null), true)\n * assert.strictEqual(isNotUndefined(\"value\"), true)\n *\n * assert.strictEqual(isNotUndefined(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotUndefined = <A>(input: A): input is Exclude<A, undefined> => input !== undefined\n\n/**\n * A refinement that checks if a value is `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNull } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNull(null), true)\n *\n * assert.strictEqual(isNull(undefined), false)\n * assert.strictEqual(isNull(\"null\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNull = (input: unknown): input is null => input === null\n\n/**\n * A refinement that checks if a value is not `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotNull } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNotNull(undefined), true)\n * assert.strictEqual(isNotNull(\"value\"), true)\n *\n * assert.strictEqual(isNotNull(null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotNull = <A>(input: A): input is Exclude<A, null> => input !== null\n\n/**\n * A refinement that always returns `false`. The type is narrowed to `never`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNever } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNever(1), false)\n * assert.strictEqual(isNever(null), false)\n * assert.strictEqual(isNever({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNever: (input: unknown) => input is never = (_: unknown): _ is never => false\n\n/**\n * A refinement that always returns `true`. The type is narrowed to `unknown`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUnknown } from \"effect/Predicate\"\n *\n * assert.strictEqual(isUnknown(1), true)\n * assert.strictEqual(isUnknown(null), true)\n * assert.strictEqual(isUnknown({}), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUnknown: (input: unknown) => input is unknown = (_): _ is unknown => true\n\n/**\n * Checks if the input is an object or an array.\n * @internal\n */\nexport const isRecordOrArray = (input: unknown): input is { [x: PropertyKey]: unknown } =>\n  typeof input === \"object\" && input !== null\n\n/**\n * A refinement that checks if a value is an `object`. Note that in JavaScript,\n * arrays and functions are also considered objects.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isObject } from \"effect/Predicate\"\n *\n * assert.strictEqual(isObject({}), true)\n * assert.strictEqual(isObject([]), true)\n * assert.strictEqual(isObject(() => {}), true)\n *\n * assert.strictEqual(isObject(null), false)\n * assert.strictEqual(isObject(\"hello\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isRecord to check for plain objects (excluding arrays and functions).\n */\nexport const isObject = (input: unknown): input is object => isRecordOrArray(input) || isFunction(input)\n\n/**\n * A refinement that checks if a value is an object-like value and has a specific property key.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { hasProperty } from \"effect/Predicate\"\n *\n * assert.strictEqual(hasProperty({ a: 1 }, \"a\"), true)\n * assert.strictEqual(hasProperty({ a: 1 }, \"b\"), false)\n *\n * const value: unknown = { name: \"Alice\" };\n * if (hasProperty(value, \"name\")) {\n *   // The type of `value` is narrowed to `{ name: unknown }`\n *   // and we can safely access `value.name`\n *   console.log(value.name)\n * }\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const hasProperty: {\n  /**\n   * A refinement that checks if a value is an object-like value and has a specific property key.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { hasProperty } from \"effect/Predicate\"\n   *\n   * assert.strictEqual(hasProperty({ a: 1 }, \"a\"), true)\n   * assert.strictEqual(hasProperty({ a: 1 }, \"b\"), false)\n   *\n   * const value: unknown = { name: \"Alice\" };\n   * if (hasProperty(value, \"name\")) {\n   *   // The type of `value` is narrowed to `{ name: unknown }`\n   *   // and we can safely access `value.name`\n   *   console.log(value.name)\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown }\n  /**\n   * A refinement that checks if a value is an object-like value and has a specific property key.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { hasProperty } from \"effect/Predicate\"\n   *\n   * assert.strictEqual(hasProperty({ a: 1 }, \"a\"), true)\n   * assert.strictEqual(hasProperty({ a: 1 }, \"b\"), false)\n   *\n   * const value: unknown = { name: \"Alice\" };\n   * if (hasProperty(value, \"name\")) {\n   *   // The type of `value` is narrowed to `{ name: unknown }`\n   *   // and we can safely access `value.name`\n   *   console.log(value.name)\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown }\n} = dual(\n  2,\n  <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown } =>\n    isObject(self) && (property in self)\n)\n\n/**\n * A refinement that checks if a value is an object with a `_tag` property\n * that matches the given tag. This is a powerful tool for working with\n * discriminated union types.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTagged } from \"effect/Predicate\"\n *\n * type Shape = { _tag: \"circle\"; radius: number } | { _tag: \"square\"; side: number }\n *\n * const isCircle = isTagged(\"circle\")\n *\n * const shape1: Shape = { _tag: \"circle\", radius: 10 }\n * const shape2: Shape = { _tag: \"square\", side: 5 }\n *\n * assert.strictEqual(isCircle(shape1), true)\n * assert.strictEqual(isCircle(shape2), false)\n *\n * if (isCircle(shape1)) {\n *   // shape1 is now narrowed to { _tag: \"circle\"; radius: number }\n *   assert.strictEqual(shape1.radius, 10)\n * }\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isTagged: {\n  /**\n   * A refinement that checks if a value is an object with a `_tag` property\n   * that matches the given tag. This is a powerful tool for working with\n   * discriminated union types.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTagged } from \"effect/Predicate\"\n   *\n   * type Shape = { _tag: \"circle\"; radius: number } | { _tag: \"square\"; side: number }\n   *\n   * const isCircle = isTagged(\"circle\")\n   *\n   * const shape1: Shape = { _tag: \"circle\", radius: 10 }\n   * const shape2: Shape = { _tag: \"square\", side: 5 }\n   *\n   * assert.strictEqual(isCircle(shape1), true)\n   * assert.strictEqual(isCircle(shape2), false)\n   *\n   * if (isCircle(shape1)) {\n   *   // shape1 is now narrowed to { _tag: \"circle\"; radius: number }\n   *   assert.strictEqual(shape1.radius, 10)\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <K extends string>(tag: K): (self: unknown) => self is { _tag: K }\n  /**\n   * A refinement that checks if a value is an object with a `_tag` property\n   * that matches the given tag. This is a powerful tool for working with\n   * discriminated union types.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTagged } from \"effect/Predicate\"\n   *\n   * type Shape = { _tag: \"circle\"; radius: number } | { _tag: \"square\"; side: number }\n   *\n   * const isCircle = isTagged(\"circle\")\n   *\n   * const shape1: Shape = { _tag: \"circle\", radius: 10 }\n   * const shape2: Shape = { _tag: \"square\", side: 5 }\n   *\n   * assert.strictEqual(isCircle(shape1), true)\n   * assert.strictEqual(isCircle(shape2), false)\n   *\n   * if (isCircle(shape1)) {\n   *   // shape1 is now narrowed to { _tag: \"circle\"; radius: number }\n   *   assert.strictEqual(shape1.radius, 10)\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <K extends string>(self: unknown, tag: K): self is { _tag: K }\n} = dual(\n  2,\n  <K extends string>(self: unknown, tag: K): self is { _tag: K } => hasProperty(self, \"_tag\") && self[\"_tag\"] === tag\n)\n\n/**\n * A refinement that checks if a value is either `null` or `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNullable } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNullable(null), true)\n * assert.strictEqual(isNullable(undefined), true)\n *\n * assert.strictEqual(isNullable(0), false)\n * assert.strictEqual(isNullable(\"\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isNotNullable\n */\nexport const isNullable = <A>(input: A): input is Extract<A, null | undefined> => input === null || input === undefined\n\n/**\n * A refinement that checks if a value is neither `null` nor `undefined`.\n * The type is narrowed to `NonNullable<A>`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotNullable } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNotNullable(0), true)\n * assert.strictEqual(isNotNullable(\"hello\"), true)\n *\n * assert.strictEqual(isNotNullable(null), false)\n * assert.strictEqual(isNotNullable(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isNullable\n */\nexport const isNotNullable = <A>(input: A): input is NonNullable<A> => input !== null && input !== undefined\n\n/**\n * A refinement that checks if a value is an instance of `Error`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isError } from \"effect/Predicate\"\n *\n * assert.strictEqual(isError(new Error(\"boom\")), true)\n * assert.strictEqual(isError(new TypeError(\"boom\")), true)\n *\n * assert.strictEqual(isError({ message: \"boom\" }), false)\n * assert.strictEqual(isError(\"boom\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isError = (input: unknown): input is Error => input instanceof Error\n\n/**\n * A refinement that checks if a value is a `Uint8Array`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUint8Array } from \"effect/Predicate\"\n *\n * assert.strictEqual(isUint8Array(new Uint8Array()), true)\n *\n * assert.strictEqual(isUint8Array(new Uint16Array()), false)\n * assert.strictEqual(isUint8Array([1, 2, 3]), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUint8Array = (input: unknown): input is Uint8Array => input instanceof Uint8Array\n\n/**\n * A refinement that checks if a value is a `Date` object.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isDate } from \"effect/Predicate\"\n *\n * assert.strictEqual(isDate(new Date()), true)\n *\n * assert.strictEqual(isDate(Date.now()), false) // `Date.now()` returns a number\n * assert.strictEqual(isDate(\"2023-01-01\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isDate = (input: unknown): input is Date => input instanceof Date\n\n/**\n * A refinement that checks if a value is an `Iterable`.\n * Many built-in types are iterable, such as `Array`, `string`, `Map`, and `Set`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isIterable } from \"effect/Predicate\"\n *\n * assert.strictEqual(isIterable([]), true)\n * assert.strictEqual(isIterable(\"hello\"), true)\n * assert.strictEqual(isIterable(new Set()), true)\n *\n * assert.strictEqual(isIterable({}), false)\n * assert.strictEqual(isIterable(123), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isIterable = (input: unknown): input is Iterable<unknown> =>\n  typeof input === \"string\" || hasProperty(input, Symbol.iterator)\n\n/**\n * A refinement that checks if a value is a record (i.e., a plain object).\n * This check returns `false` for arrays, `null`, and functions.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isRecord } from \"effect/Predicate\"\n *\n * assert.strictEqual(isRecord({}), true)\n * assert.strictEqual(isRecord({ a: 1 }), true)\n *\n * assert.strictEqual(isRecord([]), false)\n * assert.strictEqual(isRecord(new Date()), false)\n * assert.strictEqual(isRecord(null), false)\n * assert.strictEqual(isRecord(() => null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isObject\n */\nexport const isRecord = (input: unknown): input is { [x: string | symbol]: unknown } =>\n  isRecordOrArray(input) && !Array.isArray(input)\n\n/**\n * A refinement that checks if a value is a readonly record (i.e., a plain object).\n * This check returns `false` for arrays, `null`, and functions.\n *\n * This is an alias for `isRecord`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isReadonlyRecord } from \"effect/Predicate\"\n *\n * assert.strictEqual(isReadonlyRecord({}), true)\n * assert.strictEqual(isReadonlyRecord({ a: 1 }), true)\n *\n * assert.strictEqual(isReadonlyRecord([]), false)\n * assert.strictEqual(isReadonlyRecord(null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isReadonlyRecord: (\n  input: unknown\n) => input is { readonly [x: string | symbol]: unknown } = isRecord\n\n/**\n * A refinement that checks if a value is a `Promise`. It performs a duck-typing check\n * for `.then` and `.catch` methods.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isPromise } from \"effect/Predicate\"\n *\n * assert.strictEqual(isPromise(Promise.resolve(1)), true)\n * assert.strictEqual(isPromise(new Promise(() => {})), true)\n *\n * assert.strictEqual(isPromise({ then() {} }), false) // Missing .catch\n * assert.strictEqual(isPromise({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isPromiseLike\n */\nexport const isPromise = (\n  input: unknown\n): input is Promise<unknown> =>\n  hasProperty(input, \"then\") && \"catch\" in input && isFunction(input.then) && isFunction(input.catch)\n\n/**\n * A refinement that checks if a value is `PromiseLike`. It performs a duck-typing\n * check for a `.then` method.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isPromiseLike } from \"effect/Predicate\"\n *\n * assert.strictEqual(isPromiseLike(Promise.resolve(1)), true)\n * assert.strictEqual(isPromiseLike({ then: () => {} }), true)\n *\n * assert.strictEqual(isPromiseLike({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isPromise\n */\nexport const isPromiseLike = (\n  input: unknown\n): input is PromiseLike<unknown> => hasProperty(input, \"then\") && isFunction(input.then)\n\n/**\n * A refinement that checks if a value is a `RegExp`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * assert.strictEqual(Predicate.isRegExp(/a/), true)\n * assert.strictEqual(Predicate.isRegExp(new RegExp(\"a\")), true)\n *\n * assert.strictEqual(Predicate.isRegExp(\"/a/\"), false)\n * ```\n *\n * @category guards\n * @since 3.9.0\n */\nexport const isRegExp = (input: unknown): input is RegExp => input instanceof RegExp\n\n/**\n * Composes a `Refinement` with another `Refinement` or `Predicate`.\n *\n * This can be used to chain checks. The first refinement is applied, and if it\n * passes, the second check is applied to the same value, potentially refining\n * the type further.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n * import * as assert from \"node:assert\"\n *\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n * const minLength = (n: number) => (s: string): boolean => s.length >= n\n *\n * // Create a refinement that checks for a string with a minimum length of 3\n * const isLongString = Predicate.compose(isString, minLength(3))\n *\n * let value: unknown = \"hello\"\n *\n * assert.strictEqual(isLongString(value), true)\n * if (isLongString(value)) {\n *   // value is narrowed to string\n *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n * }\n * assert.strictEqual(isLongString(\"hi\"), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const compose: {\n  /**\n   * Composes a `Refinement` with another `Refinement` or `Predicate`.\n   *\n   * This can be used to chain checks. The first refinement is applied, and if it\n   * passes, the second check is applied to the same value, potentially refining\n   * the type further.\n   *\n   * @example\n   * ```ts\n   * import { Predicate } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const minLength = (n: number) => (s: string): boolean => s.length >= n\n   *\n   * // Create a refinement that checks for a string with a minimum length of 3\n   * const isLongString = Predicate.compose(isString, minLength(3))\n   *\n   * let value: unknown = \"hello\"\n   *\n   * assert.strictEqual(isLongString(value), true)\n   * if (isLongString(value)) {\n   *   // value is narrowed to string\n   *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n   * }\n   * assert.strictEqual(isLongString(\"hi\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B extends A, C extends B, D extends C>(bc: Refinement<C, D>): (ab: Refinement<A, B>) => Refinement<A, D>\n  /**\n   * Composes a `Refinement` with another `Refinement` or `Predicate`.\n   *\n   * This can be used to chain checks. The first refinement is applied, and if it\n   * passes, the second check is applied to the same value, potentially refining\n   * the type further.\n   *\n   * @example\n   * ```ts\n   * import { Predicate } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const minLength = (n: number) => (s: string): boolean => s.length >= n\n   *\n   * // Create a refinement that checks for a string with a minimum length of 3\n   * const isLongString = Predicate.compose(isString, minLength(3))\n   *\n   * let value: unknown = \"hello\"\n   *\n   * assert.strictEqual(isLongString(value), true)\n   * if (isLongString(value)) {\n   *   // value is narrowed to string\n   *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n   * }\n   * assert.strictEqual(isLongString(\"hi\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B extends A>(bc: Predicate<NoInfer<B>>): (ab: Refinement<A, B>) => Refinement<A, B>\n  /**\n   * Composes a `Refinement` with another `Refinement` or `Predicate`.\n   *\n   * This can be used to chain checks. The first refinement is applied, and if it\n   * passes, the second check is applied to the same value, potentially refining\n   * the type further.\n   *\n   * @example\n   * ```ts\n   * import { Predicate } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const minLength = (n: number) => (s: string): boolean => s.length >= n\n   *\n   * // Create a refinement that checks for a string with a minimum length of 3\n   * const isLongString = Predicate.compose(isString, minLength(3))\n   *\n   * let value: unknown = \"hello\"\n   *\n   * assert.strictEqual(isLongString(value), true)\n   * if (isLongString(value)) {\n   *   // value is narrowed to string\n   *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n   * }\n   * assert.strictEqual(isLongString(\"hi\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B extends A, C extends B, D extends C>(ab: Refinement<A, B>, bc: Refinement<C, D>): Refinement<A, D>\n  /**\n   * Composes a `Refinement` with another `Refinement` or `Predicate`.\n   *\n   * This can be used to chain checks. The first refinement is applied, and if it\n   * passes, the second check is applied to the same value, potentially refining\n   * the type further.\n   *\n   * @example\n   * ```ts\n   * import { Predicate } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const minLength = (n: number) => (s: string): boolean => s.length >= n\n   *\n   * // Create a refinement that checks for a string with a minimum length of 3\n   * const isLongString = Predicate.compose(isString, minLength(3))\n   *\n   * let value: unknown = \"hello\"\n   *\n   * assert.strictEqual(isLongString(value), true)\n   * if (isLongString(value)) {\n   *   // value is narrowed to string\n   *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n   * }\n   * assert.strictEqual(isLongString(\"hi\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B extends A>(ab: Refinement<A, B>, bc: Predicate<NoInfer<B>>): Refinement<A, B>\n} = dual(\n  2,\n  <A, B extends A, C extends B, D extends C>(ab: Refinement<A, B>, bc: Refinement<C, D>): Refinement<A, D> =>\n  (a): a is D => ab(a) && bc(a as C)\n)\n\n/**\n * Combines two predicates to test a tuple of two values. The first predicate tests the\n * first element of the tuple, and the second predicate tests the second element.\n *\n * @category combining\n * @since 2.0.0\n */\nexport const product =\n  <A, B>(self: Predicate<A>, that: Predicate<B>): Predicate<readonly [A, B]> /* readonly because contravariant */ =>\n  ([a, b]) => self(a) && that(b)\n\n/**\n * Takes an iterable of predicates and returns a new predicate that tests an array of values.\n * The new predicate returns `true` if each predicate at a given index is satisfied by the\n * value at the same index in the array. The check stops at the length of the shorter of\n * the two iterables (predicates or values).\n *\n * @category combining\n * @since 2.0.0\n * @see tuple for a more powerful, variadic version.\n */\nexport const all = <A>(\n  collection: Iterable<Predicate<A>>\n): Predicate<ReadonlyArray<A>> => {\n  return (as) => {\n    let collectionIndex = 0\n    for (const p of collection) {\n      if (collectionIndex >= as.length) {\n        break\n      }\n      if (p(as[collectionIndex]) === false) {\n        return false\n      }\n      collectionIndex++\n    }\n    return true\n  }\n}\n\n/**\n * Combines a predicate for a single value and an iterable of predicates for the rest of an array.\n * Useful for checking the head and tail of an array separately.\n *\n * @category combining\n * @since 2.0.0\n */\nexport const productMany = <A>(\n  self: Predicate<A>,\n  collection: Iterable<Predicate<A>>\n): Predicate<readonly [A, ...Array<A>]> /* readonly because contravariant */ => {\n  const rest = all(collection)\n  return ([head, ...tail]) => self(head) === false ? false : rest(tail)\n}\n\n/**\n * Combines an array of predicates into a single predicate that tests an array of values.\n * This function is highly type-aware and will produce a `Refinement` if any of the provided\n * predicates are `Refinement`s, allowing for powerful type-narrowing of tuples.\n *\n * - If all predicates are `Predicate<T>`, the result is `Predicate<[T, T, ...]>`.\n * - If any predicate is a `Refinement<A, B>`, the result is a `Refinement` that narrows\n *   the input tuple type to a more specific tuple type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n *\n * // Create a refinement for a [string, number] tuple\n * const isStringNumberTuple = Predicate.tuple(isString, isNumber)\n *\n * const value: [unknown, unknown] = [\"hello\", 123]\n * if (isStringNumberTuple(value)) {\n *   // value is narrowed to [string, number]\n *   const [s, n] = value\n *   assert.strictEqual(s.toUpperCase(), \"HELLO\")\n *   assert.strictEqual(n.toFixed(2), \"123.00\")\n * }\n * assert.strictEqual(isStringNumberTuple([\"hello\", \"123\"]), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const tuple: {\n  /**\n   * Combines an array of predicates into a single predicate that tests an array of values.\n   * This function is highly type-aware and will produce a `Refinement` if any of the provided\n   * predicates are `Refinement`s, allowing for powerful type-narrowing of tuples.\n   *\n   * - If all predicates are `Predicate<T>`, the result is `Predicate<[T, T, ...]>`.\n   * - If any predicate is a `Refinement<A, B>`, the result is a `Refinement` that narrows\n   *   the input tuple type to a more specific tuple type.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * // Create a refinement for a [string, number] tuple\n   * const isStringNumberTuple = Predicate.tuple(isString, isNumber)\n   *\n   * const value: [unknown, unknown] = [\"hello\", 123]\n   * if (isStringNumberTuple(value)) {\n   *   // value is narrowed to [string, number]\n   *   const [s, n] = value\n   *   assert.strictEqual(s.toUpperCase(), \"HELLO\")\n   *   assert.strictEqual(n.toFixed(2), \"123.00\")\n   * }\n   * assert.strictEqual(isStringNumberTuple([\"hello\", \"123\"]), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <T extends ReadonlyArray<Predicate.Any>>(...elements: T): [Extract<T[number], Refinement.Any>] extends [never] ? Predicate<{ readonly [I in keyof T]: Predicate.In<T[I]> }>\n    : Refinement<\n      { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.In<T[I]> : Predicate.In<T[I]> },\n      { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.Out<T[I]> : Predicate.In<T[I]> }\n    >\n} = (...elements: ReadonlyArray<Predicate.Any>) => all(elements) as any\n\n/**\n * Combines a record of predicates into a single predicate that tests a record of values.\n * This function is highly type-aware and will produce a `Refinement` if any of the provided\n * predicates are `Refinement`s, allowing for powerful type-narrowing of structs.\n *\n * - If all predicates are `Predicate<T>`, the result is `Predicate<{ k: T, ... }>`.\n * - If any predicate is a `Refinement<A, B>`, the result is a `Refinement` that narrows\n *   the input record type to a more specific record type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n *\n * const personPredicate = Predicate.struct({\n *   name: isString,\n *   age: isNumber\n * })\n *\n * const value: { name: unknown; age: unknown } = { name: \"Alice\", age: 30 }\n * if (personPredicate(value)) {\n *   // value is narrowed to { name: string; age: number }\n *   assert.strictEqual(value.name.toUpperCase(), \"ALICE\")\n *   assert.strictEqual(value.age.toFixed(0), \"30\")\n * }\n * assert.strictEqual(personPredicate({ name: \"Bob\", age: \"40\" }), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const struct: {\n  /**\n   * Combines a record of predicates into a single predicate that tests a record of values.\n   * This function is highly type-aware and will produce a `Refinement` if any of the provided\n   * predicates are `Refinement`s, allowing for powerful type-narrowing of structs.\n   *\n   * - If all predicates are `Predicate<T>`, the result is `Predicate<{ k: T, ... }>`.\n   * - If any predicate is a `Refinement<A, B>`, the result is a `Refinement` that narrows\n   *   the input record type to a more specific record type.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const personPredicate = Predicate.struct({\n   *   name: isString,\n   *   age: isNumber\n   * })\n   *\n   * const value: { name: unknown; age: unknown } = { name: \"Alice\", age: 30 }\n   * if (personPredicate(value)) {\n   *   // value is narrowed to { name: string; age: number }\n   *   assert.strictEqual(value.name.toUpperCase(), \"ALICE\")\n   *   assert.strictEqual(value.age.toFixed(0), \"30\")\n   * }\n   * assert.strictEqual(personPredicate({ name: \"Bob\", age: \"40\" }), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <R extends Record<string, Predicate.Any>>(fields: R): [Extract<R[keyof R], Refinement.Any>] extends [never] ?\n    Predicate<{ readonly [K in keyof R]: Predicate.In<R[K]> }> :\n    Refinement<\n      { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.In<R[K]> : Predicate.In<R[K]> },\n      { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.Out<R[K]> : Predicate.In<R[K]> }\n    >\n} = (<R extends Record<string, Predicate.Any>>(fields: R) => {\n  const keys = Object.keys(fields)\n  return (a: Record<string, unknown>) => {\n    for (const key of keys) {\n      if (!fields[key](a[key] as never)) {\n        return false\n      }\n    }\n    return true\n  }\n}) as any\n\n/**\n * Returns a new predicate that is the logical negation of the given predicate.\n *\n * **Note**: If the input is a `Refinement`, the resulting predicate will be a\n * simple `Predicate`, as TypeScript cannot infer the negative type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate, Number } from \"effect\"\n *\n * const isNonPositive = Predicate.not(Number.greaterThan(0))\n *\n * assert.strictEqual(isNonPositive(-1), true)\n * assert.strictEqual(isNonPositive(0), true)\n * assert.strictEqual(isNonPositive(1), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const not = <A>(self: Predicate<A>): Predicate<A> => (a) => !self(a)\n\n/**\n * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n * if at least one of the predicates returns `true`.\n *\n * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n * union of their target types (`B | C`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n *\n * const isStringOrNumber = Predicate.or(isString, isNumber)\n *\n * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n * assert.strictEqual(isStringOrNumber(123), true)\n * assert.strictEqual(isStringOrNumber(null), false)\n *\n * const value: unknown = \"world\"\n * if (isStringOrNumber(value)) {\n *   // value is narrowed to string | number\n *   console.log(value)\n * }\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const or: {\n  /**\n   * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n   * if at least one of the predicates returns `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * union of their target types (`B | C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const isStringOrNumber = Predicate.or(isString, isNumber)\n   *\n   * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n   * assert.strictEqual(isStringOrNumber(123), true)\n   * assert.strictEqual(isStringOrNumber(null), false)\n   *\n   * const value: unknown = \"world\"\n   * if (isStringOrNumber(value)) {\n   *   // value is narrowed to string | number\n   *   console.log(value)\n   * }\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B | C>\n  /**\n   * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n   * if at least one of the predicates returns `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * union of their target types (`B | C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const isStringOrNumber = Predicate.or(isString, isNumber)\n   *\n   * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n   * assert.strictEqual(isStringOrNumber(123), true)\n   * assert.strictEqual(isStringOrNumber(null), false)\n   *\n   * const value: unknown = \"world\"\n   * if (isStringOrNumber(value)) {\n   *   // value is narrowed to string | number\n   *   console.log(value)\n   * }\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B | C>\n  /**\n   * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n   * if at least one of the predicates returns `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * union of their target types (`B | C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const isStringOrNumber = Predicate.or(isString, isNumber)\n   *\n   * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n   * assert.strictEqual(isStringOrNumber(123), true)\n   * assert.strictEqual(isStringOrNumber(null), false)\n   *\n   * const value: unknown = \"world\"\n   * if (isStringOrNumber(value)) {\n   *   // value is narrowed to string | number\n   *   console.log(value)\n   * }\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n   * if at least one of the predicates returns `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * union of their target types (`B | C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const isStringOrNumber = Predicate.or(isString, isNumber)\n   *\n   * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n   * assert.strictEqual(isStringOrNumber(123), true)\n   * assert.strictEqual(isStringOrNumber(null), false)\n   *\n   * const value: unknown = \"world\"\n   * if (isStringOrNumber(value)) {\n   *   // value is narrowed to string | number\n   *   console.log(value)\n   * }\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) || that(a))\n\n/**\n * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n * only if both of the predicates return `true`.\n *\n * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n * intersection of their target types (`B & C`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * type Person = { name: string }\n * type Employee = { id: number }\n *\n * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n *\n * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n *\n * const val: unknown = { name: \"Alice\", id: 123 }\n * if (isPersonAndEmployee(val)) {\n *   // val is narrowed to Person & Employee\n *   assert.strictEqual(val.name, \"Alice\")\n *   assert.strictEqual(val.id, 123)\n * }\n *\n * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const and: {\n  /**\n   * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n   * only if both of the predicates return `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * intersection of their target types (`B & C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type Person = { name: string }\n   * type Employee = { id: number }\n   *\n   * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n   * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n   *\n   * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n   *\n   * const val: unknown = { name: \"Alice\", id: 123 }\n   * if (isPersonAndEmployee(val)) {\n   *   // val is narrowed to Person & Employee\n   *   assert.strictEqual(val.name, \"Alice\")\n   *   assert.strictEqual(val.id, 123)\n   * }\n   *\n   * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n   * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>\n  /**\n   * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n   * only if both of the predicates return `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * intersection of their target types (`B & C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type Person = { name: string }\n   * type Employee = { id: number }\n   *\n   * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n   * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n   *\n   * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n   *\n   * const val: unknown = { name: \"Alice\", id: 123 }\n   * if (isPersonAndEmployee(val)) {\n   *   // val is narrowed to Person & Employee\n   *   assert.strictEqual(val.name, \"Alice\")\n   *   assert.strictEqual(val.id, 123)\n   * }\n   *\n   * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n   * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>\n  /**\n   * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n   * only if both of the predicates return `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * intersection of their target types (`B & C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type Person = { name: string }\n   * type Employee = { id: number }\n   *\n   * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n   * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n   *\n   * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n   *\n   * const val: unknown = { name: \"Alice\", id: 123 }\n   * if (isPersonAndEmployee(val)) {\n   *   // val is narrowed to Person & Employee\n   *   assert.strictEqual(val.name, \"Alice\")\n   *   assert.strictEqual(val.id, 123)\n   * }\n   *\n   * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n   * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n   * only if both of the predicates return `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * intersection of their target types (`B & C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type Person = { name: string }\n   * type Employee = { id: number }\n   *\n   * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n   * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n   *\n   * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n   *\n   * const val: unknown = { name: \"Alice\", id: 123 }\n   * if (isPersonAndEmployee(val)) {\n   *   // val is narrowed to Person & Employee\n   *   assert.strictEqual(val.name, \"Alice\")\n   *   assert.strictEqual(val.id, 123)\n   * }\n   *\n   * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n   * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) && that(a))\n\n/**\n * Combines two predicates with a logical \"XOR\" (exclusive OR). The resulting predicate\n * returns `true` if one of the predicates returns `true`, but not both.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isPositive = (n: number) => n > 0\n * const isEven = (n: number) => n % 2 === 0\n *\n * const isPositiveXorEven = Predicate.xor(isPositive, isEven)\n *\n * assert.strictEqual(isPositiveXorEven(4), false)  // both true -> false\n * assert.strictEqual(isPositiveXorEven(3), true)   // one true -> true\n * assert.strictEqual(isPositiveXorEven(-2), true)  // one true -> true\n * assert.strictEqual(isPositiveXorEven(-1), false) // both false -> false\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const xor: {\n  /**\n   * Combines two predicates with a logical \"XOR\" (exclusive OR). The resulting predicate\n   * returns `true` if one of the predicates returns `true`, but not both.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isPositive = (n: number) => n > 0\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * const isPositiveXorEven = Predicate.xor(isPositive, isEven)\n   *\n   * assert.strictEqual(isPositiveXorEven(4), false)  // both true -> false\n   * assert.strictEqual(isPositiveXorEven(3), true)   // one true -> true\n   * assert.strictEqual(isPositiveXorEven(-2), true)  // one true -> true\n   * assert.strictEqual(isPositiveXorEven(-1), false) // both false -> false\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"XOR\" (exclusive OR). The resulting predicate\n   * returns `true` if one of the predicates returns `true`, but not both.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isPositive = (n: number) => n > 0\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * const isPositiveXorEven = Predicate.xor(isPositive, isEven)\n   *\n   * assert.strictEqual(isPositiveXorEven(4), false)  // both true -> false\n   * assert.strictEqual(isPositiveXorEven(3), true)   // one true -> true\n   * assert.strictEqual(isPositiveXorEven(-2), true)  // one true -> true\n   * assert.strictEqual(isPositiveXorEven(-1), false) // both false -> false\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) !== that(a))\n\n/**\n * Combines two predicates with a logical \"EQV\" (equivalence). The resulting predicate\n * returns `true` if both predicates return the same boolean value (both `true` or both `false`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isPositive = (n: number) => n > 0\n * const isEven = (n: number) => n % 2 === 0\n *\n * const isPositiveEqvEven = Predicate.eqv(isPositive, isEven)\n *\n * assert.strictEqual(isPositiveEqvEven(4), true)   // both true -> true\n * assert.strictEqual(isPositiveEqvEven(3), false)  // different -> false\n * assert.strictEqual(isPositiveEqvEven(-2), false) // different -> false\n * assert.strictEqual(isPositiveEqvEven(-1), true)  // both false -> true\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const eqv: {\n  /**\n   * Combines two predicates with a logical \"EQV\" (equivalence). The resulting predicate\n   * returns `true` if both predicates return the same boolean value (both `true` or both `false`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isPositive = (n: number) => n > 0\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * const isPositiveEqvEven = Predicate.eqv(isPositive, isEven)\n   *\n   * assert.strictEqual(isPositiveEqvEven(4), true)   // both true -> true\n   * assert.strictEqual(isPositiveEqvEven(3), false)  // different -> false\n   * assert.strictEqual(isPositiveEqvEven(-2), false) // different -> false\n   * assert.strictEqual(isPositiveEqvEven(-1), true)  // both false -> true\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"EQV\" (equivalence). The resulting predicate\n   * returns `true` if both predicates return the same boolean value (both `true` or both `false`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isPositive = (n: number) => n > 0\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * const isPositiveEqvEven = Predicate.eqv(isPositive, isEven)\n   *\n   * assert.strictEqual(isPositiveEqvEven(4), true)   // both true -> true\n   * assert.strictEqual(isPositiveEqvEven(3), false)  // different -> false\n   * assert.strictEqual(isPositiveEqvEven(-2), false) // different -> false\n   * assert.strictEqual(isPositiveEqvEven(-1), true)  // both false -> true\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) === that(a))\n\n/**\n * Creates a predicate that represents a logical \"if-then\" rule.\n *\n * Think of it as a conditional promise: **\"If `antecedent` holds true, then I promise `consequent` will also be true.\"**\n *\n * This function is invaluable for defining complex validation logic where one condition dictates another.\n *\n * ### How It Works\n *\n * The rule only fails (returns `false`) when the \"if\" part is `true`, but the \"then\" part is `false`.\n * In all other cases, the promise is considered kept, and the result is `true`.\n *\n * This includes the concept of **\"vacuous truth\"**: if the \"if\" part is `false`, the rule doesn't apply,\n * so the promise isn't broken, and the result is `true`. (e.g., \"If it rains, I'll bring an umbrella.\"\n * If it doesn't rain, you haven't broken your promise, no matter what).\n *\n * ### Key Details\n *\n * - **Logical Equivalence**: `implies(p, q)` is the same as `not(p).or(q)`, or simply `!p || q`\n *   in plain JavaScript. This can be a helpful way to reason about its behavior.\n *\n * - **Type-Safety Warning**: This function always returns a `Predicate`, never a type-narrowing\n *   `Refinement`. A `true` result doesn't guarantee the `consequent` passed (it could be `true`\n *   simply because the `antecedent` was `false`), so it cannot be used to safely narrow a type.\n *\n * @example\n * ```ts\n * // Rule: A user can only be an admin if they also belong to the \"staff\" group.\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * type User = {\n *   isStaff: boolean\n *   isAdmin: boolean\n * }\n *\n * const isValidUserPermission = Predicate.implies(\n *   // antecedent: \"if\" the user is an admin...\n *   (user: User) => user.isAdmin,\n *   // consequent: \"then\" they must be staff.\n *   (user: User) => user.isStaff\n * )\n *\n * // A non-admin who is not staff. Rule doesn't apply (antecedent is false).\n * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: false }), true)\n *\n * // A staff member who is not an admin. Rule doesn't apply (antecedent is false).\n * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: false }), true)\n *\n * // An admin who is also staff. The rule was followed.\n * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: true }), true)\n *\n * // An admin who is NOT staff. The rule was broken!\n * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: true }), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const implies: {\n  /**\n   * Creates a predicate that represents a logical \"if-then\" rule.\n   *\n   * Think of it as a conditional promise: **\"If `antecedent` holds true, then I promise `consequent` will also be true.\"**\n   *\n   * This function is invaluable for defining complex validation logic where one condition dictates another.\n   *\n   * ### How It Works\n   *\n   * The rule only fails (returns `false`) when the \"if\" part is `true`, but the \"then\" part is `false`.\n   * In all other cases, the promise is considered kept, and the result is `true`.\n   *\n   * This includes the concept of **\"vacuous truth\"**: if the \"if\" part is `false`, the rule doesn't apply,\n   * so the promise isn't broken, and the result is `true`. (e.g., \"If it rains, I'll bring an umbrella.\"\n   * If it doesn't rain, you haven't broken your promise, no matter what).\n   *\n   * ### Key Details\n   *\n   * - **Logical Equivalence**: `implies(p, q)` is the same as `not(p).or(q)`, or simply `!p || q`\n   *   in plain JavaScript. This can be a helpful way to reason about its behavior.\n   *\n   * - **Type-Safety Warning**: This function always returns a `Predicate`, never a type-narrowing\n   *   `Refinement`. A `true` result doesn't guarantee the `consequent` passed (it could be `true`\n   *   simply because the `antecedent` was `false`), so it cannot be used to safely narrow a type.\n   *\n   * @example\n   * ```ts\n   * // Rule: A user can only be an admin if they also belong to the \"staff\" group.\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type User = {\n   *   isStaff: boolean\n   *   isAdmin: boolean\n   * }\n   *\n   * const isValidUserPermission = Predicate.implies(\n   *   // antecedent: \"if\" the user is an admin...\n   *   (user: User) => user.isAdmin,\n   *   // consequent: \"then\" they must be staff.\n   *   (user: User) => user.isStaff\n   * )\n   *\n   * // A non-admin who is not staff. Rule doesn't apply (antecedent is false).\n   * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: false }), true)\n   *\n   * // A staff member who is not an admin. Rule doesn't apply (antecedent is false).\n   * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: false }), true)\n   *\n   * // An admin who is also staff. The rule was followed.\n   * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: true }), true)\n   *\n   * // An admin who is NOT staff. The rule was broken!\n   * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: true }), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(consequent: Predicate<A>): (antecedent: Predicate<A>) => Predicate<A>\n  /**\n   * Creates a predicate that represents a logical \"if-then\" rule.\n   *\n   * Think of it as a conditional promise: **\"If `antecedent` holds true, then I promise `consequent` will also be true.\"**\n   *\n   * This function is invaluable for defining complex validation logic where one condition dictates another.\n   *\n   * ### How It Works\n   *\n   * The rule only fails (returns `false`) when the \"if\" part is `true`, but the \"then\" part is `false`.\n   * In all other cases, the promise is considered kept, and the result is `true`.\n   *\n   * This includes the concept of **\"vacuous truth\"**: if the \"if\" part is `false`, the rule doesn't apply,\n   * so the promise isn't broken, and the result is `true`. (e.g., \"If it rains, I'll bring an umbrella.\"\n   * If it doesn't rain, you haven't broken your promise, no matter what).\n   *\n   * ### Key Details\n   *\n   * - **Logical Equivalence**: `implies(p, q)` is the same as `not(p).or(q)`, or simply `!p || q`\n   *   in plain JavaScript. This can be a helpful way to reason about its behavior.\n   *\n   * - **Type-Safety Warning**: This function always returns a `Predicate`, never a type-narrowing\n   *   `Refinement`. A `true` result doesn't guarantee the `consequent` passed (it could be `true`\n   *   simply because the `antecedent` was `false`), so it cannot be used to safely narrow a type.\n   *\n   * @example\n   * ```ts\n   * // Rule: A user can only be an admin if they also belong to the \"staff\" group.\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type User = {\n   *   isStaff: boolean\n   *   isAdmin: boolean\n   * }\n   *\n   * const isValidUserPermission = Predicate.implies(\n   *   // antecedent: \"if\" the user is an admin...\n   *   (user: User) => user.isAdmin,\n   *   // consequent: \"then\" they must be staff.\n   *   (user: User) => user.isStaff\n   * )\n   *\n   * // A non-admin who is not staff. Rule doesn't apply (antecedent is false).\n   * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: false }), true)\n   *\n   * // A staff member who is not an admin. Rule doesn't apply (antecedent is false).\n   * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: false }), true)\n   *\n   * // An admin who is also staff. The rule was followed.\n   * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: true }), true)\n   *\n   * // An admin who is NOT staff. The rule was broken!\n   * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: true }), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A> => (a) => antecedent(a) ? consequent(a) : true\n)\n\n/**\n * Combines two predicates with a logical \"NOR\" (negated OR). The resulting predicate\n * returns `true` only if both predicates return `false`.\n * This is equivalent to `not(or(p, q))`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const nor: {\n  /**\n   * Combines two predicates with a logical \"NOR\" (negated OR). The resulting predicate\n   * returns `true` only if both predicates return `false`.\n   * This is equivalent to `not(or(p, q))`.\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"NOR\" (negated OR). The resulting predicate\n   * returns `true` only if both predicates return `false`.\n   * This is equivalent to `not(or(p, q))`.\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => !(self(a) || that(a))\n)\n\n/**\n * Combines two predicates with a logical \"NAND\" (negated AND). The resulting predicate\n * returns `true` if at least one of the predicates returns `false`.\n * This is equivalent to `not(and(p, q))`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const nand: {\n  /**\n   * Combines two predicates with a logical \"NAND\" (negated AND). The resulting predicate\n   * returns `true` if at least one of the predicates returns `false`.\n   * This is equivalent to `not(and(p, q))`.\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"NAND\" (negated AND). The resulting predicate\n   * returns `true` if at least one of the predicates returns `false`.\n   * This is equivalent to `not(and(p, q))`.\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => !(self(a) && that(a))\n)\n\n/**\n * Takes an iterable of predicates and returns a new predicate. The new predicate\n * returns `true` if all predicates in the collection return `true` for a given value.\n *\n * This is like `Array.prototype.every` but for a collection of predicates.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isPositive = (n: number) => n > 0\n * const isEven = (n: number) => n % 2 === 0\n *\n * const isPositiveAndEven = Predicate.every([isPositive, isEven])\n *\n * assert.strictEqual(isPositiveAndEven(4), true)\n * assert.strictEqual(isPositiveAndEven(3), false)\n * assert.strictEqual(isPositiveAndEven(-2), false)\n * ```\n *\n * @category elements\n * @since 2.0.0\n * @see some\n */\nexport const every = <A>(collection: Iterable<Predicate<A>>): Predicate<A> => (a: A) => {\n  for (const p of collection) {\n    if (!p(a)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Takes an iterable of predicates and returns a new predicate. The new predicate\n * returns `true` if at least one predicate in the collection returns `true` for a given value.\n *\n * This is like `Array.prototype.some` but for a collection of predicates.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isNegative = (n: number) => n < 0\n * const isOdd = (n: number) => n % 2 !== 0\n *\n * const isNegativeOrOdd = Predicate.some([isNegative, isOdd])\n *\n * assert.strictEqual(isNegativeOrOdd(-2), true) // isNegative is true\n * assert.strictEqual(isNegativeOrOdd(3), true)  // isOdd is true\n * assert.strictEqual(isNegativeOrOdd(4), false) // both are false\n * ```\n *\n * @category elements\n * @since 2.0.0\n * @see every\n */\nexport const some = <A>(collection: Iterable<Predicate<A>>): Predicate<A> => (a) => {\n  for (const p of collection) {\n    if (p(a)) {\n      return true\n    }\n  }\n  return false\n}\n","/**\n * @since 2.0.0\n */\n\n/** @internal */\nexport const getBugErrorMessage = (message: string) =>\n  `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`\n","/**\n * @since 2.0.0\n */\nimport { identity } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport type { Kind, TypeLambda } from \"./HKT.js\"\nimport { getBugErrorMessage } from \"./internal/errors.js\"\nimport { isNullable, isObject } from \"./Predicate.js\"\nimport type * as Types from \"./Types.js\"\n\n/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 2.0.0\n */\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const GenKindTypeId: unique symbol = Symbol.for(\"effect/Gen/GenKind\")\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport type GenKindTypeId = typeof GenKindTypeId\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface GenKind<F extends TypeLambda, R, O, E, A> extends Variance<F, R, O, E> {\n  readonly value: Kind<F, R, O, E, A>\n\n  [Symbol.iterator](): IterableIterator<GenKind<F, R, O, E, A>, A>\n}\n\n/**\n * @category predicates\n * @since 3.0.6\n */\nexport const isGenKind = (u: unknown): u is GenKind<any, any, any, any, any> => isObject(u) && GenKindTypeId in u\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport class GenKindImpl<F extends TypeLambda, R, O, E, A> implements GenKind<F, R, O, E, A> {\n  constructor(\n    /**\n     * @since 2.0.0\n     */\n    readonly value: Kind<F, R, O, E, A>\n  ) {}\n\n  /**\n   * @since 2.0.0\n   */\n  get _F() {\n    return identity\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _R() {\n    return (_: R) => _\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _O() {\n    return (_: never): O => _\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _E() {\n    return (_: never): E => _\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  readonly [GenKindTypeId]: typeof GenKindTypeId = GenKindTypeId;\n\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator](): IterableIterator<GenKind<F, R, O, E, A>, A> {\n    return new SingleShotGen<GenKind<F, R, O, E, A>, A>(this as any)\n  }\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport class SingleShotGen<T, A> implements IterableIterator<T, A> {\n  private called = false\n\n  constructor(readonly self: T) {}\n\n  /**\n   * @since 2.0.0\n   */\n  next(a: A): IteratorResult<T, A> {\n    return this.called ?\n      ({\n        value: a,\n        done: true\n      }) :\n      (this.called = true,\n        ({\n          value: this.self,\n          done: false\n        }))\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  return(a: A): IteratorResult<T, A> {\n    return ({\n      value: a,\n      done: true\n    })\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  throw(e: unknown): IteratorResult<T, A> {\n    throw e\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator](): IterableIterator<T, A> {\n    return new SingleShotGen<T, A>(this.self)\n  }\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const makeGenKind = <F extends TypeLambda, R, O, E, A>(\n  kind: Kind<F, R, O, E, A>\n): GenKind<F, R, O, E, A> => new GenKindImpl(kind)\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Variance<in out F extends TypeLambda, in R, out O, out E> {\n  readonly [GenKindTypeId]: GenKindTypeId\n  readonly _F: Types.Invariant<F>\n  readonly _R: Types.Contravariant<R>\n  readonly _O: Types.Covariant<O>\n  readonly _E: Types.Covariant<E>\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Gen<F extends TypeLambda, Z> {\n  <Self, K extends Variance<F, any, any, any> | YieldWrap<Kind<F, any, any, any, any>>, A>(\n    ...args:\n      | [\n        self: Self,\n        body: (this: Self, resume: Z) => Generator<K, A, never>\n      ]\n      | [\n        body: (resume: Z) => Generator<K, A, never>\n      ]\n  ): Kind<\n    F,\n    [K] extends [Variance<F, infer R, any, any>] ? R\n      : [K] extends [YieldWrap<Kind<F, infer R, any, any, any>>] ? R\n      : never,\n    [K] extends [Variance<F, any, infer O, any>] ? O\n      : [K] extends [YieldWrap<Kind<F, any, infer O, any, any>>] ? O\n      : never,\n    [K] extends [Variance<F, any, any, infer E>] ? E\n      : [K] extends [YieldWrap<Kind<F, any, any, infer E, any>>] ? E\n      : never,\n    A\n  >\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Adapter<Z extends TypeLambda> {\n  <_R, _O, _E, _A>(\n    self: Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, _R, _O, _E, _A>(a: A, ab: (a: A) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>\n  <A, B, _R, _O, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: F) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n}\n\n/**\n * @category adapters\n * @since 2.0.0\n */\nexport const adapter: <F extends TypeLambda>() => Adapter<F> = () => (function() {\n  let x = arguments[0]\n  for (let i = 1; i < arguments.length; i++) {\n    x = arguments[i](x)\n  }\n  return new GenKindImpl(x) as any\n})\n\nconst defaultIncHi = 0x14057b7e\nconst defaultIncLo = 0xf767814f\nconst MUL_HI = 0x5851f42d >>> 0\nconst MUL_LO = 0x4c957f2d >>> 0\nconst BIT_53 = 9007199254740992.0\nconst BIT_27 = 134217728.0\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport type PCGRandomState = [number, number, number, number]\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport type OptionalNumber = number | null | undefined\n\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 2.0.0\n */\nexport class PCGRandom {\n  private _state!: Int32Array\n\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * - `seed` - The low 32 bits of the seed (0 is used for high 32 bits).\n   *\n   * @memberOf PCGRandom\n   */\n  constructor(seed?: OptionalNumber)\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * - `seedHi` - The high 32 bits of the seed.\n   * - `seedLo` - The low 32 bits of the seed.\n   * - `inc` - The low 32 bits of the incrementer (0 is used for high 32 bits).\n   *\n   * @memberOf PCGRandom\n   */\n  constructor(seedHi: OptionalNumber, seedLo: OptionalNumber, inc?: OptionalNumber)\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * - `seedHi` - The high 32 bits of the seed.\n   * - `seedLo` - The low 32 bits of the seed.\n   * - `incHi` - The high 32 bits of the incrementer.\n   * - `incLo` - The low 32 bits of the incrementer.\n   *\n   * @memberOf PCGRandom\n   */\n  constructor(\n    seedHi: OptionalNumber,\n    seedLo: OptionalNumber,\n    incHi: OptionalNumber,\n    incLo: OptionalNumber\n  )\n  constructor(\n    seedHi?: OptionalNumber,\n    seedLo?: OptionalNumber,\n    incHi?: OptionalNumber,\n    incLo?: OptionalNumber\n  ) {\n    if (isNullable(seedLo) && isNullable(seedHi)) {\n      seedLo = (Math.random() * 0xffffffff) >>> 0\n      seedHi = 0\n    } else if (isNullable(seedLo)) {\n      seedLo = seedHi\n      seedHi = 0\n    }\n    if (isNullable(incLo) && isNullable(incHi)) {\n      incLo = this._state ? this._state[3] : defaultIncLo\n      incHi = this._state ? this._state[2] : defaultIncHi\n    } else if (isNullable(incLo)) {\n      incLo = <number> incHi\n      incHi = 0\n    }\n\n    this._state = new Int32Array([0, 0, (<number> incHi) >>> 0, ((incLo || 0) | 1) >>> 0])\n    this._next()\n    add64(\n      this._state,\n      this._state[0]!,\n      this._state[1]!,\n      (<number> seedHi) >>> 0,\n      (<number> seedLo) >>> 0\n    )\n    this._next()\n    return this\n  }\n\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  getState(): PCGRandomState {\n    return [this._state[0]!, this._state[1]!, this._state[2]!, this._state[3]!]\n  }\n\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @since 2.0.0\n   */\n  setState(state: PCGRandomState) {\n    this._state[0] = state[0]\n    this._state[1] = state[1]\n    this._state[2] = state[2]\n    this._state[3] = state[3] | 1\n  }\n\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 2.0.0\n   */\n  integer(max: number) {\n    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max\n  }\n\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0\n    const lo = (this._next() & 0x07ffffff) * 1.0\n    return (hi * BIT_27 + lo) / BIT_53\n  }\n\n  /** @internal */\n  private _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0]! >>> 0\n    const oldLo = this._state[1]! >>> 0\n\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO)\n    add64(this._state, this._state[0]!, this._state[1]!, this._state[2]!, this._state[3]!)\n\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18\n    let xsLo = ((oldLo >>> 18) | (oldHi << 14)) >>> 0\n    xsHi = (xsHi ^ oldHi) >>> 0\n    xsLo = (xsLo ^ oldLo) >>> 0\n    const xorshifted = ((xsLo >>> 27) | (xsHi << 5)) >>> 0\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27\n    const rot2 = ((-rot >>> 0) & 31) >>> 0\n    return ((xorshifted >>> rot) | (xorshifted << rot2)) >>> 0\n  }\n}\n\nfunction mul64(\n  out: Int32Array,\n  aHi: number,\n  aLo: number,\n  bHi: number,\n  bLo: number\n): void {\n  let c1 = ((aLo >>> 16) * (bLo & 0xffff)) >>> 0\n  let c0 = ((aLo & 0xffff) * (bLo >>> 16)) >>> 0\n\n  let lo = ((aLo & 0xffff) * (bLo & 0xffff)) >>> 0\n  let hi = ((aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16))) >>> 0\n\n  c0 = (c0 << 16) >>> 0\n  lo = (lo + c0) >>> 0\n  if ((lo >>> 0) < (c0 >>> 0)) {\n    hi = (hi + 1) >>> 0\n  }\n\n  c1 = (c1 << 16) >>> 0\n  lo = (lo + c1) >>> 0\n  if ((lo >>> 0) < (c1 >>> 0)) {\n    hi = (hi + 1) >>> 0\n  }\n\n  hi = (hi + Math.imul(aLo, bHi)) >>> 0\n  hi = (hi + Math.imul(aHi, bLo)) >>> 0\n\n  out[0] = hi\n  out[1] = lo\n}\n\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(\n  out: Int32Array,\n  aHi: number,\n  aLo: number,\n  bHi: number,\n  bLo: number\n): void {\n  let hi = (aHi + bHi) >>> 0\n  const lo = (aLo + bLo) >>> 0\n  if ((lo >>> 0) < (aLo >>> 0)) {\n    hi = (hi + 1) | 0\n  }\n  out[0] = hi\n  out[1] = lo\n}\n\n/**\n * @since 3.0.6\n */\nexport const YieldWrapTypeId: unique symbol = Symbol.for(\"effect/Utils/YieldWrap\")\n\n/**\n * @since 3.0.6\n */\nexport class YieldWrap<T> {\n  /**\n   * @since 3.0.6\n   */\n  readonly #value: T\n  constructor(value: T) {\n    this.#value = value\n  }\n  /**\n   * @since 3.0.6\n   */\n  [YieldWrapTypeId](): T {\n    return this.#value\n  }\n}\n\n/**\n * @since 3.0.6\n */\nexport function yieldWrapGet<T>(self: YieldWrap<T>): T {\n  if (typeof self === \"object\" && self !== null && YieldWrapTypeId in self) {\n    return self[YieldWrapTypeId]()\n  }\n  throw new Error(getBugErrorMessage(\"yieldWrapGet\"))\n}\n\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nexport const structuralRegionState = globalValue(\n  \"effect/Utils/isStructuralRegion\",\n  (): { enabled: boolean; tester: ((a: unknown, b: unknown) => boolean) | undefined } => ({\n    enabled: false,\n    tester: undefined\n  })\n)\n\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nexport const structuralRegion = <A>(body: () => A, tester?: (a: unknown, b: unknown) => boolean): A => {\n  const current = structuralRegionState.enabled\n  const currentTester = structuralRegionState.tester\n  structuralRegionState.enabled = true\n  if (tester) {\n    structuralRegionState.tester = tester\n  }\n  try {\n    return body()\n  } finally {\n    structuralRegionState.enabled = current\n    structuralRegionState.tester = currentTester\n  }\n}\n\nconst standard = {\n  effect_internal_function: <A>(body: () => A) => {\n    return body()\n  }\n}\n\nconst forced = {\n  effect_internal_function: <A>(body: () => A) => {\n    try {\n      return body()\n    } finally {\n      //\n    }\n  }\n}\n\nconst isNotOptimizedAway =\n  standard.effect_internal_function(() => new Error().stack)?.includes(\"effect_internal_function\") === true\n\n/**\n * @since 3.2.2\n * @status experimental\n * @category tracing\n */\nexport const internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function\n\nconst genConstructor = (function*() {}).constructor\n\n/**\n * @since 3.11.0\n */\nexport const isGeneratorFunction = (u: unknown): u is (...args: Array<any>) => Generator<any, any, any> =>\n  isObject(u) && u.constructor === genConstructor\n","/**\n * @since 2.0.0\n */\nimport { pipe } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport { structuralRegionState } from \"./Utils.js\"\n\n/** @internal */\nconst randomHashCache = globalValue(\n  Symbol.for(\"effect/Hash/randomHashCache\"),\n  () => new WeakMap<object, number>()\n)\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const symbol: unique symbol = Symbol.for(\"effect/Hash\")\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Hash {\n  [symbol](): number\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const hash: <A>(self: A) => number = <A>(self: A) => {\n  if (structuralRegionState.enabled === true) {\n    return 0\n  }\n\n  switch (typeof self) {\n    case \"number\":\n      return number(self)\n    case \"bigint\":\n      return string(self.toString(10))\n    case \"boolean\":\n      return string(String(self))\n    case \"symbol\":\n      return string(String(self))\n    case \"string\":\n      return string(self)\n    case \"undefined\":\n      return string(\"undefined\")\n    case \"function\":\n    case \"object\": {\n      if (self === null) {\n        return string(\"null\")\n      } else if (self instanceof Date) {\n        return hash(self.toISOString())\n      } else if (self instanceof URL) {\n        return hash(self.href)\n      } else if (isHash(self)) {\n        return self[symbol]()\n      } else {\n        return random(self)\n      }\n    }\n    default:\n      throw new Error(\n        `BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`\n      )\n  }\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const random: <A extends object>(self: A) => number = (self) => {\n  if (!randomHashCache.has(self)) {\n    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)))\n  }\n  return randomHashCache.get(self)!\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const combine: (b: number) => (self: number) => number = (b) => (self) => (self * 53) ^ b\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const optimize = (n: number): number => (n & 0xbfffffff) | ((n >>> 1) & 0x40000000)\n\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isHash = (u: unknown): u is Hash => hasProperty(u, symbol)\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const number = (n: number) => {\n  if (n !== n || n === Infinity) {\n    return 0\n  }\n  let h = n | 0\n  if (h !== n) {\n    h ^= n * 0xffffffff\n  }\n  while (n > 0xffffffff) {\n    h ^= n /= 0xffffffff\n  }\n  return optimize(h)\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const string = (str: string) => {\n  let h = 5381, i = str.length\n  while (i) {\n    h = (h * 33) ^ str.charCodeAt(--i)\n  }\n  return optimize(h)\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const structureKeys = <A extends object>(o: A, keys: ReadonlyArray<keyof A>) => {\n  let h = 12289\n  for (let i = 0; i < keys.length; i++) {\n    h ^= pipe(string(keys[i]! as string), combine(hash((o as any)[keys[i]!])))\n  }\n  return optimize(h)\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const structure = <A extends object>(o: A) =>\n  structureKeys(o, Object.keys(o) as unknown as ReadonlyArray<keyof A>)\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const array = <A>(arr: ReadonlyArray<A>) => {\n  let h = 6151\n  for (let i = 0; i < arr.length; i++) {\n    h = pipe(h, combine(hash(arr[i])))\n  }\n  return optimize(h)\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const cached: {\n  /**\n   * @since 2.0.0\n   * @category hashing\n   */\n  (self: object): (hash: number) => number\n  /**\n   * @since 2.0.0\n   * @category hashing\n   */\n  (self: object, hash: number): number\n} = function() {\n  if (arguments.length === 1) {\n    const self = arguments[0] as object\n    return function(hash: number) {\n      Object.defineProperty(self, symbol, {\n        value() {\n          return hash\n        },\n        enumerable: false\n      })\n      return hash\n    } as any\n  }\n  const self = arguments[0] as object\n  const hash = arguments[1] as number\n  Object.defineProperty(self, symbol, {\n    value() {\n      return hash\n    },\n    enumerable: false\n  })\n\n  return hash\n}\n","/**\n * @since 2.0.0\n */\nimport type { Equivalence } from \"./Equivalence.js\"\nimport * as Hash from \"./Hash.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport { structuralRegionState } from \"./Utils.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const symbol: unique symbol = Symbol.for(\"effect/Equal\")\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Equal extends Hash.Hash {\n  [symbol](that: Equal): boolean\n}\n\n/**\n * @since 2.0.0\n * @category equality\n */\nexport function equals<B>(that: B): <A>(self: A) => boolean\nexport function equals<A, B>(self: A, that: B): boolean\nexport function equals(): any {\n  if (arguments.length === 1) {\n    return (self: unknown) => compareBoth(self, arguments[0])\n  }\n  return compareBoth(arguments[0], arguments[1])\n}\n\nfunction compareBoth(self: unknown, that: unknown): boolean {\n  if (self === that) {\n    return true\n  }\n  const selfType = typeof self\n  if (selfType !== typeof that) {\n    return false\n  }\n  if (selfType === \"object\" || selfType === \"function\") {\n    if (self !== null && that !== null) {\n      if (isEqual(self) && isEqual(that)) {\n        if (Hash.hash(self) === Hash.hash(that) && self[symbol](that)) {\n          return true\n        } else {\n          return structuralRegionState.enabled && structuralRegionState.tester\n            ? structuralRegionState.tester(self, that)\n            : false\n        }\n      } else if (self instanceof Date && that instanceof Date) {\n        return self.toISOString() === that.toISOString()\n      } else if (self instanceof URL && that instanceof URL) {\n        return self.href === that.href\n      }\n    }\n    if (structuralRegionState.enabled) {\n      if (Array.isArray(self) && Array.isArray(that)) {\n        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]))\n      }\n      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {\n        const keysSelf = Object.keys(self as any)\n        const keysThat = Object.keys(that as any)\n        if (keysSelf.length === keysThat.length) {\n          for (const key of keysSelf) {\n            // @ts-expect-error\n            if (!(key in that && compareBoth(self[key], that[key]))) {\n              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false\n            }\n          }\n          return true\n        }\n      }\n      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false\n    }\n  }\n\n  return structuralRegionState.enabled && structuralRegionState.tester\n    ? structuralRegionState.tester(self, that)\n    : false\n}\n\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isEqual = (u: unknown): u is Equal => hasProperty(u, symbol)\n\n/**\n * @since 2.0.0\n * @category instances\n */\nexport const equivalence: <A>() => Equivalence<A> = () => equals\n","/**\n * @since 2.0.0\n */\nimport type * as FiberRefs from \"./FiberRefs.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport { hasProperty, isFunction } from \"./Predicate.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const NodeInspectSymbol = Symbol.for(\"nodejs.util.inspect.custom\")\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type NodeInspectSymbol = typeof NodeInspectSymbol\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Inspectable {\n  toString(): string\n  toJSON(): unknown\n  [NodeInspectSymbol](): unknown\n}\n\n/**\n * @since 2.0.0\n */\nexport const toJSON = (x: unknown): unknown => {\n  try {\n    if (\n      hasProperty(x, \"toJSON\") && isFunction(x[\"toJSON\"]) &&\n      x[\"toJSON\"].length === 0\n    ) {\n      return x.toJSON()\n    } else if (Array.isArray(x)) {\n      return x.map(toJSON)\n    }\n  } catch {\n    return {}\n  }\n  return redact(x)\n}\n\n/**\n * @since 2.0.0\n */\nexport const format = (x: unknown): string => JSON.stringify(x, null, 2)\n\n/**\n * @since 2.0.0\n */\nexport const BaseProto: Inspectable = {\n  toJSON() {\n    return toJSON(this)\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  toString() {\n    return format(this.toJSON())\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport abstract class Class {\n  /**\n   * @since 2.0.0\n   */\n  abstract toJSON(): unknown\n  /**\n   * @since 2.0.0\n   */\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  /**\n   * @since 2.0.0\n   */\n  toString() {\n    return format(this.toJSON())\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const toStringUnknown = (u: unknown, whitespace: number | string | undefined = 2): string => {\n  if (typeof u === \"string\") {\n    return u\n  }\n  try {\n    return typeof u === \"object\" ? stringifyCircular(u, whitespace) : String(u)\n  } catch {\n    return String(u)\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const stringifyCircular = (obj: unknown, whitespace?: number | string | undefined): string => {\n  let cache: Array<unknown> = []\n  const retVal = JSON.stringify(\n    obj,\n    (_key, value) =>\n      typeof value === \"object\" && value !== null\n        ? cache.includes(value)\n          ? undefined // circular reference\n          : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value)\n            ? value[symbolRedactable](redactableState.fiberRefs)\n            : value)\n        : value,\n    whitespace\n  )\n  ;(cache as any) = undefined\n  return retVal\n}\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport interface Redactable {\n  readonly [symbolRedactable]: (fiberRefs: FiberRefs.FiberRefs) => unknown\n}\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const symbolRedactable: unique symbol = Symbol.for(\"effect/Inspectable/Redactable\")\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const isRedactable = (u: unknown): u is Redactable =>\n  typeof u === \"object\" && u !== null && symbolRedactable in u\n\nconst redactableState = globalValue(\"effect/Inspectable/redactableState\", () => ({\n  fiberRefs: undefined as FiberRefs.FiberRefs | undefined\n}))\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const withRedactableContext = <A>(context: FiberRefs.FiberRefs, f: () => A): A => {\n  const prev = redactableState.fiberRefs\n  redactableState.fiberRefs = context\n  try {\n    return f()\n  } finally {\n    redactableState.fiberRefs = prev\n  }\n}\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const redact = (u: unknown): unknown => {\n  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {\n    return u[symbolRedactable](redactableState.fiberRefs)\n  }\n  return u\n}\n","/**\n * @since 2.0.0\n */\n\nimport type { Ctor } from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category Models\n */\nexport interface Pipeable {\n  pipe<A>(this: A): A\n  pipe<A, B = never>(this: A, ab: (_: A) => B): B\n  pipe<A, B = never, C = never>(this: A, ab: (_: A) => B, bc: (_: B) => C): C\n  pipe<A, B = never, C = never, D = never>(this: A, ab: (_: A) => B, bc: (_: B) => C, cd: (_: C) => D): D\n  pipe<A, B = never, C = never, D = never, E = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E\n  ): E\n  pipe<A, B = never, C = never, D = never, E = never, F = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F\n  ): F\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G\n  ): G\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H\n  ): H\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I\n  ): I\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J\n  ): J\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K\n  ): K\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L\n  ): L\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M\n  ): M\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N\n  ): N\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O\n  ): O\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P\n  ): P\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q\n  ): Q\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R\n  ): R\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S\n  ): S\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T\n  ): T\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never,\n    U = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T,\n    tu: (_: T) => U\n  ): U\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never,\n    U = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T,\n    tu: (_: T) => U\n  ): U\n}\n\n/**\n * @since 2.0.0\n */\nexport const pipeArguments = <A>(self: A, args: IArguments): unknown => {\n  switch (args.length) {\n    case 0:\n      return self\n    case 1:\n      return args[0](self)\n    case 2:\n      return args[1](args[0](self))\n    case 3:\n      return args[2](args[1](args[0](self)))\n    case 4:\n      return args[3](args[2](args[1](args[0](self))))\n    case 5:\n      return args[4](args[3](args[2](args[1](args[0](self)))))\n    case 6:\n      return args[5](args[4](args[3](args[2](args[1](args[0](self))))))\n    case 7:\n      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))\n    case 8:\n      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))))\n    case 9:\n      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))))\n    default: {\n      let ret = self\n      for (let i = 0, len = args.length; i < len; i++) {\n        ret = args[i](ret)\n      }\n      return ret\n    }\n  }\n}\n\n/**\n * @since 3.15.0\n * @category Models\n */\nexport interface PipeableConstructor {\n  new(...args: Array<any>): Pipeable\n}\n\n/**\n * @since 3.15.0\n * @category Prototypes\n */\nexport const Prototype: Pipeable = {\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst Base: PipeableConstructor = (function() {\n  function PipeableBase() {}\n  PipeableBase.prototype = Prototype\n  return PipeableBase as any\n})()\n\n/**\n * @since 3.15.0\n * @category Constructors\n */\nexport const Class: {\n  /**\n   * @since 3.15.0\n   * @category Constructors\n   */\n  (): PipeableConstructor\n  /**\n   * @since 3.15.0\n   * @category Constructors\n   */\n  <TBase extends Ctor>(klass: TBase): TBase & PipeableConstructor\n} = (klass?: Ctor) =>\n  klass ?\n    class extends klass {\n      pipe() {\n        return pipeArguments(this, arguments)\n      }\n    }\n    : Base\n","/** @internal */\nexport type OP_ASYNC = typeof OP_ASYNC\n\n/** @internal */\nexport const OP_ASYNC = \"Async\" as const\n\n/** @internal */\nexport type OP_COMMIT = typeof OP_COMMIT\n\n/** @internal */\nexport const OP_COMMIT = \"Commit\" as const\n\n/** @internal */\nexport type OP_FAILURE = typeof OP_FAILURE\n\n/** @internal */\nexport const OP_FAILURE = \"Failure\" as const\n\n/** @internal */\nexport type OP_ON_FAILURE = typeof OP_ON_FAILURE\n\n/** @internal */\nexport const OP_ON_FAILURE = \"OnFailure\" as const\n\n/** @internal */\nexport type OP_ON_SUCCESS = typeof OP_ON_SUCCESS\n\n/** @internal */\nexport const OP_ON_SUCCESS = \"OnSuccess\" as const\n\n/** @internal */\nexport type OP_ON_SUCCESS_AND_FAILURE = typeof OP_ON_SUCCESS_AND_FAILURE\n\n/** @internal */\nexport const OP_ON_SUCCESS_AND_FAILURE = \"OnSuccessAndFailure\" as const\n\n/** @internal */\nexport type OP_SUCCESS = typeof OP_SUCCESS\n\n/** @internal */\nexport const OP_SUCCESS = \"Success\" as const\n\n/** @internal */\nexport type OP_SYNC = typeof OP_SYNC\n\n/** @internal */\nexport const OP_SYNC = \"Sync\" as const\n\n/** @internal */\nexport const OP_TAG = \"Tag\" as const\n\n/** @internal */\nexport type OP_TAG = typeof OP_TAG\n\n/** @internal */\nexport type OP_UPDATE_RUNTIME_FLAGS = typeof OP_UPDATE_RUNTIME_FLAGS\n\n/** @internal */\nexport const OP_UPDATE_RUNTIME_FLAGS = \"UpdateRuntimeFlags\" as const\n\n/** @internal */\nexport type OP_WHILE = typeof OP_WHILE\n\n/** @internal */\nexport const OP_WHILE = \"While\" as const\n\n/** @internal */\nexport type OP_ITERATOR = typeof OP_ITERATOR\n\n/** @internal */\nexport const OP_ITERATOR = \"Iterator\" as const\n\n/** @internal */\nexport type OP_WITH_RUNTIME = typeof OP_WITH_RUNTIME\n\n/** @internal */\nexport const OP_WITH_RUNTIME = \"WithRuntime\" as const\n\n/** @internal */\nexport type OP_YIELD = typeof OP_YIELD\n\n/** @internal */\nexport const OP_YIELD = \"Yield\" as const\n\n/** @internal */\nexport type OP_REVERT_FLAGS = typeof OP_REVERT_FLAGS\n\n/** @internal */\nexport const OP_REVERT_FLAGS = \"RevertFlags\" as const\n","let moduleVersion = \"3.18.4\"\n\nexport const getCurrentVersion = () => moduleVersion\n\nexport const setCurrentVersion = (version: string) => {\n  moduleVersion = version\n}\n","import type * as Channel from \"../Channel.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type * as Effectable from \"../Effectable.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as Hash from \"../Hash.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type * as Sink from \"../Sink.js\"\nimport type * as Stream from \"../Stream.js\"\nimport { SingleShotGen, YieldWrap } from \"../Utils.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport * as version from \"./version.js\"\n\n/** @internal */\nexport const EffectTypeId: Effect.EffectTypeId = Symbol.for(\"effect/Effect\") as Effect.EffectTypeId\n\n/** @internal */\nexport const StreamTypeId: Stream.StreamTypeId = Symbol.for(\"effect/Stream\") as Stream.StreamTypeId\n\n/** @internal */\nexport const SinkTypeId: Sink.SinkTypeId = Symbol.for(\"effect/Sink\") as Sink.SinkTypeId\n\n/** @internal */\nexport const ChannelTypeId: Channel.ChannelTypeId = Symbol.for(\"effect/Channel\") as Channel.ChannelTypeId\n\n/** @internal */\nexport const effectVariance = {\n  /* c8 ignore next */\n  _R: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _A: (_: never) => _,\n\n  _V: version.getCurrentVersion()\n}\n\nconst sinkVariance = {\n  /* c8 ignore next */\n  _A: (_: never) => _,\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _L: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\nconst channelVariance = {\n  /* c8 ignore next */\n  _Env: (_: never) => _,\n  /* c8 ignore next */\n  _InErr: (_: unknown) => _,\n  /* c8 ignore next */\n  _InElem: (_: unknown) => _,\n  /* c8 ignore next */\n  _InDone: (_: unknown) => _,\n  /* c8 ignore next */\n  _OutErr: (_: never) => _,\n  /* c8 ignore next */\n  _OutElem: (_: never) => _,\n  /* c8 ignore next */\n  _OutDone: (_: never) => _\n}\n\n/** @internal */\nexport const EffectPrototype: Effect.Effect<never> & Equal.Equal = {\n  [EffectTypeId]: effectVariance,\n  [StreamTypeId]: effectVariance,\n  [SinkTypeId]: sinkVariance,\n  [ChannelTypeId]: channelVariance,\n  [Equal.symbol](that: any) {\n    return this === that\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.random(this))\n  },\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this)) as any\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const StructuralPrototype: Equal.Equal = {\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.structure(this))\n  },\n  [Equal.symbol](this: Equal.Equal, that: Equal.Equal) {\n    const selfKeys = Object.keys(this)\n    const thatKeys = Object.keys(that as object)\n    if (selfKeys.length !== thatKeys.length) {\n      return false\n    }\n    for (const key of selfKeys) {\n      if (!(key in (that as object) && Equal.equals((this as any)[key], (that as any)[key]))) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n/** @internal */\nexport const CommitPrototype: Effect.Effect<never> = {\n  ...EffectPrototype,\n  _op: OpCodes.OP_COMMIT\n} as any\n\n/** @internal */\nexport const StructuralCommitPrototype: Effect.Effect<never> = {\n  ...CommitPrototype,\n  ...StructuralPrototype\n} as any\n\n/** @internal */\nexport const Base: Effectable.CommitPrimitive = (function() {\n  function Base() {}\n  Base.prototype = CommitPrototype\n  return Base as any\n})()\n\n/** @internal */\nexport const StructuralBase: Effectable.CommitPrimitive = (function() {\n  function Base() {}\n  Base.prototype = StructuralCommitPrototype\n  return Base as any\n})()\n","/**\n * @since 2.0.0\n */\n\nimport * as Equal from \"../Equal.js\"\nimport * as Hash from \"../Hash.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport type * as Option from \"../Option.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport { EffectPrototype } from \"./effectable.js\"\n\nconst TypeId: Option.TypeId = Symbol.for(\"effect/Option\") as Option.TypeId\n\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _A: (_: never) => _\n  },\n  [NodeInspectSymbol]<A>(this: Option.Option<A>) {\n    return this.toJSON()\n  },\n  toString<A>(this: Option.Option<A>) {\n    return format(this.toJSON())\n  }\n}\n\nconst SomeProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"Some\",\n  _op: \"Some\",\n  [Equal.symbol]<A>(this: Option.Some<A>, that: unknown): boolean {\n    return isOption(that) && isSome(that) && Equal.equals(this.value, that.value)\n  },\n  [Hash.symbol]<A>(this: Option.Some<A>) {\n    return Hash.cached(this, Hash.combine(Hash.hash(this._tag))(Hash.hash(this.value)))\n  },\n  toJSON<A>(this: Option.Some<A>) {\n    return {\n      _id: \"Option\",\n      _tag: this._tag,\n      value: toJSON(this.value)\n    }\n  }\n})\n\nconst NoneHash = Hash.hash(\"None\")\nconst NoneProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"None\",\n  _op: \"None\",\n  [Equal.symbol]<A>(this: Option.None<A>, that: unknown): boolean {\n    return isOption(that) && isNone(that)\n  },\n  [Hash.symbol]<A>(this: Option.None<A>) {\n    return NoneHash\n  },\n  toJSON<A>(this: Option.None<A>) {\n    return {\n      _id: \"Option\",\n      _tag: this._tag\n    }\n  }\n})\n\n/** @internal */\nexport const isOption = (input: unknown): input is Option.Option<unknown> => hasProperty(input, TypeId)\n\n/** @internal */\nexport const isNone = <A>(fa: Option.Option<A>): fa is Option.None<A> => fa._tag === \"None\"\n\n/** @internal */\nexport const isSome = <A>(fa: Option.Option<A>): fa is Option.Some<A> => fa._tag === \"Some\"\n\n/** @internal */\nexport const none: Option.Option<never> = Object.create(NoneProto)\n\n/** @internal */\nexport const some = <A>(value: A): Option.Option<A> => {\n  const a = Object.create(SomeProto)\n  a.value = value\n  return a\n}\n","/**\n * @since 2.0.0\n */\n\nimport type * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport { dual } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport type { Option } from \"../Option.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport { EffectPrototype } from \"./effectable.js\"\nimport * as option from \"./option.js\"\n\n/**\n * @internal\n */\nexport const TypeId: Either.TypeId = Symbol.for(\"effect/Either\") as Either.TypeId\n\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _R: (_: never) => _\n  },\n  [NodeInspectSymbol]<L, R>(this: Either.Either<R, L>) {\n    return this.toJSON()\n  },\n  toString<L, R>(this: Either.Left<L, R>) {\n    return format(this.toJSON())\n  }\n}\n\nconst RightProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"Right\",\n  _op: \"Right\",\n  [Equal.symbol]<L, R>(this: Either.Right<L, R>, that: unknown): boolean {\n    return isEither(that) && isRight(that) && Equal.equals(this.right, that.right)\n  },\n  [Hash.symbol]<L, R>(this: Either.Right<L, R>) {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.right))\n  },\n  toJSON<L, R>(this: Either.Right<L, R>) {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      right: toJSON(this.right)\n    }\n  }\n})\n\nconst LeftProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"Left\",\n  _op: \"Left\",\n  [Equal.symbol]<L, R>(this: Either.Left<L, R>, that: unknown): boolean {\n    return isEither(that) && isLeft(that) && Equal.equals(this.left, that.left)\n  },\n  [Hash.symbol]<L, R>(this: Either.Left<L, R>) {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.left))\n  },\n  toJSON<E, A>(this: Either.Left<E, A>) {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      left: toJSON(this.left)\n    }\n  }\n})\n\n/** @internal */\nexport const isEither = (input: unknown): input is Either.Either<unknown, unknown> => hasProperty(input, TypeId)\n\n/** @internal */\nexport const isLeft = <R, L>(ma: Either.Either<R, L>): ma is Either.Left<L, R> => ma._tag === \"Left\"\n\n/** @internal */\nexport const isRight = <R, L>(ma: Either.Either<R, L>): ma is Either.Right<L, R> => ma._tag === \"Right\"\n\n/** @internal */\nexport const left = <L>(left: L): Either.Either<never, L> => {\n  const a = Object.create(LeftProto)\n  a.left = left\n  return a\n}\n\n/** @internal */\nexport const right = <R>(right: R): Either.Either<R> => {\n  const a = Object.create(RightProto)\n  a.right = right\n  return a\n}\n\n/** @internal */\nexport const getLeft = <R, L>(\n  self: Either.Either<R, L>\n): Option<L> => (isRight(self) ? option.none : option.some(self.left))\n\n/** @internal */\nexport const getRight = <R, L>(\n  self: Either.Either<R, L>\n): Option<R> => (isLeft(self) ? option.none : option.some(self.right))\n\n/** @internal */\nexport const fromOption: {\n  <L>(onNone: () => L): <R>(self: Option<R>) => Either.Either<R, L>\n  <R, L>(self: Option<R>, onNone: () => L): Either.Either<R, L>\n} = dual(\n  2,\n  <R, L>(self: Option<R>, onNone: () => L): Either.Either<R, L> =>\n    option.isNone(self) ? left(onNone()) : right(self.value)\n)\n","/**\n * @since 2.0.0\n */\n\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { constNull, constUndefined, dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as doNotation from \"./internal/doNotation.js\"\nimport * as either from \"./internal/either.js\"\nimport * as option_ from \"./internal/option.js\"\nimport type { Option } from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport { isFunction } from \"./Predicate.js\"\nimport type { Covariant, NoInfer, NotFunction } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport * as Gen from \"./Utils.js\"\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type Either<A, E = never> = Left<E, A> | Right<E, A>\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const TypeId: unique symbol = either.TypeId\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport type TypeId = typeof TypeId\n\n// TODO(4.0): flip the order of the type parameters\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Left<out E, out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Left\"\n  readonly _op: \"Left\"\n  readonly left: E\n  readonly [TypeId]: {\n    readonly _R: Covariant<A>\n    readonly _L: Covariant<E>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}\n\n// TODO(4.0): flip the order of the type parameters\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Right<out E, out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Right\"\n  readonly _op: \"Right\"\n  readonly right: A\n  readonly [TypeId]: {\n    readonly _R: Covariant<A>\n    readonly _L: Covariant<E>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface EitherUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Either?: () => A[Unify.typeSymbol] extends Either<infer R0, infer L0> | infer _ ? Either<R0, L0> : never\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface EitherUnifyIgnore {}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface EitherTypeLambda extends TypeLambda {\n  readonly type: Either<this[\"Target\"], this[\"Out1\"]>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Either {\n  /**\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Left<T extends Either<any, any>> = [T] extends [Either<infer _A, infer _E>] ? _E : never\n  /**\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Right<T extends Either<any, any>> = [T] extends [Either<infer _A, infer _E>] ? _A : never\n}\n\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const right: <A>(a: A) => Either<A> = either.right\n\nconst void_: Either<void> = right(void 0)\nexport {\n  /**\n   * @category constructors\n   * @since 3.13.0\n   */\n  void_ as void\n}\n\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const left: <E>(e: E) => Either<never, E> = either.left\n\n/**\n * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromNullable: {\n  /**\n   * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n   * the provided default as a `Left`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n   * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, E>(onNullable: (right: A) => E): (self: A) => Either<NonNullable<A>, E>\n  /**\n   * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n   * the provided default as a `Left`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n   * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, E>(self: A, onNullable: (right: A) => E): Either<NonNullable<A>, E>\n} = dual(\n  2,\n  <A, E>(self: A, onNullable: (right: A) => E): Either<NonNullable<A>, E> =>\n    self == null ? left(onNullable(self)) : right(self)\n)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromOption: {\n  /**\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n   * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <E>(onNone: () => E): <A>(self: Option<A>) => Either<A, E>\n  /**\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n   * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, E>(self: Option<A>, onNone: () => E): Either<A, E>\n} = either.fromOption\n\nconst try_: {\n  <A, E>(\n    options: {\n      readonly try: LazyArg<A>\n      readonly catch: (error: unknown) => E\n    }\n  ): Either<A, E>\n  <A>(evaluate: LazyArg<A>): Either<A, unknown>\n} = (<A, E>(\n  evaluate: LazyArg<A> | {\n    readonly try: LazyArg<A>\n    readonly catch: (error: unknown) => E\n  }\n) => {\n  if (isFunction(evaluate)) {\n    try {\n      return right(evaluate())\n    } catch (e) {\n      return left(e)\n    }\n  } else {\n    try {\n      return right(evaluate.try())\n    } catch (e) {\n      return left(evaluate.catch(e))\n    }\n  }\n}) as any\n\nexport {\n  /**\n   * Imports a synchronous side-effect into a pure `Either` value, translating any\n   * thrown exceptions into typed failed eithers creating with `Either.left`.\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  try_ as try\n}\n\n/**\n * Tests if a value is a `Either`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isEither(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isEither(Either.left(\"a\")), true)\n * assert.deepStrictEqual(Either.isEither({ right: 1 }), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEither: (input: unknown) => input is Either<unknown, unknown> = either.isEither\n\n/**\n * Determine if a `Either` is a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\n * assert.deepStrictEqual(Either.isLeft(Either.left(\"a\")), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isLeft: <A, E>(self: Either<A, E>) => self is Left<E, A> = either.isLeft\n\n/**\n * Determine if a `Either` is a `Right`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isRight(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isRight(Either.left(\"a\")), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isRight: <A, E>(self: Either<A, E>) => self is Right<E, A> = either.isRight\n\n/**\n * Converts a `Either` to an `Option` discarding the `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))\n * assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getRight: <A, E>(self: Either<A, E>) => Option<A> = either.getRight\n\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())\n * assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getLeft: <A, E>(self: Either<A, E>) => Option<E> = either.getLeft\n\n/**\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <A, E>({ left, right }: {\n  right: Equivalence.Equivalence<A>\n  left: Equivalence.Equivalence<E>\n}): Equivalence.Equivalence<Either<A, E>> =>\n  Equivalence.make((x, y) =>\n    isLeft(x) ?\n      isLeft(y) && left(x.left, y.left) :\n      isRight(y) && right(x.right, y.right)\n  )\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapBoth: {\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <E, E2, A, A2>(\n    options: {\n      readonly onLeft: (left: E) => E2\n      readonly onRight: (right: A) => A2\n    }\n  ): (self: Either<A, E>) => Either<A2, E2>\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, E, E2, A2>(\n    self: Either<A, E>,\n    options: {\n      readonly onLeft: (left: E) => E2\n      readonly onRight: (right: A) => A2\n    }\n  ): Either<A2, E2>\n} = dual(\n  2,\n  <A, E, E2, A2>(self: Either<A, E>, { onLeft, onRight }: {\n    readonly onLeft: (left: E) => E2\n    readonly onRight: (right: A) => A2\n  }): Either<A2, E2> => isLeft(self) ? left(onLeft(self.left)) : right(onRight(self.right))\n)\n\n/**\n * Maps the `Left` side of an `Either` value to a new `Either` value.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapLeft: {\n  /**\n   * Maps the `Left` side of an `Either` value to a new `Either` value.\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <E, E2>(f: (left: E) => E2): <A>(self: Either<A, E>) => Either<A, E2>\n  /**\n   * Maps the `Left` side of an `Either` value to a new `Either` value.\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, E, E2>(self: Either<A, E>, f: (left: E) => E2): Either<A, E2>\n} = dual(\n  2,\n  <A, E, E2>(self: Either<A, E>, f: (left: E) => E2): Either<A, E2> =>\n    isLeft(self) ? left(f(self.left)) : right(self.right)\n)\n\n/**\n * Maps the `Right` side of an `Either` value to a new `Either` value.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  /**\n   * Maps the `Right` side of an `Either` value to a new `Either` value.\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, A2>(f: (right: A) => A2): <E>(self: Either<A, E>) => Either<A2, E>\n  /**\n   * Maps the `Right` side of an `Either` value to a new `Either` value.\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, E, A2>(self: Either<A, E>, f: (right: A) => A2): Either<A2, E>\n} = dual(\n  2,\n  <A, E, A2>(self: Either<A, E>, f: (right: A) => A2): Either<A2, E> =>\n    isRight(self) ? right(f(self.right)) : left(self.left)\n)\n\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n * if the value is a `Right` the inner value is applied to the `onRight` function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n * assert.deepStrictEqual(\n *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n *   'strings: string 1, string 2'\n * )\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  /**\n   * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n   * if the value is a `Right` the inner value is applied to the `onRight` function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n   *\n   * const onRight = (value: number): string => `Ok: ${value}`\n   *\n   * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n   * assert.deepStrictEqual(\n   *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n   *   'strings: string 1, string 2'\n   * )\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <E, B, A, C = B>(\n    options: {\n      readonly onLeft: (left: E) => B\n      readonly onRight: (right: A) => C\n    }\n  ): (self: Either<A, E>) => B | C\n  /**\n   * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n   * if the value is a `Right` the inner value is applied to the `onRight` function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n   *\n   * const onRight = (value: number): string => `Ok: ${value}`\n   *\n   * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n   * assert.deepStrictEqual(\n   *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n   *   'strings: string 1, string 2'\n   * )\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, E, B, C = B>(\n    self: Either<A, E>,\n    options: {\n      readonly onLeft: (left: E) => B\n      readonly onRight: (right: A) => C\n    }\n  ): B | C\n} = dual(\n  2,\n  <A, E, B, C = B>(self: Either<A, E>, { onLeft, onRight }: {\n    readonly onLeft: (left: E) => B\n    readonly onRight: (right: A) => C\n  }): B | C => isLeft(self) ? onLeft(self.left) : onRight(self.right)\n)\n\n/**\n * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n * or `Left` of the result of the provided function if the predicate returns false\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n *\n * assert.deepStrictEqual(\n *   isPositiveEither(1),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   isPositiveEither(0),\n *   Either.left(\"0 is not positive\")\n * )\n * ```\n *\n * @category lifting\n * @since 3.4.0\n */\nexport const liftPredicate: {\n  /**\n   * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n   * or `Left` of the result of the provided function if the predicate returns false\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n   *\n   * assert.deepStrictEqual(\n   *   isPositiveEither(1),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   isPositiveEither(0),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @category lifting\n   * @since 3.4.0\n   */\n  <A, B extends A, E>(refinement: Refinement<A, B>, orLeftWith: (a: A) => E): (a: A) => Either<B, E>\n  /**\n   * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n   * or `Left` of the result of the provided function if the predicate returns false\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n   *\n   * assert.deepStrictEqual(\n   *   isPositiveEither(1),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   isPositiveEither(0),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @category lifting\n   * @since 3.4.0\n   */\n  <B extends A, E, A = B>(predicate: Predicate<A>, orLeftWith: (a: A) => E): (a: B) => Either<B, E>\n  /**\n   * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n   * or `Left` of the result of the provided function if the predicate returns false\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n   *\n   * assert.deepStrictEqual(\n   *   isPositiveEither(1),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   isPositiveEither(0),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @category lifting\n   * @since 3.4.0\n   */\n  <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>\n  /**\n   * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n   * or `Left` of the result of the provided function if the predicate returns false\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n   *\n   * assert.deepStrictEqual(\n   *   isPositiveEither(1),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   isPositiveEither(0),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @category lifting\n   * @since 3.4.0\n   */\n  <B extends A, E, A = B>(self: B, predicate: Predicate<A>, orLeftWith: (a: A) => E): Either<B, E>\n} = dual(\n  3,\n  <A, E>(a: A, predicate: Predicate<A>, orLeftWith: (a: A) => E): Either<A, E> =>\n    predicate(a) ? right(a) : left(orLeftWith(a))\n)\n\n/**\n * Filter the right value with the provided function.\n * If the predicate fails, set the left value with the result of the provided function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(1),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(0),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.left(\"0 is not positive\")\n * )\n * ```\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nexport const filterOrLeft: {\n  /**\n   * Filter the right value with the provided function.\n   * If the predicate fails, set the left value with the result of the provided function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(1),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(0),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering & conditionals\n   */\n  <A, B extends A, E2>(\n    refinement: Refinement<NoInfer<A>, B>,\n    orLeftWith: (right: NoInfer<A>) => E2\n  ): <E>(self: Either<A, E>) => Either<B, E2 | E>\n  /**\n   * Filter the right value with the provided function.\n   * If the predicate fails, set the left value with the result of the provided function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(1),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(0),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering & conditionals\n   */\n  <A, E2>(predicate: Predicate<NoInfer<A>>, orLeftWith: (right: NoInfer<A>) => E2): <E>(self: Either<A, E>) => Either<A, E2 | E>\n  /**\n   * Filter the right value with the provided function.\n   * If the predicate fails, set the left value with the result of the provided function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(1),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(0),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering & conditionals\n   */\n  <A, E, B extends A, E2>(\n    self: Either<A, E>,\n    refinement: Refinement<A, B>,\n    orLeftWith: (right: A) => E2\n  ): Either<B, E | E2>\n  /**\n   * Filter the right value with the provided function.\n   * If the predicate fails, set the left value with the result of the provided function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(1),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(0),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering & conditionals\n   */\n  <A, E, E2>(self: Either<A, E>, predicate: Predicate<A>, orLeftWith: (right: A) => E2): Either<A, E | E2>\n} = dual(3, <A, E, E2>(\n  self: Either<A, E>,\n  predicate: Predicate<A>,\n  orLeftWith: (right: A) => E2\n): Either<A, E | E2> => flatMap(self, (r) => predicate(r) ? right(r) : left(orLeftWith(r))))\n\n/**\n * @category getters\n * @since 2.0.0\n */\nexport const merge: <A, E>(self: Either<A, E>) => E | A = match({\n  onLeft: identity,\n  onRight: identity\n})\n\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrElse: {\n  /**\n   * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n   * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <E, A2>(onLeft: (left: E) => A2): <A>(self: Either<A, E>) => A2 | A\n  /**\n   * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n   * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A, E, A2>(self: Either<A, E>, onLeft: (left: E) => A2): A | A2\n} = dual(\n  2,\n  <A, E, A2>(self: Either<A, E>, onLeft: (left: E) => A2): A | A2 => isLeft(self) ? onLeft(self.left) : self.right\n)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrNull: <A, E>(self: Either<A, E>) => A | null = getOrElse(constNull)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrUndefined: <A, E>(self: Either<A, E>) => A | undefined = getOrElse(constUndefined)\n\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n *   1\n * )\n * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrThrowWith: {\n  /**\n   * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n   *\n   * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n   *   1\n   * )\n   * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <E>(onLeft: (left: E) => unknown): <A>(self: Either<A, E>) => A\n  /**\n   * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n   *\n   * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n   *   1\n   * )\n   * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A, E>(self: Either<A, E>, onLeft: (left: E) => unknown): A\n} = dual(2, <A, E>(self: Either<A, E>, onLeft: (left: E) => unknown): A => {\n  if (isRight(self)) {\n    return self.right\n  }\n  throw onLeft(self.left)\n})\n\n// TODO(4.0): by default should throw `L` (i.e getOrThrowWith with the identity function)\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\n * assert.throws(() => Either.getOrThrow(Either.left(\"error\")))\n * ```\n *\n * @throws `Error(\"getOrThrow called on a Left\")`\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrThrow: <A, E>(self: Either<A, E>) => A = getOrThrowWith(() =>\n  new Error(\"getOrThrow called on a Left\")\n)\n\n/**\n * Returns `self` if it is a `Right` or `that` otherwise.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport const orElse: {\n  /**\n   * Returns `self` if it is a `Right` or `that` otherwise.\n   *\n   * @category error handling\n   * @since 2.0.0\n   */\n  <E, A2, E2>(that: (left: E) => Either<A2, E2>): <A>(self: Either<A, E>) => Either<A | A2, E2>\n  /**\n   * Returns `self` if it is a `Right` or `that` otherwise.\n   *\n   * @category error handling\n   * @since 2.0.0\n   */\n  <A, E, A2, E2>(self: Either<A, E>, that: (left: E) => Either<A2, E2>): Either<A | A2, E2>\n} = dual(\n  2,\n  <A, E, A2, E2>(self: Either<A, E>, that: (left: E) => Either<A2, E2>): Either<A | A2, E2> =>\n    isLeft(self) ? that(self.left) : right(self.right)\n)\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  /**\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, A2, E2>(f: (right: A) => Either<A2, E2>): <E>(self: Either<A, E>) => Either<A2, E | E2>\n  /**\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2>): Either<A2, E | E2>\n} = dual(\n  2,\n  <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2>): Either<A2, E | E2> =>\n    isLeft(self) ? left(self.left) : f(self.right)\n)\n\n/**\n * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const andThen: {\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, A2, E2>(f: (right: A) => Either<A2, E2>): <E>(self: Either<A, E>) => Either<A2, E | E2>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A2, E2>(f: Either<A2, E2>): <E, A>(self: Either<A, E>) => Either<A2, E | E2>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, A2>(f: (right: A) => A2): <E>(self: Either<A, E>) => Either<A2, E>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A2>(right: NotFunction<A2>): <A, E>(self: Either<A, E>) => Either<A2, E>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2>): Either<A2, E | E2>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2, E2>(self: Either<A, E>, f: Either<A2, E2>): Either<A2, E | E2>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2>(self: Either<A, E>, f: (right: A) => A2): Either<A2, E>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2>(self: Either<A, E>, f: NotFunction<A2>): Either<A2, E>\n} = dual(\n  2,\n  <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2> | Either<A2, E2>): Either<A2, E | E2> =>\n    flatMap(self, (a) => {\n      const b = isFunction(f) ? f(a) : f\n      return isEither(b) ? b : right(b)\n    })\n)\n\n/**\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  /**\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A2, E2, A, B>(that: Either<A2, E2>, f: (right: A, right2: A2) => B): <E>(self: Either<A, E>) => Either<B, E2 | E>\n  /**\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A, E, A2, E2, B>(self: Either<A, E>, that: Either<A2, E2>, f: (right: A, right2: A2) => B): Either<B, E | E2>\n} = dual(\n  3,\n  <A, E, A2, E2, B>(self: Either<A, E>, that: Either<A2, E2>, f: (right: A, right2: A2) => B): Either<B, E | E2> =>\n    flatMap(self, (r) => map(that, (r2) => f(r, r2)))\n)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const ap: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A, E2>(that: Either<A, E2>): <A2, E>(self: Either<(right: A) => A2, E>) => Either<A2, E | E2>\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A, A2, E, E2>(self: Either<(right: A) => A2, E>, that: Either<A, E2>): Either<A2, E | E2>\n} = dual(\n  2,\n  <A, E, A2, E2>(self: Either<(right: A) => A2, E>, that: Either<A, E2>): Either<A2, E | E2> =>\n    zipWith(self, that, (f, a) => f(a))\n)\n\n/**\n * Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Either` will contain an array.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n * ```\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nexport const all: <const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(\n  input: I\n) => [I] extends [ReadonlyArray<Either<any, any>>] ? Either<\n    { -readonly [K in keyof I]: [I[K]] extends [Either<infer A, any>] ? A : never },\n    I[number] extends never ? never : [I[number]] extends [Either<any, infer E>] ? E : never\n  >\n  : [I] extends [Iterable<Either<infer A, infer E>>] ? Either<Array<A>, E>\n  : Either<\n    { -readonly [K in keyof I]: [I[K]] extends [Either<infer A, any>] ? A : never },\n    I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer E>] ? E : never\n  > = (\n    input: Iterable<Either<any, any>> | Record<string, Either<any, any>>\n  ): Either<any, any> => {\n    if (Symbol.iterator in input) {\n      const out: Array<Either<any, any>> = []\n      for (const e of input) {\n        if (isLeft(e)) {\n          return e\n        }\n        out.push(e.right)\n      }\n      return right(out)\n    }\n\n    const out: Record<string, any> = {}\n    for (const key of Object.keys(input)) {\n      const e = input[key]\n      if (isLeft(e)) {\n        return e\n      }\n      out[key] = e.right\n    }\n    return right(out)\n  }\n\n/**\n * Returns an `Either` that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const flip = <A, E>(self: Either<A, E>): Either<E, A> => isLeft(self) ? right(self.left) : left(self.right)\n\nconst adapter = Gen.adapter<EitherTypeLambda>()\n\n/**\n * @category generators\n * @since 2.0.0\n */\nexport const gen: Gen.Gen<EitherTypeLambda, Gen.Adapter<EitherTypeLambda>> = (...args) => {\n  const f = args.length === 1 ? args[0] : args[1].bind(args[0])\n  const iterator = f(adapter)\n  let state: IteratorResult<any> = iterator.next()\n  while (!state.done) {\n    const current = Gen.isGenKind(state.value)\n      ? state.value.value\n      : Gen.yieldWrapGet(state.value)\n    if (isLeft(current)) {\n      return current\n    }\n    state = iterator.next(current.right as never)\n  }\n  return right(state.value) as any\n}\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link bind}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const Do: Either<{}> = right({})\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const bind: {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  <N extends string, A extends object, B, E2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, E2>): <E>(self: Either<A, E>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E | E2>\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  <A extends object, E, N extends string, B, E2>(\n    self: Either<A, E>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => Either<B, E2>\n  ): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E | E2>\n} = doNotation.bind<EitherTypeLambda>(map, flatMap)\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const bindTo: {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  <N extends string>(name: N): <A, E>(self: Either<A, E>) => Either<{ [K in N]: A }, E>\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  <A, E, N extends string>(self: Either<A, E>, name: N): Either<{ [K in N]: A }, E>\n} = doNotation.bindTo<EitherTypeLambda>(map)\n\nconst let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (r: NoInfer<A>) => B\n  ): <E>(self: Either<A, E>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E>\n  <A extends object, E, N extends string, B>(\n    self: Either<A, E>,\n    name: Exclude<N, keyof A>,\n    f: (r: NoInfer<A>) => B\n  ): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E>\n} = doNotation.let_<EitherTypeLambda>(map)\n\nexport {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link bind}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  let_ as let\n}\n\n/**\n * Converts an `Option` of an `Either` into an `Either` of an `Option`.\n *\n * **Details**\n *\n * This function transforms an `Option<Either<A, E>>` into an\n * `Either<Option<A>, E>`. If the `Option` is `None`, the resulting `Either`\n * will be a `Right` with a `None` value. If the `Option` is `Some`, the\n * inner `Either` will be executed, and its result wrapped in a `Some`.\n *\n * @example\n * ```ts\n * import { Effect, Either, Option } from \"effect\"\n *\n * //      ┌─── Option<Either<number, never>>\n * //      ▼\n * const maybe = Option.some(Either.right(42))\n *\n * //      ┌─── Either<Option<number>, never, never>\n * //      ▼\n * const result = Either.transposeOption(maybe)\n *\n * console.log(Effect.runSync(result))\n * // Output: { _id: 'Option', _tag: 'Some', value: 42 }\n * ```\n *\n * @since 3.14.0\n * @category Optional Wrapping & Unwrapping\n */\nexport const transposeOption = <A = never, E = never>(\n  self: Option<Either<A, E>>\n): Either<Option<A>, E> => {\n  return option_.isNone(self) ? right(option_.none) : map(self.value, option_.some)\n}\n\n/**\n * Applies an `Either` on an `Option` and transposes the result.\n *\n * **Details**\n *\n * If the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.\n * If the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.\n *\n * @example\n * ```ts\n * import { Either, Option, pipe } from \"effect\"\n *\n * //          ┌─── Either<Option<number>, never>>\n * //          ▼\n * const noneResult = pipe(\n *   Option.none(),\n *   Either.transposeMapOption(() => Either.right(42)) // will not be executed\n * )\n * console.log(noneResult)\n * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }\n *\n * //          ┌─── Either<Option<number>, never>>\n * //          ▼\n * const someRightResult = pipe(\n *   Option.some(42),\n *   Either.transposeMapOption((value) => Either.right(value * 2))\n * )\n * console.log(someRightResult)\n * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }\n * ```\n *\n * @since 3.15.0\n * @category Optional Wrapping & Unwrapping\n */\nexport const transposeMapOption = dual<\n  /**\n   * Applies an `Either` on an `Option` and transposes the result.\n   *\n   * **Details**\n   *\n   * If the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.\n   * If the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.\n   *\n   * @example\n   * ```ts\n   * import { Either, Option, pipe } from \"effect\"\n   *\n   * //          ┌─── Either<Option<number>, never>>\n   * //          ▼\n   * const noneResult = pipe(\n   *   Option.none(),\n   *   Either.transposeMapOption(() => Either.right(42)) // will not be executed\n   * )\n   * console.log(noneResult)\n   * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }\n   *\n   * //          ┌─── Either<Option<number>, never>>\n   * //          ▼\n   * const someRightResult = pipe(\n   *   Option.some(42),\n   *   Either.transposeMapOption((value) => Either.right(value * 2))\n   * )\n   * console.log(someRightResult)\n   * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }\n   * ```\n   *\n   * @since 3.15.0\n   * @category Optional Wrapping & Unwrapping\n   */\n  <A, B, E = never>(f: (self: A) => Either<B, E>) => (self: Option<A>) => Either<Option<B>, E>,\n  /**\n   * Applies an `Either` on an `Option` and transposes the result.\n   *\n   * **Details**\n   *\n   * If the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.\n   * If the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.\n   *\n   * @example\n   * ```ts\n   * import { Either, Option, pipe } from \"effect\"\n   *\n   * //          ┌─── Either<Option<number>, never>>\n   * //          ▼\n   * const noneResult = pipe(\n   *   Option.none(),\n   *   Either.transposeMapOption(() => Either.right(42)) // will not be executed\n   * )\n   * console.log(noneResult)\n   * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }\n   *\n   * //          ┌─── Either<Option<number>, never>>\n   * //          ▼\n   * const someRightResult = pipe(\n   *   Option.some(42),\n   *   Either.transposeMapOption((value) => Either.right(value * 2))\n   * )\n   * console.log(someRightResult)\n   * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }\n   * ```\n   *\n   * @since 3.15.0\n   * @category Optional Wrapping & Unwrapping\n   */\n  <A, B, E = never>(self: Option<A>, f: (self: A) => Either<B, E>) => Either<Option<B>, E>\n>(2, (self, f) => option_.isNone(self) ? right(option_.none) : map(f(self.value), option_.some))\n","/**\n * @since 2.0.0\n */\n\nimport type { NonEmptyArray } from \"../Array.js\"\n\n/** @internal */\nexport const isNonEmptyArray = <A>(self: ReadonlyArray<A>): self is NonEmptyArray<A> => self.length > 0\n","/**\n * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.\n * An order is defined by a relation `<=`, which obeys the following laws:\n *\n * - either `x <= y` or `y <= x` (totality)\n * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)\n * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)\n *\n * The truth table for compare is defined as follows:\n *\n * | `x <= y` | `x >= y` | Ordering |                       |\n * | -------- | -------- | -------- | --------------------- |\n * | `true`   | `true`   | `0`      | corresponds to x == y |\n * | `true`   | `false`  | `< 0`    | corresponds to x < y  |\n * | `false`  | `true`   | `> 0`    | corresponds to x > y  |\n *\n * @since 2.0.0\n */\nimport { dual } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\n\n/**\n * @category type class\n * @since 2.0.0\n */\nexport interface Order<in A> {\n  (self: A, that: A): -1 | 0 | 1\n}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface OrderTypeLambda extends TypeLambda {\n  readonly type: Order<this[\"Target\"]>\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <A>(\n  compare: (self: A, that: A) => -1 | 0 | 1\n): Order<A> =>\n(self, that) => self === that ? 0 : compare(self, that)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const string: Order<string> = make((self, that) => self < that ? -1 : 1)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const number: Order<number> = make((self, that) => self < that ? -1 : 1)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const boolean: Order<boolean> = make((self, that) => self < that ? -1 : 1)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const bigint: Order<bigint> = make((self, that) => self < that ? -1 : 1)\n\n/**\n * @since 2.0.0\n */\nexport const reverse = <A>(O: Order<A>): Order<A> => make((self, that) => O(that, self))\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combine: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(that: Order<A>): (self: Order<A>) => Order<A>\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(self: Order<A>, that: Order<A>): Order<A>\n} = dual(2, <A>(self: Order<A>, that: Order<A>): Order<A> =>\n  make((a1, a2) => {\n    const out = self(a1, a2)\n    if (out !== 0) {\n      return out\n    }\n    return that(a1, a2)\n  }))\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineMany: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(collection: Iterable<Order<A>>): (self: Order<A>) => Order<A>\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<A>\n} = dual(2, <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<A> =>\n  make((a1, a2) => {\n    let out = self(a1, a2)\n    if (out !== 0) {\n      return out\n    }\n    for (const O of collection) {\n      out = O(a1, a2)\n      if (out !== 0) {\n        return out\n      }\n    }\n    return out\n  }))\n\n/**\n * @since 2.0.0\n */\nexport const empty = <A>(): Order<A> => make(() => 0)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineAll = <A>(collection: Iterable<Order<A>>): Order<A> => combineMany(empty(), collection)\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapInput: {\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <B, A>(f: (b: B) => A): (self: Order<A>) => Order<B>\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, B>(self: Order<A>, f: (b: B) => A): Order<B>\n} = dual(\n  2,\n  <A, B>(self: Order<A>, f: (b: B) => A): Order<B> => make((b1, b2) => self(f(b1), f(b2)))\n)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Date: Order<Date> = mapInput(number, (date) => date.getTime())\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const product: {\n  <B>(that: Order<B>): <A>(self: Order<A>) => Order<readonly [A, B]> // readonly because invariant\n  <A, B>(self: Order<A>, that: Order<B>): Order<readonly [A, B]> // readonly because invariant\n} = dual(2, <A, B>(self: Order<A>, that: Order<B>): Order<readonly [A, B]> =>\n  make(([xa, xb], [ya, yb]) => {\n    const o = self(xa, ya)\n    return o !== 0 ? o : that(xb, yb)\n  }))\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const all = <A>(collection: Iterable<Order<A>>): Order<ReadonlyArray<A>> => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length)\n    let collectionLength = 0\n    for (const O of collection) {\n      if (collectionLength >= len) {\n        break\n      }\n      const o = O(x[collectionLength], y[collectionLength])\n      if (o !== 0) {\n        return o\n      }\n      collectionLength++\n    }\n    return 0\n  })\n}\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const productMany: {\n  <A>(collection: Iterable<Order<A>>): (self: Order<A>) => Order<readonly [A, ...Array<A>]> // readonly because invariant\n  <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<readonly [A, ...Array<A>]> // readonly because invariant\n} = dual(2, <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<readonly [A, ...Array<A>]> => {\n  const O = all(collection)\n  return make((x, y) => {\n    const o = self(x[0], y[0])\n    return o !== 0 ? o : O(x.slice(1), y.slice(1))\n  })\n})\n\n/**\n * Similar to `Promise.all` but operates on `Order`s.\n *\n * ```\n * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const tuple = <T extends ReadonlyArray<Order<any>>>(\n  ...elements: T\n): Order<Readonly<{ [I in keyof T]: [T[I]] extends [Order<infer A>] ? A : never }>> => all(elements) as any\n\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const array = <A>(O: Order<A>): Order<ReadonlyArray<A>> =>\n  make((self, that) => {\n    const aLen = self.length\n    const bLen = that.length\n    const len = Math.min(aLen, bLen)\n    for (let i = 0; i < len; i++) {\n      const o = O(self[i], that[i])\n      if (o !== 0) {\n        return o\n      }\n    }\n    return number(aLen, bLen)\n  })\n\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const struct = <R extends { readonly [x: string]: Order<any> }>(\n  fields: R\n): Order<{ [K in keyof R]: [R[K]] extends [Order<infer A>] ? A : never }> => {\n  const keys = Object.keys(fields)\n  return make((self, that) => {\n    for (const key of keys) {\n      const o = fields[key](self[key], that[key])\n      if (o !== 0) {\n        return o\n      }\n    }\n    return 0\n  })\n}\n\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 2.0.0\n */\nexport const lessThan = <A>(O: Order<A>): {\n  (that: A): (self: A) => boolean\n  (self: A, that: A): boolean\n} => dual(2, (self: A, that: A) => O(self, that) === -1)\n\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 2.0.0\n */\nexport const greaterThan = <A>(O: Order<A>): {\n  (that: A): (self: A) => boolean\n  (self: A, that: A): boolean\n} => dual(2, (self: A, that: A) => O(self, that) === 1)\n\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 2.0.0\n */\nexport const lessThanOrEqualTo = <A>(O: Order<A>): {\n  (that: A): (self: A) => boolean\n  (self: A, that: A): boolean\n} => dual(2, (self: A, that: A) => O(self, that) !== 1)\n\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 2.0.0\n */\nexport const greaterThanOrEqualTo = <A>(O: Order<A>): {\n  (that: A): (self: A) => boolean\n  (self: A, that: A): boolean\n} => dual(2, (self: A, that: A) => O(self, that) !== -1)\n\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nexport const min = <A>(O: Order<A>): {\n  (that: A): (self: A) => A\n  (self: A, that: A): A\n} => dual(2, (self: A, that: A) => self === that || O(self, that) < 1 ? self : that)\n\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nexport const max = <A>(O: Order<A>): {\n  (that: A): (self: A) => A\n  (self: A, that: A): A\n} => dual(2, (self: A, that: A) => self === that || O(self, that) > -1 ? self : that)\n\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Order, Number } from \"effect\"\n *\n * const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })\n *\n * assert.equal(clamp(3), 3)\n * assert.equal(clamp(0), 1)\n * assert.equal(clamp(6), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const clamp = <A>(O: Order<A>): {\n  (options: {\n    minimum: A\n    maximum: A\n  }): (self: A) => A\n  (self: A, options: {\n    minimum: A\n    maximum: A\n  }): A\n} =>\n  dual(\n    2,\n    (self: A, options: {\n      minimum: A\n      maximum: A\n    }): A => min(O)(options.maximum, max(O)(options.minimum, self))\n  )\n\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 2.0.0\n */\nexport const between = <A>(O: Order<A>): {\n  (options: {\n    minimum: A\n    maximum: A\n  }): (self: A) => boolean\n  (self: A, options: {\n    minimum: A\n    maximum: A\n  }): boolean\n} =>\n  dual(\n    2,\n    (self: A, options: {\n      minimum: A\n      maximum: A\n    }): boolean => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum)\n  )\n","/**\n * @since 2.0.0\n */\nimport type { Either } from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { constNull, constUndefined, dual, identity, isFunction } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as doNotation from \"./internal/doNotation.js\"\nimport * as either from \"./internal/either.js\"\nimport * as option from \"./internal/option.js\"\nimport type { Order } from \"./Order.js\"\nimport * as order from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport type { Covariant, NoInfer, NotFunction } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport * as Gen from \"./Utils.js\"\n\n/**\n * The `Option` data type represents optional values. An `Option<A>` can either\n * be `Some<A>`, containing a value of type `A`, or `None`, representing the\n * absence of a value.\n *\n * **When to Use**\n *\n * You can use `Option` in scenarios like:\n *\n * - Using it for initial values\n * - Returning values from functions that are not defined for all possible\n *   inputs (referred to as “partial functions”)\n * - Managing optional fields in data structures\n * - Handling optional function arguments\n *\n * @category Models\n * @since 2.0.0\n */\nexport type Option<A> = None<A> | Some<A>\n\n/**\n * @category Symbols\n * @since 2.0.0\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Option\")\n\n/**\n * @category Symbols\n * @since 2.0.0\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface None<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"None\"\n  readonly _op: \"None\"\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface Some<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Some\"\n  readonly _op: \"Some\"\n  readonly value: A\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface OptionUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Option?: () => A[Unify.typeSymbol] extends Option<infer A0> | infer _ ? Option<A0> : never\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Option {\n  /**\n   * Extracts the type of the value contained in an `Option`.\n   *\n   * **Example** (Getting the Value Type of an Option)\n   *\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Declare an Option holding a string\n   * declare const myOption: Option.Option<string>\n   *\n   * // Extract the type of the value within the Option\n   * //\n   * //      ┌─── string\n   * //      ▼\n   * type MyType = Option.Option.Value<typeof myOption>\n   * ```\n   *\n   * @since 2.0.0\n   * @category Type-level Utils\n   */\n  export type Value<T extends Option<any>> = [T] extends [Option<infer _A>] ? _A : never\n}\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface OptionUnifyIgnore {}\n\n/**\n * @category Type Lambdas\n * @since 2.0.0\n */\nexport interface OptionTypeLambda extends TypeLambda {\n  readonly type: Option<this[\"Target\"]>\n}\n\n/**\n * Represents the absence of a value by creating an empty `Option`.\n *\n * `Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.\n * This means you can use it in place of any `Option<A>` regardless of the type\n * `A`.\n *\n * **Example** (Creating an Option with No Value)\n *\n * ```ts\n * import { Option } from \"effect\"\n *\n * // An Option holding no value\n * //\n * //      ┌─── Option<never>\n * //      ▼\n * const noValue = Option.none()\n *\n * console.log(noValue)\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @see {@link some} for the opposite operation.\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const none = <A = never>(): Option<A> => option.none\n\n/**\n * Wraps the given value into an `Option` to represent its presence.\n *\n * **Example** (Creating an Option with a Value)\n *\n * ```ts\n * import { Option } from \"effect\"\n *\n * // An Option holding the number 1\n * //\n * //      ┌─── Option<number>\n * //      ▼\n * const value = Option.some(1)\n *\n * console.log(value)\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @see {@link none} for the opposite operation.\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const some: <A>(value: A) => Option<A> = option.some\n\n/**\n * Determines whether the given value is an `Option`.\n *\n * **Details**\n *\n * This function checks if a value is an instance of `Option`. It returns `true`\n * if the value is either `Option.some` or `Option.none`, and `false` otherwise.\n * This is particularly useful when working with unknown values or when you need\n * to ensure type safety in your code.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isOption(Option.some(1)))\n * // Output: true\n *\n * console.log(Option.isOption(Option.none()))\n * // Output: true\n *\n * console.log(Option.isOption({}))\n * // Output: false\n * ```\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isOption: (input: unknown) => input is Option<unknown> = option.isOption\n\n/**\n * Checks whether an `Option` represents the absence of a value (`None`).\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isNone(Option.some(1)))\n * // Output: false\n *\n * console.log(Option.isNone(Option.none()))\n * // Output: true\n * ```\n *\n * @see {@link isSome} for the opposite check.\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isNone: <A>(self: Option<A>) => self is None<A> = option.isNone\n\n/**\n * Checks whether an `Option` contains a value (`Some`).\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isSome(Option.some(1)))\n * // Output: true\n *\n * console.log(Option.isSome(Option.none()))\n * // Output: false\n * ```\n *\n * @see {@link isNone} for the opposite check.\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isSome: <A>(self: Option<A>) => self is Some<A> = option.isSome\n\n/**\n * Performs pattern matching on an `Option` to handle both `Some` and `None`\n * cases.\n *\n * **Details**\n *\n * This function allows you to match against an `Option` and handle both\n * scenarios: when the `Option` is `None` (i.e., contains no value), and when\n * the `Option` is `Some` (i.e., contains a value). It executes one of the\n * provided functions based on the case:\n *\n * - If the `Option` is `None`, the `onNone` function is executed and its result\n *   is returned.\n * - If the `Option` is `Some`, the `onSome` function is executed with the\n *   contained value, and its result is returned.\n *\n * This function provides a concise and functional way to handle optional values\n * without resorting to `if` or manual checks, making your code more declarative\n * and readable.\n *\n * **Example** (Pattern Matching with Option)\n *\n * ```ts\n * import { Option } from \"effect\"\n *\n * const foo = Option.some(1)\n *\n * const message = Option.match(foo, {\n *   onNone: () => \"Option is empty\",\n *   onSome: (value) => `Option has a value: ${value}`\n * })\n *\n * console.log(message)\n * // Output: \"Option has a value: 1\"\n * ```\n *\n * @category Pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  /**\n   * Performs pattern matching on an `Option` to handle both `Some` and `None`\n   * cases.\n   *\n   * **Details**\n   *\n   * This function allows you to match against an `Option` and handle both\n   * scenarios: when the `Option` is `None` (i.e., contains no value), and when\n   * the `Option` is `Some` (i.e., contains a value). It executes one of the\n   * provided functions based on the case:\n   *\n   * - If the `Option` is `None`, the `onNone` function is executed and its result\n   *   is returned.\n   * - If the `Option` is `Some`, the `onSome` function is executed with the\n   *   contained value, and its result is returned.\n   *\n   * This function provides a concise and functional way to handle optional values\n   * without resorting to `if` or manual checks, making your code more declarative\n   * and readable.\n   *\n   * **Example** (Pattern Matching with Option)\n   *\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const foo = Option.some(1)\n   *\n   * const message = Option.match(foo, {\n   *   onNone: () => \"Option is empty\",\n   *   onSome: (value) => `Option has a value: ${value}`\n   * })\n   *\n   * console.log(message)\n   * // Output: \"Option has a value: 1\"\n   * ```\n   *\n   * @category Pattern matching\n   * @since 2.0.0\n   */\n  <B, A, C = B>(\n    options: {\n      readonly onNone: LazyArg<B>\n      readonly onSome: (a: A) => C\n    }\n  ): (self: Option<A>) => B | C\n  /**\n   * Performs pattern matching on an `Option` to handle both `Some` and `None`\n   * cases.\n   *\n   * **Details**\n   *\n   * This function allows you to match against an `Option` and handle both\n   * scenarios: when the `Option` is `None` (i.e., contains no value), and when\n   * the `Option` is `Some` (i.e., contains a value). It executes one of the\n   * provided functions based on the case:\n   *\n   * - If the `Option` is `None`, the `onNone` function is executed and its result\n   *   is returned.\n   * - If the `Option` is `Some`, the `onSome` function is executed with the\n   *   contained value, and its result is returned.\n   *\n   * This function provides a concise and functional way to handle optional values\n   * without resorting to `if` or manual checks, making your code more declarative\n   * and readable.\n   *\n   * **Example** (Pattern Matching with Option)\n   *\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const foo = Option.some(1)\n   *\n   * const message = Option.match(foo, {\n   *   onNone: () => \"Option is empty\",\n   *   onSome: (value) => `Option has a value: ${value}`\n   * })\n   *\n   * console.log(message)\n   * // Output: \"Option has a value: 1\"\n   * ```\n   *\n   * @category Pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    self: Option<A>,\n    options: {\n      readonly onNone: LazyArg<B>\n      readonly onSome: (a: A) => C\n    }\n  ): B | C\n} = dual(\n  2,\n  <A, B, C = B>(self: Option<A>, { onNone, onSome }: {\n    readonly onNone: LazyArg<B>\n    readonly onSome: (a: A) => C\n  }): B | C => isNone(self) ? onNone() : onSome(self.value)\n)\n\n/**\n * Converts an `Option`-returning function into a type guard.\n *\n * **Details**\n *\n * This function transforms a function that returns an `Option` into a type\n * guard, ensuring type safety when validating or narrowing types. The returned\n * type guard function checks whether the input satisfies the condition defined\n * in the original `Option`-returning function.\n *\n * If the original function returns `Option.some`, the type guard evaluates to\n * `true`, confirming the input is of the desired type. If the function returns\n * `Option.none`, the type guard evaluates to `false`.\n *\n * This utility is especially useful for validating types in union types,\n * filtering arrays, or ensuring safe handling of specific subtypes.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * type MyData = string | number\n *\n * const parseString = (data: MyData): Option.Option<string> =>\n *   typeof data === \"string\" ? Option.some(data) : Option.none()\n *\n * //      ┌─── (a: MyData) => a is string\n * //      ▼\n * const isString = Option.toRefinement(parseString)\n *\n * console.log(isString(\"a\"))\n * // Output: true\n *\n * console.log(isString(1))\n * // Output: false\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const toRefinement = <A, B extends A>(f: (a: A) => Option<B>): (a: A) => a is B => (a: A): a is B => isSome(f(a))\n\n/**\n * Converts an `Iterable` into an `Option`, wrapping the first element if it\n * exists.\n *\n * **Details**\n *\n * This function takes an `Iterable` (e.g., an array, a generator, or any object\n * implementing the `Iterable` interface) and returns an `Option` based on its\n * content:\n *\n * - If the `Iterable` contains at least one element, the first element is\n *   wrapped in a `Some` and returned.\n * - If the `Iterable` is empty, `None` is returned, representing the absence of\n *   a value.\n *\n * This utility is useful for safely handling collections that might be empty,\n * ensuring you explicitly handle both cases where a value exists or doesn't.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.fromIterable([1, 2, 3]))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(Option.fromIterable([]))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const fromIterable = <A>(collection: Iterable<A>): Option<A> => {\n  for (const a of collection) {\n    return some(a)\n  }\n  return none()\n}\n\n/**\n * Converts an `Either` into an `Option` by discarding the error and extracting\n * the right value.\n *\n * **Details**\n *\n * This function takes an `Either` and returns an `Option` based on its value:\n *\n * - If the `Either` is a `Right`, its value is wrapped in a `Some` and\n *   returned.\n * - If the `Either` is a `Left`, the error is discarded, and `None` is\n *   returned.\n *\n * This is particularly useful when you only care about the success case\n * (`Right`) of an `Either` and want to handle the result using `Option`. By\n * using this function, you can convert `Either` into a simpler structure for\n * cases where error handling is not required.\n *\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * console.log(Option.getRight(Either.right(\"ok\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'ok' }\n *\n * console.log(Option.getRight(Either.left(\"err\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @see {@link getLeft} for the opposite operation.\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getRight: <R, L>(self: Either<R, L>) => Option<R> = either.getRight\n\n/**\n * Converts an `Either` into an `Option` by discarding the right value and\n * extracting the left value.\n *\n * **Details**\n *\n * This function transforms an `Either` into an `Option` as follows:\n *\n * - If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.\n * - If the `Either` is a `Right`, the value is discarded, and `None` is\n *   returned.\n *\n * This utility is useful when you only care about the error case (`Left`) of an\n * `Either` and want to handle it as an `Option`. By discarding the right value,\n * it simplifies error-focused workflows.\n *\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * console.log(Option.getLeft(Either.right(\"ok\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.getLeft(Either.left(\"err\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'err' }\n * ```\n *\n * @see {@link getRight} for the opposite operation.\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getLeft: <R, L>(self: Either<R, L>) => Option<L> = either.getLeft\n\n/**\n * Returns the value contained in the `Option` if it is `Some`, otherwise\n * evaluates and returns the result of `onNone`.\n *\n * **Details**\n *\n * This function allows you to provide a fallback value or computation for when\n * an `Option` is `None`. If the `Option` contains a value (`Some`), that value\n * is returned. If it is empty (`None`), the `onNone` function is executed, and\n * its result is returned instead.\n *\n * This utility is helpful for safely handling `Option` values by ensuring you\n * always receive a meaningful result, whether or not the `Option` contains a\n * value. It is particularly useful for providing default values or alternative\n * logic when working with optional values.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n * // Output: 1\n *\n * console.log(Option.none().pipe(Option.getOrElse(() => 0)))\n * // Output: 0\n * ```\n *\n * @see {@link getOrNull} for a version that returns `null` instead of executing a function.\n * @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrElse: {\n  /**\n   * Returns the value contained in the `Option` if it is `Some`, otherwise\n   * evaluates and returns the result of `onNone`.\n   *\n   * **Details**\n   *\n   * This function allows you to provide a fallback value or computation for when\n   * an `Option` is `None`. If the `Option` contains a value (`Some`), that value\n   * is returned. If it is empty (`None`), the `onNone` function is executed, and\n   * its result is returned instead.\n   *\n   * This utility is helpful for safely handling `Option` values by ensuring you\n   * always receive a meaningful result, whether or not the `Option` contains a\n   * value. It is particularly useful for providing default values or alternative\n   * logic when working with optional values.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n   * // Output: 1\n   *\n   * console.log(Option.none().pipe(Option.getOrElse(() => 0)))\n   * // Output: 0\n   * ```\n   *\n   * @see {@link getOrNull} for a version that returns `null` instead of executing a function.\n   * @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.\n   *\n   * @category Getters\n   * @since 2.0.0\n   */\n  <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A\n  /**\n   * Returns the value contained in the `Option` if it is `Some`, otherwise\n   * evaluates and returns the result of `onNone`.\n   *\n   * **Details**\n   *\n   * This function allows you to provide a fallback value or computation for when\n   * an `Option` is `None`. If the `Option` contains a value (`Some`), that value\n   * is returned. If it is empty (`None`), the `onNone` function is executed, and\n   * its result is returned instead.\n   *\n   * This utility is helpful for safely handling `Option` values by ensuring you\n   * always receive a meaningful result, whether or not the `Option` contains a\n   * value. It is particularly useful for providing default values or alternative\n   * logic when working with optional values.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n   * // Output: 1\n   *\n   * console.log(Option.none().pipe(Option.getOrElse(() => 0)))\n   * // Output: 0\n   * ```\n   *\n   * @see {@link getOrNull} for a version that returns `null` instead of executing a function.\n   * @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.\n   *\n   * @category Getters\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B\n} = dual(\n  2,\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B => isNone(self) ? onNone() : self.value\n)\n\n/**\n * Returns the provided `Option` `that` if the current `Option` (`self`) is\n * `None`; otherwise, it returns `self`.\n *\n * **Details**\n *\n * This function provides a fallback mechanism for `Option` values. If the\n * current `Option` is `None` (i.e., it contains no value), the `that` function\n * is evaluated, and its resulting `Option` is returned. If the current `Option`\n * is `Some` (i.e., it contains a value), the original `Option` is returned\n * unchanged.\n *\n * This is particularly useful for chaining fallback values or computations,\n * allowing you to provide alternative `Option` values when the first one is\n * empty.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.none().pipe(Option.orElse(() => Option.none())))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n *\n * console.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElse: {\n  /**\n   * Returns the provided `Option` `that` if the current `Option` (`self`) is\n   * `None`; otherwise, it returns `self`.\n   *\n   * **Details**\n   *\n   * This function provides a fallback mechanism for `Option` values. If the\n   * current `Option` is `None` (i.e., it contains no value), the `that` function\n   * is evaluated, and its resulting `Option` is returned. If the current `Option`\n   * is `Some` (i.e., it contains a value), the original `Option` is returned\n   * unchanged.\n   *\n   * This is particularly useful for chaining fallback values or computations,\n   * allowing you to provide alternative `Option` values when the first one is\n   * empty.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.none().pipe(Option.orElse(() => Option.none())))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   *\n   * console.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>\n  /**\n   * Returns the provided `Option` `that` if the current `Option` (`self`) is\n   * `None`; otherwise, it returns `self`.\n   *\n   * **Details**\n   *\n   * This function provides a fallback mechanism for `Option` values. If the\n   * current `Option` is `None` (i.e., it contains no value), the `that` function\n   * is evaluated, and its resulting `Option` is returned. If the current `Option`\n   * is `Some` (i.e., it contains a value), the original `Option` is returned\n   * unchanged.\n   *\n   * This is particularly useful for chaining fallback values or computations,\n   * allowing you to provide alternative `Option` values when the first one is\n   * empty.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.none().pipe(Option.orElse(() => Option.none())))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   *\n   * console.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B> => isNone(self) ? that() : self\n)\n\n/**\n * Returns the provided default value wrapped in `Some` if the current `Option`\n * (`self`) is `None`; otherwise, returns `self`.\n *\n * **Details**\n *\n * This function provides a way to supply a default value for cases where an\n * `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\n * function is executed to compute the default value, which is then wrapped in a\n * `Some`. If the current `Option` contains a value (`Some`), it is returned as\n * is.\n *\n * This is particularly useful for handling optional values where a fallback\n * default needs to be provided explicitly in case of absence.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElseSome: {\n  /**\n   * Returns the provided default value wrapped in `Some` if the current `Option`\n   * (`self`) is `None`; otherwise, returns `self`.\n   *\n   * **Details**\n   *\n   * This function provides a way to supply a default value for cases where an\n   * `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\n   * function is executed to compute the default value, which is then wrapped in a\n   * `Some`. If the current `Option` contains a value (`Some`), it is returned as\n   * is.\n   *\n   * This is particularly useful for handling optional values where a fallback\n   * default needs to be provided explicitly in case of absence.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>\n  /**\n   * Returns the provided default value wrapped in `Some` if the current `Option`\n   * (`self`) is `None`; otherwise, returns `self`.\n   *\n   * **Details**\n   *\n   * This function provides a way to supply a default value for cases where an\n   * `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\n   * function is executed to compute the default value, which is then wrapped in a\n   * `Some`. If the current `Option` contains a value (`Some`), it is returned as\n   * is.\n   *\n   * This is particularly useful for handling optional values where a fallback\n   * default needs to be provided explicitly in case of absence.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B> => isNone(self) ? some(onNone()) : self\n)\n\n/**\n * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n * indicate the source of the value.\n *\n * **Details**\n *\n * This function allows you to provide a fallback `Option` in case the current\n * `Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\n * wrapped in an `Either` object, providing additional information about where\n * the value came from:\n *\n * - If the value is from the fallback `Option` (`that`), it is wrapped in an\n *   `Either.right`.\n * - If the value is from the original `Option` (`self`), it is wrapped in an\n *   `Either.left`.\n *\n * This is especially useful when you need to differentiate between values\n * originating from the primary `Option` and those coming from the fallback,\n * while still maintaining the `Option`-style handling.\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElseEither: {\n  /**\n   * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n   * indicate the source of the value.\n   *\n   * **Details**\n   *\n   * This function allows you to provide a fallback `Option` in case the current\n   * `Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\n   * wrapped in an `Either` object, providing additional information about where\n   * the value came from:\n   *\n   * - If the value is from the fallback `Option` (`that`), it is wrapped in an\n   *   `Either.right`.\n   * - If the value is from the original `Option` (`self`), it is wrapped in an\n   *   `Either.left`.\n   *\n   * This is especially useful when you need to differentiate between values\n   * originating from the primary `Option` and those coming from the fallback,\n   * while still maintaining the `Option`-style handling.\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>\n  /**\n   * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n   * indicate the source of the value.\n   *\n   * **Details**\n   *\n   * This function allows you to provide a fallback `Option` in case the current\n   * `Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\n   * wrapped in an `Either` object, providing additional information about where\n   * the value came from:\n   *\n   * - If the value is from the fallback `Option` (`that`), it is wrapped in an\n   *   `Either.right`.\n   * - If the value is from the original `Option` (`self`), it is wrapped in an\n   *   `Either.left`.\n   *\n   * This is especially useful when you need to differentiate between values\n   * originating from the primary `Option` and those coming from the fallback,\n   * while still maintaining the `Option`-style handling.\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>> =>\n    isNone(self) ? map(that(), either.right) : map(self, either.left)\n)\n\n/**\n * Returns the first `Some` value found in an `Iterable` collection of\n * `Option`s, or `None` if no `Some` is found.\n *\n * **Details**\n *\n * This function iterates over a collection of `Option` values and returns the\n * first `Some` it encounters. If the collection contains only `None` values,\n * the result will also be `None`. This utility is useful for efficiently\n * finding the first valid value in a sequence of potentially empty or invalid\n * options.\n *\n * The iteration stops as soon as a `Some` is found, making this function\n * efficient for large collections.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.firstSomeOf([\n *   Option.none(),\n *   Option.some(1),\n *   Option.some(2)\n * ]))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const firstSomeOf = <T, C extends Iterable<Option<T>> = Iterable<Option<T>>>(\n  collection: C\n): [C] extends [Iterable<Option<infer A>>] ? Option<A> : never => {\n  let out: Option<unknown> = none()\n  for (out of collection) {\n    if (isSome(out)) {\n      return out as any\n    }\n  }\n  return out as any\n}\n\n/**\n * Converts a nullable value into an `Option`. Returns `None` if the value is\n * `null` or `undefined`, otherwise wraps the value in a `Some`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.fromNullable(undefined))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.fromNullable(null))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.fromNullable(1))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const fromNullable = <A>(\n  nullableValue: A\n): Option<NonNullable<A>> => (nullableValue == null ? none() : some(nullableValue as NonNullable<A>))\n\n/**\n * Lifts a function that returns `null` or `undefined` into the `Option`\n * context.\n *\n * **Details**\n *\n * This function takes a function `f` that might return `null` or `undefined`\n * and transforms it into a function that returns an `Option`. The resulting\n * function will return:\n * - `Some` if the original function produces a non-null, non-undefined value.\n * - `None` if the original function produces `null` or `undefined`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = Option.liftNullable(parse)\n *\n * console.log(parseOption(\"1\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parseOption(\"not a number\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const liftNullable = <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n): (...a: A) => Option<NonNullable<B>> =>\n(...a) => fromNullable(f(...a))\n\n/**\n * Returns the value contained in the `Option` if it is `Some`; otherwise,\n * returns `null`.\n *\n * **Details**\n *\n * This function provides a way to extract the value of an `Option` while\n * falling back to `null` if the `Option` is `None`.\n *\n * It is particularly useful in scenarios where `null` is an acceptable\n * placeholder for the absence of a value, such as when interacting with APIs or\n * systems that use `null` as a default for missing values.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.getOrNull(Option.some(1)))\n * // Output: 1\n *\n * console.log(Option.getOrNull(Option.none()))\n * // Output: null\n * ```\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrNull: <A>(self: Option<A>) => A | null = getOrElse(constNull)\n\n/**\n * Returns the value contained in the `Option` if it is `Some`; otherwise,\n * returns `undefined`.\n *\n * **Details**\n *\n * This function provides a way to extract the value of an `Option` while\n * falling back to `undefined` if the `Option` is `None`.\n *\n * It is particularly useful in scenarios where `undefined` is an acceptable\n * placeholder for the absence of a value, such as when interacting with APIs or\n * systems that use `undefined` as a default for missing values.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.getOrUndefined(Option.some(1)))\n * // Output: 1\n *\n * console.log(Option.getOrUndefined(Option.none()))\n * // Output: undefined\n * ```\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrUndefined: <A>(self: Option<A>) => A | undefined = getOrElse(constUndefined)\n\n/**\n * Lifts a function that throws exceptions into a function that returns an\n * `Option`.\n *\n * **Details**\n *\n * This utility function takes a function `f` that might throw an exception and\n * transforms it into a safer function that returns an `Option`. If the original\n * function executes successfully, the result is wrapped in a `Some`. If an\n * exception is thrown, the result is `None`, allowing the developer to handle\n * errors in a functional, type-safe way.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = Option.liftThrowable(JSON.parse)\n *\n * console.log(parse(\"1\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parse(\"\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const liftThrowable = <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B\n): (...a: A) => Option<B> =>\n(...a) => {\n  try {\n    return some(f(...a))\n  } catch {\n    return none()\n  }\n}\n\n/**\n * Extracts the value of an `Option` or throws an error if the `Option` is\n * `None`, using a custom error factory.\n *\n * **Details**\n *\n * This function allows you to extract the value of an `Option` when it is\n * `Some`. If the `Option` is `None`, it throws an error generated by the\n * provided `onNone` function. This utility is particularly useful when you need\n * a fail-fast behavior for empty `Option` values and want to provide a custom\n * error message or object.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n * ```\n *\n * @see {@link getOrThrow} for a version that throws a default error.\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getOrThrowWith: {\n  /**\n   * Extracts the value of an `Option` or throws an error if the `Option` is\n   * `None`, using a custom error factory.\n   *\n   * **Details**\n   *\n   * This function allows you to extract the value of an `Option` when it is\n   * `Some`. If the `Option` is `None`, it throws an error generated by the\n   * provided `onNone` function. This utility is particularly useful when you need\n   * a fail-fast behavior for empty `Option` values and want to provide a custom\n   * error message or object.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n   *   1\n   * )\n   * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n   * ```\n   *\n   * @see {@link getOrThrow} for a version that throws a default error.\n   *\n   * @category Conversions\n   * @since 2.0.0\n   */\n  (onNone: () => unknown): <A>(self: Option<A>) => A\n  /**\n   * Extracts the value of an `Option` or throws an error if the `Option` is\n   * `None`, using a custom error factory.\n   *\n   * **Details**\n   *\n   * This function allows you to extract the value of an `Option` when it is\n   * `Some`. If the `Option` is `None`, it throws an error generated by the\n   * provided `onNone` function. This utility is particularly useful when you need\n   * a fail-fast behavior for empty `Option` values and want to provide a custom\n   * error message or object.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n   *   1\n   * )\n   * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n   * ```\n   *\n   * @see {@link getOrThrow} for a version that throws a default error.\n   *\n   * @category Conversions\n   * @since 2.0.0\n   */\n  <A>(self: Option<A>, onNone: () => unknown): A\n} = dual(2, <A>(self: Option<A>, onNone: () => unknown): A => {\n  if (isSome(self)) {\n    return self.value\n  }\n  throw onNone()\n})\n\n/**\n * Extracts the value of an `Option` or throws a default error if the `Option`\n * is `None`.\n *\n * **Details**\n *\n * This function extracts the value from an `Option` if it is `Some`. If the\n * `Option` is `None`, it throws a default error. It is useful for fail-fast\n * scenarios where the absence of a value is treated as an exceptional case and\n * a default error is sufficient.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\n * assert.throws(() => Option.getOrThrow(Option.none()))\n * ```\n *\n * @see {@link getOrThrowWith} for a version that allows you to provide a custom error.\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getOrThrow: <A>(self: Option<A>) => A = getOrThrowWith(() => new Error(\"getOrThrow called on a None\"))\n\n/**\n * Transforms the value inside a `Some` to a new value using the provided\n * function, while leaving `None` unchanged.\n *\n * **Details**\n *\n * This function applies a mapping function `f` to the value inside an `Option`\n * if it is a `Some`. If the `Option` is `None`, it remains unchanged. The\n * result is a new `Option` with the transformed value (if it was a `Some`) or\n * still `None`.\n *\n * This utility is particularly useful for chaining transformations in a\n * functional way without needing to manually handle `None` cases.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Mapping over a `Some`\n * const someValue = Option.some(2)\n *\n * console.log(Option.map(someValue, (n) => n * 2))\n * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n *\n * // Mapping over a `None`\n * const noneValue = Option.none<number>()\n *\n * console.log(Option.map(noneValue, (n) => n * 2))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const map: {\n  /**\n   * Transforms the value inside a `Some` to a new value using the provided\n   * function, while leaving `None` unchanged.\n   *\n   * **Details**\n   *\n   * This function applies a mapping function `f` to the value inside an `Option`\n   * if it is a `Some`. If the `Option` is `None`, it remains unchanged. The\n   * result is a new `Option` with the transformed value (if it was a `Some`) or\n   * still `None`.\n   *\n   * This utility is particularly useful for chaining transformations in a\n   * functional way without needing to manually handle `None` cases.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Mapping over a `Some`\n   * const someValue = Option.some(2)\n   *\n   * console.log(Option.map(someValue, (n) => n * 2))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n   *\n   * // Mapping over a `None`\n   * const noneValue = Option.none<number>()\n   *\n   * console.log(Option.map(noneValue, (n) => n * 2))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Mapping\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>\n  /**\n   * Transforms the value inside a `Some` to a new value using the provided\n   * function, while leaving `None` unchanged.\n   *\n   * **Details**\n   *\n   * This function applies a mapping function `f` to the value inside an `Option`\n   * if it is a `Some`. If the `Option` is `None`, it remains unchanged. The\n   * result is a new `Option` with the transformed value (if it was a `Some`) or\n   * still `None`.\n   *\n   * This utility is particularly useful for chaining transformations in a\n   * functional way without needing to manually handle `None` cases.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Mapping over a `Some`\n   * const someValue = Option.some(2)\n   *\n   * console.log(Option.map(someValue, (n) => n * 2))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n   *\n   * // Mapping over a `None`\n   * const noneValue = Option.none<number>()\n   *\n   * console.log(Option.map(noneValue, (n) => n * 2))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Mapping\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B> => isNone(self) ? none() : some(f(self.value))\n)\n\n/**\n * Replaces the value inside a `Some` with the specified constant value, leaving\n * `None` unchanged.\n *\n * **Details**\n *\n * This function transforms an `Option` by replacing the value inside a `Some`\n * with the given constant value `b`. If the `Option` is `None`, it remains\n * unchanged.\n *\n * This is useful when you want to preserve the presence of a value (`Some`) but\n * replace its content with a fixed value.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Replacing the value of a `Some`\n * const someValue = Option.some(42)\n *\n * console.log(Option.as(someValue, \"new value\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n *\n * // Replacing a `None` (no effect)\n * const noneValue = Option.none<number>()\n *\n * console.log(Option.as(noneValue, \"new value\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const as: {\n  /**\n   * Replaces the value inside a `Some` with the specified constant value, leaving\n   * `None` unchanged.\n   *\n   * **Details**\n   *\n   * This function transforms an `Option` by replacing the value inside a `Some`\n   * with the given constant value `b`. If the `Option` is `None`, it remains\n   * unchanged.\n   *\n   * This is useful when you want to preserve the presence of a value (`Some`) but\n   * replace its content with a fixed value.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Replacing the value of a `Some`\n   * const someValue = Option.some(42)\n   *\n   * console.log(Option.as(someValue, \"new value\"))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n   *\n   * // Replacing a `None` (no effect)\n   * const noneValue = Option.none<number>()\n   *\n   * console.log(Option.as(noneValue, \"new value\"))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Mapping\n   * @since 2.0.0\n   */\n  <B>(b: B): <X>(self: Option<X>) => Option<B>\n  /**\n   * Replaces the value inside a `Some` with the specified constant value, leaving\n   * `None` unchanged.\n   *\n   * **Details**\n   *\n   * This function transforms an `Option` by replacing the value inside a `Some`\n   * with the given constant value `b`. If the `Option` is `None`, it remains\n   * unchanged.\n   *\n   * This is useful when you want to preserve the presence of a value (`Some`) but\n   * replace its content with a fixed value.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Replacing the value of a `Some`\n   * const someValue = Option.some(42)\n   *\n   * console.log(Option.as(someValue, \"new value\"))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n   *\n   * // Replacing a `None` (no effect)\n   * const noneValue = Option.none<number>()\n   *\n   * console.log(Option.as(noneValue, \"new value\"))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Mapping\n   * @since 2.0.0\n   */\n  <X, B>(self: Option<X>, b: B): Option<B>\n} = dual(2, <X, B>(self: Option<X>, b: B): Option<B> => map(self, () => b))\n\n/**\n * Replaces the value inside a `Some` with the constant value `void`, leaving\n * `None` unchanged.\n *\n * **Details**\n *\n * This function transforms an `Option` by replacing the value inside a `Some`\n * with `void`. If the `Option` is `None`, it remains unchanged.\n *\n * This is particularly useful in scenarios where the presence or absence of a\n * value is significant, but the actual content of the value is irrelevant.\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const asVoid: <_>(self: Option<_>) => Option<void> = as(undefined)\n\nconst void_: Option<void> = some(undefined)\nexport {\n  /**\n   * @since 2.0.0\n   */\n  void_ as void\n}\n\n/**\n * Applies a function to the value of a `Some` and flattens the resulting\n * `Option`. If the input is `None`, it remains `None`.\n *\n * **Details**\n *\n * This function allows you to chain computations that return `Option` values.\n * If the input `Option` is `Some`, the provided function `f` is applied to the\n * contained value, and the resulting `Option` is returned. If the input is\n * `None`, the function is not applied, and the result remains `None`.\n *\n * This utility is particularly useful for sequencing operations that may fail\n * or produce optional results, enabling clean and concise workflows for\n * handling such cases.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * interface Address {\n *   readonly city: string\n *   readonly street: Option.Option<string>\n * }\n *\n * interface User {\n *   readonly id: number\n *   readonly username: string\n *   readonly email: Option.Option<string>\n *   readonly address: Option.Option<Address>\n * }\n *\n * const user: User = {\n *   id: 1,\n *   username: \"john_doe\",\n *   email: Option.some(\"john.doe@example.com\"),\n *   address: Option.some({\n *     city: \"New York\",\n *     street: Option.some(\"123 Main St\")\n *   })\n * }\n *\n * // Use flatMap to extract the street value\n * const street = user.address.pipe(\n *   Option.flatMap((address) => address.street)\n * )\n *\n * console.log(street)\n * // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  /**\n   * Applies a function to the value of a `Some` and flattens the resulting\n   * `Option`. If the input is `None`, it remains `None`.\n   *\n   * **Details**\n   *\n   * This function allows you to chain computations that return `Option` values.\n   * If the input `Option` is `Some`, the provided function `f` is applied to the\n   * contained value, and the resulting `Option` is returned. If the input is\n   * `None`, the function is not applied, and the result remains `None`.\n   *\n   * This utility is particularly useful for sequencing operations that may fail\n   * or produce optional results, enabling clean and concise workflows for\n   * handling such cases.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * interface Address {\n   *   readonly city: string\n   *   readonly street: Option.Option<string>\n   * }\n   *\n   * interface User {\n   *   readonly id: number\n   *   readonly username: string\n   *   readonly email: Option.Option<string>\n   *   readonly address: Option.Option<Address>\n   * }\n   *\n   * const user: User = {\n   *   id: 1,\n   *   username: \"john_doe\",\n   *   email: Option.some(\"john.doe@example.com\"),\n   *   address: Option.some({\n   *     city: \"New York\",\n   *     street: Option.some(\"123 Main St\")\n   *   })\n   * }\n   *\n   * // Use flatMap to extract the street value\n   * const street = user.address.pipe(\n   *   Option.flatMap((address) => address.street)\n   * )\n   *\n   * console.log(street)\n   * // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  /**\n   * Applies a function to the value of a `Some` and flattens the resulting\n   * `Option`. If the input is `None`, it remains `None`.\n   *\n   * **Details**\n   *\n   * This function allows you to chain computations that return `Option` values.\n   * If the input `Option` is `Some`, the provided function `f` is applied to the\n   * contained value, and the resulting `Option` is returned. If the input is\n   * `None`, the function is not applied, and the result remains `None`.\n   *\n   * This utility is particularly useful for sequencing operations that may fail\n   * or produce optional results, enabling clean and concise workflows for\n   * handling such cases.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * interface Address {\n   *   readonly city: string\n   *   readonly street: Option.Option<string>\n   * }\n   *\n   * interface User {\n   *   readonly id: number\n   *   readonly username: string\n   *   readonly email: Option.Option<string>\n   *   readonly address: Option.Option<Address>\n   * }\n   *\n   * const user: User = {\n   *   id: 1,\n   *   username: \"john_doe\",\n   *   email: Option.some(\"john.doe@example.com\"),\n   *   address: Option.some({\n   *     city: \"New York\",\n   *     street: Option.some(\"123 Main St\")\n   *   })\n   * }\n   *\n   * // Use flatMap to extract the street value\n   * const street = user.address.pipe(\n   *   Option.flatMap((address) => address.street)\n   * )\n   *\n   * console.log(street)\n   * // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B> => isNone(self) ? none() : f(self.value)\n)\n\n/**\n * Chains two `Option`s together. The second `Option` can either be a static\n * value or depend on the result of the first `Option`.\n *\n * **Details**\n *\n * This function enables sequencing of two `Option` computations. If the first\n * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n * either:\n *\n * - Be a static `Option` value.\n * - Be a function that produces an `Option`, optionally based on the value of\n *   the first `Option`.\n *\n * If the first `Option` is `None`, the function skips the evaluation of the\n * second `Option` and directly returns `None`.\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const andThen: {\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: Option<B>): Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => Option<B> | Option<B>): Option<B> =>\n    flatMap(self, (a) => {\n      const b = isFunction(f) ? f(a) : f\n      return isOption(b) ? b : some(b)\n    })\n)\n\n/**\n * Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\n * using a function that may return `null` or `undefined`.\n *\n * **Details**\n *\n * This function applies a transformation function `f` to the value inside a\n * `Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\n * returns a value, it is wrapped in a `Some`. If `f` returns `null` or\n * `undefined`, the result is `None`. If the input `Option` is `None`, the\n * function is not applied, and `None` is returned.\n *\n * This utility is particularly useful when working with deeply nested optional\n * values or chaining computations that may result in `null` or `undefined` at\n * some point.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n *\n * // Extracting a deeply nested property\n * console.log(\n *   Option.some(employee1)\n *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n * )\n * // Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * // Property does not exist\n * console.log(\n *   Option.some(employee2)\n *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n * )\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable: {\n  /**\n   * Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\n   * using a function that may return `null` or `undefined`.\n   *\n   * **Details**\n   *\n   * This function applies a transformation function `f` to the value inside a\n   * `Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\n   * returns a value, it is wrapped in a `Some`. If `f` returns `null` or\n   * `undefined`, the result is `None`. If the input `Option` is `None`, the\n   * function is not applied, and `None` is returned.\n   *\n   * This utility is particularly useful when working with deeply nested optional\n   * values or chaining computations that may result in `null` or `undefined` at\n   * some point.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * interface Employee {\n   *   company?: {\n   *     address?: {\n   *       street?: {\n   *         name?: string\n   *       }\n   *     }\n   *   }\n   * }\n   *\n   * const employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n   *\n   * // Extracting a deeply nested property\n   * console.log(\n   *   Option.some(employee1)\n   *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n   * )\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n   *\n   * const employee2: Employee = { company: { address: { street: {} } } }\n   *\n   * // Property does not exist\n   * console.log(\n   *   Option.some(employee2)\n   *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n   * )\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>\n  /**\n   * Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\n   * using a function that may return `null` or `undefined`.\n   *\n   * **Details**\n   *\n   * This function applies a transformation function `f` to the value inside a\n   * `Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\n   * returns a value, it is wrapped in a `Some`. If `f` returns `null` or\n   * `undefined`, the result is `None`. If the input `Option` is `None`, the\n   * function is not applied, and `None` is returned.\n   *\n   * This utility is particularly useful when working with deeply nested optional\n   * values or chaining computations that may result in `null` or `undefined` at\n   * some point.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * interface Employee {\n   *   company?: {\n   *     address?: {\n   *       street?: {\n   *         name?: string\n   *       }\n   *     }\n   *   }\n   * }\n   *\n   * const employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n   *\n   * // Extracting a deeply nested property\n   * console.log(\n   *   Option.some(employee1)\n   *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n   * )\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n   *\n   * const employee2: Employee = { company: { address: { street: {} } } }\n   *\n   * // Property does not exist\n   * console.log(\n   *   Option.some(employee2)\n   *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n   * )\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>> =>\n    isNone(self) ? none() : fromNullable(f(self.value))\n)\n\n/**\n * Flattens an `Option` of `Option` into a single `Option`.\n *\n * **Details**\n *\n * This function takes an `Option` that wraps another `Option` and flattens it\n * into a single `Option`. If the outer `Option` is `Some`, the function\n * extracts the inner `Option`. If the outer `Option` is `None`, the result\n * remains `None`.\n *\n * This is useful for simplifying nested `Option` structures that may arise\n * during functional operations.\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatten: <A>(self: Option<Option<A>>) => Option<A> = flatMap(identity)\n\n/**\n * Combines two `Option`s, keeping the value from the second `Option` if both\n * are `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and returns the second one if the first is\n * `Some`. If the first `Option` is `None`, the result will also be `None`,\n * regardless of the second `Option`. It effectively \"zips\" the two `Option`s\n * while discarding the value from the first `Option`.\n *\n * This is particularly useful when sequencing computations where the result of\n * the first computation is not needed, and you only care about the result of\n * the second computation.\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipRight: {\n  /**\n   * Combines two `Option`s, keeping the value from the second `Option` if both\n   * are `Some`.\n   *\n   * **Details**\n   *\n   * This function takes two `Option`s and returns the second one if the first is\n   * `Some`. If the first `Option` is `None`, the result will also be `None`,\n   * regardless of the second `Option`. It effectively \"zips\" the two `Option`s\n   * while discarding the value from the first `Option`.\n   *\n   * This is particularly useful when sequencing computations where the result of\n   * the first computation is not needed, and you only care about the result of\n   * the second computation.\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>\n  /**\n   * Combines two `Option`s, keeping the value from the second `Option` if both\n   * are `Some`.\n   *\n   * **Details**\n   *\n   * This function takes two `Option`s and returns the second one if the first is\n   * `Some`. If the first `Option` is `None`, the result will also be `None`,\n   * regardless of the second `Option`. It effectively \"zips\" the two `Option`s\n   * while discarding the value from the first `Option`.\n   *\n   * This is particularly useful when sequencing computations where the result of\n   * the first computation is not needed, and you only care about the result of\n   * the second computation.\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <X, B>(self: Option<X>, that: Option<B>): Option<B>\n} = dual(2, <X, B>(self: Option<X>, that: Option<B>): Option<B> => flatMap(self, () => that))\n\n/**\n * Combines two `Option`s, keeping the value from the first `Option` if both are\n * `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and returns the first one if it is `Some`.\n * If either the first `Option` or the second `Option` is `None`, the result\n * will be `None`. This operation \"zips\" the two `Option`s while discarding the\n * value from the second `Option`.\n *\n * This is useful when sequencing computations where the second `Option`\n * represents a dependency or condition that must hold, but its value is\n * irrelevant.\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipLeft: {\n  /**\n   * Combines two `Option`s, keeping the value from the first `Option` if both are\n   * `Some`.\n   *\n   * **Details**\n   *\n   * This function takes two `Option`s and returns the first one if it is `Some`.\n   * If either the first `Option` or the second `Option` is `None`, the result\n   * will be `None`. This operation \"zips\" the two `Option`s while discarding the\n   * value from the second `Option`.\n   *\n   * This is useful when sequencing computations where the second `Option`\n   * represents a dependency or condition that must hold, but its value is\n   * irrelevant.\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>\n  /**\n   * Combines two `Option`s, keeping the value from the first `Option` if both are\n   * `Some`.\n   *\n   * **Details**\n   *\n   * This function takes two `Option`s and returns the first one if it is `Some`.\n   * If either the first `Option` or the second `Option` is `None`, the result\n   * will be `None`. This operation \"zips\" the two `Option`s while discarding the\n   * value from the second `Option`.\n   *\n   * This is useful when sequencing computations where the second `Option`\n   * represents a dependency or condition that must hold, but its value is\n   * irrelevant.\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <A, X>(self: Option<A>, that: Option<X>): Option<A>\n} = dual(2, <A, X>(self: Option<A>, that: Option<X>): Option<A> => tap(self, () => that))\n\n/**\n * Composes two functions that return `Option` values, creating a new function\n * that chains them together.\n *\n * **Details**\n *\n * This function allows you to compose two computations, each represented by a\n * function that returns an `Option`. The result of the first function is passed\n * to the second function if it is `Some`. If the first function returns `None`,\n * the composed function short-circuits and returns `None` without invoking the\n * second function.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n *\n * const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n *\n * const parseAndDouble = Option.composeK(parse, double)\n *\n * console.log(parseAndDouble(\"42\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n *\n * console.log(parseAndDouble(\"not a number\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const composeK: {\n  /**\n   * Composes two functions that return `Option` values, creating a new function\n   * that chains them together.\n   *\n   * **Details**\n   *\n   * This function allows you to compose two computations, each represented by a\n   * function that returns an `Option`. The result of the first function is passed\n   * to the second function if it is `Some`. If the first function returns `None`,\n   * the composed function short-circuits and returns `None` without invoking the\n   * second function.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n   *\n   * const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n   *\n   * const parseAndDouble = Option.composeK(parse, double)\n   *\n   * console.log(parseAndDouble(\"42\"))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n   *\n   * console.log(parseAndDouble(\"not a number\"))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>\n  /**\n   * Composes two functions that return `Option` values, creating a new function\n   * that chains them together.\n   *\n   * **Details**\n   *\n   * This function allows you to compose two computations, each represented by a\n   * function that returns an `Option`. The result of the first function is passed\n   * to the second function if it is `Some`. If the first function returns `None`,\n   * the composed function short-circuits and returns `None` without invoking the\n   * second function.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n   *\n   * const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n   *\n   * const parseAndDouble = Option.composeK(parse, double)\n   *\n   * console.log(parseAndDouble(\"42\"))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n   *\n   * console.log(parseAndDouble(\"not a number\"))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>\n} = dual(2, <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>) => (a: A): Option<C> => flatMap(afb(a), bfc))\n\n/**\n * Applies the provided function `f` to the value of the `Option` if it is\n * `Some` and returns the original `Option`, unless `f` returns `None`, in which\n * case it returns `None`.\n *\n * **Details**\n *\n * This function allows you to perform additional computations on the value of\n * an `Option` without modifying its original value. If the `Option` is `Some`,\n * the provided function `f` is executed with the value, and its result\n * determines whether the original `Option` is returned (`Some`) or the result\n * is `None` if `f` returns `None`. If the input `Option` is `None`, the\n * function is not executed, and `None` is returned.\n *\n * This is particularly useful for applying side conditions or performing\n * validation checks while retaining the original `Option`'s value.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n *\n * console.log(Option.tap(Option.none(), getInteger))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.tap(Option.some(1), getInteger))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(Option.tap(Option.some(1.14), getInteger))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const tap: {\n  /**\n   * Applies the provided function `f` to the value of the `Option` if it is\n   * `Some` and returns the original `Option`, unless `f` returns `None`, in which\n   * case it returns `None`.\n   *\n   * **Details**\n   *\n   * This function allows you to perform additional computations on the value of\n   * an `Option` without modifying its original value. If the `Option` is `Some`,\n   * the provided function `f` is executed with the value, and its result\n   * determines whether the original `Option` is returned (`Some`) or the result\n   * is `None` if `f` returns `None`. If the input `Option` is `None`, the\n   * function is not executed, and `None` is returned.\n   *\n   * This is particularly useful for applying side conditions or performing\n   * validation checks while retaining the original `Option`'s value.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n   *\n   * console.log(Option.tap(Option.none(), getInteger))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(Option.tap(Option.some(1), getInteger))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(Option.tap(Option.some(1.14), getInteger))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>\n  /**\n   * Applies the provided function `f` to the value of the `Option` if it is\n   * `Some` and returns the original `Option`, unless `f` returns `None`, in which\n   * case it returns `None`.\n   *\n   * **Details**\n   *\n   * This function allows you to perform additional computations on the value of\n   * an `Option` without modifying its original value. If the `Option` is `Some`,\n   * the provided function `f` is executed with the value, and its result\n   * determines whether the original `Option` is returned (`Some`) or the result\n   * is `None` if `f` returns `None`. If the input `Option` is `None`, the\n   * function is not executed, and `None` is returned.\n   *\n   * This is particularly useful for applying side conditions or performing\n   * validation checks while retaining the original `Option`'s value.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n   *\n   * console.log(Option.tap(Option.none(), getInteger))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(Option.tap(Option.some(1), getInteger))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(Option.tap(Option.some(1.14), getInteger))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>\n} = dual(2, <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A> => flatMap(self, (a) => map(f(a), () => a)))\n\n/**\n * Combines two `Option` values into a single `Option` containing a tuple of\n * their values if both are `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and combines their values into a tuple `[A,\n * B]` if both are `Some`. If either of the `Option`s is `None`, the result is\n * `None`. This is particularly useful for combining multiple `Option` values\n * into a single one, ensuring both contain valid values.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const product = <A, B>(self: Option<A>, that: Option<B>): Option<[A, B]> =>\n  isSome(self) && isSome(that) ? some([self.value, that.value]) : none()\n\n/**\n * Combines an `Option` with a collection of `Option`s into a single `Option`\n * containing a tuple of their values if all are `Some`.\n *\n * **Details**\n *\n * This function takes a primary `Option` and a collection of `Option`s and\n * combines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If\n * the primary `Option` or any `Option` in the collection is `None`, the result\n * is `None`.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const productMany = <A>(\n  self: Option<A>,\n  collection: Iterable<Option<A>>\n): Option<[A, ...Array<A>]> => {\n  if (isNone(self)) {\n    return none()\n  }\n  const out: [A, ...Array<A>] = [self.value]\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none()\n    }\n    out.push(o.value)\n  }\n  return some(out)\n}\n\n/**\n * Combines a structure of `Option`s into a single `Option` containing the\n * values with the same structure.\n *\n * **Details**\n *\n * This function takes a structure of `Option`s (a tuple, struct, or iterable)\n * and produces a single `Option` that contains the values from the input\n * structure if all `Option`s are `Some`. If any `Option` in the input is\n * `None`, the result is `None`. The structure of the input is preserved in the\n * output.\n *\n * - If the input is a tuple (e.g., an array), the result will be an `Option`\n *   containing a tuple with the same length.\n * - If the input is a struct (e.g., an object), the result will be an `Option`\n *   containing a struct with the same keys.\n * - If the input is an iterable, the result will be an `Option` containing an\n *   array.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * //      ┌─── Option<[string, number]>\n * //      ▼\n * const tuple = Option.all([maybeName, maybeAge])\n * console.log(tuple)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }\n *\n * //      ┌─── Option<{ name: string; age: number; }>\n * //      ▼\n * const struct = Option.all({ name: maybeName, age: maybeAge })\n * console.log(struct)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }\n * ```\n *\n * @category Combining\n * @since 2.0.0\n */\n// @ts-expect-error\nexport const all: <const I extends Iterable<Option<any>> | Record<string, Option<any>>>(\n  input: I\n) => [I] extends [ReadonlyArray<Option<any>>] ? Option<\n    { -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never }\n  >\n  : [I] extends [Iterable<Option<infer A>>] ? Option<Array<A>>\n  : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never }> = (\n    input: Iterable<Option<any>> | Record<string, Option<any>>\n  ): Option<any> => {\n    if (Symbol.iterator in input) {\n      const out: Array<Option<any>> = []\n      for (const o of (input as Iterable<Option<any>>)) {\n        if (isNone(o)) {\n          return none()\n        }\n        out.push(o.value)\n      }\n      return some(out)\n    }\n\n    const out: Record<string, any> = {}\n    for (const key of Object.keys(input)) {\n      const o = input[key]\n      if (isNone(o)) {\n        return none()\n      }\n      out[key] = o.value\n    }\n    return some(out)\n  }\n\n/**\n * Combines two `Option` values into a new `Option` by applying a provided\n * function to their values.\n *\n * **Details**\n *\n * This function takes two `Option` values (`self` and `that`) and a combining\n * function `f`. If both `Option` values are `Some`, the function `f` is applied\n * to their values, and the result is wrapped in a new `Some`. If either\n * `Option` is `None`, the result is `None`.\n *\n * This utility is useful for combining two optional computations into a single\n * result while maintaining type safety and avoiding explicit checks for `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * // Combine the name and age into a person object\n * const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n *   name: name.toUpperCase(),\n *   age\n * }))\n *\n * console.log(person)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n * ```\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  /**\n   * Combines two `Option` values into a new `Option` by applying a provided\n   * function to their values.\n   *\n   * **Details**\n   *\n   * This function takes two `Option` values (`self` and `that`) and a combining\n   * function `f`. If both `Option` values are `Some`, the function `f` is applied\n   * to their values, and the result is wrapped in a new `Some`. If either\n   * `Option` is `None`, the result is `None`.\n   *\n   * This utility is useful for combining two optional computations into a single\n   * result while maintaining type safety and avoiding explicit checks for `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const maybeName: Option.Option<string> = Option.some(\"John\")\n   * const maybeAge: Option.Option<number> = Option.some(25)\n   *\n   * // Combine the name and age into a person object\n   * const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n   *   name: name.toUpperCase(),\n   *   age\n   * }))\n   *\n   * console.log(person)\n   * // Output:\n   * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n   * ```\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>\n  /**\n   * Combines two `Option` values into a new `Option` by applying a provided\n   * function to their values.\n   *\n   * **Details**\n   *\n   * This function takes two `Option` values (`self` and `that`) and a combining\n   * function `f`. If both `Option` values are `Some`, the function `f` is applied\n   * to their values, and the result is wrapped in a new `Some`. If either\n   * `Option` is `None`, the result is `None`.\n   *\n   * This utility is useful for combining two optional computations into a single\n   * result while maintaining type safety and avoiding explicit checks for `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const maybeName: Option.Option<string> = Option.some(\"John\")\n   * const maybeAge: Option.Option<number> = Option.some(25)\n   *\n   * // Combine the name and age into a person object\n   * const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n   *   name: name.toUpperCase(),\n   *   age\n   * }))\n   *\n   * console.log(person)\n   * // Output:\n   * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n   * ```\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>\n} = dual(\n  3,\n  <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C> =>\n    map(product(self, that), ([a, b]) => f(a, b))\n)\n\n/**\n * Applies a function inside a `Some` to a value inside another `Some`,\n * combining them into a new `Option`.\n *\n * **Details**\n *\n * This function allows you to apply a function wrapped in an `Option` (`self`)\n * to a value wrapped in another `Option` (`that`). If both `Option`s are\n * `Some`, the function is applied to the value, and the result is wrapped in a\n * new `Some`. If either `Option` is `None`, the result is `None`.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const ap: {\n  /**\n   * Applies a function inside a `Some` to a value inside another `Some`,\n   * combining them into a new `Option`.\n   *\n   * **Details**\n   *\n   * This function allows you to apply a function wrapped in an `Option` (`self`)\n   * to a value wrapped in another `Option` (`that`). If both `Option`s are\n   * `Some`, the function is applied to the value, and the result is wrapped in a\n   * new `Some`. If either `Option` is `None`, the result is `None`.\n   *\n   * @category Combining\n   * @since 2.0.0\n   */\n  <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>\n  /**\n   * Applies a function inside a `Some` to a value inside another `Some`,\n   * combining them into a new `Option`.\n   *\n   * **Details**\n   *\n   * This function allows you to apply a function wrapped in an `Option` (`self`)\n   * to a value wrapped in another `Option` (`that`). If both `Option`s are\n   * `Some`, the function is applied to the value, and the result is wrapped in a\n   * new `Some`. If either `Option` is `None`, the result is `None`.\n   *\n   * @category Combining\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>\n} = dual(2, <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B> => zipWith(self, that, (f, a) => f(a)))\n\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\n * elements that are `None`.\n *\n * **Details**\n *\n * This function takes an initial value of type `B` and a reducing function `f`\n * that combines the accumulator with values of type `A`. It processes an\n * iterable of `Option<A>`, applying `f` only to the `Some` values while\n * ignoring the `None` values. The result is a single value of type `B`.\n *\n * This utility is particularly useful for aggregating values from an iterable\n * of `Option`s while skipping the absent (`None`) values.\n *\n * @example\n * ```ts\n * import { Option, pipe } from \"effect\"\n *\n * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n *\n * console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n * // Output: 3\n * ```\n *\n * @category Reducing\n * @since 2.0.0\n */\nexport const reduceCompact: {\n  /**\n   * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\n   * elements that are `None`.\n   *\n   * **Details**\n   *\n   * This function takes an initial value of type `B` and a reducing function `f`\n   * that combines the accumulator with values of type `A`. It processes an\n   * iterable of `Option<A>`, applying `f` only to the `Some` values while\n   * ignoring the `None` values. The result is a single value of type `B`.\n   *\n   * This utility is particularly useful for aggregating values from an iterable\n   * of `Option`s while skipping the absent (`None`) values.\n   *\n   * @example\n   * ```ts\n   * import { Option, pipe } from \"effect\"\n   *\n   * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n   *\n   * console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n   * // Output: 3\n   * ```\n   *\n   * @category Reducing\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B\n  /**\n   * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\n   * elements that are `None`.\n   *\n   * **Details**\n   *\n   * This function takes an initial value of type `B` and a reducing function `f`\n   * that combines the accumulator with values of type `A`. It processes an\n   * iterable of `Option<A>`, applying `f` only to the `Some` values while\n   * ignoring the `None` values. The result is a single value of type `B`.\n   *\n   * This utility is particularly useful for aggregating values from an iterable\n   * of `Option`s while skipping the absent (`None`) values.\n   *\n   * @example\n   * ```ts\n   * import { Option, pipe } from \"effect\"\n   *\n   * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n   *\n   * console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n   * // Output: 3\n   * ```\n   *\n   * @category Reducing\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B\n} = dual(\n  3,\n  <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B => {\n    let out: B = b\n    for (const oa of self) {\n      if (isSome(oa)) {\n        out = f(out, oa.value)\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Converts an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, its value is wrapped in a single-element array.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.toArray(Option.some(1)))\n * // Output: [1]\n *\n * console.log(Option.toArray(Option.none()))\n * // Output: []\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const toArray = <A>(self: Option<A>): Array<A> => isNone(self) ? [] : [self.value]\n\n/**\n * Splits an `Option` into two `Option`s based on the result of a mapping\n * function that produces an `Either`.\n *\n * **Details**\n *\n * This function takes an `Option` and a mapping function `f` that converts its\n * value into an `Either`. It returns a tuple of two `Option`s:\n *\n * - The first `Option` (`left`) contains the value from the `Left` side of the\n *   `Either` if it exists, otherwise `None`.\n * - The second `Option` (`right`) contains the value from the `Right` side of\n *   the `Either` if it exists, otherwise `None`.\n *\n * If the input `Option` is `None`, both returned `Option`s are `None`.\n *\n * This utility is useful for filtering and categorizing the contents of an\n * `Option` based on a bifurcating computation.\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  /**\n   * Splits an `Option` into two `Option`s based on the result of a mapping\n   * function that produces an `Either`.\n   *\n   * **Details**\n   *\n   * This function takes an `Option` and a mapping function `f` that converts its\n   * value into an `Either`. It returns a tuple of two `Option`s:\n   *\n   * - The first `Option` (`left`) contains the value from the `Left` side of the\n   *   `Either` if it exists, otherwise `None`.\n   * - The second `Option` (`right`) contains the value from the `Right` side of\n   *   the `Either` if it exists, otherwise `None`.\n   *\n   * If the input `Option` is `None`, both returned `Option`s are `None`.\n   *\n   * This utility is useful for filtering and categorizing the contents of an\n   * `Option` based on a bifurcating computation.\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]\n  /**\n   * Splits an `Option` into two `Option`s based on the result of a mapping\n   * function that produces an `Either`.\n   *\n   * **Details**\n   *\n   * This function takes an `Option` and a mapping function `f` that converts its\n   * value into an `Either`. It returns a tuple of two `Option`s:\n   *\n   * - The first `Option` (`left`) contains the value from the `Left` side of the\n   *   `Either` if it exists, otherwise `None`.\n   * - The second `Option` (`right`) contains the value from the `Right` side of\n   *   the `Either` if it exists, otherwise `None`.\n   *\n   * If the input `Option` is `None`, both returned `Option`s are `None`.\n   *\n   * This utility is useful for filtering and categorizing the contents of an\n   * `Option` based on a bifurcating computation.\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]\n} = dual(2, <A, B, C>(\n  self: Option<A>,\n  f: (a: A) => Either<C, B>\n): [excluded: Option<B>, satisfying: Option<C>] => {\n  if (isNone(self)) {\n    return [none(), none()]\n  }\n  const e = f(self.value)\n  return either.isLeft(e) ? [some(e.left), none()] : [none(), some(e.right)]\n})\n\n// TODO(4.0): remove?\n/**\n * Alias of {@link flatMap}.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Transform and filter numbers\n * const transformEven = (n: Option.Option<number>): Option.Option<string> =>\n *   Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n *\n * console.log(transformEven(Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(transformEven(Option.some(1)))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(transformEven(Option.some(2)))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n * ```\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const filterMap: {\n  // TODO(4.0): remove?\n  /**\n   * Alias of {@link flatMap}.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Transform and filter numbers\n   * const transformEven = (n: Option.Option<number>): Option.Option<string> =>\n   *   Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n   *\n   * console.log(transformEven(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(transformEven(Option.some(1)))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(transformEven(Option.some(2)))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  // TODO(4.0): remove?\n  /**\n   * Alias of {@link flatMap}.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Transform and filter numbers\n   * const transformEven = (n: Option.Option<number>): Option.Option<string> =>\n   *   Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n   *\n   * console.log(transformEven(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(transformEven(Option.some(1)))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(transformEven(Option.some(2)))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n} = flatMap\n\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const removeEmptyString = (input: Option.Option<string>) =>\n *   Option.filter(input, (value) => value !== \"\")\n *\n * console.log(removeEmptyString(Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(removeEmptyString(Option.some(\"\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(removeEmptyString(Option.some(\"a\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const filter: {\n  /**\n   * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n   *\n   * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const removeEmptyString = (input: Option.Option<string>) =>\n   *   Option.filter(input, (value) => value !== \"\")\n   *\n   * console.log(removeEmptyString(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"\")))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"a\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>\n  /**\n   * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n   *\n   * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const removeEmptyString = (input: Option.Option<string>) =>\n   *   Option.filter(input, (value) => value !== \"\")\n   *\n   * console.log(removeEmptyString(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"\")))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"a\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>\n  /**\n   * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n   *\n   * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const removeEmptyString = (input: Option.Option<string>) =>\n   *   Option.filter(input, (value) => value !== \"\")\n   *\n   * console.log(removeEmptyString(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"\")))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"a\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>\n  /**\n   * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n   *\n   * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const removeEmptyString = (input: Option.Option<string>) =>\n   *   Option.filter(input, (value) => value !== \"\")\n   *\n   * console.log(removeEmptyString(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"\")))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"a\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A>(self: Option<A>, predicate: Predicate<A>): Option<A>\n} = dual(\n  2,\n  <A>(self: Option<A>, predicate: Predicate<A>): Option<A> =>\n    filterMap(self, (b) => (predicate(b) ? option.some(b) : option.none))\n)\n\n/**\n * Creates an `Equivalence` instance for comparing `Option` values, using a\n * provided `Equivalence` for the inner type.\n *\n * **Details**\n *\n * This function takes an `Equivalence` instance for a specific type `A` and\n * produces an `Equivalence` instance for `Option<A>`. The resulting\n * `Equivalence` determines whether two `Option` values are equivalent:\n *\n * - Two `None`s are considered equivalent.\n * - A `Some` and a `None` are not equivalent.\n * - Two `Some` values are equivalent if their inner values are equivalent\n *   according to the provided `Equivalence`.\n *\n * **Example** (Comparing Optional Numbers for Equivalence)\n *\n * ```ts\n * import { Number, Option } from \"effect\"\n *\n * const isEquivalent = Option.getEquivalence(Number.Equivalence)\n *\n * console.log(isEquivalent(Option.none(), Option.none()))\n * // Output: true\n *\n * console.log(isEquivalent(Option.none(), Option.some(1)))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.none()))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.some(2)))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.some(1)))\n * // Output: true\n * ```\n *\n * @category Equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <A>(isEquivalent: Equivalence.Equivalence<A>): Equivalence.Equivalence<Option<A>> =>\n  Equivalence.make((x, y) => isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value))\n\n/**\n * Creates an `Order` instance for comparing `Option` values, using a provided\n * `Order` for the inner type.\n *\n * **Details**\n *\n * This function produces an `Order` instance for `Option<A>`, allowing `Option`\n * values to be compared:\n *\n * - `None` is always considered less than any `Some` value.\n * - If both are `Some`, their inner values are compared using the provided\n *   `Order` instance.\n *\n * @example\n * ```ts\n * import { Number, Option } from \"effect\"\n *\n * const order = Option.getOrder(Number.Order)\n *\n * console.log(order(Option.none(), Option.none()))\n * // Output: 0\n *\n * console.log(order(Option.none(), Option.some(1)))\n * // Output: -1\n *\n * console.log(order(Option.some(1), Option.none()))\n * // Output: 1\n *\n * console.log(order(Option.some(1), Option.some(2)))\n * // Output: -1\n *\n * console.log(order(Option.some(1), Option.some(1)))\n * // Output: 0\n * ```\n *\n * @category Sorting\n * @since 2.0.0\n */\nexport const getOrder = <A>(O: Order<A>): Order<Option<A>> =>\n  order.make((self, that) => isSome(self) ? (isSome(that) ? O(self.value, that.value) : 1) : -1)\n\n/**\n * Lifts a binary function to work with `Option` values, allowing the function\n * to operate on two `Option`s.\n *\n * **Details**\n *\n * This function takes a binary function `f` and returns a new function that\n * applies `f` to the values of two `Option`s (`self` and `that`). If both\n * `Option`s are `Some`, the binary function `f` is applied to their values, and\n * the result is wrapped in a new `Some`. If either `Option` is `None`, the\n * result is `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // A binary function to add two numbers\n * const add = (a: number, b: number): number => a + b\n *\n * // Lift the `add` function to work with `Option` values\n * const addOptions = Option.lift2(add)\n *\n * // Both `Option`s are `Some`\n * console.log(addOptions(Option.some(2), Option.some(3)))\n * // Output: { _id: 'Option', _tag: 'Some', value: 5 }\n *\n * // One `Option` is `None`\n * console.log(addOptions(Option.some(2), Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Lifting\n * @since 2.0.0\n */\nexport const lift2 = <A, B, C>(f: (a: A, b: B) => C): {\n  (that: Option<B>): (self: Option<A>) => Option<C>\n  (self: Option<A>, that: Option<B>): Option<C>\n} => dual(2, (self: Option<A>, that: Option<B>): Option<C> => zipWith(self, that, f))\n\n/**\n * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n *\n * **Details**\n *\n * This function transforms a `Predicate` (or a more specific `Refinement`) into\n * a function that produces an `Option`. If the predicate evaluates to `true`,\n * the input value is wrapped in a `Some`. If the predicate evaluates to\n * `false`, the result is `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Check if a number is positive\n * const isPositive = (n: number) => n > 0\n *\n * //      ┌─── (b: number) => Option<number>\n * //      ▼\n * const parsePositive = Option.liftPredicate(isPositive)\n *\n * console.log(parsePositive(1))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parsePositive(-1))\n * // OUtput: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Lifting\n * @since 2.0.0\n */\nexport const liftPredicate: { // Note: I intentionally avoid using the NoInfer pattern here.\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>\n  /**\n   * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n   * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n   *\n   * **Details**\n   *\n   * This function transforms a `Predicate` (or a more specific `Refinement`) into\n   * a function that produces an `Option`. If the predicate evaluates to `true`,\n   * the input value is wrapped in a `Some`. If the predicate evaluates to\n   * `false`, the result is `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Check if a number is positive\n   * const isPositive = (n: number) => n > 0\n   *\n   * //      ┌─── (b: number) => Option<number>\n   * //      ▼\n   * const parsePositive = Option.liftPredicate(isPositive)\n   *\n   * console.log(parsePositive(1))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(parsePositive(-1))\n   * // OUtput: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Lifting\n   * @since 2.0.0\n   */\n  <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>\n  /**\n   * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n   * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n   *\n   * **Details**\n   *\n   * This function transforms a `Predicate` (or a more specific `Refinement`) into\n   * a function that produces an `Option`. If the predicate evaluates to `true`,\n   * the input value is wrapped in a `Some`. If the predicate evaluates to\n   * `false`, the result is `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Check if a number is positive\n   * const isPositive = (n: number) => n > 0\n   *\n   * //      ┌─── (b: number) => Option<number>\n   * //      ▼\n   * const parsePositive = Option.liftPredicate(isPositive)\n   *\n   * console.log(parsePositive(1))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(parsePositive(-1))\n   * // OUtput: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Lifting\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>\n  /**\n   * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n   * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n   *\n   * **Details**\n   *\n   * This function transforms a `Predicate` (or a more specific `Refinement`) into\n   * a function that produces an `Option`. If the predicate evaluates to `true`,\n   * the input value is wrapped in a `Some`. If the predicate evaluates to\n   * `false`, the result is `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Check if a number is positive\n   * const isPositive = (n: number) => n > 0\n   *\n   * //      ┌─── (b: number) => Option<number>\n   * //      ▼\n   * const parsePositive = Option.liftPredicate(isPositive)\n   *\n   * console.log(parsePositive(1))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(parsePositive(-1))\n   * // OUtput: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Lifting\n   * @since 2.0.0\n   */\n  <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>\n} = dual(\n  2,\n  <B extends A, A = B>(b: B, predicate: Predicate<A>): Option<B> => predicate(b) ? some(b) : none()\n)\n\n/**\n * Returns a function that checks if an `Option` contains a specified value,\n * using a provided equivalence function.\n *\n * **Details**\n *\n * This function allows you to check whether an `Option` contains a specific\n * value. It uses an equivalence function `isEquivalent` to compare the value\n * inside the `Option` to the provided value. If the `Option` is `Some` and the\n * equivalence function returns `true`, the result is `true`. If the `Option` is\n * `None` or the values are not equivalent, the result is `false`.\n *\n * @example\n * ```ts\n * import { Number, Option } from \"effect\"\n *\n * const contains = Option.containsWith(Number.Equivalence)\n *\n * console.log(Option.some(2).pipe(contains(2)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(contains(2)))\n * // Output: false\n *\n * console.log(Option.none().pipe(contains(2)))\n * // Output: false\n * ```\n *\n * @see {@link contains} for a version that uses the default `Equivalence`.\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const containsWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (a: A): (self: Option<A>) => boolean\n  (self: Option<A>, a: A): boolean\n} => dual(2, (self: Option<A>, a: A): boolean => isNone(self) ? false : isEquivalent(self.value, a))\n\nconst _equivalence = Equal.equivalence()\n\n/**\n * Returns a function that checks if an `Option` contains a specified value\n * using the default `Equivalence`.\n *\n * **Details**\n *\n * This function allows you to check whether an `Option` contains a specific\n * value. It uses the default `Equivalence` for equality comparison. If the\n * `Option` is `Some` and its value is equivalent to the provided value, the\n * result is `true`. If the `Option` is `None` or the values are not equivalent,\n * the result is `false`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.some(2).pipe(Option.contains(2)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(Option.contains(2)))\n * // Output: false\n *\n * console.log(Option.none().pipe(Option.contains(2)))\n * // Output: false\n * ```\n *\n * @see {@link containsWith} for a version that allows you to specify a custom equivalence function.\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const contains: {\n  /**\n   * Returns a function that checks if an `Option` contains a specified value\n   * using the default `Equivalence`.\n   *\n   * **Details**\n   *\n   * This function allows you to check whether an `Option` contains a specific\n   * value. It uses the default `Equivalence` for equality comparison. If the\n   * `Option` is `Some` and its value is equivalent to the provided value, the\n   * result is `true`. If the `Option` is `None` or the values are not equivalent,\n   * the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.some(2).pipe(Option.contains(2)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.contains(2)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.contains(2)))\n   * // Output: false\n   * ```\n   *\n   * @see {@link containsWith} for a version that allows you to specify a custom equivalence function.\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A>(a: A): (self: Option<A>) => boolean\n  /**\n   * Returns a function that checks if an `Option` contains a specified value\n   * using the default `Equivalence`.\n   *\n   * **Details**\n   *\n   * This function allows you to check whether an `Option` contains a specific\n   * value. It uses the default `Equivalence` for equality comparison. If the\n   * `Option` is `Some` and its value is equivalent to the provided value, the\n   * result is `true`. If the `Option` is `None` or the values are not equivalent,\n   * the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.some(2).pipe(Option.contains(2)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.contains(2)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.contains(2)))\n   * // Output: false\n   * ```\n   *\n   * @see {@link containsWith} for a version that allows you to specify a custom equivalence function.\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A>(self: Option<A>, a: A): boolean\n} = containsWith(_equivalence)\n\n/**\n * Checks if a value in an `Option` satisfies a given predicate or refinement.\n *\n * **Details**\n *\n * This function allows you to check if a value inside a `Some` meets a\n * specified condition. If the `Option` is `None`, the result is `false`. If the\n * `Option` is `Some`, the provided predicate or refinement is applied to the\n * value:\n *\n * - If the condition is met, the result is `true`.\n * - If the condition is not met, the result is `false`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * console.log(Option.some(2).pipe(Option.exists(isEven)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(Option.exists(isEven)))\n * // Output: false\n *\n * console.log(Option.none().pipe(Option.exists(isEven)))\n * // Output: false\n * ```\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const exists: {\n  /**\n   * Checks if a value in an `Option` satisfies a given predicate or refinement.\n   *\n   * **Details**\n   *\n   * This function allows you to check if a value inside a `Some` meets a\n   * specified condition. If the `Option` is `None`, the result is `false`. If the\n   * `Option` is `Some`, the provided predicate or refinement is applied to the\n   * value:\n   *\n   * - If the condition is met, the result is `true`.\n   * - If the condition is not met, the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * console.log(Option.some(2).pipe(Option.exists(isEven)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.exists(isEven)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.exists(isEven)))\n   * // Output: false\n   * ```\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>\n  /**\n   * Checks if a value in an `Option` satisfies a given predicate or refinement.\n   *\n   * **Details**\n   *\n   * This function allows you to check if a value inside a `Some` meets a\n   * specified condition. If the `Option` is `None`, the result is `false`. If the\n   * `Option` is `Some`, the provided predicate or refinement is applied to the\n   * value:\n   *\n   * - If the condition is met, the result is `true`.\n   * - If the condition is not met, the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * console.log(Option.some(2).pipe(Option.exists(isEven)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.exists(isEven)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.exists(isEven)))\n   * // Output: false\n   * ```\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean\n  /**\n   * Checks if a value in an `Option` satisfies a given predicate or refinement.\n   *\n   * **Details**\n   *\n   * This function allows you to check if a value inside a `Some` meets a\n   * specified condition. If the `Option` is `None`, the result is `false`. If the\n   * `Option` is `Some`, the provided predicate or refinement is applied to the\n   * value:\n   *\n   * - If the condition is met, the result is `true`.\n   * - If the condition is not met, the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * console.log(Option.some(2).pipe(Option.exists(isEven)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.exists(isEven)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.exists(isEven)))\n   * // Output: false\n   * ```\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>\n  /**\n   * Checks if a value in an `Option` satisfies a given predicate or refinement.\n   *\n   * **Details**\n   *\n   * This function allows you to check if a value inside a `Some` meets a\n   * specified condition. If the `Option` is `None`, the result is `false`. If the\n   * `Option` is `Some`, the provided predicate or refinement is applied to the\n   * value:\n   *\n   * - If the condition is met, the result is `true`.\n   * - If the condition is not met, the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * console.log(Option.some(2).pipe(Option.exists(isEven)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.exists(isEven)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.exists(isEven)))\n   * // Output: false\n   * ```\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A>(self: Option<A>, predicate: Predicate<A>): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B> =>\n    isNone(self) ? false : refinement(self.value)\n)\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const bindTo: {\n  // -------------------------------------------------------------------------------------\n  // do notation\n  // -------------------------------------------------------------------------------------\n\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A }>\n  // -------------------------------------------------------------------------------------\n  // do notation\n  // -------------------------------------------------------------------------------------\n\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A }>\n} = doNotation.bindTo<OptionTypeLambda>(map)\n\nconst let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  <A extends object, N extends string, B>(\n    self: Option<A>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = doNotation.let_<OptionTypeLambda>(map)\n\nexport {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link bindTo}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  let_ as let\n}\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const bind: {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <A extends object, N extends string, B>(\n    self: Option<A>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => Option<B>\n  ): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = doNotation.bind<OptionTypeLambda>(map, flatMap)\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const Do: Option<{}> = some({})\n\nconst adapter = Gen.adapter<OptionTypeLambda>()\n\n/**\n * Similar to `Effect.gen`, `Option.gen` provides a more readable,\n * generator-based syntax for working with `Option` values, making code that\n * involves `Option` easier to write and understand. This approach is similar to\n * using `async/await` but tailored for `Option`.\n *\n * **Example** (Using `Option.gen` to Create a Combined Value)\n *\n * ```ts\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * const person = Option.gen(function* () {\n *   const name = (yield* maybeName).toUpperCase()\n *   const age = yield* maybeAge\n *   return { name, age }\n * })\n *\n * console.log(person)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n * ```\n *\n * @category Generators\n * @since 2.0.0\n */\nexport const gen: Gen.Gen<OptionTypeLambda, Gen.Adapter<OptionTypeLambda>> = (...args) => {\n  const f = args.length === 1 ? args[0] : args[1].bind(args[0])\n  const iterator = f(adapter)\n  let state: IteratorResult<any> = iterator.next()\n  while (!state.done) {\n    const current = Gen.isGenKind(state.value)\n      ? state.value.value\n      : Gen.yieldWrapGet(state.value)\n    if (isNone(current)) {\n      return current\n    }\n    state = iterator.next(current.value as never)\n  }\n  return some(state.value)\n}\n\n/**\n * Merges two optional values, applying a function if both exist.\n * Unlike {@link zipWith}, this function returns `None` only if both inputs are `None`.\n *\n * @internal\n */\nexport const mergeWith = <A>(f: (a1: A, a2: A) => A) => (o1: Option<A>, o2: Option<A>): Option<A> => {\n  if (isNone(o1)) {\n    return o2\n  } else if (isNone(o2)) {\n    return o1\n  }\n  return some(f(o1.value, o2.value))\n}\n","/**\n * This module provides utility functions for working with records in TypeScript.\n *\n * @since 2.0.0\n */\n\nimport type { Either } from \"./Either.js\"\nimport * as E from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport type { Equivalence } from \"./Equivalence.js\"\nimport { dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as Option from \"./Option.js\"\nimport type { NoInfer } from \"./Types.js\"\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type ReadonlyRecord<in out K extends string | symbol, out A> = {\n  readonly [P in K]: A\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ReadonlyRecord {\n  type IsFiniteString<T extends string> = T extends \"\" ? true :\n    [T] extends [`${infer Head}${infer Rest}`]\n      ? string extends Head ? false : `${number}` extends Head ? false : Rest extends \"\" ? true : IsFiniteString<Rest>\n    : false\n\n  /**\n   * @since 2.0.0\n   */\n  export type NonLiteralKey<K extends string | symbol> = K extends string ? IsFiniteString<K> extends true ? string : K\n    : symbol\n\n  /**\n   * @since 2.0.0\n   */\n  export type IntersectKeys<K1 extends string, K2 extends string> = [string] extends [K1 | K2] ?\n    NonLiteralKey<K1> & NonLiteralKey<K2>\n    : K1 & K2\n}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface ReadonlyRecordTypeLambda<K extends string = string> extends TypeLambda {\n  readonly type: ReadonlyRecord<K, this[\"Target\"]>\n}\n\n/**\n * Creates a new, empty record.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const empty = <K extends string | symbol = never, V = never>(): Record<\n  ReadonlyRecord.NonLiteralKey<K>,\n  V\n> => ({} as any)\n\n/**\n * Determine if a record is empty.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isEmptyRecord } from \"effect/Record\"\n *\n * assert.deepStrictEqual(isEmptyRecord({}), true);\n * assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyRecord = <K extends string, A>(self: Record<K, A>): self is Record<K, never> =>\n  keys(self).length === 0\n\n/**\n * Determine if a record is empty.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isEmptyReadonlyRecord } from \"effect/Record\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\n * assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyReadonlyRecord: <K extends string, A>(\n  self: ReadonlyRecord<K, A>\n) => self is ReadonlyRecord<K, never> = isEmptyRecord\n\n/**\n * Takes an iterable and a projection function and returns a record.\n * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { fromIterableWith } from \"effect/Record\"\n *\n * const input = [1, 2, 3, 4]\n *\n * assert.deepStrictEqual(\n *   fromIterableWith(input, a => [String(a), a * 2]),\n *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n * )\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterableWith: {\n  /**\n   * Takes an iterable and a projection function and returns a record.\n   * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { fromIterableWith } from \"effect/Record\"\n   *\n   * const input = [1, 2, 3, 4]\n   *\n   * assert.deepStrictEqual(\n   *   fromIterableWith(input, a => [String(a), a * 2]),\n   *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n   * )\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, K extends string | symbol, B>(f: (a: A) => readonly [K, B]): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  /**\n   * Takes an iterable and a projection function and returns a record.\n   * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { fromIterableWith } from \"effect/Record\"\n   *\n   * const input = [1, 2, 3, 4]\n   *\n   * assert.deepStrictEqual(\n   *   fromIterableWith(input, a => [String(a), a * 2]),\n   *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n   * )\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, K extends string | symbol, B>(self: Iterable<A>, f: (a: A) => readonly [K, B]): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n} = dual(\n  2,\n  <A, K extends string, B>(\n    self: Iterable<A>,\n    f: (a: A) => readonly [K, B]\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B> => {\n    const out: Record<string, B> = empty()\n    for (const a of self) {\n      const [k, b] = f(a)\n      out[k] = b\n    }\n    return out\n  }\n)\n\n/**\n * Creates a new record from an iterable, utilizing the provided function to determine the key for each element.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { fromIterableBy } from \"effect/Record\"\n *\n * const users = [\n *   { id: \"2\", name: \"name2\" },\n *   { id: \"1\", name: \"name1\" }\n * ]\n *\n * assert.deepStrictEqual(\n *   fromIterableBy(users, user => user.id),\n *   {\n *     \"2\": { id: \"2\", name: \"name2\" },\n *     \"1\": { id: \"1\", name: \"name1\" }\n *   }\n * )\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterableBy = <A, K extends string | symbol>(\n  items: Iterable<A>,\n  f: (a: A) => K\n): Record<ReadonlyRecord.NonLiteralKey<K>, A> => fromIterableWith(items, (a) => [f(a), a])\n\n/**\n * Builds a record from an iterable of key-value pairs.\n *\n * If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the\n * previous ones. So the resulting record will only have the value of the last occurrence of each key.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { fromEntries } from \"effect/Record\"\n *\n * const input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n *\n * assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEntries: <Entry extends readonly [string | symbol, any]>(\n  entries: Iterable<Entry>\n) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]> = Object.fromEntries\n\n/**\n * Transforms the values of a record into an `Array` with a custom mapping function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { collect } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const collect: {\n  /**\n   * Transforms the values of a record into an `Array` with a custom mapping function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { collect } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n   * ```\n   *\n   * @category conversions\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>\n  /**\n   * Transforms the values of a record into an `Array` with a custom mapping function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { collect } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n   * ```\n   *\n   * @category conversions\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>\n} = dual(\n  2,\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B> => {\n    const out: Array<B> = []\n    for (const key of keys(self)) {\n      out.push(f(key, self[key]))\n    }\n    return out\n  }\n)\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { toEntries } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]> = collect((\n  key,\n  value\n) => [key, value])\n\n/**\n * Returns the number of key/value pairs in a record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { size } from \"effect/Record\";\n *\n * assert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);\n * ```\n *\n * @since 2.0.0\n */\nexport const size = <K extends string, A>(self: ReadonlyRecord<K, A>): number => keys(self).length\n\n/**\n * Check if a given `key` exists in a record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { empty, has } from \"effect/Record\"\n *\n * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n * assert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n * ```\n *\n * @since 2.0.0\n */\nexport const has: {\n  /**\n   * Check if a given `key` exists in a record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { empty, has } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n   * assert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => boolean\n  /**\n   * Check if a given `key` exists in a record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { empty, has } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n   * assert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): boolean\n} = dual(\n  2,\n  <K extends string | symbol, A>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>\n  ): boolean => Object.prototype.hasOwnProperty.call(self, key)\n)\n\n/**\n * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record as R, Option } from \"effect\"\n *\n * const person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n *\n * assert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\n * assert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n * ```\n *\n * @since 2.0.0\n */\nexport const get: {\n  /**\n   * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * const person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n   *\n   * assert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\n   * assert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>\n  /**\n   * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * const person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n   *\n   * assert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\n   * assert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>\n} = dual(\n  2,\n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A> =>\n    has(self, key) ? Option.some(self[key]) : Option.none()\n)\n\n/**\n * Apply a function to the element at the specified key, creating a new record.\n * If the key does not exist, the record is returned unchanged.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record as R } from \"effect\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  R.modify({ a: 3 }, 'a', f),\n *  { a: 6 }\n * )\n * assert.deepStrictEqual(\n *  R.modify({ a: 3 } as Record<string, number>, 'b', f),\n *  { a: 3 }\n * )\n * ```\n *\n * @since 2.0.0\n */\nexport const modify: {\n  /**\n   * Apply a function to the element at the specified key, creating a new record.\n   * If the key does not exist, the record is returned unchanged.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R } from \"effect\"\n   *\n   * const f = (x: number) => x * 2\n   *\n   * assert.deepStrictEqual(\n   *  R.modify({ a: 3 }, 'a', f),\n   *  { a: 6 }\n   * )\n   * assert.deepStrictEqual(\n   *  R.modify({ a: 3 } as Record<string, number>, 'b', f),\n   *  { a: 3 }\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Record<K, A | B>\n  /**\n   * Apply a function to the element at the specified key, creating a new record.\n   * If the key does not exist, the record is returned unchanged.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R } from \"effect\"\n   *\n   * const f = (x: number) => x * 2\n   *\n   * assert.deepStrictEqual(\n   *  R.modify({ a: 3 }, 'a', f),\n   *  { a: 6 }\n   * )\n   * assert.deepStrictEqual(\n   *  R.modify({ a: 3 } as Record<string, number>, 'b', f),\n   *  { a: 3 }\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B> => {\n    if (!has(self, key)) {\n      return { ...self }\n    }\n    return { ...self, [key]: f(self[key]) }\n  }\n)\n\n/**\n * Apply a function to the element at the specified key, creating a new record,\n * or return `None` if the key doesn't exist.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record as R, Option } from \"effect\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  R.modifyOption({ a: 3 }, 'a', f),\n *  Option.some({ a: 6 })\n * )\n * assert.deepStrictEqual(\n *  R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n *  Option.none()\n * )\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyOption: {\n  /**\n   * Apply a function to the element at the specified key, creating a new record,\n   * or return `None` if the key doesn't exist.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * const f = (x: number) => x * 2\n   *\n   * assert.deepStrictEqual(\n   *  R.modifyOption({ a: 3 }, 'a', f),\n   *  Option.some({ a: 6 })\n   * )\n   * assert.deepStrictEqual(\n   *  R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n   *  Option.none()\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>\n  /**\n   * Apply a function to the element at the specified key, creating a new record,\n   * or return `None` if the key doesn't exist.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * const f = (x: number) => x * 2\n   *\n   * assert.deepStrictEqual(\n   *  R.modifyOption({ a: 3 }, 'a', f),\n   *  Option.some({ a: 6 })\n   * )\n   * assert.deepStrictEqual(\n   *  R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n   *  Option.none()\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Option.Option<Record<K, A | B>>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>,\n    f: (a: A) => B\n  ): Option.Option<Record<K, A | B>> => {\n    if (!has(self, key)) {\n      return Option.none()\n    }\n    return Option.some({ ...self, [key]: f(self[key]) })\n  }\n)\n\n/**\n * Replaces a value in the record with the new value passed as parameter.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n *   Option.some({ a: 10, b: 2, c: 3 })\n * )\n * assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n * ```\n *\n * @since 2.0.0\n */\nexport const replaceOption: {\n  /**\n   * Replaces a value in the record with the new value passed as parameter.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n   *   Option.some({ a: 10, b: 2, c: 3 })\n   * )\n   * assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, B>(key: NoInfer<K>, b: B): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>\n  /**\n   * Replaces a value in the record with the new value passed as parameter.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n   *   Option.some({ a: 10, b: 2, c: 3 })\n   * )\n   * assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, b: B): Option.Option<Record<K, A | B>>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>,\n    b: B\n  ): Option.Option<Record<K, A | B>> => modifyOption(self, key, () => b)\n)\n\n/**\n * If the given key exists in the record, returns a new record with the key removed,\n * otherwise returns a copy of the original record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { remove } from \"effect/Record\"\n *\n * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n * ```\n *\n * @since 2.0.0\n */\nexport const remove: {\n  /**\n   * If the given key exists in the record, returns a new record with the key removed,\n   * otherwise returns a copy of the original record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { remove } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>\n  /**\n   * If the given key exists in the record, returns a new record with the key removed,\n   * otherwise returns a copy of the original record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { remove } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>\n} = dual(\n  2,\n  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A> => {\n    if (!has(self, key)) {\n      return { ...self }\n    }\n    const out = { ...self }\n    delete out[key]\n    return out\n  }\n)\n\n/**\n * Retrieves the value of the property with the given `key` from a record and returns an `Option`\n * of a tuple with the value and the record with the removed property.\n * If the key is not present, returns `O.none`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record as R, Option } from \"effect\"\n *\n * assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\n * assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n * ```\n *\n * @category record\n * @since 2.0.0\n */\nexport const pop: {\n  /**\n   * Retrieves the value of the property with the given `key` from a record and returns an `Option`\n   * of a tuple with the value and the record with the removed property.\n   * If the key is not present, returns `O.none`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\n   * assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n   * ```\n   *\n   * @category record\n   * @since 2.0.0\n   */\n  <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>\n  /**\n   * Retrieves the value of the property with the given `key` from a record and returns an `Option`\n   * of a tuple with the value and the record with the removed property.\n   * If the key is not present, returns `O.none`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\n   * assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n   * ```\n   *\n   * @category record\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Option.Option<[A, Record<Exclude<K, X>, A>]>\n} = dual(2, <K extends string | symbol, A, X extends K>(\n  self: ReadonlyRecord<K, A>,\n  key: X\n): Option.Option<[A, Record<Exclude<K, X>, A>]> =>\n  has(self, key) ? Option.some([self[key], remove(self, key)]) : Option.none())\n\n/**\n * Maps a record into another record by applying a transformation function to each of its values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { map } from \"effect/Record\"\n *\n * const f = (n: number) => `-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n *\n * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  /**\n   * Maps a record into another record by applying a transformation function to each of its values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { map } from \"effect/Record\"\n   *\n   * const f = (n: number) => `-${n}`\n   *\n   * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n   *\n   * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n   *\n   * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>\n  /**\n   * Maps a record into another record by applying a transformation function to each of its values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { map } from \"effect/Record\"\n   *\n   * const f = (n: number) => `-${n}`\n   *\n   * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n   *\n   * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n   *\n   * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>\n} = dual(\n  2,\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B> => {\n    const out: Record<K, B> = { ...self } as any\n    for (const key of keys(self)) {\n      out[key] = f(self[key], key)\n    }\n    return out\n  }\n)\n\n/**\n * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { mapKeys } from \"effect/Record\"\n *\n * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapKeys: {\n  /**\n   * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { mapKeys } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, K2 extends string>(f: (key: K, a: A) => K2): (self: ReadonlyRecord<K, A>) => Record<K2, A>\n  /**\n   * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { mapKeys } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, K2 extends string>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => K2): Record<K2, A>\n} = dual(\n  2,\n  <K extends string, A, K2 extends string>(\n    self: ReadonlyRecord<K, A>,\n    f: (key: K, a: A) => K2\n  ): Record<K2, A> => {\n    const out: Record<K2, A> = {} as any\n    for (const key of keys(self)) {\n      const a = self[key]\n      out[f(key, a)] = a\n    }\n    return out\n  }\n)\n\n/**\n * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { mapEntries } from \"effect/Record\"\n *\n * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapEntries: {\n  /**\n   * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { mapEntries } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, K2 extends string, B>(f: (a: A, key: K) => readonly [K2, B]): (self: ReadonlyRecord<K, A>) => Record<K2, B>\n  /**\n   * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { mapEntries } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, K2 extends string, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => [K2, B]): Record<K2, B>\n} = dual(\n  2,\n  <K extends string, A, K2 extends string, B>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => [K2, B]\n  ): Record<K2, B> => {\n    const out = <Record<K2, B>> {}\n    for (const key of keys(self)) {\n      const [k, b] = f(self[key], key)\n      out[k] = b\n    }\n    return out\n  }\n)\n\n/**\n * Transforms a record into a record by applying the function `f` to each key and value in the original record.\n * If the function returns `Some`, the key-value pair is included in the output record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Option } from \"effect\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\n * assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n * ```\n *\n * @since 2.0.0\n */\nexport const filterMap: {\n  /**\n   * Transforms a record into a record by applying the function `f` to each key and value in the original record.\n   * If the function returns `Some`, the key-value pair is included in the output record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Option } from \"effect\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\n   * assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(f: (a: A, key: K) => Option.Option<B>): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  /**\n   * Transforms a record into a record by applying the function `f` to each key and value in the original record.\n   * If the function returns `Some`, the key-value pair is included in the output record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Option } from \"effect\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\n   * assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Option.Option<B>): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n} = dual(\n  2,\n  <K extends string, A, B>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => Option.Option<B>\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B> => {\n    const out: Record<string, B> = empty()\n    for (const key of keys(self)) {\n      const o = f(self[key], key)\n      if (Option.isSome(o)) {\n        out[key] = o.value\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Selects properties from a record whose values match the given predicate.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { filter } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3, d: 4 }\n * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filter: {\n  /**\n   * Selects properties from a record whose values match the given predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { filter } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3, d: 4 }\n   * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  /**\n   * Selects properties from a record whose values match the given predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { filter } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3, d: 4 }\n   * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A>(predicate: (A: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>\n  /**\n   * Selects properties from a record whose values match the given predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { filter } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3, d: 4 }\n   * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  /**\n   * Selects properties from a record whose values match the given predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { filter } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3, d: 4 }\n   * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): Record<ReadonlyRecord.NonLiteralKey<K>, A>\n} = dual(\n  2,\n  <K extends string, A>(\n    self: ReadonlyRecord<K, A>,\n    predicate: (a: A, key: K) => boolean\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, A> => {\n    const out: Record<string, A> = empty()\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        out[key] = self[key]\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),\n *   { a: 1, c: 2 }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getSomes: <K extends string, A>(\n  self: ReadonlyRecord<K, Option.Option<A>>\n) => Record<ReadonlyRecord.NonLiteralKey<K>, A> = filterMap(\n  identity\n)\n\n/**\n * Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getLefts({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n *   { b: \"err\" }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getLefts = <K extends string, R, L>(\n  self: ReadonlyRecord<K, Either<R, L>>\n): Record<ReadonlyRecord.NonLiteralKey<K>, L> => {\n  const out: Record<string, L> = empty()\n  for (const key of keys(self)) {\n    const value = self[key]\n    if (E.isLeft(value)) {\n      out[key] = value.left\n    }\n  }\n\n  return out\n}\n\n/**\n * Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getRights({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n *   { a: 1, c: 2 }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getRights = <K extends string, R, L>(\n  self: ReadonlyRecord<K, Either<R, L>>\n): Record<string, R> => {\n  const out: Record<string, R> = empty()\n  for (const key of keys(self)) {\n    const value = self[key]\n    if (E.isRight(value)) {\n      out[key] = value.right\n    }\n  }\n\n  return out\n}\n\n/**\n * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Either } from \"effect\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\n * assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  /**\n   * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Either } from \"effect\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\n   * assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B, C>(f: (a: A, key: K) => Either<C, B>): (\n    self: ReadonlyRecord<K, A>\n  ) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]\n  /**\n   * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Either } from \"effect\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\n   * assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B, C>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Either<C, B>): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]\n} = dual(\n  2,\n  <K extends string, A, B, C>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => Either<C, B>\n  ): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>] => {\n    const left: Record<string, B> = empty()\n    const right: Record<string, C> = empty()\n    for (const key of keys(self)) {\n      const e = f(self[key], key)\n      if (E.isLeft(e)) {\n        left[key] = e.left\n      } else {\n        right[key] = e.right\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Partitions a record of `Either` values into two separate records,\n * one with the `Left` values and one with the `Right` values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.separate({ a: Either.left(\"e\"), b: Either.right(1) }),\n *   [{ a: \"e\" }, { b: 1 }]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate: <K extends string, A, B>(\n  self: ReadonlyRecord<K, Either<B, A>>\n) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>] = partitionMap(identity)\n\n/**\n * Partitions a record into two separate records based on the result of a predicate function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { partition } from \"effect/Record\"\n *\n * assert.deepStrictEqual(\n *   partition({ a: 1, b: 3 }, (n) => n > 2),\n *   [{ a: 1 }, { b: 3 }]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition: {\n  /**\n   * Partitions a record into two separate records based on the result of a predicate function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { partition } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(\n   *   partition({ a: 1, b: 3 }, (n) => n > 2),\n   *   [{ a: 1 }, { b: 3 }]\n   * )\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (\n    self: ReadonlyRecord<K, A>\n  ) => [\n    excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>,\n    satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  ]\n  /**\n   * Partitions a record into two separate records based on the result of a predicate function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { partition } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(\n   *   partition({ a: 1, b: 3 }, (n) => n > 2),\n   *   [{ a: 1 }, { b: 3 }]\n   * )\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A>(predicate: (a: NoInfer<A>, key: K) => boolean): (\n    self: ReadonlyRecord<K, A>\n  ) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]\n  /**\n   * Partitions a record into two separate records based on the result of a predicate function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { partition } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(\n   *   partition({ a: 1, b: 3 }, (n) => n > 2),\n   *   [{ a: 1 }, { b: 3 }]\n   * )\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): [\n    excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>,\n    satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  ]\n  /**\n   * Partitions a record into two separate records based on the result of a predicate function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { partition } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(\n   *   partition({ a: 1, b: 3 }, (n) => n > 2),\n   *   [{ a: 1 }, { b: 3 }]\n   * )\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]\n} = dual(\n  2,\n  <K extends string, A>(\n    self: ReadonlyRecord<K, A>,\n    predicate: (a: A, key: K) => boolean\n  ): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>] => {\n    const left: Record<string, A> = empty()\n    const right: Record<string, A> = empty()\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        right[key] = self[key]\n      } else {\n        left[key] = self[key]\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Retrieve the keys of a given record as an array.\n *\n * @since 2.0.0\n */\nexport const keys = <K extends string | symbol, A>(self: ReadonlyRecord<K, A>): Array<K & string> =>\n  Object.keys(self) as Array<K & string>\n\n/**\n * Retrieve the values of a given record as an array.\n *\n * @since 2.0.0\n */\nexport const values = <K extends string, A>(self: ReadonlyRecord<K, A>): Array<A> => collect(self, (_, a) => a)\n\n/**\n * Add a new key-value pair or update an existing key's value in a record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { set } from \"effect/Record\"\n *\n * assert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n * ```\n *\n * @since 2.0.0\n */\nexport const set: {\n  /**\n   * Add a new key-value pair or update an existing key's value in a record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { set } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n   * assert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(key: K1, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>\n  /**\n   * Add a new key-value pair or update an existing key's value in a record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { set } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n   * assert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(self: ReadonlyRecord<K, A>, key: K1, value: B): Record<K | K1, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(\n    self: ReadonlyRecord<K, A>,\n    key: K1,\n    value: B\n  ): Record<K | K1, A | B> => {\n    return { ...self, [key]: value } as any\n  }\n)\n\n/**\n * Replace a key's value in a record and return the updated record.\n * If the key does not exist in the record, a copy of the original record is returned.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record } from \"effect\"\n *\n * assert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\n * assert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n * ```\n *\n * @since 2.0.0\n */\nexport const replace: {\n  /**\n   * Replace a key's value in a record and return the updated record.\n   * If the key does not exist in the record, a copy of the original record is returned.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record } from \"effect\"\n   *\n   * assert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\n   * assert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>\n  /**\n   * Replace a key's value in a record and return the updated record.\n   * If the key does not exist in the record, a copy of the original record is returned.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record } from \"effect\"\n   *\n   * assert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\n   * assert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B> => {\n    if (has(self, key)) {\n      return { ...self, [key]: value }\n    }\n    return { ...self }\n  }\n)\n\n/**\n * Check if all the keys and values in one record are also found in another record.\n *\n * @since 2.0.0\n */\nexport const isSubrecordBy = <A>(equivalence: Equivalence<A>): {\n  <K extends string>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean\n  <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean\n} =>\n  dual(2, <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean => {\n    for (const key of keys(self)) {\n      if (!has(that, key) || !equivalence(self[key], that[key])) {\n        return false\n      }\n    }\n    return true\n  })\n\n/**\n * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\n * This comparison uses default equality checks (`Equal.equivalence()`).\n *\n * @since 2.0.0\n */\nexport const isSubrecord: {\n  /**\n   * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\n   * This comparison uses default equality checks (`Equal.equivalence()`).\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean\n  /**\n   * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\n   * This comparison uses default equality checks (`Equal.equivalence()`).\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean\n} = isSubrecordBy(Equal.equivalence())\n\n/**\n * Reduce a record to a single value by combining its entries with a specified function.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  /**\n   * Reduce a record to a single value by combining its entries with a specified function.\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <Z, V, K extends string>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: ReadonlyRecord<K, V>) => Z\n  /**\n   * Reduce a record to a single value by combining its entries with a specified function.\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <K extends string, V, Z>(\n    self: ReadonlyRecord<K, V>,\n    zero: Z,\n    f: (accumulator: Z, value: V, key: K) => Z\n  ): Z\n} = dual(\n  3,\n  <K extends string, V, Z>(\n    self: ReadonlyRecord<K, V>,\n    zero: Z,\n    f: (accumulator: Z, value: V, key: K) => Z\n  ): Z => {\n    let out: Z = zero\n    for (const key of keys(self)) {\n      out = f(out, self[key], key)\n    }\n    return out\n  }\n)\n\n/**\n * Check if all entries in a record meet a specific condition.\n *\n * @since 2.0.0\n */\nexport const every: {\n  /**\n   * Check if all entries in a record meet a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <A, K extends string, B extends A>(refinement: (value: A, key: K) => value is B): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>\n  /**\n   * Check if all entries in a record meet a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean\n  /**\n   * Check if all entries in a record meet a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <A, K extends string, B extends A>(self: ReadonlyRecord<K, A>, refinement: (value: A, key: K) => value is B): self is ReadonlyRecord<K, B>\n  /**\n   * Check if all entries in a record meet a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean\n} = dual(\n  2,\n  <A, K extends string, B extends A>(\n    self: ReadonlyRecord<K, A>,\n    refinement: (value: A, key: K) => value is B\n  ): self is ReadonlyRecord<K, B> => {\n    for (const key of keys(self)) {\n      if (!refinement(self[key], key)) {\n        return false\n      }\n    }\n    return true\n  }\n)\n\n/**\n * Check if any entry in a record meets a specific condition.\n *\n * @since 2.0.0\n */\nexport const some: {\n  /**\n   * Check if any entry in a record meets a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean\n  /**\n   * Check if any entry in a record meets a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean\n} = dual(\n  2,\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean => {\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        return true\n      }\n    }\n    return false\n  }\n)\n\n/**\n * Merge two records, preserving entries that exist in either of the records.\n *\n * @since 2.0.0\n */\nexport const union: {\n  /**\n   * Merge two records, preserving entries that exist in either of the records.\n   *\n   * @since 2.0.0\n   */\n  <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>\n  /**\n   * Merge two records, preserving entries that exist in either of the records.\n   *\n   * @since 2.0.0\n   */\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<K0 | K1, A | B | C>\n} = dual(\n  3,\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<K0 | K1, A | B | C> => {\n    if (isEmptyRecord(self)) {\n      return { ...that } as any\n    }\n    if (isEmptyRecord(that)) {\n      return { ...self } as any\n    }\n    const out: Record<string, A | B | C> = empty()\n    for (const key of keys(self)) {\n      if (has(that, key as any)) {\n        out[key] = combine(self[key], that[key as unknown as K1])\n      } else {\n        out[key] = self[key]\n      }\n    }\n    for (const key of keys(that)) {\n      if (!has(out, key)) {\n        out[key] = that[key]\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Merge two records, retaining only the entries that exist in both records.\n *\n * @since 2.0.0\n */\nexport const intersection: {\n  /**\n   * Merge two records, retaining only the entries that exist in both records.\n   *\n   * @since 2.0.0\n   */\n  <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>\n  /**\n   * Merge two records, retaining only the entries that exist in both records.\n   *\n   * @since 2.0.0\n   */\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>\n} = dual(\n  3,\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C> => {\n    const out: Record<string, C> = empty()\n    if (isEmptyRecord(self) || isEmptyRecord(that)) {\n      return out\n    }\n    for (const key of keys(self)) {\n      if (has(that, key as any)) {\n        out[key] = combine(self[key], that[key as unknown as K1])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Merge two records, preserving only the entries that are unique to each record.\n *\n * @since 2.0.0\n */\nexport const difference: {\n  /**\n   * Merge two records, preserving only the entries that are unique to each record.\n   *\n   * @since 2.0.0\n   */\n  <K1 extends string, B>(that: ReadonlyRecord<K1, B>): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>\n  /**\n   * Merge two records, preserving only the entries that are unique to each record.\n   *\n   * @since 2.0.0\n   */\n  <K0 extends string, A, K1 extends string, B>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>): Record<K0 | K1, A | B>\n} = dual(2, <K0 extends string, A, K1 extends string, B>(\n  self: ReadonlyRecord<K0, A>,\n  that: ReadonlyRecord<K1, B>\n): Record<K0 | K1, A | B> => {\n  if (isEmptyRecord(self)) {\n    return { ...that } as any\n  }\n  if (isEmptyRecord(that)) {\n    return { ...self } as any\n  }\n  const out = <Record<K0 | K1, A | B>> {}\n  for (const key of keys(self)) {\n    if (!has(that, key as any)) {\n      out[key] = self[key]\n    }\n  }\n  for (const key of keys(that)) {\n    if (!has(self, key as any)) {\n      out[key] = that[key]\n    }\n  }\n  return out\n})\n\n/**\n * Create an `Equivalence` for records using the provided `Equivalence` for values.\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getEquivalence = <K extends string, A>(\n  equivalence: Equivalence<A>\n): Equivalence<ReadonlyRecord<K, A>> => {\n  const is = isSubrecordBy(equivalence)\n  return (self, that) => is(self, that) && is(that, self)\n}\n\n/**\n * Create a non-empty record from a single element.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const singleton = <K extends string | symbol, A>(key: K, value: A): Record<K, A> => ({\n  [key]: value\n} as any)\n\n/**\n * Returns the first entry that satisfies the specified\n * predicate, or `None` if no such entry exists.\n *\n * @example\n * ```ts\n * import { Record, Option } from \"effect\"\n *\n * const record = { a: 1, b: 2, c: 3 }\n * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n * console.log(result) // Option.Some([\"c\", 3])\n * ```\n *\n * @category elements\n * @since 3.14.0\n */\nexport const findFirst: {\n  /**\n   * Returns the first entry that satisfies the specified\n   * predicate, or `None` if no such entry exists.\n   *\n   * @example\n   * ```ts\n   * import { Record, Option } from \"effect\"\n   *\n   * const record = { a: 1, b: 2, c: 3 }\n   * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n   * console.log(result) // Option.Some([\"c\", 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.14.0\n   */\n  <K extends string | symbol, V, V2 extends V>(refinement: (value: NoInfer<V>, key: NoInfer<K>) => value is V2): (self: ReadonlyRecord<K, V>) => Option.Option<[K, V2]>\n  /**\n   * Returns the first entry that satisfies the specified\n   * predicate, or `None` if no such entry exists.\n   *\n   * @example\n   * ```ts\n   * import { Record, Option } from \"effect\"\n   *\n   * const record = { a: 1, b: 2, c: 3 }\n   * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n   * console.log(result) // Option.Some([\"c\", 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.14.0\n   */\n  <K extends string | symbol, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): (self: ReadonlyRecord<K, V>) => Option.Option<[K, V]>\n  /**\n   * Returns the first entry that satisfies the specified\n   * predicate, or `None` if no such entry exists.\n   *\n   * @example\n   * ```ts\n   * import { Record, Option } from \"effect\"\n   *\n   * const record = { a: 1, b: 2, c: 3 }\n   * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n   * console.log(result) // Option.Some([\"c\", 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.14.0\n   */\n  <K extends string | symbol, V, V2 extends V>(\n    self: ReadonlyRecord<K, V>,\n    refinement: (value: NoInfer<V>, key: NoInfer<K>) => value is V2\n  ): Option.Option<[K, V2]>\n  /**\n   * Returns the first entry that satisfies the specified\n   * predicate, or `None` if no such entry exists.\n   *\n   * @example\n   * ```ts\n   * import { Record, Option } from \"effect\"\n   *\n   * const record = { a: 1, b: 2, c: 3 }\n   * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n   * console.log(result) // Option.Some([\"c\", 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.14.0\n   */\n  <K extends string | symbol, V>(\n    self: ReadonlyRecord<K, V>,\n    predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean\n  ): Option.Option<[K, V]>\n} = dual(\n  2,\n  <K extends string | symbol, V>(self: ReadonlyRecord<K, V>, f: (value: V, key: K) => boolean) => {\n    const k = keys(self)\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i]\n      if (f(self[key], key)) {\n        return Option.some([key, self[key]])\n      }\n    }\n    return Option.none()\n  }\n)\n","/**\n * This module provides utility functions for working with arrays in TypeScript.\n *\n * @since 2.0.0\n */\n\nimport * as Either from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as internalArray from \"./internal/array.js\"\nimport * as internalDoNotation from \"./internal/doNotation.js\"\nimport * as moduleIterable from \"./Iterable.js\"\nimport * as Option from \"./Option.js\"\nimport * as Order from \"./Order.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport * as Record from \"./Record.js\"\nimport * as Tuple from \"./Tuple.js\"\nimport type { NoInfer } from \"./Types.js\"\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface ReadonlyArrayTypeLambda extends TypeLambda {\n  readonly type: ReadonlyArray<this[\"Target\"]>\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type NonEmptyReadonlyArray<A> = readonly [A, ...Array<A>]\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type NonEmptyArray<A> = [A, ...Array<A>]\n\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.make(1, 2, 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <Elements extends NonEmptyArray<any>>(\n  ...elements: Elements\n): NonEmptyArray<Elements[number]> => elements\n\n/**\n * Creates a new `Array` of the specified length.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.allocate<number>(3)\n * console.log(result) // [ <3 empty items> ]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const allocate = <A = never>(n: number): Array<A | undefined> => new Array(n)\n\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * **Example**\n *\n * ```ts\n * import { makeBy } from \"effect/Array\"\n *\n * const result = makeBy(5, n => n * 2)\n * console.log(result) // [0, 2, 4, 6, 8]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy: {\n  /**\n   * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { makeBy } from \"effect/Array\"\n   *\n   * const result = makeBy(5, n => n * 2)\n   * console.log(result) // [0, 2, 4, 6, 8]\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(f: (i: number) => A): (n: number) => NonEmptyArray<A>\n  /**\n   * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { makeBy } from \"effect/Array\"\n   *\n   * const result = makeBy(5, n => n * 2)\n   * console.log(result) // [0, 2, 4, 6, 8]\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(n: number, f: (i: number) => A): NonEmptyArray<A>\n} = dual(2, <A>(n: number, f: (i: number) => A) => {\n  const max = Math.max(1, Math.floor(n))\n  const out = new Array(max)\n  for (let i = 0; i < max; i++) {\n    out[i] = f(i)\n  }\n  return out as NonEmptyArray<A>\n})\n\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * **Example**\n *\n * ```ts\n * import { range } from \"effect/Array\"\n *\n * const result = range(1, 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start: number, end: number): NonEmptyArray<number> =>\n  start <= end ? makeBy(end - start + 1, (i) => start + i) : [start]\n\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replicate(\"a\", 3)\n * console.log(result) // [\"a\", \"a\", \"a\"]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const replicate: {\n  /**\n   * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replicate(\"a\", 3)\n   * console.log(result) // [\"a\", \"a\", \"a\"]\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  (n: number): <A>(a: A) => NonEmptyArray<A>\n  /**\n   * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replicate(\"a\", 3)\n   * console.log(result) // [\"a\", \"a\", \"a\"]\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(a: A, n: number): NonEmptyArray<A>\n} = dual(2, <A>(a: A, n: number): NonEmptyArray<A> => makeBy(n, () => a))\n\n/**\n * Creates a new `Array` from an iterable collection of values.\n * If the input is already an array, it returns the input as-is.\n * Otherwise, it converts the iterable collection to an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.fromIterable(new Set([1, 2, 3]))\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = <A>(collection: Iterable<A>): Array<A> =>\n  Array.isArray(collection) ? collection : Array.from(collection)\n\n/**\n * Creates a new `Array` from a value that might not be an iterable.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.ensure(\"a\")) // [\"a\"]\n * console.log(Array.ensure([\"a\"])) // [\"a\"]\n * console.log(Array.ensure([\"a\", \"b\", \"c\"])) // [\"a\", \"b\", \"c\"]\n * ```\n *\n * @category constructors\n * @since 3.3.0\n */\nexport const ensure = <A>(self: ReadonlyArray<A> | A): Array<A> => Array.isArray(self) ? self : [self as A]\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.fromRecord({ a: 1, b: 2, c: 3 })\n * console.log(result) // [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]> = Record.toEntries\n\n/**\n * Converts an `Option` to an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * console.log(Array.fromOption(Option.some(1))) // [1]\n * console.log(Array.fromOption(Option.none())) // []\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromOption: <A>(self: Option.Option<A>) => Array<A> = Option.toArray\n\n/**\n * Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const match = Array.match({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n * })\n * console.log(match([])) // \"empty\"\n * console.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  /**\n   * Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const match = Array.match({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n   * })\n   * console.log(match([])) // \"empty\"\n   * console.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  /**\n   * Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const match = Array.match({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n   * })\n   * console.log(match([])) // \"empty\"\n   * console.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n  }\n): B | C => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty())\n\n/**\n * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const matchLeft = Array.matchLeft({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n * })\n * console.log(matchLeft([])) // \"empty\"\n * console.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const matchLeft: {\n  /**\n   * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const matchLeft = Array.matchLeft({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n   * })\n   * console.log(matchLeft([])) // \"empty\"\n   * console.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (head: A, tail: Array<A>) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  /**\n   * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const matchLeft = Array.matchLeft({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n   * })\n   * console.log(matchLeft([])) // \"empty\"\n   * console.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (head: A, tail: Array<A>) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (head: A, tail: Array<A>) => C\n  }\n): B | C => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty())\n\n/**\n * Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const matchRight = Array.matchRight({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n * })\n * console.log(matchRight([])) // \"empty\"\n * console.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const matchRight: {\n  /**\n   * Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const matchRight = Array.matchRight({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n   * })\n   * console.log(matchRight([])) // \"empty\"\n   * console.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (init: Array<A>, last: A) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  /**\n   * Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const matchRight = Array.matchRight({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n   * })\n   * console.log(matchRight([])) // \"empty\"\n   * console.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (init: Array<A>, last: A) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (init: Array<A>, last: A) => C\n  }\n): B | C =>\n  isNonEmptyReadonlyArray(self) ?\n    onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) :\n    onEmpty())\n\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.prepend([2, 3, 4], 1)\n * console.log(result) // [1, 2, 3, 4]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend: {\n  /**\n   * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prepend([2, 3, 4], 1)\n   * console.log(result) // [1, 2, 3, 4]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>\n  /**\n   * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prepend([2, 3, 4], 1)\n   * console.log(result) // [1, 2, 3, 4]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B> => [head, ...self])\n\n/**\n * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n * If either array is non-empty, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.prependAll([2, 3], [0, 1])\n * console.log(result) // [0, 1, 2, 3]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll: {\n  /**\n   * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prependAll([2, 3], [0, 1])\n   * console.log(result) // [0, 1, 2, 3]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  /**\n   * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prependAll([2, 3], [0, 1])\n   * console.log(result) // [0, 1, 2, 3]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  /**\n   * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prependAll([2, 3], [0, 1])\n   * console.log(result) // [0, 1, 2, 3]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>\n  /**\n   * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prependAll([2, 3], [0, 1])\n   * console.log(result) // [0, 1, 2, 3]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(that).concat(fromIterable(self))\n)\n\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.append([1, 2, 3], 4);\n * console.log(result) // [1, 2, 3, 4]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append: {\n  /**\n   * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.append([1, 2, 3], 4);\n   * console.log(result) // [1, 2, 3, 4]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>\n  /**\n   * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.append([1, 2, 3], 4);\n   * console.log(result) // [1, 2, 3, 4]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, last: B): Array<A | B> => [...self, last])\n\n/**\n * Concatenates two arrays (or iterables), combining their elements.\n * If either array is non-empty, the result is also a non-empty array.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll: {\n  /**\n   * Concatenates two arrays (or iterables), combining their elements.\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  /**\n   * Concatenates two arrays (or iterables), combining their elements.\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  /**\n   * Concatenates two arrays (or iterables), combining their elements.\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>\n  /**\n   * Concatenates two arrays (or iterables), combining their elements.\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).concat(fromIterable(that))\n)\n\n/**\n * Accumulates values from an `Iterable` starting from the left, storing\n * each intermediate result in an array. Useful for tracking the progression of\n * a value through a series of transformations.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\n * console.log(result) // [0, 1, 3, 6, 10]\n *\n * // Explanation:\n * // This function starts with the initial value (0 in this case)\n * // and adds each element of the array to this accumulator one by one,\n * // keeping track of the cumulative sum after each addition.\n * // Each of these sums is captured in the resulting array.\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scan: {\n  /**\n   * Accumulates values from an `Iterable` starting from the left, storing\n   * each intermediate result in an array. Useful for tracking the progression of\n   * a value through a series of transformations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\";\n   *\n   * const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\n   * console.log(result) // [0, 1, 3, 6, 10]\n   *\n   * // Explanation:\n   * // This function starts with the initial value (0 in this case)\n   * // and adds each element of the array to this accumulator one by one,\n   * // keeping track of the cumulative sum after each addition.\n   * // Each of these sums is captured in the resulting array.\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>\n  /**\n   * Accumulates values from an `Iterable` starting from the left, storing\n   * each intermediate result in an array. Useful for tracking the progression of\n   * a value through a series of transformations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\";\n   *\n   * const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\n   * console.log(result) // [0, 1, 3, 6, 10]\n   *\n   * // Explanation:\n   * // This function starts with the initial value (0 in this case)\n   * // and adds each element of the array to this accumulator one by one,\n   * // keeping track of the cumulative sum after each addition.\n   * // Each of these sums is captured in the resulting array.\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>\n} = dual(3, <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B> => {\n  const out: NonEmptyArray<B> = [b]\n  let i = 0\n  for (const a of self) {\n    out[i + 1] = f(out[i], a)\n    i++\n  }\n  return out\n})\n\n/**\n * Accumulates values from an `Iterable` starting from the right, storing\n * each intermediate result in an array. Useful for tracking the progression of\n * a value through a series of transformations.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\n * console.log(result) // [10, 9, 7, 4, 0]\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scanRight: {\n  /**\n   * Accumulates values from an `Iterable` starting from the right, storing\n   * each intermediate result in an array. Useful for tracking the progression of\n   * a value through a series of transformations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\";\n   *\n   * const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\n   * console.log(result) // [10, 9, 7, 4, 0]\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>\n  /**\n   * Accumulates values from an `Iterable` starting from the right, storing\n   * each intermediate result in an array. Useful for tracking the progression of\n   * a value through a series of transformations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\";\n   *\n   * const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\n   * console.log(result) // [10, 9, 7, 4, 0]\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>\n} = dual(3, <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B> => {\n  const input = fromIterable(self)\n  const out: NonEmptyArray<B> = new Array(input.length + 1) as any\n  out[input.length] = b\n  for (let i = input.length - 1; i >= 0; i--) {\n    out[i] = f(out[i + 1], input[i])\n  }\n  return out\n})\n\n/**\n * Determine if `unknown` is an Array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isArray(null)) // false\n * console.log(Array.isArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isArray: {\n  /**\n   * Determine if `unknown` is an Array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * console.log(Array.isArray(null)) // false\n   * console.log(Array.isArray([1, 2, 3])) // true\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  (self: unknown): self is Array<unknown>\n  /**\n   * Determine if `unknown` is an Array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * console.log(Array.isArray(null)) // false\n   * console.log(Array.isArray([1, 2, 3])) // true\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <T>(self: T): self is Extract<T, ReadonlyArray<any>>\n} = Array.isArray\n\n/**\n * Determine if an `Array` is empty narrowing down the type to `[]`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isEmptyArray([])) // true\n * console.log(Array.isEmptyArray([1, 2, 3])) // false\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyArray = <A>(self: Array<A>): self is [] => self.length === 0\n\n/**\n * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isEmptyReadonlyArray([])) // true\n * console.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly [] = isEmptyArray as any\n\n/**\n * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n *\n * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isNonEmptyArray([])) // false\n * console.log(Array.isNonEmptyArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A> = internalArray.isNonEmptyArray\n\n/**\n * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n *\n * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isNonEmptyReadonlyArray([])) // false\n * console.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A> =\n  internalArray.isNonEmptyArray\n\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const length = <A>(self: ReadonlyArray<A>): number => self.length\n\nconst isOutOfBounds = <A>(i: number, as: ReadonlyArray<A>): boolean => i < 0 || i >= as.length\n\nconst clamp = <A>(i: number, as: ReadonlyArray<A>): number => Math.floor(Math.min(Math.max(0, i), as.length))\n\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const get: {\n  /**\n   * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (index: number): <A>(self: ReadonlyArray<A>) => Option.Option<A>\n  /**\n   * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: ReadonlyArray<A>, index: number): Option.Option<A>\n} = dual(2, <A>(self: ReadonlyArray<A>, index: number): Option.Option<A> => {\n  const i = Math.floor(index)\n  return isOutOfBounds(i, self) ? Option.none() : Option.some(self[i])\n})\n\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet: {\n  /**\n   * Gets an element unsafely, will throw on out of bounds.\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  (index: number): <A>(self: ReadonlyArray<A>) => A\n  /**\n   * Gets an element unsafely, will throw on out of bounds.\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <A>(self: ReadonlyArray<A>, index: number): A\n} = dual(2, <A>(self: ReadonlyArray<A>, index: number): A => {\n  const i = Math.floor(index)\n  if (isOutOfBounds(i, self)) {\n    throw new Error(`Index ${i} out of bounds`)\n  }\n  return self[i]\n})\n\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.unprepend([1, 2, 3, 4])\n * console.log(result) // [1, [2, 3, 4]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const unprepend = <A>(\n  self: NonEmptyReadonlyArray<A>\n): [firstElement: A, remainingElements: Array<A>] => [headNonEmpty(self), tailNonEmpty(self)]\n\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.unappend([1, 2, 3, 4])\n * console.log(result) // [[1, 2, 3], 4]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const unappend = <A>(\n  self: NonEmptyReadonlyArray<A>\n): [arrayWithoutLastElement: Array<A>, lastElement: A] => [initNonEmpty(self), lastNonEmpty(self)]\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const head: <A>(self: ReadonlyArray<A>) => Option.Option<A> = get(0)\n\n/**\n * Get the first element of a non empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.headNonEmpty([1, 2, 3, 4])\n * console.log(result) // 1\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A = unsafeGet(0)\n\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const last = <A>(self: ReadonlyArray<A>): Option.Option<A> =>\n  isNonEmptyReadonlyArray(self) ? Option.some(lastNonEmpty(self)) : Option.none()\n\n/**\n * Get the last element of a non empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.lastNonEmpty([1, 2, 3, 4])\n * console.log(result) // 4\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const lastNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): A => self[self.length - 1]\n\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const tail = <A>(self: Iterable<A>): Option.Option<Array<A>> => {\n  const input = fromIterable(self)\n  return isNonEmptyReadonlyArray(input) ? Option.some(tailNonEmpty(input)) : Option.none()\n}\n\n/**\n * Get all but the first element of a `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.tailNonEmpty([1, 2, 3, 4])\n * console.log(result) // [2, 3, 4]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const tailNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): Array<A> => self.slice(1)\n\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const init = <A>(self: Iterable<A>): Option.Option<Array<A>> => {\n  const input = fromIterable(self)\n  return isNonEmptyReadonlyArray(input) ? Option.some(initNonEmpty(input)) : Option.none()\n}\n\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.initNonEmpty([1, 2, 3, 4])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const initNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): Array<A> => self.slice(0, -1)\n\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.take([1, 2, 3, 4, 5], 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const take: {\n  /**\n   * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.take([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.take([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(0, clamp(n, input))\n})\n\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.takeRight([1, 2, 3, 4, 5], 3)\n * console.log(result) // [3, 4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeRight: {\n  /**\n   * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeRight([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [3, 4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeRight([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [3, 4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  const i = clamp(n, input)\n  return i === 0 ? [] : input.slice(-i)\n})\n\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n * console.log(result) // [1, 3, 2]\n *\n * // Explanation:\n * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n * // - The next element (`3`) is also less than `4`, so it adds `3`.\n * // - The next element (`2`) is again less than `4`, so it adds `2`.\n * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeWhile: {\n  /**\n   * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n   * console.log(result) // [1, 3, 2]\n   *\n   * // Explanation:\n   * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n   * // - The next element (`3`) is also less than `4`, so it adds `3`.\n   * // - The next element (`2`) is again less than `4`, so it adds `2`.\n   * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>\n  /**\n   * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n   * console.log(result) // [1, 3, 2]\n   *\n   * // Explanation:\n   * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n   * // - The next element (`3`) is also less than `4`, so it adds `3`.\n   * // - The next element (`2`) is again less than `4`, so it adds `2`.\n   * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  /**\n   * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n   * console.log(result) // [1, 3, 2]\n   *\n   * // Explanation:\n   * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n   * // - The next element (`3`) is also less than `4`, so it adds `3`.\n   * // - The next element (`2`) is again less than `4`, so it adds `2`.\n   * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>\n  /**\n   * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n   * console.log(result) // [1, 3, 2]\n   *\n   * // Explanation:\n   * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n   * // - The next element (`3`) is also less than `4`, so it adds `3`.\n   * // - The next element (`2`) is again less than `4`, so it adds `2`.\n   * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> => {\n  let i = 0\n  const out: Array<A> = []\n  for (const a of self) {\n    if (!predicate(a, i)) {\n      break\n    }\n    out.push(a)\n    i++\n  }\n  return out\n})\n\nconst spanIndex = <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): number => {\n  let i = 0\n  for (const a of self) {\n    if (!predicate(a, i)) {\n      break\n    }\n    i++\n  }\n  return i\n}\n\n/**\n * Split an `Iterable` into two parts:\n *\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const span: {\n  /**\n   * Split an `Iterable` into two parts:\n   *\n   * 1. the longest initial subarray for which all elements satisfy the specified predicate\n   * 2. the remaining elements\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>]\n  /**\n   * Split an `Iterable` into two parts:\n   *\n   * 1. the longest initial subarray for which all elements satisfy the specified predicate\n   * 2. the remaining elements\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>]\n  /**\n   * Split an `Iterable` into two parts:\n   *\n   * 1. the longest initial subarray for which all elements satisfy the specified predicate\n   * 2. the remaining elements\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [init: Array<B>, rest: Array<Exclude<A, B>>]\n  /**\n   * Split an `Iterable` into two parts:\n   *\n   * 1. the longest initial subarray for which all elements satisfy the specified predicate\n   * 2. the remaining elements\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>] =>\n    splitAt(self, spanIndex(self, predicate))\n)\n\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.drop([1, 2, 3, 4, 5], 2)\n * console.log(result) // [3, 4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const drop: {\n  /**\n   * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.drop([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [3, 4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.drop([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [3, 4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(clamp(n, input), input.length)\n})\n\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dropRight([1, 2, 3, 4, 5], 2)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const dropRight: {\n  /**\n   * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dropRight([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dropRight([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(0, input.length - clamp(n, input))\n})\n\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\n * console.log(result) // [4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const dropWhile: {\n  /**\n   * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\n   * console.log(result) // [4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  /**\n   * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\n   * console.log(result) // [4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> =>\n    fromIterable(self).slice(spanIndex(self, predicate))\n)\n\n/**\n * Return the first index for which a predicate holds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\n * console.log(result) // Option.some(2)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirstIndex: {\n  /**\n   * Return the first index for which a predicate holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\n   * console.log(result) // Option.some(2)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>\n  /**\n   * Return the first index for which a predicate holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\n   * console.log(result) // Option.some(2)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number> => {\n  let i = 0\n  for (const a of self) {\n    if (predicate(a, i)) {\n      return Option.some(i)\n    }\n    i++\n  }\n  return Option.none()\n})\n\n/**\n * Return the last index for which a predicate holds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\n * console.log(result) // Option.some(1)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLastIndex: {\n  /**\n   * Return the last index for which a predicate holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\n   * console.log(result) // Option.some(1)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>\n  /**\n   * Return the last index for which a predicate holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\n   * console.log(result) // Option.some(1)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number> => {\n  const input = fromIterable(self)\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i], i)) {\n      return Option.some(i)\n    }\n  }\n  return Option.none()\n})\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n * console.log(result) // Option.some(4)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>\n} = moduleIterable.findFirst\n\n/**\n * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n * console.log(result) // Option.some(4)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast: {\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>\n} = dual(\n  2,\n  <A>(\n    self: Iterable<A>,\n    f: ((a: A, i: number) => boolean) | ((a: A, i: number) => Option.Option<A>)\n  ): Option.Option<A> => {\n    const input = fromIterable(self)\n    for (let i = input.length - 1; i >= 0; i--) {\n      const a = input[i]\n      const o = f(a, i)\n      if (Predicate.isBoolean(o)) {\n        if (o) {\n          return Option.some(a)\n        }\n      } else {\n        if (Option.isSome(o)) {\n          return o\n        }\n      }\n    }\n    return Option.none()\n  }\n)\n\n/**\n * Returns a tuple of the first element that satisfies the specified\n * predicate and its index, or `None` if no such element exists.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n * console.log(result) // Option.some([4, 3])\n * ```\n *\n * @category elements\n * @since 3.17.0\n */\nexport const findFirstWithIndex: {\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<[B, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<[B, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<[A, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<[B, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<[B, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<[A, number]>\n} = dual(\n  2,\n  <A>(\n    self: Iterable<A>,\n    f: ((a: A, i: number) => boolean) | ((a: A, i: number) => Option.Option<A>)\n  ): Option.Option<[A, number]> => {\n    let i = 0\n    for (const a of self) {\n      const o = f(a, i)\n      if (Predicate.isBoolean(o)) {\n        if (o) {\n          return Option.some([a, i])\n        }\n      } else {\n        if (Option.isSome(o)) {\n          return Option.some([o.value, i])\n        }\n      }\n      i++\n    }\n    return Option.none()\n  }\n)\n\n/**\n * Counts all the element of the given array that pass the given predicate\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)\n * console.log(result) // 2\n * ```\n *\n * @category folding\n * @since 3.16.0\n */\nexport const countBy: {\n  /**\n   * Counts all the element of the given array that pass the given predicate\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // 2\n   * ```\n   *\n   * @category folding\n   * @since 3.16.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => number\n  /**\n   * Counts all the element of the given array that pass the given predicate\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // 2\n   * ```\n   *\n   * @category folding\n   * @since 3.16.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): number\n} = dual(\n  2,\n  <A>(\n    self: Iterable<A>,\n    f: (a: A, i: number) => boolean\n  ): number => {\n    let count = 0\n    const as = fromIterable(self)\n    for (let i = 0; i < as.length; i++) {\n      const a = as[i]\n      if (f(a, i)) {\n        count++\n      }\n    }\n    return count\n  }\n)\n\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\n * console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n * ```\n *\n * @since 2.0.0\n */\nexport const insertAt: {\n  /**\n   * Insert an element at the specified index, creating a new `NonEmptyArray`,\n   * or return `None` if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\n   * console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A>(self: Iterable<A>) => Option.Option<NonEmptyArray<A | B>>\n  /**\n   * Insert an element at the specified index, creating a new `NonEmptyArray`,\n   * or return `None` if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\n   * console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<NonEmptyArray<A | B>>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<NonEmptyArray<A | B>> => {\n  const out: Array<A | B> = Array.from(self)\n  //             v--- `= self.length` is ok, it means inserting in last position\n  if (i < 0 || i > out.length) {\n    return Option.none()\n  }\n  out.splice(i, 0, b)\n  return Option.some(out) as any\n})\n\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\n * console.log(result) // ['a', 'z', 'c', 'd']\n * ```\n *\n * @since 2.0.0\n */\nexport const replace: {\n  /**\n   * Change the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\n   * console.log(result) // ['a', 'z', 'c', 'd']\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(\n    self: S\n  ) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n  /**\n   * Change the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\n   * console.log(result) // ['a', 'z', 'c', 'd']\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, b: B): Array<A | B> => modify(self, i, () => b))\n\n/**\n * Replaces an element in an array with the given value, returning an option of the updated array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replaceOption([1, 2, 3], 1, 4)\n * console.log(result) // Option.some([1, 4, 3])\n * ```\n *\n * @since 2.0.0\n */\nexport const replaceOption: {\n  /**\n   * Replaces an element in an array with the given value, returning an option of the updated array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replaceOption([1, 2, 3], 1, 4)\n   * console.log(result) // Option.some([1, 4, 3])\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(\n    self: S\n  ) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>\n  /**\n   * Replaces an element in an array with the given value, returning an option of the updated array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replaceOption([1, 2, 3], 1, 4)\n   * console.log(result) // Option.some([1, 4, 3])\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<Array<A | B>> => modifyOption(self, i, () => b)\n)\n\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\n * console.log(result) // [1, 2, 6, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const modify: {\n  /**\n   * Apply a function to the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\n   * console.log(result) // [1, 2, 6, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n  /**\n   * Apply a function to the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\n   * console.log(result) // [1, 2, 6, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, i: number, f: (a: A) => B): Array<A | B> => {\n    const out: Array<A | B> = Array.from(self)\n    if (isOutOfBounds(i, out)) {\n      return out\n    }\n    const b = f(out[i] as A)\n    out[i] = b\n    return out\n  }\n)\n\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const input = [1, 2, 3, 4]\n * const result = Array.modifyOption(input, 2, (n) => n * 2)\n * console.log(result) // Option.some([1, 2, 6, 4])\n *\n * const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\n * console.log(outOfBoundsResult) // Option.none()\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyOption: {\n  /**\n   * Apply a function to the element at the specified index, creating a new `Array`,\n   * or return `None` if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const input = [1, 2, 3, 4]\n   * const result = Array.modifyOption(input, 2, (n) => n * 2)\n   * console.log(result) // Option.some([1, 2, 6, 4])\n   *\n   * const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\n   * console.log(outOfBoundsResult) // Option.none()\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>\n  /**\n   * Apply a function to the element at the specified index, creating a new `Array`,\n   * or return `None` if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const input = [1, 2, 3, 4]\n   * const result = Array.modifyOption(input, 2, (n) => n * 2)\n   * console.log(result) // Option.some([1, 2, 6, 4])\n   *\n   * const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\n   * console.log(outOfBoundsResult) // Option.none()\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, f: (a: A) => B): Option.Option<Array<A | B>> => {\n  const arr = fromIterable(self)\n  if (isOutOfBounds(i, arr)) {\n    return Option.none()\n  }\n  const out: Array<A | B> = Array.isArray(self) ? self.slice() : arr\n  const b = f(arr[i])\n  out[i] = b\n  return Option.some(out)\n})\n\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const input = [1, 2, 3, 4]\n * const result = Array.remove(input, 2)\n * console.log(result) // [1, 2, 4]\n *\n * const outOfBoundsResult = Array.remove(input, 5)\n * console.log(outOfBoundsResult) // [1, 2, 3, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const remove: {\n  /**\n   * Delete the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const input = [1, 2, 3, 4]\n   * const result = Array.remove(input, 2)\n   * console.log(result) // [1, 2, 4]\n   *\n   * const outOfBoundsResult = Array.remove(input, 5)\n   * console.log(outOfBoundsResult) // [1, 2, 3, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  (i: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Delete the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const input = [1, 2, 3, 4]\n   * const result = Array.remove(input, 2)\n   * console.log(result) // [1, 2, 4]\n   *\n   * const outOfBoundsResult = Array.remove(input, 5)\n   * console.log(outOfBoundsResult) // [1, 2, 3, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, i: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, i: number): Array<A> => {\n  const out = Array.from(self)\n  if (isOutOfBounds(i, out)) {\n    return out\n  }\n  out.splice(i, 1)\n  return out\n})\n\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Array, Option } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.removeOption(numbers, 2)\n * assert.deepStrictEqual(result, Option.some([1, 2, 4]))\n *\n * const outOfBoundsResult = Array.removeOption(numbers, 5)\n * assert.deepStrictEqual(outOfBoundsResult, Option.none())\n * ```\n *\n * @since 3.16.0\n */\nexport const removeOption: {\n  /**\n   * Delete the element at the specified index, creating a new `Array`,\n   * or return `None` if the index is out of bounds.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Array, Option } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4]\n   * const result = Array.removeOption(numbers, 2)\n   * assert.deepStrictEqual(result, Option.some([1, 2, 4]))\n   *\n   * const outOfBoundsResult = Array.removeOption(numbers, 5)\n   * assert.deepStrictEqual(outOfBoundsResult, Option.none())\n   * ```\n   *\n   * @since 3.16.0\n   */\n  (i: number): <A>(self: Iterable<A>) => Option.Option<Array<A>>\n  /**\n   * Delete the element at the specified index, creating a new `Array`,\n   * or return `None` if the index is out of bounds.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Array, Option } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4]\n   * const result = Array.removeOption(numbers, 2)\n   * assert.deepStrictEqual(result, Option.some([1, 2, 4]))\n   *\n   * const outOfBoundsResult = Array.removeOption(numbers, 5)\n   * assert.deepStrictEqual(outOfBoundsResult, Option.none())\n   * ```\n   *\n   * @since 3.16.0\n   */\n  <A>(self: Iterable<A>, i: number): Option.Option<Array<A>>\n} = dual(2, <A>(self: Iterable<A>, i: number): Option.Option<Array<A>> => {\n  const arr = fromIterable(self)\n  if (isOutOfBounds(i, arr)) {\n    return Option.none()\n  }\n  const out = Array.isArray(self) ? self.slice() : arr\n  out.splice(i, 1)\n  return Option.some(out)\n})\n\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reverse([1, 2, 3, 4])\n * console.log(result) // [4, 3, 2, 1]\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const reverse = <S extends Iterable<any>>(\n  self: S\n): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never =>\n  Array.from(self).reverse() as any\n\n/**\n * Create a new array with elements sorted in increasing order based on the specified comparator.\n * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const sort: {\n  /**\n   * Create a new array with elements sorted in increasing order based on the specified comparator.\n   * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n   *\n   * @category sorting\n   * @since 2.0.0\n   */\n  <B>(O: Order.Order<B>): <A extends B, S extends Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * Create a new array with elements sorted in increasing order based on the specified comparator.\n   * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n   *\n   * @category sorting\n   * @since 2.0.0\n   */\n  <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>\n  /**\n   * Create a new array with elements sorted in increasing order based on the specified comparator.\n   * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n   *\n   * @category sorting\n   * @since 2.0.0\n   */\n  <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>\n} = dual(2, <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A> => {\n  const out = Array.from(self)\n  out.sort(O)\n  return out\n})\n\n/**\n * Sorts an array based on a provided mapping function and order. The mapping\n * function transforms the elements into a value that can be compared, and the\n * order defines how those values should be sorted.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n *\n * // Explanation:\n * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n * // converts each string into its length, and the `Order.number` specifies that the lengths should\n * // be sorted in ascending order.\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const sortWith: {\n  /**\n   * Sorts an array based on a provided mapping function and order. The mapping\n   * function transforms the elements into a value that can be compared, and the\n   * order defines how those values should be sorted.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n   * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n   *\n   * // Explanation:\n   * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n   * // converts each string into its length, and the `Order.number` specifies that the lengths should\n   * // be sorted in ascending order.\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <S extends Iterable<any>, B>(f: (a: ReadonlyArray.Infer<S>) => B, order: Order.Order<B>): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * Sorts an array based on a provided mapping function and order. The mapping\n   * function transforms the elements into a value that can be compared, and the\n   * order defines how those values should be sorted.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n   * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n   *\n   * // Explanation:\n   * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n   * // converts each string into its length, and the `Order.number` specifies that the lengths should\n   * // be sorted in ascending order.\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>\n  /**\n   * Sorts an array based on a provided mapping function and order. The mapping\n   * function transforms the elements into a value that can be compared, and the\n   * order defines how those values should be sorted.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n   * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n   *\n   * // Explanation:\n   * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n   * // converts each string into its length, and the `Order.number` specifies that the lengths should\n   * // be sorted in ascending order.\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A> =>\n    Array.from(self).map((a) => [a, f(a)] as const).sort(([, a], [, b]) => order(a, b)).map(([_]) => _)\n)\n\n/**\n * Sorts the elements of an `Iterable` in increasing order based on the provided\n * orders. The elements are compared using the first order in `orders`, then the\n * second order if the first comparison is equal, and so on.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order, pipe } from \"effect\"\n *\n * const users = [\n *   { name: \"Alice\", age: 30 },\n *   { name: \"Bob\", age: 25 },\n *   { name: \"Charlie\", age: 30 }\n * ]\n *\n * const result = pipe(\n *   users,\n *   Array.sortBy(\n *     Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n *     Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n *   )\n * )\n *\n * console.log(result)\n * // [\n * //   { name: \"Bob\", age: 25 },\n * //   { name: \"Alice\", age: 30 },\n * //   { name: \"Charlie\", age: 30 }\n * // ]\n *\n * // Explanation:\n * // The array of users is sorted first by age in ascending order. When ages are equal,\n * // the users are further sorted by name in ascending order.\n * ```\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const sortBy = <S extends Iterable<any>>(\n  ...orders: ReadonlyArray<Order.Order<ReadonlyArray.Infer<S>>>\n) => {\n  const sortByAll = sort(Order.combineAll(orders))\n  return (\n    self: S\n  ): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      return sortByAll(input) as any\n    }\n    return [] as any\n  }\n}\n\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.zip([1, 2, 3], ['a', 'b'])\n * console.log(result) // [[1, 'a'], [2, 'b']]\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zip: {\n  /**\n   * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n   * If one input `Iterable` is short, excess elements of the\n   * longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zip([1, 2, 3], ['a', 'b'])\n   * console.log(result) // [[1, 'a'], [2, 'b']]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>\n  /**\n   * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n   * If one input `Iterable` is short, excess elements of the\n   * longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zip([1, 2, 3], ['a', 'b'])\n   * console.log(result) // [[1, 'a'], [2, 'b']]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>\n  /**\n   * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n   * If one input `Iterable` is short, excess elements of the\n   * longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zip([1, 2, 3], ['a', 'b'])\n   * console.log(result) // [[1, 'a'], [2, 'b']]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>\n  /**\n   * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n   * If one input `Iterable` is short, excess elements of the\n   * longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zip([1, 2, 3], ['a', 'b'])\n   * console.log(result) // [[1, 'a'], [2, 'b']]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]> => zipWith(self, that, Tuple.make)\n)\n\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n * console.log(result) // [5, 7, 9]\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  /**\n   * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n   * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n   * console.log(result) // [5, 7, 9]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>\n  /**\n   * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n   * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n   * console.log(result) // [5, 7, 9]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>\n  /**\n   * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n   * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n   * console.log(result) // [5, 7, 9]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A, B, C>(\n    self: NonEmptyReadonlyArray<A>,\n    that: NonEmptyReadonlyArray<B>,\n    f: (a: A, b: B) => C\n  ): NonEmptyArray<C>\n  /**\n   * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n   * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n   * console.log(result) // [5, 7, 9]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>\n} = dual(3, <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C> => {\n  const as = fromIterable(self)\n  const bs = fromIterable(that)\n  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {\n    const out: NonEmptyArray<C> = [f(headNonEmpty(as), headNonEmpty(bs))]\n    const len = Math.min(as.length, bs.length)\n    for (let i = 1; i < len; i++) {\n      out[i] = f(as[i], bs[i])\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.unzip([[1, \"a\"], [2, \"b\"], [3, \"c\"]])\n * console.log(result) // [[1, 2, 3], ['a', 'b', 'c']]\n * ```\n *\n * @since 2.0.0\n */\nexport const unzip: <S extends Iterable<readonly [any, any]>>(\n  self: S\n) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]> ? [NonEmptyArray<A>, NonEmptyArray<B>]\n  : S extends Iterable<readonly [infer A, infer B]> ? [Array<A>, Array<B>]\n  : never = (<A, B>(self: Iterable<readonly [A, B]>): [Array<A>, Array<B>] => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      const fa: NonEmptyArray<A> = [input[0][0]]\n      const fb: NonEmptyArray<B> = [input[0][1]]\n      for (let i = 1; i < input.length; i++) {\n        fa[i] = input[i][0]\n        fb[i] = input[i][1]\n      }\n      return [fa, fb]\n    }\n    return [[], []]\n  }) as any\n\n/**\n * Places an element in between members of an `Iterable`.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.intersperse([1, 2, 3], 0)\n * console.log(result) // [1, 0, 2, 0, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersperse: {\n  /**\n   * Places an element in between members of an `Iterable`.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersperse([1, 2, 3], 0)\n   * console.log(result) // [1, 0, 2, 0, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n  /**\n   * Places an element in between members of an `Iterable`.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersperse([1, 2, 3], 0)\n   * console.log(result) // [1, 0, 2, 0, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>\n  /**\n   * Places an element in between members of an `Iterable`.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersperse([1, 2, 3], 0)\n   * console.log(result) // [1, 0, 2, 0, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, middle: B): Array<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, middle: B): Array<A | B> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const out: NonEmptyArray<A | B> = [headNonEmpty(input)]\n    const tail = tailNonEmpty(input)\n    for (let i = 0; i < tail.length; i++) {\n      if (i < tail.length) {\n        out.push(middle)\n      }\n      out.push(tail[i])\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\n * console.log(result) // [10, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyNonEmptyHead: {\n  /**\n   * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\n   * console.log(result) // [10, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  /**\n   * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\n   * console.log(result) // [10, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    f: (a: A) => B\n  ): NonEmptyArray<A | B> => [f(headNonEmpty(self)), ...tailNonEmpty(self)]\n)\n\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.setNonEmptyHead([1, 2, 3], 10)\n * console.log(result) // [10, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const setNonEmptyHead: {\n  /**\n   * Change the head, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.setNonEmptyHead([1, 2, 3], 10)\n   * console.log(result) // [10, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  /**\n   * Change the head, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.setNonEmptyHead([1, 2, 3], 10)\n   * console.log(result) // [10, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B> => modifyNonEmptyHead(self, () => b)\n)\n\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\n * console.log(result) // [1, 2, 6]\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyNonEmptyLast: {\n  /**\n   * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\n   * console.log(result) // [1, 2, 6]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  /**\n   * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\n   * console.log(result) // [1, 2, 6]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B> =>\n    append(initNonEmpty(self), f(lastNonEmpty(self)))\n)\n\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.setNonEmptyLast([1, 2, 3], 4)\n * console.log(result) // [1, 2, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const setNonEmptyLast: {\n  /**\n   * Change the last element, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.setNonEmptyLast([1, 2, 3], 4)\n   * console.log(result) // [1, 2, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  /**\n   * Change the last element, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.setNonEmptyLast([1, 2, 3], 4)\n   * console.log(result) // [1, 2, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B> => modifyNonEmptyLast(self, () => b)\n)\n\n/**\n * Rotate an `Iterable` by `n` steps.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\n * console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n * ```\n *\n * @since 2.0.0\n */\nexport const rotate: {\n  /**\n   * Rotate an `Iterable` by `n` steps.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\n   * console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * Rotate an `Iterable` by `n` steps.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\n   * console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>\n  /**\n   * Rotate an `Iterable` by `n` steps.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\n   * console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const len = input.length\n    const m = Math.round(n) % len\n    if (isOutOfBounds(Math.abs(m), input) || m === 0) {\n      return copy(input)\n    }\n    if (m < 0) {\n      const [f, s] = splitNonEmptyAt(input, -m)\n      return appendAll(s, f)\n    } else {\n      return rotate(self, m - len)\n    }\n  }\n  return []\n})\n\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const isEquivalent = (a: number, b: number) => a === b\n * const containsNumber = Array.containsWith(isEquivalent)\n * const result = pipe([1, 2, 3, 4], containsNumber(3))\n * console.log(result) // true\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (a: A): (self: Iterable<A>) => boolean\n  (self: Iterable<A>, a: A): boolean\n} =>\n  dual(2, (self: Iterable<A>, a: A): boolean => {\n    for (const i of self) {\n      if (isEquivalent(a, i)) {\n        return true\n      }\n    }\n    return false\n  })\n\nconst _equivalence = Equal.equivalence()\n\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\n * console.log(result) // true\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains: {\n  /**\n   * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\n   * console.log(result) // true\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(a: A): (self: Iterable<A>) => boolean\n  /**\n   * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\n   * console.log(result) // true\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, a: A): boolean\n} = containsWith(_equivalence)\n\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n * console.log(result) // [2, 4, 6, 8, 10]\n *\n * // Explanation:\n * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n * // resulting in a new array `[2, 4, 6, 8, 10]`.\n * ```\n *\n * @since 2.0.0\n */\nexport const chop: {\n  /**\n   * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n   * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n   * value and the rest of the `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n   * console.log(result) // [2, 4, 6, 8, 10]\n   *\n   * // Explanation:\n   * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n   * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n   * // resulting in a new array `[2, 4, 6, 8, 10]`.\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>, B>(\n    f: (as: NonEmptyReadonlyArray<ReadonlyArray.Infer<S>>) => readonly [B, ReadonlyArray<ReadonlyArray.Infer<S>>]\n  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n   * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n   * value and the rest of the `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n   * console.log(result) // [2, 4, 6, 8, 10]\n   *\n   * // Explanation:\n   * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n   * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n   * // resulting in a new array `[2, 4, 6, 8, 10]`.\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n  ): NonEmptyArray<B>\n  /**\n   * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n   * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n   * value and the rest of the `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n   * console.log(result) // [2, 4, 6, 8, 10]\n   *\n   * // Explanation:\n   * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n   * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n   * // resulting in a new array `[2, 4, 6, 8, 10]`.\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: Iterable<A>,\n    f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n  ): Array<B>\n} = dual(2, <A, B>(\n  self: Iterable<A>,\n  f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n): Array<B> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const [b, rest] = f(input)\n    const out: NonEmptyArray<B> = [b]\n    let next: ReadonlyArray<A> = rest\n    while (internalArray.isNonEmptyArray(next)) {\n      const [b, rest] = f(next)\n      out.push(b)\n      next = rest\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` can be `0`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitAt([1, 2, 3, 4, 5], 3)\n * console.log(result) // [[1, 2, 3], [4, 5]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitAt: {\n  /**\n   * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` can be `0`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitAt([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [[1, 2, 3], [4, 5]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]\n  /**\n   * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` can be `0`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitAt([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [[1, 2, 3], [4, 5]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]\n} = dual(2, <A>(self: Iterable<A>, n: number): [Array<A>, Array<A>] => {\n  const input = Array.from(self)\n  const _n = Math.floor(n)\n  if (isNonEmptyReadonlyArray(input)) {\n    if (_n >= 1) {\n      return splitNonEmptyAt(input, _n)\n    }\n    return [[], input]\n  }\n  return [input, []]\n})\n\n/**\n * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\n * console.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitNonEmptyAt: {\n  /**\n   * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` must be `>= 1`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\n   * console.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]\n  /**\n   * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` must be `>= 1`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\n   * console.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, n: number): [NonEmptyArray<A>, Array<A>] => {\n  const _n = Math.max(1, Math.floor(n))\n  return _n >= self.length ?\n    [copy(self), []] :\n    [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)]\n})\n\n/**\n * Splits this iterable into `n` equally sized arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\n * console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const split: {\n  /**\n   * Splits this iterable into `n` equally sized arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\n   * console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<Array<A>>\n  /**\n   * Splits this iterable into `n` equally sized arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\n   * console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  <A>(self: Iterable<A>, n: number): Array<Array<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number) => {\n  const input = fromIterable(self)\n  return chunksOf(input, Math.ceil(input.length / Math.floor(n)))\n})\n\n/**\n * Splits this iterable on the first element that matches this predicate.\n * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\n * console.log(result) // [[1, 2, 3], [4, 5]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitWhere: {\n  /**\n   * Splits this iterable on the first element that matches this predicate.\n   * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\n   * console.log(result) // [[1, 2, 3], [4, 5]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]\n  /**\n   * Splits this iterable on the first element that matches this predicate.\n   * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\n   * console.log(result) // [[1, 2, 3], [4, 5]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>] =>\n    span(self, (a: A, i: number) => !predicate(a, i))\n)\n\n/**\n * Copies an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.copy([1, 2, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const copy: {\n  /**\n   * Copies an array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.copy([1, 2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>\n  /**\n   * Copies an array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.copy([1, 2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: ReadonlyArray<A>): Array<A>\n} = (<A>(self: ReadonlyArray<A>): Array<A> => self.slice()) as any\n\n/**\n * Pads an array.\n * Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\n * If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\n * If `n` is less than or equal to 0, the returned array will be an empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.pad([1, 2, 3], 6, 0)\n * console.log(result) // [1, 2, 3, 0, 0, 0]\n * ```\n *\n * @since 3.8.4\n */\nexport const pad: {\n  /**\n   * Pads an array.\n   * Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\n   * If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\n   * If `n` is less than or equal to 0, the returned array will be an empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.pad([1, 2, 3], 6, 0)\n   * console.log(result) // [1, 2, 3, 0, 0, 0]\n   * ```\n   *\n   * @since 3.8.4\n   */\n  <A, T>(n: number, fill: T): (\n    self: Array<A>\n  ) => Array<A | T>\n  /**\n   * Pads an array.\n   * Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\n   * If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\n   * If `n` is less than or equal to 0, the returned array will be an empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.pad([1, 2, 3], 6, 0)\n   * console.log(result) // [1, 2, 3, 0, 0, 0]\n   * ```\n   *\n   * @since 3.8.4\n   */\n  <A, T>(self: Array<A>, n: number, fill: T): Array<A | T>\n} = dual(3, <A, T>(self: Array<A>, n: number, fill: T): Array<A | T> => {\n  if (self.length >= n) {\n    return take(self, n)\n  }\n  return appendAll(\n    self,\n    makeBy(n - self.length, () => fill)\n  )\n})\n\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts skip-type-checking\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n * console.log(result) // [[1, 2], [3, 4], [5]]\n *\n * // Explanation:\n * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n * // the last chunk contains the remaining elements.\n * // The result is `[[1, 2], [3, 4], [5]]`.\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const chunksOf: {\n  /**\n   * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n   * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n   * definition of `chunksOf`; it satisfies the property that\n   *\n   * ```ts skip-type-checking\n   * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n   * ```\n   *\n   * whenever `n` evenly divides the length of `self`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [[1, 2], [3, 4], [5]]\n   *\n   * // Explanation:\n   * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n   * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n   * // the last chunk contains the remaining elements.\n   * // The result is `[[1, 2], [3, 4], [5]]`.\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  (n: number): <S extends Iterable<any>>(\n    self: S\n  ) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>\n  /**\n   * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n   * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n   * definition of `chunksOf`; it satisfies the property that\n   *\n   * ```ts skip-type-checking\n   * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n   * ```\n   *\n   * whenever `n` evenly divides the length of `self`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [[1, 2], [3, 4], [5]]\n   *\n   * // Explanation:\n   * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n   * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n   * // the last chunk contains the remaining elements.\n   * // The result is `[[1, 2], [3, 4], [5]]`.\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>\n  /**\n   * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n   * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n   * definition of `chunksOf`; it satisfies the property that\n   *\n   * ```ts skip-type-checking\n   * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n   * ```\n   *\n   * whenever `n` evenly divides the length of `self`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [[1, 2], [3, 4], [5]]\n   *\n   * // Explanation:\n   * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n   * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n   * // the last chunk contains the remaining elements.\n   * // The result is `[[1, 2], [3, 4], [5]]`.\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    return chop(input, splitNonEmptyAt(n))\n  }\n  return []\n})\n\n/**\n * Creates sliding windows of size `n` from an `Iterable`.\n * If the number of elements is less than `n` or if `n` is not greater than zero,\n * an empty array is returned.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n * assert.deepStrictEqual(Array.window(numbers, 6), [])\n * ```\n *\n * @category splitting\n * @since 3.13.2\n */\nexport const window: {\n  /**\n   * Creates sliding windows of size `n` from an `Iterable`.\n   * If the number of elements is less than `n` or if `n` is not greater than zero,\n   * an empty array is returned.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Array } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5]\n   * assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n   * assert.deepStrictEqual(Array.window(numbers, 6), [])\n   * ```\n   *\n   * @category splitting\n   * @since 3.13.2\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<Array<A>>\n  /**\n   * Creates sliding windows of size `n` from an `Iterable`.\n   * If the number of elements is less than `n` or if `n` is not greater than zero,\n   * an empty array is returned.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Array } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5]\n   * assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n   * assert.deepStrictEqual(Array.window(numbers, 6), [])\n   * ```\n   *\n   * @category splitting\n   * @since 3.13.2\n   */\n  <A>(self: Iterable<A>, n: number): Array<Array<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<Array<A>> => {\n  const input = fromIterable(self)\n  if (n > 0 && isNonEmptyReadonlyArray(input)) {\n    return Array.from(\n      { length: input.length - (n - 1) },\n      (_, index) => input.slice(index, index + n)\n    )\n  }\n  return []\n})\n\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\n * console.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupWith: {\n  /**\n   * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\n   * console.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n   * ```\n   *\n   * @category grouping\n   * @since 2.0.0\n   */\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>\n  /**\n   * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\n   * console.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n   * ```\n   *\n   * @category grouping\n   * @since 2.0.0\n   */\n  <A>(\n    self: NonEmptyReadonlyArray<A>,\n    isEquivalent: (self: A, that: A) => boolean\n  ): NonEmptyArray<NonEmptyArray<A>>\n} = dual(\n  2,\n  <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>> =>\n    chop(self, (as) => {\n      const h = headNonEmpty(as)\n      const out: NonEmptyArray<A> = [h]\n      let i = 1\n      for (; i < as.length; i++) {\n        const a = as[i]\n        if (isEquivalent(a, h)) {\n          out.push(a)\n        } else {\n          break\n        }\n      }\n      return [out, as.slice(i)]\n    })\n)\n\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.group([1, 1, 2, 2, 2, 3, 1])\n * console.log(result) // [[1, 1], [2, 2, 2], [3], [1]]\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>> = groupWith(\n  Equal.equivalence()\n)\n\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const people = [\n *   { name: \"Alice\", group: \"A\" },\n *   { name: \"Bob\", group: \"B\" },\n *   { name: \"Charlie\", group: \"A\" }\n * ]\n *\n * const result = Array.groupBy(people, person => person.group)\n * console.log(result)\n * // {\n * //  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n * //  B: [{ name: \"Bob\", group: \"B\" }]\n * // }\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupBy: {\n  /**\n   * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n   * function on each element, and grouping the results according to values returned\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const people = [\n   *   { name: \"Alice\", group: \"A\" },\n   *   { name: \"Bob\", group: \"B\" },\n   *   { name: \"Charlie\", group: \"A\" }\n   * ]\n   *\n   * const result = Array.groupBy(people, person => person.group)\n   * console.log(result)\n   * // {\n   * //  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n   * //  B: [{ name: \"Bob\", group: \"B\" }]\n   * // }\n   * ```\n   *\n   * @category grouping\n   * @since 2.0.0\n   */\n  <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>\n  /**\n   * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n   * function on each element, and grouping the results according to values returned\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const people = [\n   *   { name: \"Alice\", group: \"A\" },\n   *   { name: \"Bob\", group: \"B\" },\n   *   { name: \"Charlie\", group: \"A\" }\n   * ]\n   *\n   * const result = Array.groupBy(people, person => person.group)\n   * console.log(result)\n   * // {\n   * //  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n   * //  B: [{ name: \"Bob\", group: \"B\" }]\n   * // }\n   * ```\n   *\n   * @category grouping\n   * @since 2.0.0\n   */\n  <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>\n} = dual(2, <A, K extends string | symbol>(\n  self: Iterable<A>,\n  f: (a: A) => K\n): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>> => {\n  const out: Record<string | symbol, NonEmptyArray<A>> = {}\n  for (const a of self) {\n    const k = f(a)\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a)\n    } else {\n      out[k] = [a]\n    }\n  }\n  return out\n})\n\n/**\n * Calculates the union of two arrays using the provided equivalence relation.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n * console.log(union) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const unionWith: {\n  /**\n   * Calculates the union of two arrays using the provided equivalence relation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n   * console.log(union) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>, T extends Iterable<any>>(\n    that: T,\n    isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean\n  ): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  /**\n   * Calculates the union of two arrays using the provided equivalence relation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n   * console.log(union) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    that: Iterable<B>,\n    isEquivalent: (self: A, that: B) => boolean\n  ): NonEmptyArray<A | B>\n  /**\n   * Calculates the union of two arrays using the provided equivalence relation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n   * console.log(union) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: Iterable<A>,\n    that: NonEmptyReadonlyArray<B>,\n    isEquivalent: (self: A, that: B) => boolean\n  ): NonEmptyArray<A | B>\n  /**\n   * Calculates the union of two arrays using the provided equivalence relation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n   * console.log(union) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: Iterable<A>,\n    that: Iterable<B>,\n    isEquivalent: (self: A, that: B) => boolean\n  ): Array<A | B>\n} = dual(3, <A>(self: Iterable<A>, that: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n  const a = fromIterable(self)\n  const b = fromIterable(that)\n  if (isNonEmptyReadonlyArray(a)) {\n    if (isNonEmptyReadonlyArray(b)) {\n      const dedupe = dedupeWith(isEquivalent)\n      return dedupe(appendAll(a, b))\n    }\n    return a\n  }\n  return b\n})\n\n/**\n * Creates a union of two arrays, removing duplicates.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.union([1, 2], [2, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const union: {\n  /**\n   * Creates a union of two arrays, removing duplicates.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.union([1, 2], [2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <T extends Iterable<any>>(that: T): <S extends Iterable<any>>(\n    self: S\n  ) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  /**\n   * Creates a union of two arrays, removing duplicates.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.union([1, 2], [2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>\n  /**\n   * Creates a union of two arrays, removing duplicates.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.union([1, 2], [2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  /**\n   * Creates a union of two arrays, removing duplicates.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.union([1, 2], [2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B> => unionWith(self, that, _equivalence))\n\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\n * const array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\n * const isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\n * const result = Array.intersectionWith(isEquivalent)(array2)(array1)\n * console.log(result) // [{ id: 1 }, { id: 3 }]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersectionWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  (self: Iterable<A>, that: Iterable<A>): Array<A>\n} => {\n  const has = containsWith(isEquivalent)\n  return dual(\n    2,\n    (self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).filter((a) => has(that, a))\n  )\n}\n\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.intersection([1, 2, 3], [3, 4, 1])\n * console.log(result) // [1, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersection: {\n  /**\n   * Creates an `Array` of unique values that are included in all given `Iterable`s.\n   * The order and references of result values are determined by the first `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersection([1, 2, 3], [3, 4, 1])\n   * console.log(result) // [1, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>\n  /**\n   * Creates an `Array` of unique values that are included in all given `Iterable`s.\n   * The order and references of result values are determined by the first `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersection([1, 2, 3], [3, 4, 1])\n   * console.log(result) // [1, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>\n} = intersectionWith(_equivalence)\n\n/**\n * Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2, 3]\n * const array2 = [2, 3, 4]\n * const difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\n * console.log(difference) // [1]\n * ```\n *\n * @since 2.0.0\n */\nexport const differenceWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  (self: Iterable<A>, that: Iterable<A>): Array<A>\n} => {\n  const has = containsWith(isEquivalent)\n  return dual(\n    2,\n    (self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).filter((a) => !has(that, a))\n  )\n}\n\n/**\n * Creates a `Array` of values not included in the other given `Iterable`.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const difference = Array.difference([1, 2, 3], [2, 3, 4])\n * console.log(difference) // [1]\n * ```\n *\n * @since 2.0.0\n */\nexport const difference: {\n  /**\n   * Creates a `Array` of values not included in the other given `Iterable`.\n   * The order and references of result values are determined by the first `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const difference = Array.difference([1, 2, 3], [2, 3, 4])\n   * console.log(difference) // [1]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  /**\n   * Creates a `Array` of values not included in the other given `Iterable`.\n   * The order and references of result values are determined by the first `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const difference = Array.difference([1, 2, 3], [2, 3, 4])\n   * console.log(difference) // [1]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A>\n} = differenceWith(_equivalence)\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty: <A = never>() => Array<A> = () => []\n\n/**\n * Constructs a new `NonEmptyArray<A>` from the specified value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = <A>(a: A): NonEmptyArray<A> => [a]\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ReadonlyArray {\n  /**\n   * @since 2.0.0\n   */\n  export type Infer<S extends Iterable<any>> = S extends ReadonlyArray<infer A> ? A\n    : S extends Iterable<infer A> ? A\n    : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type With<S extends Iterable<any>, A> = S extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type OrNonEmpty<\n    S extends Iterable<any>,\n    T extends Iterable<any>,\n    A\n  > = S extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : T extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type AndNonEmpty<\n    S extends Iterable<any>,\n    T extends Iterable<any>,\n    A\n  > = S extends NonEmptyReadonlyArray<any> ? T extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type Flatten<T extends ReadonlyArray<ReadonlyArray<any>>> = T extends\n    NonEmptyReadonlyArray<NonEmptyReadonlyArray<infer A>> ? NonEmptyArray<A>\n    : T extends ReadonlyArray<ReadonlyArray<infer A>> ? Array<A>\n    : never\n}\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <S extends ReadonlyArray<any>, B>(f: (a: ReadonlyArray.Infer<S>, i: number) => B): (self: S) => ReadonlyArray.With<S, B>\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <S extends ReadonlyArray<any>, B>(self: S, f: (a: ReadonlyArray.Infer<S>, i: number) => B): ReadonlyArray.With<S, B>\n} = dual(2, <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => B): Array<B> => self.map(f))\n\n/**\n * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  /**\n   * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => T): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>\n  /**\n   * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    f: (a: A, i: number) => NonEmptyReadonlyArray<B>\n  ): NonEmptyArray<B>\n  /**\n   * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B> => {\n    if (isEmptyReadonlyArray(self)) {\n      return []\n    }\n    const out: Array<B> = []\n    for (let i = 0; i < self.length; i++) {\n      const inner = f(self[i], i)\n      for (let j = 0; j < inner.length; j++) {\n        out.push(inner[j])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Combines multiple arrays into a single array by concatenating all elements\n * from each nested array. This function ensures that the structure of nested\n * arrays is collapsed into a single, flat array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])\n * console.log(result) // [1, 2, 3, 4, 5, 6]\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S> = flatMap(\n  identity\n) as any\n\n/**\n * Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\n * This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n *\n * const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\n * console.log(result) // [4, 16]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMap: {\n  /**\n   * Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\n   * This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Option } from \"effect\"\n   *\n   * const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n   *\n   * const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\n   * console.log(result) // [4, 16]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>\n  /**\n   * Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\n   * This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Option } from \"effect\"\n   *\n   * const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n   *\n   * const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\n   * console.log(result) // [4, 16]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B> => {\n    const as = fromIterable(self)\n    const out: Array<B> = []\n    for (let i = 0; i < as.length; i++) {\n      const o = f(as[i], i)\n      if (Option.isSome(o)) {\n        out.push(o.value)\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\n * This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\n * This is useful when you need to transform an array but only up to the point where a certain condition holds true.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n *\n * const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\n * console.log(result) // [4, 16]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMapWhile: {\n  /**\n   * Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\n   * This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\n   * This is useful when you need to transform an array but only up to the point where a certain condition holds true.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Option } from \"effect\"\n   *\n   * const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n   *\n   * const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\n   * console.log(result) // [4, 16]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>\n  /**\n   * Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\n   * This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\n   * This is useful when you need to transform an array but only up to the point where a certain condition holds true.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Option } from \"effect\"\n   *\n   * const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n   *\n   * const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\n   * console.log(result) // [4, 16]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>\n} = dual(2, <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>) => {\n  let i = 0\n  const out: Array<B> = []\n  for (const a of self) {\n    const b = f(a, i)\n    if (Option.isSome(b)) {\n      out.push(b.value)\n    } else {\n      break\n    }\n    i++\n  }\n  return out\n})\n\n/**\n * Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\n * This function is particularly useful for operations where each element can result in two possible types,\n * and you want to separate these types into different collections. For instance, separating validation results\n * into successes and failures.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\";\n *\n * const isEven = (x: number) => x % 2 === 0\n *\n * const result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n *   isEven(x) ? Either.right(x) : Either.left(x)\n * )\n * console.log(result)\n * // [\n * //   [1, 3, 5],\n * //   [2, 4]\n * // ]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  /**\n   * Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\n   * This function is particularly useful for operations where each element can result in two possible types,\n   * and you want to separate these types into different collections. For instance, separating validation results\n   * into successes and failures.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Either } from \"effect\";\n   *\n   * const isEven = (x: number) => x % 2 === 0\n   *\n   * const result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n   *   isEven(x) ? Either.right(x) : Either.left(x)\n   * )\n   * console.log(result)\n   * // [\n   * //   [1, 3, 5],\n   * //   [2, 4]\n   * // ]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(f: (a: A, i: number) => Either.Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]\n  /**\n   * Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\n   * This function is particularly useful for operations where each element can result in two possible types,\n   * and you want to separate these types into different collections. For instance, separating validation results\n   * into successes and failures.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Either } from \"effect\";\n   *\n   * const isEven = (x: number) => x % 2 === 0\n   *\n   * const result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n   *   isEven(x) ? Either.right(x) : Either.left(x)\n   * )\n   * console.log(result)\n   * // [\n   * //   [1, 3, 5],\n   * //   [2, 4]\n   * // ]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either.Either<C, B>): [left: Array<B>, right: Array<C>]\n} = dual(\n  2,\n  <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either.Either<C, B>): [left: Array<B>, right: Array<C>] => {\n    const left: Array<B> = []\n    const right: Array<C> = []\n    const as = fromIterable(self)\n    for (let i = 0; i < as.length; i++) {\n      const e = f(as[i], i)\n      if (Either.isLeft(e)) {\n        left.push(e.left)\n      } else {\n        right.push(e.right)\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])\n * console.log(result) // [1, 2]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\n\nexport const getSomes: <T extends Iterable<Option.Option<X>>, X = any>(\n  self: T\n) => Array<Option.Option.Value<ReadonlyArray.Infer<T>>> = filterMap(identity as any)\n\n/**\n * Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const result = Array.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])\n * console.log(result) // [\"err\"]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getLefts = <T extends Iterable<Either.Either<any, any>>>(\n  self: T\n): Array<Either.Either.Left<ReadonlyArray.Infer<T>>> => {\n  const out: Array<any> = []\n  for (const a of self) {\n    if (Either.isLeft(a)) {\n      out.push(a.left)\n    }\n  }\n\n  return out\n}\n\n/**\n * Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const result = Array.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])\n * console.log(result) // [1, 2]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getRights = <T extends Iterable<Either.Either<any, any>>>(\n  self: T\n): Array<Either.Either.Right<ReadonlyArray.Infer<T>>> => {\n  const out: Array<any> = []\n  for (const a of self) {\n    if (Either.isRight(a)) {\n      out.push(a.right)\n    }\n  }\n\n  return out\n}\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const filter: {\n  /**\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>\n  /**\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  /**\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>\n  /**\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> => {\n    const as = fromIterable(self)\n    const out: Array<A> = []\n    for (let i = 0; i < as.length; i++) {\n      if (predicate(as[i], i)) {\n        out.push(as[i])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n * console.log(result) // [[1, 3], [2, 4]]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition: {\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n   * console.log(result) // [[1, 3], [2, 4]]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (\n    self: Iterable<A>\n  ) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n   * console.log(result) // [[1, 3], [2, 4]]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n   * console.log(result) // [[1, 3], [2, 4]]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n   * console.log(result) // [[1, 3], [2, 4]]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>] => {\n    const left: Array<A> = []\n    const right: Array<A> = []\n    const as = fromIterable(self)\n    for (let i = 0; i < as.length; i++) {\n      if (predicate(as[i], i)) {\n        right.push(as[i])\n      } else {\n        left.push(as[i])\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Separates an `Iterable` into two arrays based on a predicate.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate: <T extends Iterable<Either.Either<any, any>>>(\n  self: T\n) => [Array<Either.Either.Left<ReadonlyArray.Infer<T>>>, Array<Either.Either.Right<ReadonlyArray.Infer<T>>>] =\n  partitionMap(identity)\n\n/**\n * Reduces an array from the left.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\n * console.log(result) // 6\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  /**\n   * Reduces an array from the left.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\n   * console.log(result) // 6\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B\n  /**\n   * Reduces an array from the left.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\n   * console.log(result) // 6\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = dual(\n  3,\n  <B, A>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B =>\n    fromIterable(self).reduce((b, a, i) => f(b, a, i), b)\n)\n\n/**\n * Reduces an array from the right.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\n * console.log(result) // 6\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduceRight: {\n  /**\n   * Reduces an array from the right.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\n   * console.log(result) // 6\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B\n  /**\n   * Reduces an array from the right.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\n   * console.log(result) // 6\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B =>\n    fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b)\n)\n\n/**\n * Lifts a predicate into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n * const to = Array.liftPredicate(isEven)\n * console.log(to(1)) // []\n * console.log(to(2)) // [2]\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */\nexport const liftPredicate: { // Note: I intentionally avoid using the NoInfer pattern here.\n  <A, B extends A>(refinement: Predicate.Refinement<A, B>): (a: A) => Array<B>\n  /**\n   * Lifts a predicate into an array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   * const to = Array.liftPredicate(isEven)\n   * console.log(to(1)) // []\n   * console.log(to(2)) // [2]\n   * ```\n   *\n   * @category lifting\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate.Predicate<A>): <B extends A>(b: B) => Array<B>\n} = <A>(predicate: Predicate.Predicate<A>) => <B extends A>(b: B): Array<B> => predicate(b) ? [b] : []\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftOption = <A extends Array<unknown>, B>(\n  f: (...a: A) => Option.Option<B>\n) =>\n(...a: A): Array<B> => fromOption(f(...a))\n\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport const fromNullable = <A>(a: A): Array<NonNullable<A>> => a == null ? empty() : [a as NonNullable<A>]\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftNullable = <A extends Array<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n): (...a: A) => Array<NonNullable<B>> =>\n(...a) => fromNullable(f(...a))\n\n/**\n * Maps over an array and flattens the result, removing null and undefined values.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\n * console.log(result) // [1, 3]\n *\n * // Explanation:\n * // The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n * // and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n * // to remove null values, resulting in [1, 3].\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable: {\n  /**\n   * Maps over an array and flattens the result, removing null and undefined values.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\n   * console.log(result) // [1, 3]\n   *\n   * // Explanation:\n   * // The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n   * // and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n   * // to remove null values, resulting in [1, 3].\n   * ```\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>\n  /**\n   * Maps over an array and flattens the result, removing null and undefined values.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\n   * console.log(result) // [1, 3]\n   *\n   * // Explanation:\n   * // The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n   * // and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n   * // to remove null values, resulting in [1, 3].\n   * ```\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>> =>\n    flatMap(self, (a) => fromNullable(f(a)))\n)\n\n/**\n * Lifts a function that returns an `Either` into a function that returns an array.\n * If the `Either` is a left, it returns an empty array.\n * If the `Either` is a right, it returns an array with the right value.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const parseNumber = (s: string): Either.Either<number, Error> =>\n *   isNaN(Number(s)) ? Either.left(new Error(\"Not a number\")) : Either.right(Number(s))\n *\n * const liftedParseNumber = Array.liftEither(parseNumber)\n *\n * const result1 = liftedParseNumber(\"42\")\n * console.log(result1) // [42]\n *\n * const result2 = liftedParseNumber(\"not a number\")\n * console.log(result2) // []\n *\n * // Explanation:\n * // The function parseNumber is lifted to return an array.\n * // When parsing \"42\", it returns an Either.left with the number 42, resulting in [42].\n * // When parsing \"not a number\", it returns an Either.right with an error, resulting in an empty array [].\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */\nexport const liftEither = <A extends Array<unknown>, E, B>(\n  f: (...a: A) => Either.Either<B, E>\n) =>\n(...a: A): Array<B> => {\n  const e = f(...a)\n  return Either.isLeft(e) ? [] : [e.right]\n}\n\n/**\n * Check if a predicate holds true for every `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const every: {\n  /**\n   * Check if a predicate holds true for every `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>\n  /**\n   * Check if a predicate holds true for every `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean\n  /**\n   * Check if a predicate holds true for every `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>\n  /**\n   * Check if a predicate holds true for every `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B> =>\n    self.every(refinement)\n)\n\n/**\n * Check if a predicate holds true for some `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some: {\n  /**\n   * Check if a predicate holds true for some `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>\n  /**\n   * Check if a predicate holds true for some `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>\n} = dual(\n  2,\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A> =>\n    self.some(predicate)\n)\n\n/**\n * Extends an array with a function that maps each subarray to a value.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.extend([1, 2, 3], as => as.length)\n * console.log(result) // [3, 2, 1]\n *\n * // Explanation:\n * // The function maps each subarray starting from each element to its length.\n * // The subarrays are: [1, 2, 3], [2, 3], [3].\n * // The lengths are: 3, 2, 1.\n * // Therefore, the result is [3, 2, 1].\n * ```\n *\n * @since 2.0.0\n */\nexport const extend: {\n  /**\n   * Extends an array with a function that maps each subarray to a value.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.extend([1, 2, 3], as => as.length)\n   * console.log(result) // [3, 2, 1]\n   *\n   * // Explanation:\n   * // The function maps each subarray starting from each element to its length.\n   * // The subarrays are: [1, 2, 3], [2, 3], [3].\n   * // The lengths are: 3, 2, 1.\n   * // Therefore, the result is [3, 2, 1].\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>\n  /**\n   * Extends an array with a function that maps each subarray to a value.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.extend([1, 2, 3], as => as.length)\n   * console.log(result) // [3, 2, 1]\n   *\n   * // Explanation:\n   * // The function maps each subarray starting from each element to its length.\n   * // The subarrays are: [1, 2, 3], [2, 3], [3].\n   * // The lengths are: 3, 2, 1.\n   * // Therefore, the result is [3, 2, 1].\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B> => self.map((_, i, as) => f(as.slice(i)))\n)\n\n/**\n * Finds the minimum element in an array based on a comparator.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.min([3, 1, 2], Order.number)\n * console.log(result) // 1\n * ```\n *\n * @since 2.0.0\n */\nexport const min: {\n  /**\n   * Finds the minimum element in an array based on a comparator.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.min([3, 1, 2], Order.number)\n   * console.log(result) // 1\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A\n  /**\n   * Finds the minimum element in an array based on a comparator.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.min([3, 1, 2], Order.number)\n   * console.log(result) // 1\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A => self.reduce(Order.min(O)))\n\n/**\n * Finds the maximum element in an array based on a comparator.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.max([3, 1, 2], Order.number)\n * console.log(result) // 3\n * ```\n *\n * @since 2.0.0\n */\nexport const max: {\n  /**\n   * Finds the maximum element in an array based on a comparator.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.max([3, 1, 2], Order.number)\n   * console.log(result) // 3\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A\n  /**\n   * Finds the maximum element in an array based on a comparator.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.max([3, 1, 2], Order.number)\n   * console.log(result) // 3\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A => self.reduce(Order.max(O)))\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unfold = <B, A>(b: B, f: (b: B) => Option.Option<readonly [A, B]>): Array<A> => {\n  const out: Array<A> = []\n  let next: B = b\n  let o: Option.Option<readonly [A, B]>\n  while (Option.isSome(o = f(next))) {\n    const [a, b] = o.value\n    out.push(a)\n    next = b\n  }\n  return out\n}\n\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>> = Order.array\n\n/**\n * Creates an equivalence relation for arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const eq = Array.getEquivalence<number>((a, b) => a === b)\n * console.log(eq([1, 2, 3], [1, 2, 3])) // true\n * ```\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getEquivalence: <A>(\n  isEquivalent: Equivalence.Equivalence<A>\n) => Equivalence.Equivalence<ReadonlyArray<A>> = Equivalence.array\n\n/**\n * Performs a side-effect for each element of the `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n * ```\n *\n * @since 2.0.0\n */\nexport const forEach: {\n  /**\n   * Performs a side-effect for each element of the `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void\n  /**\n   * Performs a side-effect for each element of the `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, f: (a: A, i: number) => void): void\n} = dual(2, <A>(self: Iterable<A>, f: (a: A, i: number) => void): void => fromIterable(self).forEach((a, i) => f(a, i)))\n\n/**\n * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n * preserving the order of the first occurrence of each element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeWith: {\n  /**\n   * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n   * preserving the order of the first occurrence of each element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>>(\n    isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean\n  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n   * preserving the order of the first occurrence of each element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(\n    self: NonEmptyReadonlyArray<A>,\n    isEquivalent: (self: A, that: A) => boolean\n  ): NonEmptyArray<A>\n  /**\n   * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n   * preserving the order of the first occurrence of each element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      const out: NonEmptyArray<A> = [headNonEmpty(input)]\n      const rest = tailNonEmpty(input)\n      for (const r of rest) {\n        if (out.every((a) => !isEquivalent(r, a))) {\n          out.push(r)\n        }\n      }\n      return out\n    }\n    return []\n  }\n)\n\n/**\n * Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\n * The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.\n *\n * @since 2.0.0\n */\nexport const dedupe = <S extends Iterable<any>>(\n  self: S\n): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never =>\n  dedupeWith(self, Equal.equivalence()) as any\n\n/**\n * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacentWith: {\n  /**\n   * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Array<A>\n  /**\n   * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>\n} = dual(2, <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n  const out: Array<A> = []\n  let lastA: Option.Option<A> = Option.none()\n  for (const a of self) {\n    if (Option.isNone(lastA) || !isEquivalent(a, lastA.value)) {\n      out.push(a)\n      lastA = Option.some(a)\n    }\n  }\n  return out\n})\n\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A> = dedupeAdjacentWith(Equal.equivalence())\n\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const strings = [\"a\", \"b\", \"c\"]\n * const joined = Array.join(strings, \"-\")\n * console.log(joined) // \"a-b-c\"\n * ```\n *\n * @since 2.0.0\n * @category folding\n */\nexport const join: {\n  /**\n   * Joins the elements together with \"sep\" in the middle.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const strings = [\"a\", \"b\", \"c\"]\n   * const joined = Array.join(strings, \"-\")\n   * console.log(joined) // \"a-b-c\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  (sep: string): (self: Iterable<string>) => string\n  /**\n   * Joins the elements together with \"sep\" in the middle.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const strings = [\"a\", \"b\", \"c\"]\n   * const joined = Array.join(strings, \"-\")\n   * console.log(joined) // \"a-b-c\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  (self: Iterable<string>, sep: string): string\n} = dual(2, (self: Iterable<string>, sep: string): string => fromIterable(self).join(sep))\n\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\n * console.log(result) // [6, [1, 3, 6]]\n * ```\n *\n * @since 2.0.0\n * @category folding\n */\nexport const mapAccum: {\n  /**\n   * Statefully maps over the chunk, producing new elements of type `B`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\n   * console.log(result) // [6, [1, 3, 6]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <S, A, B, I extends Iterable<A> = Iterable<A>>(s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]\n  /**\n   * Statefully maps over the chunk, producing new elements of type `B`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\n   * console.log(result) // [6, [1, 3, 6]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <S, A, B, I extends Iterable<A> = Iterable<A>>(\n    self: I,\n    s: S,\n    f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]\n  ): [state: S, mappedArray: ReadonlyArray.With<I, B>]\n} = dual(\n  3,\n  <S, A, B>(self: Iterable<A>, s: S, f: (s: S, a: A, i: number) => [S, B]): [state: S, mappedArray: Array<B>] => {\n    let i = 0\n    let s1 = s\n    const out: Array<B> = []\n    for (const a of self) {\n      const r = f(s1, a, i)\n      s1 = r[0]\n      out.push(r[1])\n      i++\n    }\n    return [s1, out]\n  }\n)\n\n/**\n * Zips this chunk crosswise with the specified chunk using the specified combiner.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\n * console.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesianWith: {\n  /**\n   * Zips this chunk crosswise with the specified chunk using the specified combiner.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\n   * console.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>\n  /**\n   * Zips this chunk crosswise with the specified chunk using the specified combiner.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\n   * console.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>\n} = dual(\n  3,\n  <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C> =>\n    flatMap(self, (a) => map(that, (b) => f(a, b)))\n)\n\n/**\n * Zips this chunk crosswise with the specified chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.cartesian([1, 2], [\"a\", \"b\"])\n * console.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesian: {\n  /**\n   * Zips this chunk crosswise with the specified chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.cartesian([1, 2], [\"a\", \"b\"])\n   * console.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>\n  /**\n   * Zips this chunk crosswise with the specified chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.cartesian([1, 2], [\"a\", \"b\"])\n   * console.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]> => cartesianWith(self, that, (a, b) => [a, b])\n)\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const Do: ReadonlyArray<{}> = of({})\n\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link Do}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const bind: {\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link Do}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  <A extends object, N extends string, B>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): (\n    self: ReadonlyArray<A>\n  ) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link Do}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  <A extends object, N extends string, B>(\n    self: ReadonlyArray<A>,\n    tag: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => ReadonlyArray<B>\n  ): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = internalDoNotation.bind<ReadonlyArrayTypeLambda>(map, flatMap) as any\n\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link Do}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const bindTo: {\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link Do}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  <N extends string>(tag: N): <A>(self: ReadonlyArray<A>) => Array<{ [K in N]: A }>\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link Do}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  <A, N extends string>(self: ReadonlyArray<A>, tag: N): Array<{ [K in N]: A }>\n} = internalDoNotation.bindTo<ReadonlyArrayTypeLambda>(map) as any\n\nconst let_: {\n  <N extends string, B, A extends object>(\n    tag: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  <N extends string, A extends object, B>(\n    self: ReadonlyArray<A>,\n    tag: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = internalDoNotation.let_<ReadonlyArrayTypeLambda>(map) as any\n\nexport {\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   *\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link bind}\n   * @see {@link Do}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  let_ as let\n}\n","import * as Either from \"effect/Either\"\nimport { dual } from \"effect/Function\"\nimport type { TypeLambda } from \"effect/HKT\"\nimport * as Option from \"effect/Option\"\n\nexport class NanoTag<R> {\n  declare \"~nano.requirements\": R\n  constructor(\n    readonly key: string\n  ) {}\n}\n\nexport const Tag = <I = never>(identifier: string) => new NanoTag<I>(identifier)\n\nexport class SingleShotGen<T, A> implements IterableIterator<T, A> {\n  private called = false\n  readonly self: T\n\n  constructor(self: T) {\n    this.self = self\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  next(a: A): IteratorResult<T, A> {\n    return this.called ?\n      ({\n        value: a,\n        done: true\n      }) :\n      (this.called = true,\n        ({\n          value: this.self,\n          done: false\n        }))\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator](): IterableIterator<T, A> {\n    return new SingleShotGen<T, A>(this.self)\n  }\n}\n\nexport interface NanoIterator<T extends Nano<any, any, any>> {\n  next(...args: ReadonlyArray<any>): IteratorResult<T, T[\"~nano.success\"]>\n}\n\nexport interface NanoTypeLambda extends TypeLambda {\n  readonly type: Nano<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}\n\nconst evaluate = Symbol.for(\"Nano.evaluate\")\nconst contA = Symbol.for(\"Nano.contA\")\ntype contA = typeof contA\nconst contE = Symbol.for(\"Nano.contE\")\ntype contE = typeof contE\nconst contAll = Symbol.for(\"Nano.contAll\")\ntype contAll = typeof contAll\nconst NanoYield = Symbol.for(\"Nano.yield\")\ntype NanoYield = typeof NanoYield\nconst args = Symbol.for(\"Nano.args\")\ntype args = typeof args\n\nexport class NanoDefectException {\n  readonly _tag = \"@effect/language-service/NanoDefectException\"\n  constructor(\n    readonly message: unknown\n  ) {}\n}\n\ninterface NanoPrimitive {\n  [args]?: any\n  [contA]?: (value: any, fiber: NanoFiber) => NanoPrimitive | NanoYield\n  [contE]?: (value: any, fiber: NanoFiber) => NanoPrimitive | NanoYield\n  [contAll]?: (fiber: NanoFiber) => NanoPrimitive | NanoYield\n  [evaluate]: (fiber: NanoFiber) => NanoPrimitive | NanoYield\n  [Symbol.iterator](): NanoIterator<Nano<any, any, any>>\n}\n\ntype NanoExit =\n  & NanoPrimitive\n  & ({\n    _tag: \"Success\"\n    value: any\n  } | {\n    _tag: \"Failure\"\n    value: any\n  })\n\n/**\n * Nano is a Effect-like interface to run things.\n * It is not intended to be used by users in production.\n * It's only a mere tool to be used in the Effect dev-tools\n * to provide a familiar effect-like experience in envs\n * where using full blown Effect will cause an Effect-in-Effect issue.\n * It is supposed to be sync only and not stack-safe.\n * Thrown exceptions are catched and converted into defects,\n * so worst case scenario, you will get only standard typescript lsp.\n */\nexport interface Nano<out A = never, out E = never, out R = never> extends NanoPrimitive {\n  readonly \"~nano.success\": A\n  readonly \"~nano.error\": E\n  readonly \"~nano.requirements\": R\n  [Symbol.iterator](): NanoIterator<Nano<A, E, R>>\n}\n\nconst PrimitiveProto: Pick<NanoPrimitive, typeof Symbol.iterator> = {\n  [Symbol.iterator]() {\n    return new SingleShotGen(this as any)\n  }\n}\n\nconst SucceedProto: NanoPrimitive & NanoExit = {\n  ...PrimitiveProto,\n  _tag: \"Success\",\n  get value() {\n    return this[args]\n  },\n  [evaluate](fiber: NanoFiber) {\n    const cont = fiber.getCont(contA)\n    return cont ? cont[contA](this[args], fiber) : fiber.yieldWith(this)\n  }\n}\nexport const succeed: <A>(value: A) => Nano<A, never, never> = <A>(value: A) => {\n  const nano = Object.create(SucceedProto)\n  nano[args] = value\n  return nano\n}\n\nconst FailureProto: NanoPrimitive & NanoExit = {\n  ...PrimitiveProto,\n  _tag: \"Failure\",\n  get value() {\n    return this[args]\n  },\n  [evaluate](fiber: NanoFiber) {\n    const cont = fiber.getCont(contE)\n    return cont ? cont[contE](this[args], fiber) : fiber.yieldWith(this)\n  }\n}\nexport const fail: <E>(error: E) => Nano<never, E, never> = <E>(error: E) => {\n  const nano = Object.create(FailureProto)\n  nano[args] = error\n  return nano\n}\n\nconst SuspendProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate]() {\n    return this[args]()\n  }\n}\nexport const suspend: <A, E, R>(fn: () => Nano<A, E, R>) => Nano<A, E, R> = <A, E, R>(fn: () => Nano<A, E, R>) => {\n  const nano = Object.create(SuspendProto)\n  nano[args] = fn\n  return nano\n}\n\nclass NanoFiber {\n  readonly _stack: Array<NanoPrimitive> = []\n  _yielded: NanoExit | undefined = undefined\n  _services: Record<string, any> = {}\n  _cache: Record<string, WeakMap<any, any>> = {}\n  _perf: boolean = false\n\n  runLoop(nano: Nano<any, any, any>) {\n    let current: NanoPrimitive | NanoYield = nano\n    while (true) {\n      current = (current as any)[evaluate](this)\n      if (current === NanoYield) {\n        return this._yielded\n      }\n    }\n  }\n\n  getCont<S extends contA | contE>(this: NanoFiber, symbol: S):\n    | (NanoPrimitive & Record<S, (value: any, fiber: NanoFiber) => NanoPrimitive>)\n    | undefined\n  {\n    while (true) {\n      const op = this._stack.pop()\n      if (!op) return undefined\n      const cont = op[contAll] && op[contAll](this)\n      if (cont) return { [symbol]: cont } as any\n      if (op[symbol]) return op as any\n    }\n  }\n\n  yieldWith(this: NanoFiber, value: NanoExit): NanoYield {\n    this._yielded = value\n    return NanoYield\n  }\n}\n\nconst timings: Record<string, number> = {}\nconst timingsCount: Record<string, number> = {}\nconst WithSpanProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const [fa, name]: [Nano<any, any, any>, string] = this[args]\n    if (!fiber._perf) return fa\n    const start = performance.now()\n    timingsCount[name] = (timingsCount[name] || 0) + 1\n    return match(fa, {\n      onSuccess: (_) => {\n        const end = performance.now()\n        timings[name] = (timings[name] || 0) + (end - start)\n        return succeed(_)\n      },\n      onFailure: (_) => {\n        const end = performance.now()\n        timings[name] = (timings[name] || 0) + (end - start)\n        return fail(_)\n      }\n    })\n  }\n}\n\nexport const withSpan = (\n  name: string\n) =>\n<A, E, R>(fa: Nano<A, E, R>): Nano<A, E, R> => {\n  const nano = Object.create(WithSpanProto)\n  nano[args] = [fa, name]\n  return nano\n}\n\nexport const unsafeRun = <A, E>(nano: Nano<A, E, never>): Either.Either<A, E | NanoDefectException> => {\n  const fiber = new NanoFiber()\n  const result = fiber.runLoop(nano)!\n  if (result._tag === \"Success\") {\n    return Either.right(result.value)\n  }\n  return Either.left(result.value)\n}\n\nexport const run = <A, E>(nano: Nano<A, E, never>): Either.Either<A, E | NanoDefectException> => {\n  try {\n    return unsafeRun(nano)\n  } catch (e) {\n    return Either.left(new NanoDefectException(e))\n  }\n}\n\nconst OnSuccessProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber: NanoFiber) {\n    fiber._stack.push(this)\n    return this[args]\n  }\n}\n\nexport const flatMap: {\n  <A, B, E2, R2>(f: (a: A) => Nano<B, E2, R2>): <E, R>(fa: Nano<A, E, R>) => Nano<B, E | E2, R | R2>\n  <A, E, R, B, E2, R2>(fa: Nano<A, E, R>, f: (a: A) => Nano<B, E2, R2>): Nano<B, E | E2, R | R2>\n} = dual(2, <A, E, R, B, E2, R2>(\n  fa: Nano<A, E, R>,\n  f: (a: A) => Nano<B, E2, R2>\n) => {\n  const nano = Object.create(OnSuccessProto)\n  nano[args] = fa\n  nano[contA] = f\n  return nano\n})\n\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(fa: Nano<A, E, R>) => Nano<B, E, R>\n  <A, E, R, B>(fa: Nano<A, E, R>, f: (a: A) => B): Nano<B, E, R>\n} = dual(2, <A, E, R, B>(\n  fa: Nano<A, E, R>,\n  f: (a: A) => B\n) => flatMap(fa, (_) => succeed(f(_))))\n\nconst SyncProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const value = this[args]()\n    const cont = fiber.getCont(contA)\n    return cont\n      ? cont[contA](value, fiber)\n      : fiber.yieldWith(succeed(value) as any)\n  }\n}\n\nexport const sync = <A>(f: () => A): Nano<A, never, never> => {\n  const nano = Object.create(SyncProto)\n  nano[args] = f\n  return nano\n}\n\nexport const void_ = succeed(undefined)\n\nconst FromIteratorProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [contA](value, fiber) {\n    const state = this[args][0].next(value)\n    if (state.done) return succeed(state.value)\n    fiber._stack.push(this)\n    return state.value\n  },\n  [evaluate](this: any, fiber: NanoFiber) {\n    return this[contA](this[args][1], fiber)\n  }\n}\n\nconst unsafeFromIterator = (\n  iterator: Iterator<Nano<any, any, any>>,\n  initial?: undefined\n) => {\n  const nano = Object.create(FromIteratorProto)\n  nano[args] = [iterator, initial]\n  return nano\n}\n\nexport const gen = <Eff extends Nano<any, any, any>, AEff>(\n  ...args: [body: () => Generator<Eff, AEff, never>]\n): Nano<\n  AEff,\n  [Eff] extends [never] ? never\n    : [Eff] extends [Nano<infer _A, infer E, infer _R>] ? E\n    : never,\n  [Eff] extends [never] ? never\n    : [Eff] extends [Nano<infer _A, infer _E, infer R>] ? R\n    : never\n> => suspend(() => unsafeFromIterator(args[0]()))\n\nexport const fn = (_: string) =>\n<Eff extends Nano<any, any, any>, AEff, Args extends Array<any>>(\n  body: (...args: Args) => Generator<Eff, AEff, never>\n) =>\n(...args: Args): Nano<\n  AEff,\n  [Eff] extends [never] ? never\n    : [Eff] extends [Nano<infer _A, infer E, infer _R>] ? E\n    : never,\n  [Eff] extends [never] ? never\n    : [Eff] extends [Nano<infer _A, infer _E, infer R>] ? R\n    : never\n> => withSpan(_)(suspend(() => unsafeFromIterator(body(...args))))\n\nconst MatchProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    fiber._stack.push(this)\n    return this[args]\n  }\n}\n\nconst match = <A, B, E, R, C, E2, R2, E3, R3>(\n  fa: Nano<A, E, R>,\n  opts: {\n    onSuccess: (a: A) => Nano<B, E2, R2>\n    onFailure: (e: E | NanoDefectException) => Nano<C, E3, R3>\n  }\n): Nano<B, E | E2 | E3, R | R2 | R3> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contA] = opts.onSuccess\n  nano[contE] = opts.onFailure\n  return nano\n}\n\nexport const orElse = <E, B, E2, R2>(\n  f: (e: E) => Nano<B, E2, R2>\n) =>\n<A, R>(fa: Nano<A, E, R>): Nano<A | B, E2, R | R2> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contE] = (_: E | NanoDefectException) => _ instanceof NanoDefectException ? fail(_) : f(_)\n  return nano\n}\n\nexport const firstSuccessOf = <A extends Array<Nano<any, any, any>>>(\n  arr: A\n): Nano<A[number][\"~nano.success\"], A[number][\"~nano.error\"], A[number][\"~nano.requirements\"]> =>\n  arr.slice(1).reduce((arr, fa) => orElse(() => fa)(arr), arr[0])\n\nconst ProvideServiceProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const prevServices = fiber._services\n    const [fa, tag, value]: [Nano<any, any, any>, NanoTag<any>, any] = this[args]\n    fiber._services = {\n      ...fiber._services,\n      [tag.key]: value\n    }\n    return match(fa, {\n      onSuccess: (_) => {\n        fiber._services = prevServices\n        return succeed(_)\n      },\n      onFailure: (_) => {\n        fiber._services = prevServices\n        return fail(_)\n      }\n    })\n  }\n}\n\nexport const provideService = <I extends NanoTag<any>>(\n  tag: I,\n  value: I[\"~nano.requirements\"]\n) =>\n<A, E, R>(fa: Nano<A, E, R>): Nano<A, E, Exclude<R, I[\"~nano.requirements\"]>> => {\n  const nano = Object.create(ProvideServiceProto)\n  nano[args] = [fa, tag, value]\n  return nano\n}\n\nconst ServiceProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const tag: NanoTag<any> = this[args]\n    if (tag.key in fiber._services) {\n      const value = fiber._services[tag.key]\n      const cont = fiber.getCont(contA)\n      return cont ? cont[contA](value, fiber) : fiber.yieldWith(succeed(value) as any)\n    }\n    const cont = fiber.getCont(contE)\n    return cont\n      ? cont[contE](tag, fiber)\n      : fiber.yieldWith(fail(new NanoDefectException(`Service ${tag.key} not found`)) as any)\n  }\n}\n\nexport const service = <I extends NanoTag<any>>(\n  tag: I\n): Nano<I[\"~nano.requirements\"], never, I[\"~nano.requirements\"]> => {\n  const nano = Object.create(ServiceProto)\n  nano[args] = tag\n  return nano\n}\n\nconst CachedProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const [fa, type, key]: [Nano<any, any, any>, string, any] = this[args]\n    const cache = fiber._cache[type] || new WeakMap<any, any>()\n    fiber._cache[type] = cache\n    const cached = cache.get(key)\n    if (cached) return cached\n    return match(fa, {\n      onSuccess: (_) => {\n        cache.set(key, succeed(_))\n        return succeed(_)\n      },\n      onFailure: (_) => {\n        cache.set(key, fail(_))\n        return fail(_)\n      }\n    })\n  }\n}\n\nexport function cachedBy<P extends Array<any>, A, E, R>(\n  fa: (...p: P) => Nano<A, E, R>,\n  type: string,\n  lookupKey: (...p: P) => object\n) {\n  return (...p: P): Nano<A, E, R> => {\n    const nano = Object.create(CachedProto)\n    nano[args] = [fa(...p), type, lookupKey(...p)]\n    return nano\n  }\n}\n\nexport const option = <A, E, R>(fa: Nano<A, E, R>): Nano<Option.Option<A>, never, R> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contA] = (_: A) => succeed(Option.some(_))\n  nano[contE] = (_: E | NanoDefectException) => _ instanceof NanoDefectException ? fail(_) : succeed(Option.none())\n  return nano\n}\n\nexport const ignore = <A, E, R>(fa: Nano<A, E, R>): Nano<void, never, R> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contA] = (_: A) => void_\n  nano[contE] = (_: E | NanoDefectException) => _ instanceof NanoDefectException ? fail(_) : void_\n  return nano\n}\n\nexport const swap = <A, E, R>(fa: Nano<A, E, R>): Nano<E, A, R> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contA] = (_: A) => fail(_)\n  nano[contE] = (_: E | NanoDefectException) => _ instanceof NanoDefectException ? fail(_) : succeed(_)\n  return nano\n}\n\nexport const all: <A extends Array<Nano<any, any, any>>>(\n  ...args: A\n) => Nano<Array<A[number][\"~nano.success\"]>, A[number][\"~nano.error\"], A[number][\"~nano.requirements\"]> = fn(\"all\")(\n  function*<A extends Array<Nano<any, any, any>>>(\n    ...args: A\n  ) {\n    const results = [] as Array<A[number][\"~nano.success\"]>\n    for (const fa of args) {\n      const result = yield* fa\n      results.push(result)\n    }\n    return results\n  }\n)\n\nexport const getTimings = () => {\n  const result: Array<[name: string, avg: number, hits: number, total: number]> = []\n  for (const key in timings) {\n    result.push([key, timings[key] / (timingsCount[key] || 1), timingsCount[key], timings[key]])\n  }\n  result.sort((a, b) => b[3] - a[3])\n  const lines: Array<string> = []\n  for (const [name, avg, hits, total] of result) {\n    lines.push(\n      `${name.padEnd(75)} tot ${total.toFixed(2).padStart(10)}ms avg ${avg.toFixed(2).padStart(10)}ms ${\n        hits.toString().padStart(10)\n      } hits`\n    )\n  }\n  return lines\n}\n","import { isArray } from \"effect/Array\"\nimport * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport { hasProperty, isBoolean, isNumber, isObject, isRecord, isString } from \"effect/Predicate\"\nimport * as Record from \"effect/Record\"\nimport * as Nano from \"./Nano\"\n\nexport type DiagnosticSeverity = \"error\" | \"warning\" | \"message\" | \"suggestion\"\n\nexport type KeyBuilderKind = \"service\" | \"error\" | \"custom\"\n\nexport interface LanguageServicePluginOptionsKeyPattern {\n  target: KeyBuilderKind\n  pattern: \"package-identifier\" | \"default\" | \"default-hashed\"\n  skipLeadingPath: Array<string>\n}\n\nexport interface LanguageServicePluginOptions {\n  refactors: boolean\n  diagnostics: boolean\n  diagnosticSeverity: Record<string, DiagnosticSeverity | \"off\">\n  diagnosticsName: boolean\n  missingDiagnosticNextLine: DiagnosticSeverity | \"off\"\n  quickinfoEffectParameters: \"always\" | \"never\" | \"whentruncated\"\n  quickinfo: boolean\n  quickinfoMaximumLength: number\n  keyPatterns: Array<LanguageServicePluginOptionsKeyPattern>\n  extendedKeyDetection: boolean\n  completions: boolean\n  goto: boolean\n  inlays: boolean\n  allowedDuplicatedPackages: Array<string>\n  namespaceImportPackages: Array<string>\n  topLevelNamedReexports: \"ignore\" | \"follow\"\n  barrelImportPackages: Array<string>\n  importAliases: Record<string, string>\n  renames: boolean\n  noExternal: boolean\n  pipeableMinArgCount: number\n}\n\nexport const LanguageServicePluginOptions = Nano.Tag<LanguageServicePluginOptions>(\"PluginOptions\")\n\nfunction isValidSeverityLevel(value: string): value is DiagnosticSeverity | \"off\" {\n  return value === \"off\" || value === \"error\" || value === \"warning\" || value === \"message\" || value === \"suggestion\"\n}\n\nfunction parseDiagnosticSeverity(config: Record<PropertyKey, unknown>): Record<string, DiagnosticSeverity | \"off\"> {\n  if (!isRecord(config)) return {}\n  return Object.fromEntries(\n    pipe(\n      Object.entries(config),\n      Array.filter(([key, value]) => isString(key) && isString(value)),\n      Array.map(([key, value]) => [String(key).toLowerCase(), String(value).toLowerCase()]),\n      Array.filter(([_, value]) => isValidSeverityLevel(value))\n    )\n  )\n}\n\nexport const defaults: LanguageServicePluginOptions = {\n  refactors: true,\n  diagnostics: true,\n  diagnosticSeverity: {},\n  diagnosticsName: true,\n  missingDiagnosticNextLine: \"warning\",\n  quickinfo: true,\n  quickinfoEffectParameters: \"whentruncated\",\n  quickinfoMaximumLength: -1,\n  completions: true,\n  goto: true,\n  inlays: true,\n  allowedDuplicatedPackages: [],\n  namespaceImportPackages: [],\n  topLevelNamedReexports: \"ignore\",\n  barrelImportPackages: [],\n  importAliases: {},\n  renames: true,\n  noExternal: false,\n  keyPatterns: [{\n    target: \"service\",\n    pattern: \"default\",\n    skipLeadingPath: [\"src/\"]\n  }, {\n    target: \"custom\",\n    pattern: \"default\",\n    skipLeadingPath: [\"src/\"]\n  }],\n  extendedKeyDetection: false,\n  pipeableMinArgCount: 1\n}\n\nfunction parseKeyPatterns(patterns: Array<unknown>): Array<LanguageServicePluginOptionsKeyPattern> {\n  const result: Array<LanguageServicePluginOptionsKeyPattern> = []\n  for (const entry of patterns) {\n    if (!isObject(entry)) continue\n    result.push({\n      target: hasProperty(entry, \"target\") && isString(entry.target) &&\n          [\"service\", \"error\", \"custom\"].includes(entry.target.toLowerCase())\n        ? entry.target.toLowerCase() as LanguageServicePluginOptionsKeyPattern[\"target\"]\n        : \"service\",\n      pattern: hasProperty(entry, \"pattern\") && isString(entry.pattern) &&\n          [\"package-identifier\", \"default\", \"default-hashed\"].includes(entry.pattern.toLowerCase())\n        ? entry.pattern.toLowerCase() as LanguageServicePluginOptionsKeyPattern[\"pattern\"]\n        : \"default\",\n      skipLeadingPath:\n        hasProperty(entry, \"skipLeadingPath\") && isArray(entry.skipLeadingPath) && entry.skipLeadingPath.every(isString)\n          ? entry.skipLeadingPath\n          : [\"src/\"]\n    })\n  }\n  return result\n}\n\nexport function parse(config: any): LanguageServicePluginOptions {\n  return {\n    refactors: isObject(config) && hasProperty(config, \"refactors\") && isBoolean(config.refactors)\n      ? config.refactors\n      : defaults.refactors,\n    diagnostics: isObject(config) && hasProperty(config, \"diagnostics\") && isBoolean(config.diagnostics)\n      ? config.diagnostics\n      : defaults.diagnostics,\n    diagnosticSeverity:\n      isObject(config) && hasProperty(config, \"diagnosticSeverity\") && isRecord(config.diagnosticSeverity)\n        ? parseDiagnosticSeverity(config.diagnosticSeverity)\n        : defaults.diagnosticSeverity,\n    diagnosticsName: isObject(config) && hasProperty(config, \"diagnosticsName\") && isBoolean(config.diagnosticsName)\n      ? config.diagnosticsName\n      : defaults.diagnosticsName,\n    missingDiagnosticNextLine: isObject(config) && hasProperty(config, \"missingDiagnosticNextLine\") &&\n        isString(config.missingDiagnosticNextLine) && isValidSeverityLevel(config.missingDiagnosticNextLine)\n      ? config.missingDiagnosticNextLine as DiagnosticSeverity | \"off\"\n      : defaults.missingDiagnosticNextLine,\n    quickinfo: isObject(config) && hasProperty(config, \"quickinfo\") && isBoolean(config.quickinfo)\n      ? config.quickinfo\n      : defaults.quickinfo,\n    quickinfoEffectParameters: isObject(config) && hasProperty(config, \"quickinfoEffectParameters\") &&\n        isString(config.quickinfoEffectParameters) &&\n        [\"always\", \"never\", \"whentruncated\"].includes(config.quickinfoEffectParameters.toLowerCase())\n      ? config.quickinfoEffectParameters.toLowerCase() as \"always\" | \"never\" | \"whentruncated\"\n      : defaults.quickinfoEffectParameters,\n    quickinfoMaximumLength:\n      isObject(config) && hasProperty(config, \"quickinfoMaximumLength\") && isNumber(config.quickinfoMaximumLength)\n        ? config.quickinfoMaximumLength\n        : defaults.quickinfoMaximumLength,\n    completions: isObject(config) && hasProperty(config, \"completions\") && isBoolean(config.completions)\n      ? config.completions\n      : defaults.completions,\n    goto: isObject(config) && hasProperty(config, \"goto\") && isBoolean(config.goto)\n      ? config.goto\n      : defaults.goto,\n    inlays: isObject(config) && hasProperty(config, \"inlays\") && isBoolean(config.inlays)\n      ? config.inlays\n      : defaults.inlays,\n    allowedDuplicatedPackages: isObject(config) && hasProperty(config, \"allowedDuplicatedPackages\") &&\n        isArray(config.allowedDuplicatedPackages) && config.allowedDuplicatedPackages.every(isString)\n      ? config.allowedDuplicatedPackages.map((_) => _.toLowerCase())\n      : defaults.allowedDuplicatedPackages,\n    namespaceImportPackages: isObject(config) && hasProperty(config, \"namespaceImportPackages\") &&\n        isArray(config.namespaceImportPackages) && config.namespaceImportPackages.every(isString)\n      ? config.namespaceImportPackages.map((_) => _.toLowerCase())\n      : defaults.namespaceImportPackages,\n    barrelImportPackages: isObject(config) && hasProperty(config, \"barrelImportPackages\") &&\n        isArray(config.barrelImportPackages) && config.barrelImportPackages.every(isString)\n      ? config.barrelImportPackages.map((_) => _.toLowerCase())\n      : defaults.barrelImportPackages,\n    importAliases: isObject(config) && hasProperty(config, \"importAliases\") && isRecord(config.importAliases)\n      ? Record.map(config.importAliases, (value) => String(value))\n      : defaults.importAliases,\n    topLevelNamedReexports: isObject(config) && hasProperty(config, \"topLevelNamedReexports\") &&\n        isString(config.topLevelNamedReexports) &&\n        [\"ignore\", \"follow\"].includes(config.topLevelNamedReexports.toLowerCase())\n      ? config.topLevelNamedReexports.toLowerCase() as \"ignore\" | \"follow\"\n      : defaults.topLevelNamedReexports,\n    renames: isObject(config) && hasProperty(config, \"renames\") && isBoolean(config.renames)\n      ? config.renames\n      : defaults.renames,\n    noExternal: isObject(config) && hasProperty(config, \"noExternal\") && isBoolean(config.noExternal)\n      ? config.noExternal\n      : defaults.noExternal,\n    keyPatterns: isObject(config) && hasProperty(config, \"keyPatterns\") && isArray(config.keyPatterns)\n      ? parseKeyPatterns(config.keyPatterns)\n      : defaults.keyPatterns,\n    extendedKeyDetection:\n      isObject(config) && hasProperty(config, \"extendedKeyDetection\") && isBoolean(config.extendedKeyDetection)\n        ? config.extendedKeyDetection\n        : defaults.extendedKeyDetection,\n    pipeableMinArgCount:\n      isObject(config) && hasProperty(config, \"pipeableMinArgCount\") && isNumber(config.pipeableMinArgCount)\n        ? config.pipeableMinArgCount\n        : defaults.pipeableMinArgCount\n  }\n}\n","import { hasProperty, isFunction } from \"effect/Predicate\"\nimport type ts from \"typescript\"\nimport * as Nano from \"../core/Nano.js\"\n\ndeclare module \"typescript\" {\n  export function getTokenPosOfNode(node: ts.Node, sourceFile: ts.SourceFileLike, includeJsDoc?: boolean): number\n\n  export function insertImports(\n    changes: textChanges.ChangeTracker,\n    sourceFile: ts.SourceFile,\n    imports: ts.ImportDeclaration,\n    blankLineBetween: boolean,\n    preferences: ts.UserPreferences\n  ): void\n\n  const nullTransformationContext: ts.TransformationContext\n\n  export namespace formatting {\n    interface FormattingHost {\n      getNewLine?(): string\n    }\n\n    export interface FormatContext {\n      readonly options: ts.FormatCodeSettings\n      readonly getRules: unknown\n    }\n\n    function getFormatContext(options: ts.FormatCodeSettings, host: FormattingHost): FormatContext\n  }\n\n  export type TextChangesContext = any\n\n  export namespace textChanges {\n    export interface ChangeNodeOptions extends ConfigurableStartEnd, InsertNodeOptions {}\n    export enum LeadingTriviaOption {\n      /** Exclude all leading trivia (use getStart()) */\n      Exclude = 0,\n      /** Include leading trivia and,\n       * if there are no line breaks between the node and the previous token,\n       * include all trivia between the node and the previous token\n       */\n      IncludeAll = 1,\n      /**\n       * Include attached JSDoc comments\n       */\n      JSDoc = 2,\n      /**\n       * Only delete trivia on the same line as getStart().\n       * Used to avoid deleting leading comments\n       */\n      StartLine = 3\n    }\n    export enum TrailingTriviaOption {\n      /** Exclude all trailing trivia (use getEnd()) */\n      Exclude = 0,\n      /** Doesn't include whitespace, but does strip comments */\n      ExcludeWhitespace = 1,\n      /** Include trailing trivia */\n      Include = 2\n    }\n    export interface ConfigurableStart {\n      leadingTriviaOption?: LeadingTriviaOption\n    }\n    export interface ConfigurableEnd {\n      trailingTriviaOption?: TrailingTriviaOption\n    }\n    export interface InsertNodeOptions {\n      /**\n       * Text to be inserted before the new node\n       */\n      prefix?: string\n      /**\n       * Text to be inserted after the new node\n       */\n      suffix?: string\n      /**\n       * Text of inserted node will be formatted with this indentation, otherwise indentation will be inferred from the old node\n       */\n      indentation?: number\n      /**\n       * Text of inserted node will be formatted with this delta, otherwise delta will be inferred from the new node kind\n       */\n      delta?: number\n    }\n    export interface ConfigurableStartEnd extends ConfigurableStart, ConfigurableEnd {\n    }\n    export class ChangeTracker {\n      static with(\n        context: ts.TextChangesContext,\n        cb: (tracker: ChangeTracker) => void\n      ): Array<ts.FileTextChanges>\n      delete(\n        sourceFile: ts.SourceFile,\n        node: ts.Node | ts.NodeArray<ts.TypeParameterDeclaration>\n      ): void\n      deleteRange(sourceFile: ts.SourceFile, range: ts.TextRange): void\n      replaceNode(\n        sourceFile: ts.SourceFile,\n        oldNode: ts.Node,\n        newNode: ts.Node,\n        options?: ts.textChanges.ChangeNodeOptions\n      ): void\n      insertNodeAt(\n        sourceFile: ts.SourceFile,\n        pos: number,\n        newNode: ts.Node,\n        options?: ts.textChanges.InsertNodeOptions\n      ): void\n      insertNodeBefore(\n        sourceFile: ts.SourceFile,\n        before: ts.Node,\n        newNode: ts.Node,\n        blankLineBetween?: boolean,\n        options?: ConfigurableStartEnd\n      ): void\n      insertNodeAfter(sourceFile: ts.SourceFile, after: ts.Node, newNode: ts.Node): void\n      insertText(sourceFile: ts.SourceFile, pos: number, text: string): void\n      insertCommentBeforeLine(\n        sourceFile: ts.SourceFile,\n        lineNumber: number,\n        position: number,\n        commentText: string\n      ): void\n    }\n    export function applyChanges(text: string, changes: ReadonlyArray<ts.TextChange>): string\n  }\n\n  export function findPrecedingToken(\n    position: number,\n    sourceFile: ts.SourceFileLike,\n    startNode: ts.Node,\n    excludeJsdoc?: boolean\n  ): ts.Node | undefined\n  export function findPrecedingToken(\n    position: number,\n    sourceFile: ts.SourceFile,\n    startNode?: ts.Node,\n    excludeJsdoc?: boolean\n  ): ts.Node | undefined\n  function findChildOfKind<T extends ts.Node>(\n    n: ts.Node,\n    kind: T[\"kind\"],\n    sourceFile: ts.SourceFileLike\n  ): T | undefined\n\n  export interface TypeChecker {\n    getUnionType(types: ReadonlyArray<ts.Type>): ts.Type\n  }\n\n  interface Identifier {\n    /** @deprecated Use the `ts.idText(node)` method instead */\n    readonly text: string\n  }\n}\n\ntype _TypeScriptApi = typeof ts\nexport interface TypeScriptApi extends _TypeScriptApi {}\nexport const TypeScriptApi = Nano.Tag<TypeScriptApi>(\"TypeScriptApi\")\n\ntype _TypeScriptProgram = ts.Program\nexport interface TypeScriptProgram extends _TypeScriptProgram {}\nexport const TypeScriptProgram = Nano.Tag<TypeScriptProgram>(\"TypeScriptProgram\")\n\nexport const ChangeTracker = Nano.Tag<ts.textChanges.ChangeTracker>(\"ChangeTracker\")\n\n// the followin APIs are not part of the public API of TypeScript, we keep them here for internal use and tracking which ones we use\nexport interface PackageJsonInfoCache {\n  __internal: any\n}\nexport function getPackageJsonInfoCache(program: ts.Program): PackageJsonInfoCache | undefined {\n  try {\n    if (hasProperty(program, \"getModuleResolutionCache\") && isFunction(program.getModuleResolutionCache)) {\n      const moduleResolutionCache = program.getModuleResolutionCache()\n      if (\n        hasProperty(moduleResolutionCache, \"getPackageJsonInfoCache\") &&\n        isFunction(moduleResolutionCache.getPackageJsonInfoCache)\n      ) {\n        return moduleResolutionCache.getPackageJsonInfoCache()\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_) {\n    return undefined\n  }\n  return undefined\n}\n\nexport function getDirectoryPath(ts: TypeScriptApi, path: string): string {\n  try {\n    if (hasProperty(ts, \"getDirectoryPath\") && isFunction(ts.getDirectoryPath)) {\n      return ts.getDirectoryPath(path)\n    }\n    return path\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_) {\n    return path\n  }\n}\n\nexport function makeGetModuleSpecifier(ts: TypeScriptApi) {\n  if (\n    !(hasProperty(ts, \"moduleSpecifiers\") && hasProperty(ts.moduleSpecifiers, \"getModuleSpecifier\") &&\n      isFunction(ts.moduleSpecifiers.getModuleSpecifier))\n  ) return\n  const _internal = ts.moduleSpecifiers.getModuleSpecifier\n  return (\n    compilerOptions: ts.CompilerOptions,\n    importingSourceFile: ts.SourceFile,\n    importingSourceFileName: string,\n    toFileName: string,\n    host: any,\n    options?: any\n  ): string => {\n    return _internal(\n      compilerOptions,\n      importingSourceFile,\n      importingSourceFileName,\n      toFileName,\n      host,\n      options\n    )\n  }\n}\n\nexport interface ModuleResolutionState {\n  __internal: any\n}\n\nexport function makeGetTemporaryModuleResolutionState(\n  ts: TypeScriptApi\n) {\n  if (hasProperty(ts, \"getTemporaryModuleResolutionState\") && isFunction(ts.getTemporaryModuleResolutionState)) {\n    const _internal = ts.getTemporaryModuleResolutionState\n    return (\n      cache: PackageJsonInfoCache | undefined,\n      program: ts.Program,\n      compilerOptions: ts.CompilerOptions\n    ): ModuleResolutionState => _internal(cache, program, compilerOptions) as any\n  }\n  return undefined\n}\n\nexport function makeGetPackageScopeForPath(\n  ts: TypeScriptApi\n) {\n  if (hasProperty(ts, \"getPackageScopeForPath\") && isFunction(ts.getPackageScopeForPath)) {\n    const _internal = ts.getPackageScopeForPath\n    return (path: string, state: ModuleResolutionState) => _internal(path, state) as any\n  }\n}\n\nexport function makeResolvePackageNameToPackageJson(\n  ts: TypeScriptApi\n) {\n  if (hasProperty(ts, \"resolvePackageNameToPackageJson\") && isFunction(ts.resolvePackageNameToPackageJson)) {\n    const _internal = ts.resolvePackageNameToPackageJson\n    return (packageName: string, fromFileName: string, compilerOptions: ts.CompilerOptions, host: any) =>\n      _internal(packageName, fromFileName, compilerOptions, host) as any\n  }\n}\n\nexport function makeGetEntrypointsFromPackageJsonInfo(\n  ts: TypeScriptApi\n) {\n  if (hasProperty(ts, \"getEntrypointsFromPackageJsonInfo\") && isFunction(ts.getEntrypointsFromPackageJsonInfo)) {\n    const _internal = ts.getEntrypointsFromPackageJsonInfo\n    return (packageJsonInfo: any, compilerOptions: ts.CompilerOptions, host: any) =>\n      _internal(packageJsonInfo, compilerOptions, host) as any\n  }\n}\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport { hasProperty, isObject, isString } from \"effect/Predicate\"\nimport type ts from \"typescript\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport interface ModuleWithPackageInfo {\n  name: string\n  version: string\n  hasEffectInPeerDependencies: boolean\n  contents: any\n  packageDirectory: string\n  referencedPackages: Array<string>\n  exportsKeys: Array<string>\n}\n\nexport interface TypeScriptUtils {\n  parsePackageContentNameAndVersionFromScope: (v: unknown) => ModuleWithPackageInfo | undefined\n  findNodeWithLeadingCommentAtPosition: (\n    sourceFile: ts.SourceFile,\n    position: number\n  ) => { node: ts.Node; commentRange: ts.CommentRange } | undefined\n  getCommentAtPosition: (sourceFile: ts.SourceFile, pos: number) => ts.CommentRange | undefined\n  resolveModulePattern: (program: ts.Program, sourceFile: ts.SourceFile, pattern: string) => Array<string>\n  getAncestorNodesInRange: (sourceFile: ts.SourceFile, textRange: ts.TextRange) => Array<ts.Node>\n  findImportedModuleIdentifierByPackageAndNameOrBarrel: (\n    sourceFile: ts.SourceFile,\n    packageName: string,\n    moduleName: string\n  ) => string | undefined\n  simplifyTypeNode: (typeNode: ts.TypeNode) => ts.TypeNode\n  createEffectGenCallExpressionWithBlock: (\n    effectModuleIdentifierName: string,\n    statement: ts.Statement | Array<ts.Statement>\n  ) => ts.CallExpression\n  createReturnYieldStarStatement: (\n    expr: ts.Expression\n  ) => ts.ReturnStatement\n  transformAsyncAwaitToEffectFn: (\n    node: ts.FunctionDeclaration | ts.ArrowFunction | ts.FunctionExpression,\n    effectModuleName: string,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ) => ts.Node\n  createDataTaggedErrorDeclaration: (\n    dataModuleIdentifier: string,\n    name: string,\n    fields: Array<ts.TypeElement>\n  ) => ts.ClassDeclaration\n  transformAsyncAwaitToEffectGen: (\n    node: ts.FunctionDeclaration | ts.ArrowFunction | ts.FunctionExpression,\n    effectModuleName: string,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ) => ts.Node\n  tryPreserveDeclarationSemantics: (\n    nodeToReplace: ts.Node,\n    node: ts.Node,\n    dropAsync: boolean\n  ) => ts.Node\n  isNodeInRange: (textRange: ts.TextRange) => (node: ts.Node) => boolean\n  toTextRange: (position: number) => ts.TextRange\n  parseDataForExtendsClassCompletion: (sourceFile: ts.SourceFile, position: number) => {\n    accessedObject: ts.Identifier\n    classDeclaration: ts.ClassDeclaration\n    className: ts.Identifier\n    replacementSpan: ts.TextSpan\n  } | undefined\n  parseAccessedExpressionForCompletion: (sourceFile: ts.SourceFile, position: number) => {\n    accessedObject: ts.Node\n    outerNode: ts.Node\n    replacementSpan: ts.TextSpan\n  } | undefined\n  findNodeAtPositionIncludingTrivia: (\n    sourceFile: ts.SourceFile,\n    position: number\n  ) => ts.Node | undefined\n  getSourceFileOfNode: (current: ts.Node | undefined) => ts.SourceFile | undefined\n  resolveModuleWithPackageInfoFromSourceFile: (\n    program: ts.Program,\n    sourceFile: ts.SourceFile\n  ) => ModuleWithPackageInfo | undefined\n}\nexport const TypeScriptUtils = Nano.Tag<TypeScriptUtils>(\"TypeScriptUtils\")\n\nexport const nanoLayer = <A, E, R>(\n  fa: Nano.Nano<A, E, R>\n) =>\n  pipe(\n    Nano.service(TypeScriptApi.TypeScriptApi),\n    Nano.flatMap((ts) => pipe(fa, Nano.provideService(TypeScriptUtils, makeTypeScriptUtils(ts))))\n  )\n\nexport function makeTypeScriptUtils(ts: TypeScriptApi.TypeScriptApi): TypeScriptUtils {\n  const getTemporaryModuleResolutionState = TypeScriptApi.makeGetTemporaryModuleResolutionState(ts)\n  const getPackageScopeForPath = TypeScriptApi.makeGetPackageScopeForPath(ts)\n\n  /**\n   * Parse internal package info from a scope\n   */\n  function parsePackageContentNameAndVersionFromScope(v: unknown): ModuleWithPackageInfo | undefined {\n    if (!isObject(v)) return\n    if (!hasProperty(v, \"packageJsonScope\")) return\n    if (!v.packageJsonScope) return\n    const packageJsonScope = v.packageJsonScope\n    if (!hasProperty(packageJsonScope, \"contents\")) return\n    if (!hasProperty(packageJsonScope.contents, \"packageJsonContent\")) return\n    const packageJsonContent = packageJsonScope.contents.packageJsonContent\n    if (!hasProperty(packageJsonContent, \"name\")) return\n    if (!hasProperty(packageJsonScope, \"packageDirectory\")) return\n    if (!isString(packageJsonScope.packageDirectory)) return\n    const { name } = packageJsonContent\n    const version = hasProperty(packageJsonScope, \"version\") ? packageJsonScope.version : \"\"\n    if (!isString(name)) return\n    if (!isString(version)) return\n    const hasEffectInPeerDependencies = hasProperty(packageJsonContent, \"peerDependencies\") &&\n      isObject(packageJsonContent.peerDependencies) &&\n      hasProperty(packageJsonContent.peerDependencies, \"effect\")\n\n    const referencedPackages = Object.keys({\n      ...(hasProperty(packageJsonContent, \"dependencies\") && isObject(packageJsonContent.dependencies)\n        ? packageJsonContent.dependencies\n        : {}),\n      ...(hasProperty(packageJsonContent, \"peerDependencies\") && isObject(packageJsonContent.peerDependencies)\n        ? packageJsonContent.peerDependencies\n        : {}),\n      ...(hasProperty(packageJsonContent, \"devDependencies\") && isObject(packageJsonContent.devDependencies)\n        ? packageJsonContent.devDependencies\n        : {})\n    })\n\n    const exportsKeys = Object.keys(\n      hasProperty(packageJsonContent, \"exports\") && isObject(packageJsonContent.exports)\n        ? packageJsonContent.exports\n        : {}\n    )\n\n    return {\n      name: name.toLowerCase(),\n      version: version.toLowerCase(),\n      hasEffectInPeerDependencies,\n      contents: packageJsonContent,\n      packageDirectory: packageJsonScope.packageDirectory,\n      referencedPackages,\n      exportsKeys\n    }\n  }\n\n  function resolveModuleWithPackageInfoFromSourceFile(\n    program: ts.Program,\n    sourceFile: ts.SourceFile\n  ): ModuleWithPackageInfo | undefined {\n    let packageJsonScope = parsePackageContentNameAndVersionFromScope(sourceFile)\n    if (\n      !packageJsonScope && getPackageScopeForPath && getTemporaryModuleResolutionState\n    ) {\n      const packageJsonInfoCache = TypeScriptApi.getPackageJsonInfoCache(program)\n      const temporaryModuleResolutionState = getTemporaryModuleResolutionState(\n        packageJsonInfoCache,\n        program,\n        program.getCompilerOptions()\n      )\n      const directoryPath = TypeScriptApi.getDirectoryPath(ts, sourceFile.fileName)\n      packageJsonScope = parsePackageContentNameAndVersionFromScope({\n        ...sourceFile,\n        packageJsonScope: getPackageScopeForPath(directoryPath, temporaryModuleResolutionState)\n      })\n    }\n    return packageJsonScope\n  }\n\n  function resolveModulePattern(program: ts.Program, sourceFile: ts.SourceFile, pattern: string) {\n    if (pattern.indexOf(\"*\") === -1) return [pattern.toLowerCase()]\n    const packageJsonScope = resolveModuleWithPackageInfoFromSourceFile(program, sourceFile)\n    const referencedPackages: Array<string> = []\n    for (const statement of sourceFile.statements) {\n      if (ts.isImportDeclaration(statement) && ts.isStringLiteral(statement.moduleSpecifier)) {\n        const moduleSpecifier = statement.moduleSpecifier.text.toLowerCase()\n        const packageName = moduleSpecifier.startsWith(\"@\")\n          ? moduleSpecifier.split(\"/\", 2).join(\"/\")\n          : moduleSpecifier.split(\"/\", 1).join(\"/\")\n        referencedPackages.push(packageName)\n      }\n    }\n    return pipe(\n      referencedPackages.concat(packageJsonScope?.referencedPackages || []),\n      Array.dedupe,\n      Array.map((packageName) => packageName.toLowerCase()),\n      Array.filter((packageName) =>\n        pattern.endsWith(\"*\") &&\n        packageName.startsWith(pattern.toLowerCase().substring(0, pattern.length - 1))\n      )\n    )\n  }\n\n  function findNodeWithLeadingCommentAtPosition(sourceFile: ts.SourceFile, position: number) {\n    const sourceText = sourceFile.text\n    let result: { node: ts.Node; commentRange: ts.CommentRange } | undefined\n\n    function find(node: ts.Node) {\n      // Check leading comments\n      const leading = ts.getLeadingCommentRanges(sourceText, node.pos)\n      if (leading) {\n        for (const commentRange of leading) {\n          if (commentRange.pos <= position && position < commentRange.end) {\n            // we found the comment\n            result = { node, commentRange }\n            return\n          }\n        }\n      }\n      // Continue traversing only if the position is within this node\n      if (node.pos <= position && position < node.end) {\n        ts.forEachChild(node, find)\n      }\n    }\n    find(sourceFile)\n    return result\n  }\n\n  /**\n   * Collects the given node and all its ancestor nodes that fully contain the specified TextRange.\n   *\n   * This function starts from the provided node and traverses up the AST, collecting\n   * the node itself and its ancestors that encompass the given range.\n   */\n  function collectSelfAndAncestorNodesInRange(\n    node: ts.Node,\n    textRange: ts.TextRange\n  ): Array<ts.Node> {\n    let result = Array.empty<ts.Node>()\n    let parent = node\n    while (parent) {\n      if (parent.end >= textRange.end) {\n        result = pipe(result, Array.append(parent))\n      }\n      parent = parent.parent\n    }\n    return result\n  }\n\n  /**\n   * Finds the deepest AST node at the specified position within the given SourceFile.\n   *\n   * This function traverses the AST to locate the node that contains the given position.\n   * If multiple nodes overlap the position, it returns the most specific (deepest) node.\n   */\n  function findNodeAtPosition(\n    sourceFile: ts.SourceFile,\n    position: number\n  ) {\n    function find(node: ts.Node): ts.Node | undefined {\n      if (position >= ts.getTokenPosOfNode(node, sourceFile) && position < node.end) {\n        // If the position is within this node, keep traversing its children\n        return ts.forEachChild(node, find) || node\n      }\n      return undefined\n    }\n\n    return find(sourceFile)\n  }\n\n  function findNodeAtPositionIncludingTrivia(\n    sourceFile: ts.SourceFile,\n    position: number\n  ) {\n    function find(node: ts.Node): ts.Node | undefined {\n      if (position >= node.pos && position < node.end) {\n        // If the position is within this node, keep traversing its children\n        return ts.forEachChild(node, find) || node\n      }\n      return undefined\n    }\n\n    return find(sourceFile)\n  }\n\n  /**\n   * Collects the node at the given position and all its ancestor nodes\n   * that fully contain the specified TextRange.\n   *\n   * This function starts from the closest token at the given position\n   * and traverses up the AST, collecting nodes that encompass the range.\n   *\n   * @param sourceFile - The TypeScript SourceFile to search within.\n   * @param textRange - The range of text to use for filtering nodes.\n   * @returns An array of `ts.Node` containing the range.\n   */\n  function getAncestorNodesInRange(\n    sourceFile: ts.SourceFile,\n    textRange: ts.TextRange\n  ) {\n    const nodeAtPosition = findNodeAtPosition(sourceFile, textRange.pos)\n    if (!nodeAtPosition) return Array.empty<ts.Node>()\n    return collectSelfAndAncestorNodesInRange(nodeAtPosition, textRange)\n  }\n\n  function getCommentAtPosition(\n    sourceFile: ts.SourceFile,\n    pos: number\n  ) {\n    const token = findNodeAtPositionIncludingTrivia(sourceFile, pos)\n\n    if (\n      token === undefined || token.kind === ts.SyntaxKind.JsxText ||\n      pos >= token.end - (ts.tokenToString(token.kind) || \"\").length\n    ) {\n      return\n    }\n    const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || \"\").length : token.pos\n\n    const result = ts.forEachTrailingCommentRange(sourceFile.text, startPos, isCommentInRange, pos) ||\n      ts.forEachLeadingCommentRange(sourceFile.text, startPos, isCommentInRange, pos)\n\n    return result\n  }\n\n  function isCommentInRange(\n    pos: number,\n    end: number,\n    kind: ts.CommentKind,\n    _nl: boolean,\n    at: number\n  ): ts.CommentRange | undefined {\n    return at >= pos && at < end ? { pos, end, kind } : undefined\n  }\n\n  /**\n   * Ensures value is a text range\n   */\n  function toTextRange(positionOrRange: number | ts.TextRange): ts.TextRange {\n    return typeof positionOrRange === \"number\"\n      ? { end: positionOrRange, pos: positionOrRange }\n      : positionOrRange\n  }\n\n  function isNodeInRange(textRange: ts.TextRange) {\n    return (node: ts.Node) => node.pos <= textRange.pos && node.end >= textRange.end\n  }\n\n  function transformAsyncAwaitToEffectGeneratorBody(\n    body: ts.ConciseBody,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ): ts.ConciseBody {\n    function visitor(_: ts.Node): ts.Node {\n      if (ts.isAwaitExpression(_)) {\n        const expression = ts.visitEachChild(_.expression, visitor, ts.nullTransformationContext)\n\n        return ts.factory.createYieldExpression(\n          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n          onAwait(expression)\n        )\n      }\n      return ts.visitEachChild(_, visitor, ts.nullTransformationContext)\n    }\n    return visitor(body) as any\n  }\n\n  function transformAsyncAwaitToEffectFn(\n    node: ts.FunctionDeclaration | ts.ArrowFunction | ts.FunctionExpression,\n    effectModuleName: string,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ) {\n    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body!, onAwait)\n    const fnName = node.name && ts.isIdentifier(node.name)\n      ? node.name\n      : ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name) && node.parent.initializer === node\n      ? node.parent.name\n      : undefined\n\n    let fnCall: ts.Expression = ts.factory.createPropertyAccessExpression(\n      ts.factory.createIdentifier(effectModuleName),\n      \"fn\"\n    )\n    if (fnName) {\n      fnCall = ts.factory.createCallExpression(\n        fnCall,\n        undefined,\n        [ts.factory.createStringLiteral(ts.idText(fnName))]\n      )\n    }\n    return tryPreserveDeclarationSemantics(\n      node,\n      ts.factory.createCallExpression(\n        fnCall,\n        undefined,\n        [\n          ts.factory.createFunctionExpression(\n            undefined,\n            ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n            undefined,\n            node.typeParameters,\n            node.parameters,\n            undefined,\n            ts.isBlock(generatorBody)\n              ? generatorBody\n              : ts.factory.createBlock([ts.factory.createReturnStatement(generatorBody)])\n          )\n        ]\n      ),\n      true\n    )\n  }\n\n  function transformAsyncAwaitToEffectGen(\n    node: ts.FunctionDeclaration | ts.ArrowFunction | ts.FunctionExpression,\n    effectModuleName: string,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ) {\n    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body!, onAwait)\n\n    const effectGenCallExp = createEffectGenCallExpression(effectModuleName, generatorBody)\n\n    let currentFlags = ts.getCombinedModifierFlags(node)\n    currentFlags &= ~ts.ModifierFlags.Async\n    const newModifiers = ts.factory.createModifiersFromModifierFlags(currentFlags)\n\n    if (ts.isArrowFunction(node)) {\n      return ts.factory.createArrowFunction(\n        newModifiers,\n        node.typeParameters,\n        node.parameters,\n        undefined,\n        node.equalsGreaterThanToken,\n        effectGenCallExp\n      )\n    }\n\n    const newBody = ts.factory.createBlock([\n      ts.factory.createReturnStatement(effectGenCallExp)\n    ])\n\n    if (ts.isFunctionDeclaration(node)) {\n      return ts.factory.createFunctionDeclaration(\n        newModifiers,\n        node.asteriskToken,\n        node.name,\n        node.typeParameters,\n        node.parameters,\n        undefined,\n        newBody\n      )\n    }\n    return ts.factory.createFunctionExpression(\n      newModifiers,\n      node.asteriskToken,\n      node.name,\n      node.typeParameters,\n      node.parameters,\n      undefined,\n      newBody\n    )\n  }\n\n  function findImportedModuleIdentifier(\n    sourceFile: ts.SourceFile,\n    test: (\n      node: ts.Node,\n      fromModule: ts.Expression,\n      importProperty: Option.Option<ts.ModuleExportName>\n    ) => boolean\n  ) {\n    for (const statement of sourceFile.statements) {\n      if (!ts.isImportDeclaration(statement)) continue\n      const importClause = statement.importClause\n      if (!importClause) continue\n      const namedBindings = importClause.namedBindings\n      if (!namedBindings) continue\n      if (ts.isNamespaceImport(namedBindings)) {\n        if (test(namedBindings.name, statement.moduleSpecifier, Option.none())) {\n          return ts.idText(namedBindings.name)\n        }\n      } else if (ts.isNamedImports(namedBindings)) {\n        for (const importSpecifier of namedBindings.elements) {\n          const importProperty = Option.fromNullable(importSpecifier.propertyName).pipe(\n            Option.orElse(() => Option.some(importSpecifier.name))\n          )\n          if (test(importSpecifier.name, statement.moduleSpecifier, importProperty)) {\n            return ts.idText(importSpecifier.name)\n          }\n        }\n      }\n    }\n  }\n\n  function findImportedModuleIdentifierByPackageAndNameOrBarrel(\n    sourceFile: ts.SourceFile,\n    packageName: string,\n    moduleName: string\n  ) {\n    return findImportedModuleIdentifier(\n      sourceFile,\n      (_, fromModule, importProperty) => {\n        // import * as Module from \"package/module\"\n        if (\n          Option.isNone(importProperty) && ts.isStringLiteral(fromModule) &&\n          fromModule.text === packageName + \"/\" + moduleName\n        ) {\n          return true\n        }\n        // import { Module } from \"package\"\n        // or\n        // import { Module as M } from \"package\"\n        if (\n          Option.isSome(importProperty) && ts.isIdentifier(importProperty.value) &&\n          ts.idText(importProperty.value) === moduleName && ts.isStringLiteral(fromModule) &&\n          fromModule.text === packageName\n        ) {\n          return true\n        }\n        return false\n      }\n    )\n  }\n\n  function simplifyTypeNode(typeNode: ts.TypeNode) {\n    function collectCallable(\n      typeNode: ts.TypeNode\n    ): Option.Option<Array<ts.CallSignatureDeclaration>> {\n      // (() => 1) -> skip to inner node\n      if (ts.isParenthesizedTypeNode(typeNode)) return collectCallable(typeNode.type)\n      // () => 1 -> convert to call signature\n      if (ts.isFunctionTypeNode(typeNode)) {\n        return Option.some([\n          ts.factory.createCallSignature(typeNode.typeParameters, typeNode.parameters, typeNode.type)\n        ])\n      }\n      // { ... } -> if every member is callsignature, return a merge of all of those\n      if (ts.isTypeLiteralNode(typeNode)) {\n        const allCallSignatures = typeNode.members.every(ts.isCallSignatureDeclaration)\n        if (allCallSignatures) {\n          return Option.some(typeNode.members as any as Array<ts.CallSignatureDeclaration>)\n        }\n      }\n      // ... & ... -> if both are callable, return merge of both\n      if (ts.isIntersectionTypeNode(typeNode)) {\n        const members = typeNode.types.map((node) => collectCallable(node))\n        if (members.every(Option.isSome)) {\n          return Option.some(members.map((_) => Option.isSome(_) ? _.value : []).flat())\n        }\n      }\n\n      return Option.none()\n    }\n\n    const callSignatures = collectCallable(typeNode)\n    if (Option.isSome(callSignatures) && callSignatures.value.length > 1) {\n      return ts.factory.createTypeLiteralNode(callSignatures.value)\n    }\n    return typeNode\n  }\n\n  function tryPreserveDeclarationSemantics(nodeToReplace: ts.Node, node: ts.Node, dropAsync: boolean) {\n    // new node should be an expression!\n    if (!ts.isExpression(node)) return node\n    // ok, we need to replace. is that a method or a function?\n    if (ts.isFunctionDeclaration(nodeToReplace)) {\n      // I need a name!!!\n      if (!nodeToReplace.name) return node\n      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace)\n      currentFlags &= ~ts.ModifierFlags.Async\n      const newModifiers = dropAsync\n        ? ts.factory.createModifiersFromModifierFlags(currentFlags)\n        : nodeToReplace.modifiers\n      return ts.factory.createVariableStatement(\n        newModifiers,\n        ts.factory.createVariableDeclarationList(\n          [ts.factory.createVariableDeclaration(\n            nodeToReplace.name,\n            undefined,\n            undefined,\n            node\n          )],\n          ts.NodeFlags.Const\n        )\n      )\n    } else if (ts.isMethodDeclaration(nodeToReplace)) {\n      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace)\n      currentFlags &= ~ts.ModifierFlags.Async\n      const newModifiers = dropAsync\n        ? ts.factory.createModifiersFromModifierFlags(currentFlags)\n        : nodeToReplace.modifiers\n      return ts.factory.createPropertyDeclaration(\n        newModifiers,\n        nodeToReplace.name,\n        undefined,\n        undefined,\n        node\n      )\n    }\n    // I don't know what else to do!\n    return node\n  }\n\n  function parseAccessedExpressionForCompletion(\n    sourceFile: ts.SourceFile,\n    position: number\n  ) {\n    // first, we find the preceding token\n    const precedingToken = ts.findPrecedingToken(position, sourceFile, undefined, true)\n    if (!precedingToken) return\n\n    let accessedObject = precedingToken\n    let replacementSpan = ts.createTextSpan(position, 0)\n    let outerNode: ts.Node = precedingToken\n    if (\n      ts.isIdentifier(precedingToken) && precedingToken.parent &&\n      ts.isPropertyAccessExpression(precedingToken.parent)\n    ) {\n      // we are in a \"extends Schema.Tag|\"\n      const spanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile)\n      replacementSpan = ts.createTextSpan(\n        spanStart,\n        precedingToken.end - spanStart\n      )\n      accessedObject = precedingToken.parent.expression\n      outerNode = precedingToken.parent\n    } else if (\n      ts.isToken(precedingToken) && precedingToken.kind === ts.SyntaxKind.DotToken &&\n      ts.isPropertyAccessExpression(precedingToken.parent)\n    ) {\n      // we are in a \"extends Schema.|\"\n      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile)\n      replacementSpan = ts.createTextSpan(\n        precedingTokenSpanStart,\n        precedingToken.end - precedingTokenSpanStart\n      )\n      accessedObject = precedingToken.parent.expression\n      outerNode = precedingToken.parent\n    } else if (ts.isIdentifier(precedingToken) && precedingToken.parent) {\n      // we are in a \"extends Schema|\"\n      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken, sourceFile)\n      replacementSpan = ts.createTextSpan(\n        precedingTokenSpanStart,\n        precedingToken.end - precedingTokenSpanStart\n      )\n      accessedObject = precedingToken\n      outerNode = precedingToken\n    } else {\n      return\n    }\n    return { accessedObject, outerNode, replacementSpan }\n  }\n\n  function parseDataForExtendsClassCompletion(\n    sourceFile: ts.SourceFile,\n    position: number\n  ) {\n    const maybeInfos = parseAccessedExpressionForCompletion(sourceFile, position)\n    if (!maybeInfos) return\n    const { accessedObject, outerNode, replacementSpan } = maybeInfos\n\n    if (!ts.isIdentifier(accessedObject)) return\n\n    // go up allowed nodes until we find the class declaration\n    let classDeclaration: ts.Node = outerNode.parent\n    while (\n      ts.isExpressionWithTypeArguments(classDeclaration) || ts.isHeritageClause(classDeclaration)\n    ) {\n      if (!classDeclaration.parent) break\n      classDeclaration = classDeclaration.parent\n    }\n    if (!ts.isClassDeclaration(classDeclaration)) return\n\n    if (!classDeclaration.name) return\n\n    return {\n      accessedObject,\n      classDeclaration,\n      className: classDeclaration.name,\n      replacementSpan\n    } as const\n  }\n\n  function createEffectGenCallExpression(\n    effectModuleIdentifierName: string,\n    node: ts.Node\n  ) {\n    const generator = ts.factory.createFunctionExpression(\n      undefined,\n      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n      undefined,\n      [],\n      [],\n      undefined,\n      node as any // NOTE(mattia): intended, to use same routine for both ConciseBody and Body\n    )\n\n    return ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(effectModuleIdentifierName),\n        \"gen\"\n      ),\n      undefined,\n      [generator]\n    )\n  }\n\n  function createEffectGenCallExpressionWithBlock(\n    effectModuleIdentifierName: string,\n    statement: ts.Statement | Array<ts.Statement>\n  ) {\n    return createEffectGenCallExpression(\n      effectModuleIdentifierName,\n      ts.factory.createBlock(Array.isArray(statement) ? statement : [statement], false)\n    )\n  }\n\n  function createReturnYieldStarStatement(\n    expr: ts.Expression\n  ) {\n    return ts.factory.createReturnStatement(\n      ts.factory.createYieldExpression(\n        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n        expr\n      )\n    )\n  }\n\n  function createDataTaggedErrorDeclaration(\n    dataModuleIdentifier: string,\n    name: string,\n    fields: Array<ts.TypeElement>\n  ) {\n    // Data.TaggedError(\"name\")\n    const invokeTaggedError = ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(dataModuleIdentifier),\n        \"TaggedError\"\n      ),\n      undefined,\n      [\n        ts.factory.createStringLiteral(name)\n      ]\n    )\n    // Data.TaggedError(\"name\")<{...fields}>\n    const withTypeFields = ts.factory.createExpressionWithTypeArguments(\n      invokeTaggedError,\n      [\n        ts.factory.createTypeLiteralNode(fields)\n      ]\n    )\n    return ts.factory.createClassDeclaration(\n      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n      name,\n      undefined,\n      [\n        ts.factory.createHeritageClause(\n          ts.SyntaxKind.ExtendsKeyword,\n          [\n            withTypeFields\n          ]\n        )\n      ],\n      []\n    )\n  }\n\n  function getSourceFileOfNode(current: ts.Node | undefined): ts.SourceFile | undefined {\n    let node = current\n    while (node && node.kind !== ts.SyntaxKind.SourceFile) {\n      node = node.parent\n    }\n    return node as ts.SourceFile\n  }\n\n  return {\n    findNodeAtPositionIncludingTrivia,\n    parsePackageContentNameAndVersionFromScope,\n    resolveModulePattern,\n    resolveModuleWithPackageInfoFromSourceFile,\n    findNodeWithLeadingCommentAtPosition,\n    getCommentAtPosition,\n    getAncestorNodesInRange,\n    toTextRange,\n    isNodeInRange,\n    transformAsyncAwaitToEffectFn,\n    transformAsyncAwaitToEffectGen,\n    createDataTaggedErrorDeclaration,\n    findImportedModuleIdentifierByPackageAndNameOrBarrel,\n    simplifyTypeNode,\n    tryPreserveDeclarationSemantics,\n    parseDataForExtendsClassCompletion,\n    createEffectGenCallExpressionWithBlock,\n    createReturnYieldStarStatement,\n    parseAccessedExpressionForCompletion,\n    getSourceFileOfNode\n  }\n}\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport type * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport type * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport type * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\nimport * as LanguageServicePluginOptions from \"./LanguageServicePluginOptions.js\"\nimport * as Nano from \"./Nano.js\"\n\nexport class RefactorNotApplicableError {\n  readonly _tag = \"@effect/language-service/RefactorNotApplicableError\"\n}\n\nexport interface RefactorDefinition {\n  name: string\n  description: string\n  apply: (\n    sourceFile: ts.SourceFile,\n    textRange: ts.TextRange\n  ) => Nano.Nano<\n    ApplicableRefactorDefinition,\n    RefactorNotApplicableError,\n    | TypeScriptApi.TypeScriptApi\n    | TypeScriptUtils.TypeScriptUtils\n    | TypeCheckerApi.TypeCheckerApi\n    | TypeCheckerUtils.TypeCheckerUtils\n    | TypeParser.TypeParser\n    | LanguageServicePluginOptions.LanguageServicePluginOptions\n  >\n}\n\nexport interface ApplicableRefactorDefinition {\n  kind: string\n  description: string\n  apply: Nano.Nano<void, never, ts.textChanges.ChangeTracker>\n}\n\nexport function createRefactor(definition: RefactorDefinition): RefactorDefinition {\n  return definition\n}\n\nexport interface DiagnosticDefinition {\n  name: string\n  code: number\n  severity: LanguageServicePluginOptions.DiagnosticSeverity | \"off\"\n  apply: (\n    sourceFile: ts.SourceFile,\n    report: (data: {\n      location: ts.TextRange | ts.Node\n      messageText: string\n      fixes: Array<ApplicableDiagnosticDefinitionFix>\n    }) => void\n  ) => Nano.Nano<\n    void,\n    never,\n    | TypeCheckerApi.TypeCheckerApi\n    | TypeParser.TypeParser\n    | LanguageServicePluginOptions.LanguageServicePluginOptions\n    | TypeScriptApi.TypeScriptApi\n    | TypeScriptUtils.TypeScriptUtils\n    | TypeCheckerUtils.TypeCheckerUtils\n    | TypeScriptApi.TypeScriptProgram\n  >\n}\n\nexport interface ApplicableDiagnosticDefinition {\n  range: ts.TextRange\n  messageText: string\n  fixes: Array<ApplicableDiagnosticDefinitionFix>\n}\n\nexport interface ApplicableDiagnosticDefinitionFix {\n  fixName: string\n  description: string\n  apply: Nano.Nano<void, never, ts.textChanges.ChangeTracker>\n}\n\nexport interface ApplicableDiagnosticDefinitionFixWithPositionAndCode extends ApplicableDiagnosticDefinitionFix {\n  code: number\n  start: number\n  end: number\n}\n\nexport function createDiagnostic(definition: DiagnosticDefinition): DiagnosticDefinition {\n  return definition\n}\n\nexport function concatDiagnostics(fa: Array<ts.Diagnostic>, fb: Array<ts.Diagnostic>): Array<ts.Diagnostic> {\n  const result = fa.slice(0)\n  for (const b of fb) {\n    const existing = result.find((a) =>\n      a.file === b.file && a.code === b.code && a.source === b.source && a.start === b.start && a.length === b.length &&\n      a.messageText === b.messageText\n    )\n    if (!existing) {\n      result.push(b)\n    }\n  }\n  return result\n}\n\nexport interface CompletionDefinition {\n  name: string\n  apply: (\n    sourceFile: ts.SourceFile,\n    position: number,\n    options: ts.GetCompletionsAtPositionOptions | undefined,\n    formatCodeSettings: ts.FormatCodeSettings | undefined\n  ) => Nano.Nano<\n    Array<CompletionEntryDefinition>,\n    never,\n    | TypeCheckerApi.TypeCheckerApi\n    | TypeParser.TypeParser\n    | LanguageServicePluginOptions.LanguageServicePluginOptions\n    | TypeScriptApi.TypeScriptApi\n    | TypeScriptUtils.TypeScriptUtils\n    | TypeCheckerUtils.TypeCheckerUtils\n    | TypeScriptApi.TypeScriptProgram\n  >\n}\n\nexport interface CompletionEntryDefinition {\n  name: string\n  kind: ts.ScriptElementKind\n  insertText: string\n  isSnippet: true\n  replacementSpan?: ts.TextSpan\n}\n\nexport function createCompletion(definition: CompletionDefinition): CompletionDefinition {\n  return definition\n}\n\nexport class SourceFileNotFoundError {\n  readonly _tag = \"@effect/language-service/SourceFileNotFoundError\"\n  constructor(\n    readonly fileName: string\n  ) {}\n}\n\nexport const getSemanticDiagnosticsWithCodeFixes = Nano.fn(\n  \"LSP.getSemanticDiagnosticsWithCodeFixes\"\n)(function*(\n  rules: Array<DiagnosticDefinition>,\n  sourceFile: ts.SourceFile\n) {\n  let effectDiagnostics: Array<ts.Diagnostic> = []\n  let effectCodeFixes: Array<ApplicableDiagnosticDefinitionFixWithPositionAndCode> = []\n  const executor = yield* createDiagnosticExecutor(sourceFile)\n  for (const rule of rules) {\n    const { codeFixes, diagnostics } = yield* (executor.execute(rule))\n    effectDiagnostics = effectDiagnostics.concat(diagnostics)\n    effectCodeFixes = effectCodeFixes.concat(codeFixes)\n  }\n\n  return ({\n    diagnostics: effectDiagnostics,\n    codeFixes: effectCodeFixes\n  })\n})\n\nfunction refactorNameToFullyQualifiedName(name: string) {\n  return `@effect/language-service/refactors/${name}`\n}\n\nexport const getApplicableRefactors = Nano.fn(\"LSP.getApplicableRefactors\")(function*(\n  refactors: Array<RefactorDefinition>,\n  sourceFile: ts.SourceFile,\n  positionOrRange: number | ts.TextRange\n) {\n  const textRange = typeof positionOrRange === \"number\"\n    ? { pos: positionOrRange, end: positionOrRange }\n    : positionOrRange\n  const effectRefactors: Array<ts.ApplicableRefactorInfo> = []\n  for (const refactor of refactors) {\n    yield* pipe(\n      refactor.apply(sourceFile, textRange),\n      Nano.map((result) =>\n        effectRefactors.push({\n          name: refactorNameToFullyQualifiedName(refactor.name),\n          description: refactor.description,\n          actions: [{\n            name: refactorNameToFullyQualifiedName(refactor.name),\n            description: result.description,\n            kind: result.kind\n          }]\n        })\n      ),\n      Nano.ignore\n    )\n  }\n  return effectRefactors\n})\n\nexport const getEditsForRefactor = Nano.fn(\"LSP.getEditsForRefactor\")(function*(\n  refactors: Array<RefactorDefinition>,\n  sourceFile: ts.SourceFile,\n  positionOrRange: number | ts.TextRange,\n  refactorName: string\n) {\n  const refactor = refactors.find((refactor) => refactorNameToFullyQualifiedName(refactor.name) === refactorName)\n  if (!refactor) {\n    return yield* Nano.fail(new RefactorNotApplicableError())\n  }\n  const textRange = typeof positionOrRange === \"number\"\n    ? { pos: positionOrRange, end: positionOrRange }\n    : positionOrRange\n\n  return yield* refactor.apply(sourceFile, textRange)\n})\n\nexport const getCompletionsAtPosition = Nano.fn(\"LSP.getCompletionsAtPosition\")(function*(\n  completions: Array<CompletionDefinition>,\n  sourceFile: ts.SourceFile,\n  position: number,\n  options: ts.GetCompletionsAtPositionOptions | undefined,\n  formatCodeSettings: ts.FormatCodeSettings | undefined\n) {\n  let effectCompletions: Array<ts.CompletionEntry> = []\n  for (const completion of completions) {\n    const result = yield* completion.apply(sourceFile, position, options, formatCodeSettings)\n    effectCompletions = effectCompletions.concat(\n      result.map((_) => ({ sortText: \"11\", ..._ }) satisfies ts.CompletionEntry)\n    )\n  }\n  return effectCompletions\n})\n\ninterface CommentNextLineOverride {\n  pos: number\n  end: number\n  level: string\n  commentRange: ts.CommentRange\n}\n\nconst createDiagnosticExecutor = Nano.fn(\"LSP.createCommentDirectivesProcessor\")(\n  function*(sourceFile: ts.SourceFile) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const pluginOptions = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    function findParentStatementForDisableNextLine(node: ts.Node) {\n      let result: ts.Node | undefined\n\n      function find(node: ts.Node) {\n        if (ts.isStatement(node)) {\n          result = node\n          return\n        }\n        if (result) return\n        if (node.parent) find(node.parent)\n      }\n      find(node)\n      return result || node\n    }\n\n    const lineOverrides: Record<\n      string,\n      Array<CommentNextLineOverride>\n    > = {}\n    const sectionOverrides: Record<\n      string,\n      Array<{ pos: number; level: string }>\n    > = {}\n    const skippedRules: Array<string> = []\n\n    const regex =\n      /@effect-diagnostics(-next-line)?((?:\\s[a-zA-Z0-9/]+:(?:off|warning|error|message|suggestion|skip-file))+)?/gm\n    let match: RegExpExecArray | null\n    while ((match = regex.exec(sourceFile.text)) !== null) {\n      const nextLineCaptureGroup = match[1]\n      const rulesCaptureGroup = match[2]\n\n      if (rulesCaptureGroup) {\n        const trimmedRuleString = rulesCaptureGroup.trim()\n        if (trimmedRuleString) {\n          const individualRules = trimmedRuleString.split(/\\s+/)\n          for (const rulePair of individualRules) {\n            const [rawRuleName, ruleLevel] = rulePair.toLowerCase().split(\":\")\n            // NOTE: for backwards compatibility, treat \"effect/ruleName\" same as \"ruleName\"\n            const ruleName = rawRuleName.startsWith(\"effect/\")\n              ? rawRuleName.substring(\"effect/\".length)\n              : rawRuleName\n            if (ruleName && ruleLevel) {\n              if (ruleLevel === \"skip-file\") skippedRules.push(ruleName)\n              const isOverrideNextLine = nextLineCaptureGroup &&\n                nextLineCaptureGroup.trim().toLowerCase() === \"-next-line\"\n              if (isOverrideNextLine) {\n                const foundNode = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, match.index)\n                if (foundNode) {\n                  lineOverrides[ruleName] = lineOverrides[ruleName] || []\n                  lineOverrides[ruleName].unshift({\n                    pos: foundNode.node.pos,\n                    end: foundNode.node.end,\n                    level: ruleLevel,\n                    commentRange: foundNode.commentRange\n                  })\n                }\n              } else {\n                sectionOverrides[ruleName] = sectionOverrides[ruleName] || []\n                sectionOverrides[ruleName].unshift({\n                  pos: match.index,\n                  level: ruleLevel\n                })\n              }\n            }\n          }\n        }\n      }\n    }\n\n    const levelToDiagnosticCategory: Record<string, ts.DiagnosticCategory> = {\n      error: ts.DiagnosticCategory.Error,\n      warning: ts.DiagnosticCategory.Warning,\n      message: ts.DiagnosticCategory.Message,\n      suggestion: ts.DiagnosticCategory.Suggestion\n    }\n\n    const execute = (\n      rule: DiagnosticDefinition\n    ) =>\n      Nano.gen(function*() {\n        const diagnostics: Array<ts.Diagnostic> = []\n        const codeFixes: Array<ApplicableDiagnosticDefinitionFixWithPositionAndCode> = []\n        const ruleNameLowered = rule.name.toLowerCase()\n        const defaultLevel = pluginOptions.diagnosticSeverity[ruleNameLowered] || rule.severity\n        // if file is skipped entirely, do not process the rule\n        if (skippedRules.indexOf(ruleNameLowered) > -1) return { diagnostics, codeFixes }\n        // if the default level is off, and there are no overrides, do not process the rule\n        if (\n          defaultLevel === \"off\" &&\n          ((lineOverrides[ruleNameLowered] || sectionOverrides[ruleNameLowered] || []).length === 0)\n        ) {\n          return { diagnostics, codeFixes }\n        }\n        // append a rule fix to disable this check only for next line\n        const fixByDisableNextLine = (\n          node: ts.Node\n        ): ApplicableDiagnosticDefinitionFix => ({\n          fixName: rule.name + \"_skipNextLine\",\n          description: \"Disable \" + rule.name + \" for this line\",\n          apply: Nano.flatMap(\n            Nano.service(TypeScriptApi.ChangeTracker),\n            (changeTracker) =>\n              Nano.gen(function*() {\n                const disableAtNode = findParentStatementForDisableNextLine(node)\n                const start = ts.getTokenPosOfNode(disableAtNode, sourceFile)\n                const { line } = ts.getLineAndCharacterOfPosition(sourceFile, start)\n\n                changeTracker.insertCommentBeforeLine(\n                  sourceFile,\n                  line,\n                  start,\n                  ` @effect-diagnostics-next-line ${rule.name}:off`\n                )\n              })\n          )\n        })\n\n        // append a rule fix to disable this check for the entire file\n        const fixByDisableEntireFile: ApplicableDiagnosticDefinitionFix = {\n          fixName: rule.name + \"_skipFile\",\n          description: \"Disable \" + rule.name + \" for this entire file\",\n          apply: Nano.flatMap(\n            Nano.service(TypeScriptApi.ChangeTracker),\n            (changeTracker) =>\n              Nano.sync(() =>\n                changeTracker.insertText(\n                  sourceFile,\n                  0,\n                  `/** @effect-diagnostics ${rule.name}:skip-file */\\n`\n                )\n              )\n          )\n        }\n        // run the executor\n        const applicableDiagnostics: Array<ApplicableDiagnosticDefinition> = []\n        yield* rule.apply(sourceFile, (entry) => {\n          const range = \"kind\" in entry.location\n            ? { pos: ts.getTokenPosOfNode(entry.location, sourceFile), end: entry.location.end }\n            : entry.location\n          const node = \"kind\" in entry.location\n            ? entry.location\n            : tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, entry.location.pos)\n          applicableDiagnostics.push({\n            range,\n            messageText: pluginOptions.diagnosticsName\n              ? `${entry.messageText}    effect(${rule.name})`\n              : entry.messageText,\n            fixes: entry.fixes.concat(node ? [fixByDisableNextLine(node)] : []).concat([fixByDisableEntireFile])\n          })\n        })\n\n        // create a list of all the comment ranges\n        const unusedLineOverrides = new Set<CommentNextLineOverride>(lineOverrides[ruleNameLowered] || [])\n\n        // loop through rules\n        for (const emitted of applicableDiagnostics.slice(0)) {\n          // by default, use the overriden level from the plugin options\n          let newLevel: string | undefined = defaultLevel\n          // attempt with line overrides\n          const lineOverride = (lineOverrides[ruleNameLowered] || []).find((_) =>\n            _.pos < emitted.range.pos && _.end >= emitted.range.end\n          )\n          if (lineOverride) {\n            newLevel = lineOverride.level\n            unusedLineOverrides.delete(lineOverride)\n          } else {\n            // then attempt with section overrides\n            const sectionOverride = (sectionOverrides[ruleNameLowered] || []).find((_) => _.pos < emitted.range.pos)\n            if (sectionOverride) newLevel = sectionOverride.level\n          }\n          // if level is off or not a valid level, skip and no output\n          if (!(newLevel in levelToDiagnosticCategory)) continue\n          // append both diagnostic and code fix\n          diagnostics.push({\n            file: sourceFile,\n            start: emitted.range.pos,\n            length: emitted.range.end - emitted.range.pos,\n            messageText: emitted.messageText,\n            category: levelToDiagnosticCategory[newLevel],\n            code: rule.code,\n            source: \"effect\"\n          })\n          // append code fixes\n          for (const fix of emitted.fixes) {\n            codeFixes.push({\n              ...fix,\n              code: rule.code,\n              start: emitted.range.pos,\n              end: emitted.range.end\n            })\n          }\n        }\n\n        if (pluginOptions.missingDiagnosticNextLine !== \"off\" && unusedLineOverrides.size > 0) {\n          for (const unusedLineOverride of unusedLineOverrides) {\n            diagnostics.push({\n              file: sourceFile,\n              start: unusedLineOverride.commentRange.pos,\n              length: unusedLineOverride.commentRange.end - unusedLineOverride.commentRange.pos,\n              messageText:\n                `@effect-diagnostics-next-line ${rule.name}:${unusedLineOverride.level} has no effect, make sure you are suppressing the right rule.`,\n              category: levelToDiagnosticCategory[pluginOptions.missingDiagnosticNextLine],\n              code: -1,\n              source: \"effect\"\n            })\n          }\n        }\n        return { diagnostics, codeFixes }\n      })\n\n    return { execute }\n  }\n)\n\nexport const cyrb53 = (str: string, seed = 0) => {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i)\n    h1 = Math.imul(h1 ^ ch, 2654435761)\n    h2 = Math.imul(h2 ^ ch, 1597334677)\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507)\n  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507)\n  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n\n  // return 4294967296 * (2097151 & h2) + (h1 >>> 0)\n  return (h2 >>> 0).toString(16).padStart(8, \"0\") + (h1 >>> 0).toString(16).padStart(8, \"0\")\n}\n\nexport class CodegenNotApplicableError {\n  readonly _tag = \"@effect/language-service/CodegenNotApplicableError\"\n  constructor(\n    readonly cause: string\n  ) {}\n}\n\nexport interface CodegenDefinition {\n  name: string\n  apply: (\n    sourceFile: ts.SourceFile,\n    commentRange: ts.TextRange\n  ) => Nano.Nano<\n    ApplicableCodegenDefinition,\n    CodegenNotApplicableError,\n    | TypeScriptApi.TypeScriptApi\n    | TypeScriptUtils.TypeScriptUtils\n    | TypeCheckerApi.TypeCheckerApi\n    | TypeCheckerUtils.TypeCheckerUtils\n    | TypeParser.TypeParser\n    | LanguageServicePluginOptions.LanguageServicePluginOptions\n  >\n}\n\nexport interface ApplicableCodegenDefinition {\n  hash: string\n  description: string\n  apply: Nano.Nano<void, never, ts.textChanges.ChangeTracker>\n}\n\nexport function createCodegen(definition: CodegenDefinition): CodegenDefinition {\n  return definition\n}\n\nexport const getCodegensForSourceFile = Nano.fn(\"LSP.getApplicableCodegens\")(function*(\n  codegens: Array<CodegenDefinition>,\n  sourceFile: ts.SourceFile\n) {\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const result: Array<{ codegen: CodegenDefinition; hash: string; range: ts.TextRange }> = []\n\n  const regex = /@effect-codegens((?:\\s[a-zA-Z0-9]+(?::(?:[a-zA-Z0-9]+))?)+)+/gmid\n  let match: RegExpExecArray | null\n  while ((match = regex.exec(sourceFile.text)) !== null) {\n    const pos = match.indices?.[0]?.[0]\n    if (!pos) continue\n    const commentRange = tsUtils.getCommentAtPosition(sourceFile, pos)\n    if (!commentRange) continue\n    const commentText = sourceFile.text.slice(pos, commentRange.end)\n    const codegenRegex = /(\\s+)(\\w+)(?::(\\w+))?/gmi\n    let codegenMatch: RegExpExecArray | null\n    while ((codegenMatch = codegenRegex.exec(commentText)) !== null) {\n      const whitespace = codegenMatch[1] || \"\"\n      const codegenName = codegenMatch[2] || \"\"\n      const codegenHash = codegenMatch[3] || \"\"\n      const range: ts.TextRange = {\n        pos: codegenMatch.index + pos + whitespace.length,\n        end: codegenMatch.index + pos + codegenMatch[0].length\n      }\n      const codegen = codegens.find((codegen) => codegen.name === codegenName)\n      if (!codegen) continue\n      result.push({ codegen, hash: codegenHash, range })\n    }\n  }\n  return result\n})\n\nexport const getEditsForCodegen = Nano.fn(\"LSP.getEditsForCodegen\")(function*(\n  codegens: Array<CodegenDefinition>,\n  sourceFile: ts.SourceFile,\n  textRange: ts.TextRange\n) {\n  const applicableCodegens = yield* getCodegensForSourceFile(codegens, sourceFile)\n  const inRangeCodegens = applicableCodegens.filter((codegen) =>\n    codegen.range.pos <= textRange.pos && codegen.range.end >= textRange.end\n  )\n  if (inRangeCodegens.length !== 1) {\n    return yield* Nano.fail(new CodegenNotApplicableError(\"zero or multiple codegens in range\"))\n  }\n  const { codegen, range } = inRangeCodegens[0]\n  const edit = yield* codegen.apply(sourceFile, range)\n  const updateHashComment = pipe(\n    Nano.service(TypeScriptApi.ChangeTracker),\n    Nano.map((changeTracker) => {\n      changeTracker.deleteRange(sourceFile, range)\n      changeTracker.insertText(sourceFile, range.pos, `${codegen.name}:${edit.hash}`)\n    })\n  )\n  return {\n    ...edit,\n    apply: pipe(\n      edit.apply,\n      Nano.flatMap(() => updateHashComment)\n    ),\n    ignore: updateHashComment\n  } satisfies ApplicableCodegenDefinition & { ignore: Nano.Nano<void, never, ts.textChanges.ChangeTracker> }\n})\n\nexport interface EffectLspPatchSourceFileMetadata {\n  relationErrors: Array<[node: ts.Node, expectedType: ts.Type, valueNode: ts.Node, realType: ts.Type]>\n}\n\nexport const getEffectLspPatchSourceFileMetadata = (\n  sourceFile: ts.SourceFile\n): EffectLspPatchSourceFileMetadata | undefined => {\n  return (sourceFile as any)[\"@effect-lsp-patch/metadata\"]\n}\n\nexport const getOrDefaultEffectLspPatchSourceFileMetadata = (\n  sourceFile: ts.SourceFile\n): EffectLspPatchSourceFileMetadata => {\n  return getEffectLspPatchSourceFileMetadata(sourceFile) ||\n    ((sourceFile as any)[\"@effect-lsp-patch/metadata\"] = {\n      relationErrors: []\n    })\n}\n","import type ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"./LanguageServicePluginOptions.js\"\nimport * as LSP from \"./LSP.js\"\nimport * as Nano from \"./Nano.js\"\nimport * as TypeScriptApi from \"./TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"./TypeScriptUtils.js\"\n\nexport interface KeyBuilder {\n  createString(identifier: string, kind: LanguageServicePluginOptions.KeyBuilderKind): string | undefined\n}\n\nexport const makeKeyBuilder = Nano.fn(\"KeyBuilder\")(\n  function*(sourceFile: ts.SourceFile) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n    const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    // Get package info for this source file, skip validation if not available\n    const packageInfo = tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile)\n\n    function createString(\n      classNameText: string,\n      kind: LanguageServicePluginOptions.KeyBuilderKind\n    ): string | undefined {\n      if (!packageInfo) return\n\n      for (const keyPattern of options.keyPatterns) {\n        // ensure this pattern applies for this kind\n        if (keyPattern.target !== kind) continue\n\n        // constructs the only filename of the source file\n        const lastIndex = sourceFile.fileName.lastIndexOf(\"/\")\n        let onlyFileName = lastIndex === -1 ? \"\" : sourceFile.fileName.slice(lastIndex + 1)\n        const lastExtensionIndex = onlyFileName.lastIndexOf(\".\")\n        if (lastExtensionIndex !== -1) onlyFileName = onlyFileName.slice(0, lastExtensionIndex)\n        if (onlyFileName.toLowerCase().endsWith(\"/index\")) onlyFileName = onlyFileName.slice(0, -6)\n        if (onlyFileName.startsWith(\"/\")) onlyFileName = onlyFileName.slice(1)\n\n        // constructs the subdirectory of the source file\n        let subDirectory = TypeScriptApi.getDirectoryPath(ts, sourceFile.fileName)\n        if (!subDirectory.startsWith(packageInfo.packageDirectory)) continue\n        subDirectory = subDirectory.slice(packageInfo.packageDirectory.length)\n        if (!subDirectory.endsWith(\"/\")) subDirectory = subDirectory + \"/\"\n        if (subDirectory.startsWith(\"/\")) subDirectory = subDirectory.slice(1)\n        for (const prefix of keyPattern.skipLeadingPath) {\n          if (subDirectory.startsWith(prefix)) {\n            subDirectory = subDirectory.slice(prefix.length)\n            break\n          }\n        }\n\n        // construct the parts of the expected identifier\n        let parts = [packageInfo.name, subDirectory, onlyFileName].concat(\n          onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]\n        )\n        if (keyPattern.pattern === \"package-identifier\") {\n          parts = [packageInfo.name, onlyFileName].concat(\n            onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]\n          )\n        }\n\n        // remove leading/trailing slashes\n        parts = parts.map((part) => part.startsWith(\"/\") ? part.slice(1) : part).map((part) =>\n          part.endsWith(\"/\") ? part.slice(0, -1) : part\n        )\n\n        // return them joined\n        const fullKey = parts.filter((_) => String(_).trim().length > 0).join(\"/\")\n\n        // if requested so, hash it\n        return keyPattern.pattern === \"default-hashed\" ? LSP.cyrb53(fullKey) : fullKey\n      }\n    }\n\n    return {\n      createString\n    }\n  }\n)\n\nconst keyBuilderCache = new Map<string, KeyBuilder>()\n\nexport const getOrMakeKeyBuilder = Nano.fn(\"getOrMakeKeyBuilder\")(function*(\n  sourceFile: ts.SourceFile\n) {\n  // NOTE: evict the oldest entry when the cache is full to avoid unbounded memory growth\n  while (keyBuilderCache.size > 5) {\n    const oldest = keyBuilderCache.keys().next().value\n    if (oldest) keyBuilderCache.delete(oldest)\n  }\n  const keyBuilder = keyBuilderCache.get(sourceFile.fileName) ||\n    (yield* makeKeyBuilder(sourceFile))\n  keyBuilderCache.set(sourceFile.fileName, keyBuilder)\n  return keyBuilder\n})\n\nexport function createString(\n  sourceFile: ts.SourceFile,\n  identifier: string,\n  kind: LanguageServicePluginOptions.KeyBuilderKind\n) {\n  return Nano.map(\n    getOrMakeKeyBuilder(sourceFile),\n    (identifierBuilder) => identifierBuilder.createString(identifier, kind)\n  )\n}\n","import * as KeyBuilder from \"../core/KeyBuilder.js\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const contextSelfInClasses = LSP.createCompletion({\n  name: \"contextSelfInClasses\",\n  apply: Nano.fn(\"contextSelfInClasses\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position)\n    if (!maybeInfos) return []\n    const { accessedObject, className, replacementSpan } = maybeInfos\n\n    // first, given the position, we go back\n    const contextIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Context\"\n    ) || \"Context\"\n\n    // ensure accessed is an identifier\n    if (contextIdentifier !== ts.idText(accessedObject)) return []\n    const name = ts.idText(className)\n\n    // create the expected identifier\n    const tagKey = (yield* KeyBuilder.createString(sourceFile, name, \"service\")) || name\n\n    return [{\n      name: `Tag(\"${name}\")`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${contextIdentifier}.Tag(\"${tagKey}\")<${name}, ${\"${0}\"}>(){}`,\n      replacementSpan,\n      isSnippet: true\n    }] satisfies Array<LSP.CompletionEntryDefinition>\n  })\n})\n","import { isFunction } from \"effect/Function\"\nimport { hasProperty } from \"effect/Predicate\"\nimport type ts from \"typescript\"\nimport * as Nano from \"../core/Nano.js\"\n\ndeclare module \"typescript\" {\n  export interface TypeChecker {\n    getIndexType(constraint: ts.Type): ts.Type\n    getParameterType(signature: ts.Signature, parameterIndex: number): ts.Type\n  }\n}\n\nexport interface TypeCheckerApi extends ts.TypeChecker {}\nexport const TypeCheckerApi = Nano.Tag<TypeCheckerApi>(\"TypeChecker\")\n\nexport function makeResolveExternalModuleName(typeChecker: TypeCheckerApi) {\n  if (!(hasProperty(typeChecker, \"resolveExternalModuleName\") && isFunction(typeChecker.resolveExternalModuleName))) {\n    return\n  }\n  const _internal = typeChecker.resolveExternalModuleName\n  return (moduleSpecifier: ts.Expression): ts.Symbol | undefined => {\n    return _internal(moduleSpecifier)\n  }\n}\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Order from \"effect/Order\"\nimport type * as ts from \"typescript\"\nimport * as Nano from \"./Nano.js\"\nimport * as TypeCheckerApi from \"./TypeCheckerApi\"\nimport * as TypeScriptApi from \"./TypeScriptApi\"\nimport * as TypeScriptUtils from \"./TypeScriptUtils\"\n\nexport interface TypeCheckerUtils {\n  isUnion: (type: ts.Type) => type is ts.UnionType\n  getTypeParameterAtPosition: (signature: ts.Signature, pos: number) => ts.Type\n  getMissingTypeEntriesInTargetType: (realType: ts.Type, expectedType: ts.Type) => Array<ts.Type>\n  unrollUnionMembers: (type: ts.Type) => Array<ts.Type>\n  appendToUniqueTypesMap: <E, R>(\n    memory: Map<string, ts.Type>,\n    initialType: ts.Type,\n    shouldExclude: (type: ts.Type) => Nano.Nano<boolean, E, R>\n  ) => Nano.Nano<{ newIndexes: Set<string>; knownIndexes: Set<string>; allIndexes: Array<string> }, E, R>\n  deterministicTypeOrder: Order.Order<ts.Type>\n  getInferredReturnType: (declaration: ConvertibleDeclaration) => ts.Type | undefined\n  expectedAndRealType: (sourceFile: ts.SourceFile) => Array<ExpectedAndRealType>\n  typeToSimplifiedTypeNode: (\n    type: ts.Type,\n    enclosingNode: ts.Node | undefined,\n    flags: ts.NodeBuilderFlags | undefined\n  ) => ts.TypeNode | undefined\n}\n\nexport const TypeCheckerUtils = Nano.Tag<TypeCheckerUtils>(\"TypeCheckerUtils\")\n\nexport const nanoLayer = <A, E, R>(\n  fa: Nano.Nano<A, E, R>\n) =>\n  pipe(\n    Nano.service(TypeScriptApi.TypeScriptApi),\n    Nano.flatMap((ts) =>\n      Nano.flatMap(Nano.service(TypeCheckerApi.TypeCheckerApi), (typeChecker) =>\n        Nano.flatMap(Nano.service(TypeScriptUtils.TypeScriptUtils), (typeScriptUtils) =>\n          pipe(fa, Nano.provideService(TypeCheckerUtils, makeTypeCheckerUtils(ts, typeChecker, typeScriptUtils)))))\n    )\n  )\n\nexport type ExpectedAndRealType = [\n  node: ts.Node,\n  expectedType: ts.Type,\n  valueNode: ts.Node,\n  realType: ts.Type\n]\n\ntype ConvertibleDeclaration =\n  | ts.FunctionDeclaration\n  | ts.FunctionExpression\n  | ts.ArrowFunction\n  | ts.MethodDeclaration\n\nexport function makeTypeCheckerUtils(\n  ts: TypeScriptApi.TypeScriptApi,\n  typeChecker: TypeCheckerApi.TypeCheckerApi,\n  tsUtils: TypeScriptUtils.TypeScriptUtils\n): TypeCheckerUtils {\n  function isUnion(type: ts.Type): type is ts.UnionType {\n    return !!(type.flags & ts.TypeFlags.Union)\n  }\n\n  function isIndexType(type: ts.Type): type is ts.IndexType {\n    return !!(type.flags & ts.TypeFlags.Index)\n  }\n\n  function isThisTypeParameter(type: ts.Type): boolean {\n    return !!(type.flags & ts.TypeFlags.TypeParameter && (type as any).isThisType)\n  }\n\n  function getTypeParameterAtPosition(signature: ts.Signature, pos: number): ts.Type {\n    const type = typeChecker.getParameterType(signature, pos)\n    if (isIndexType(type) && isThisTypeParameter(type.type)) {\n      const constraint = typeChecker.getBaseConstraintOfType(type.type)\n      if (constraint) {\n        return typeChecker.getIndexType(constraint)\n      }\n    }\n    return type\n  }\n\n  const unrollUnionMembers = (type: ts.Type) => {\n    const result: Array<ts.Type> = []\n    let toTest: Array<ts.Type> = [type]\n    while (toTest.length > 0) {\n      const type = toTest.pop()!\n      if (isUnion(type)) {\n        toTest = toTest.concat(type.types)\n      } else {\n        result.push(type)\n      }\n    }\n    return result\n  }\n\n  const getMissingTypeEntriesInTargetType = function(realType: ts.Type, expectedType: ts.Type) {\n    if (realType === expectedType) return []\n\n    const result: Array<ts.Type> = []\n    let toTest: Array<ts.Type> = [realType]\n    while (toTest.length > 0) {\n      const type = toTest.pop()\n      if (!type) return result\n      if (isUnion(type)) {\n        toTest = toTest.concat(type.types)\n      } else {\n        const assignable = typeChecker.isTypeAssignableTo(type, expectedType)\n        if (!assignable) {\n          result.push(type)\n        }\n      }\n    }\n    return result\n  }\n\n  /**\n   * Appends a type to a map of unique types, ensuring that the type is not already in the map.\n   *\n   * @param memory - The map that will be used as memory and updated as new types are encountered.\n   * @param initialType - The type to start with, unions will be unrolled.\n   * @param shouldExclude - A function that determines if a type should be excluded from the checking\n   * @returns An object with the following properties:\n   * - newIndexes: A set of new indexes that were added to the memory.\n   * - knownIndexes: A set of indexes that were already in the memory.\n   * - allIndexes: A set of all indexes that were encountered.\n   */\n  const appendToUniqueTypesMap = Nano.fn(\n    \"TypeCheckerUtils.appendToUniqueTypesMap\"\n  )(\n    function*<E, R>(\n      memory: Map<string, ts.Type>,\n      initialType: ts.Type,\n      shouldExclude: (type: ts.Type) => Nano.Nano<boolean, E, R>\n    ) {\n      const newIndexes: Set<string> = new Set()\n      const knownIndexes: Set<string> = new Set()\n      let toTest: Array<ts.Type> = [initialType]\n      while (toTest.length > 0) {\n        const type = toTest.pop()\n        if (!type) break\n        if (yield* shouldExclude(type)) {\n          continue\n        }\n        if (isUnion(type)) {\n          toTest = toTest.concat(type.types)\n        } else {\n          const foundMatch: Array<string> = []\n          for (const [typeId, knownType] of memory.entries()) {\n            const areSame = typeChecker.isTypeAssignableTo(knownType, type) &&\n              typeChecker.isTypeAssignableTo(type, knownType)\n            if (areSame) {\n              foundMatch.push(typeId)\n              break\n            }\n          }\n          if (foundMatch.length === 0) {\n            const newId = \"t\" + (memory.size + 1)\n            memory.set(newId, type)\n            newIndexes.add(newId)\n          } else {\n            knownIndexes.add(foundMatch[0])\n          }\n        }\n      }\n      return {\n        newIndexes,\n        knownIndexes,\n        allIndexes: pipe(\n          Array.fromIterable(newIndexes),\n          Array.appendAll(Array.fromIterable(knownIndexes))\n        )\n      }\n    }\n  )\n\n  const deterministicTypeOrder = Order.make((a: ts.Type, b: ts.Type) => {\n    const aName = typeChecker.typeToString(a)\n    const bName = typeChecker.typeToString(b)\n    if (aName < bName) return -1\n    if (aName > bName) return 1\n    return 0\n  })\n\n  const getAncestorConvertibleDeclaration = (node: ts.Node) => {\n    let current: ts.Node | undefined = node\n    while (current) {\n      if (\n        ts.isFunctionDeclaration(current) ||\n        ts.isFunctionExpression(current) ||\n        ts.isArrowFunction(current) ||\n        ts.isMethodDeclaration(current)\n      ) {\n        return current\n      }\n      current = current.parent\n    }\n  }\n\n  const getInferredReturnType = (\n    declaration: ConvertibleDeclaration\n  ) => {\n    if (!declaration.body) {\n      return\n    }\n\n    let returnType: ts.Type | undefined\n\n    if (typeChecker.isImplementationOfOverload(declaration)) {\n      const signatures = typeChecker.getSignaturesOfType(\n        typeChecker.getTypeAtLocation(declaration),\n        ts.SignatureKind.Call\n      )\n      if (signatures.length > 1) {\n        returnType = typeChecker.getUnionType(\n          signatures.map((s) => typeChecker.getReturnTypeOfSignature(s)).filter((_) => !!_)\n        )\n      }\n    }\n    if (!returnType) {\n      const signature = typeChecker.getSignatureFromDeclaration(declaration)\n      if (signature) {\n        const typePredicate = typeChecker.getTypePredicateOfSignature(signature)\n        if (typePredicate && typePredicate.type) {\n          return typePredicate.type\n        } else {\n          returnType = typeChecker.getReturnTypeOfSignature(signature)\n        }\n      }\n    }\n\n    return returnType\n  }\n\n  const expectedAndRealTypeCache = new WeakMap<ts.SourceFile, Array<ExpectedAndRealType>>()\n  const expectedAndRealType = (\n    sourceFile: ts.SourceFile\n  ) => {\n    const cached = expectedAndRealTypeCache.get(sourceFile)\n    if (cached) return cached\n    const result: Array<ExpectedAndRealType> = []\n\n    const nodeToVisit: Array<ts.Node> = [sourceFile]\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      if (ts.isVariableDeclaration(node) && node.initializer) {\n        // const a: Effect<...> = node\n        const expectedType = typeChecker.getTypeAtLocation(node.name)\n        const realType = typeChecker.getTypeAtLocation(node.initializer)\n        result.push([node.name, expectedType, node.initializer, realType])\n        appendNodeToVisit(node.initializer)\n        continue\n      } else if (ts.isCallExpression(node)) {\n        // fn(a)\n        const resolvedSignature = typeChecker.getResolvedSignature(node)\n        if (resolvedSignature) {\n          resolvedSignature.parameters.map((parameter, index) => {\n            const expectedType = typeChecker.getTypeOfSymbolAtLocation(parameter, node)\n            const realType = typeChecker.getTypeAtLocation(node.arguments[index])\n            result.push([\n              node.arguments[index] as ts.Node,\n              expectedType,\n              node.arguments[index],\n              realType\n            ])\n          })\n        }\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      } else if (\n        ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node) ||\n        ts.isNoSubstitutionTemplateLiteral(node)\n      ) {\n        // { key: node } as { key: Effect<...> }\n        const parent = node.parent\n        if (ts.isObjectLiteralElement(parent)) {\n          if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {\n            const type = typeChecker.getContextualType(parent.parent)\n            if (type) {\n              const name = ts.isIdentifier(node) ? ts.idText(node) : ts.isStringLiteral(node) ? node.text : undefined\n              if (name) {\n                const symbol = typeChecker.getPropertyOfType(type, name)\n                if (symbol) {\n                  const expectedType = typeChecker.getTypeOfSymbolAtLocation(symbol, node)\n                  const realType = typeChecker.getTypeAtLocation(node)\n                  result.push([node, expectedType, node, realType])\n                }\n              }\n            }\n          }\n        }\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      } else if (\n        ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken\n      ) {\n        // var a: Effect<...> = node\n        const expectedType = typeChecker.getTypeAtLocation(node.left)\n        const realType = typeChecker.getTypeAtLocation(node.right)\n        result.push([node.left, expectedType, node.right, realType])\n        appendNodeToVisit(node.right)\n        continue\n      } else if (ts.isReturnStatement(node) && node.expression) {\n        // function(): Effect<...> { return a }\n        const parentDeclaration = getAncestorConvertibleDeclaration(node)\n        if (parentDeclaration) {\n          const expectedType = getInferredReturnType(parentDeclaration)\n          const realType = typeChecker.getTypeAtLocation(node.expression)\n          if (expectedType) {\n            result.push([node, expectedType, node, realType])\n          }\n        }\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      } else if (\n        ts.isArrowFunction(node) && (node.typeParameters || []).length === 0 &&\n        ts.isExpression(node.body)\n      ) {\n        // (): Effect<...> => node\n        const body = node.body\n        const expectedType = typeChecker.getContextualType(body)\n        const realType = typeChecker.getTypeAtLocation(body)\n        if (expectedType) {\n          result.push([body, expectedType, body, realType])\n        }\n        ts.forEachChild(body, appendNodeToVisit)\n        continue\n      } else if (\n        ts.isArrowFunction(node) && (node.typeParameters || []).length > 0 &&\n        ts.isExpression(node.body)\n      ) {\n        // <A>(): Effect<...> => node\n        const body = node.body\n        const expectedType = getInferredReturnType(node)\n        const realType = typeChecker.getTypeAtLocation(body)\n        if (expectedType) {\n          result.push([body, expectedType, body, realType])\n        }\n        ts.forEachChild(body, appendNodeToVisit)\n        continue\n      } else if (ts.isSatisfiesExpression(node)) {\n        // node as Effect<....>\n        const expectedType = typeChecker.getTypeAtLocation(node.type)\n        const realType = typeChecker.getTypeAtLocation(node.expression)\n        result.push([node.expression as ts.Node, expectedType, node.expression, realType])\n        appendNodeToVisit(node.expression)\n        continue\n      }\n\n      // no previous case has been hit, continue with childs\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n    expectedAndRealTypeCache.set(sourceFile, result)\n    return result\n  }\n\n  function typeToSimplifiedTypeNode(\n    type: ts.Type,\n    enclosingNode: ts.Node | undefined,\n    flags: ts.NodeBuilderFlags | undefined\n  ): ts.TypeNode | undefined {\n    return typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, 0)\n  }\n\n  function typeToSimplifiedTypeNodeWorker(\n    type: ts.Type,\n    enclosingNode: ts.Node | undefined,\n    flags: ts.NodeBuilderFlags | undefined,\n    depth: number\n  ): ts.TypeNode | undefined {\n    const fallbackStandard = () => {\n      const typeNode = typeChecker.typeToTypeNode(type, enclosingNode, flags)\n      if (!typeNode) return undefined\n      return tsUtils.simplifyTypeNode(typeNode)\n    }\n    // prevent infinite recursion\n    if (depth > 20) return fallbackStandard()\n\n    const members = unrollUnionMembers(type)\n    // A | B | C -> process each member\n    if (members.length > 1 && !(type.flags & ts.TypeFlags.Boolean)) {\n      const typeNodes: Array<ts.TypeNode> = []\n      members.sort(deterministicTypeOrder)\n      for (const member of members) {\n        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1)\n        if (!memberNode) return fallbackStandard()\n        typeNodes.push(memberNode)\n      }\n      return tsUtils.simplifyTypeNode(ts.factory.createUnionTypeNode(typeNodes))\n    }\n    // A & B & B -> process each member\n    if (type.flags & ts.TypeFlags.Intersection) {\n      const intersectionType = type as ts.IntersectionType\n      const typeNodes: Array<ts.TypeNode> = []\n      for (const member of intersectionType.types) {\n        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1)\n        if (!memberNode) return fallbackStandard()\n        typeNodes.push(memberNode)\n      }\n      return tsUtils.simplifyTypeNode(ts.factory.createIntersectionTypeNode(typeNodes))\n    }\n    // Effect<number, never, never> -> Effect<number>\n    if (type.flags & ts.TypeFlags.Object && (type as ts.ObjectType).objectFlags & ts.ObjectFlags.Reference) {\n      const typeReference = type as ts.TypeReference\n      // compute the standard type reference node and ensure we get the same amount of type arguments\n      const standard = fallbackStandard()\n      if (!standard) return undefined\n      if (!ts.isTypeReferenceNode(standard)) return standard\n      if (typeReference.target.typeParameters?.length !== typeReference.typeArguments?.length) return standard\n      if (standard.typeArguments?.length !== typeReference.typeArguments?.length) return standard\n      const typeParametersCount = (typeReference.target.typeParameters || []).length\n      for (let i = typeParametersCount - 1; i >= 0; i--) {\n        const typeParameter = typeReference.target.typeParameters![i]\n        const typeArgument = typeReference.typeArguments![i]\n        const defaultType = typeChecker.getDefaultFromTypeParameter(typeParameter)\n        if (defaultType !== typeArgument || i === 0) {\n          return tsUtils.simplifyTypeNode(ts.factory.updateTypeReferenceNode(\n            standard,\n            standard.typeName,\n            ts.factory.createNodeArray((standard.typeArguments || []).slice(0, Math.min(typeParametersCount, i + 1)))\n          ))\n        }\n      }\n      return standard\n    }\n    // () => Effect<number, never, never> -> () => Effect<number>\n    if (type.flags & ts.TypeFlags.Object) {\n      const standard = fallbackStandard()\n      if (!standard) return undefined\n      if (!ts.isFunctionTypeNode(standard)) return standard\n      const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n      if (signatures.length !== 1) return standard\n      const returnType = typeChecker.getReturnTypeOfSignature(signatures[0])\n      if (!returnType) return standard\n      const returnTypeNode = typeToSimplifiedTypeNodeWorker(returnType, enclosingNode, flags, depth + 1)\n      if (!returnTypeNode) return standard\n      return tsUtils.simplifyTypeNode(ts.factory.updateFunctionTypeNode(\n        standard,\n        standard.typeParameters,\n        standard.parameters,\n        returnTypeNode\n      ))\n    }\n\n    return fallbackStandard()\n  }\n\n  return {\n    isUnion,\n    getTypeParameterAtPosition,\n    getMissingTypeEntriesInTargetType,\n    unrollUnionMembers,\n    appendToUniqueTypesMap,\n    deterministicTypeOrder,\n    getInferredReturnType,\n    expectedAndRealType,\n    typeToSimplifiedTypeNode\n  }\n}\n","import * as Array from \"effect/Array\"\nimport { hasProperty } from \"effect/Predicate\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\n\nexport const durationInput = LSP.createCompletion({\n  name: \"durationInput\",\n  apply: Nano.fn(\"durationInput\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    let isInString: boolean = false\n    const previousToken = ts.findPrecedingToken(position, sourceFile)\n    if (previousToken && ts.isStringTextContainingNode(previousToken)) {\n      const start = ts.getTokenPosOfNode(previousToken, sourceFile)\n      const end = previousToken.end\n\n      // To be \"in\" one of these literals, the position has to be:\n      //   1. entirely within the token text.\n      //   2. at the end position of an unterminated token.\n      //   3. at the end of a regular expression (due to trailing flags like '/foo/g').\n      if (start < position && position < end) {\n        isInString = true\n      }\n\n      if (position === end) {\n        isInString = !!(previousToken as ts.LiteralExpression).isUnterminated\n      }\n\n      if (isInString && ts.isExpression(previousToken)) {\n        const type = typeChecker.getContextualType(previousToken)\n\n        if (type) {\n          // the type is an union\n          if (!typeCheckerUtils.isUnion(type)) return []\n          // and has members with nanos, millis, etc...\n          for (const member of type.types) {\n            if (member.flags & ts.TypeFlags.TemplateLiteral) {\n              if (\n                hasProperty(member, \"texts\") && Array.isArray(member.texts) && member.texts.length === 2 &&\n                String(member.texts[1]).trim() === \"nanos\"\n              ) {\n                // nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks\n                return [\"nanos\", \"micros\", \"millis\", \"seconds\", \"minutes\", \"hours\", \"days\", \"weeks\"].map(\n                  (name) => ({\n                    name,\n                    kind: ts.ScriptElementKind.string,\n                    insertText: `${\"${0}\"} ${name}`,\n                    isSnippet: true\n                  })\n                ) satisfies Array<LSP.CompletionEntryDefinition>\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return []\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as Nano from \"./Nano.js\"\nimport * as TypeCheckerApi from \"./TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"./TypeCheckerUtils.js\"\nimport * as TypeScriptApi from \"./TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"./TypeScriptUtils.js\"\n\nexport interface TypeParser {\n  effectType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; E: ts.Type; R: ts.Type }, TypeParserIssue>\n  strictEffectType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; E: ts.Type; R: ts.Type }, TypeParserIssue>\n  layerType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ ROut: ts.Type; E: ts.Type; RIn: ts.Type }, TypeParserIssue>\n  fiberType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; E: ts.Type; R: ts.Type }, TypeParserIssue>\n  effectSubtype: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; E: ts.Type; R: ts.Type }, TypeParserIssue>\n  importedEffectModule: (\n    node: ts.Node\n  ) => Nano.Nano<ts.Node, TypeParserIssue>\n  isNodeReferenceToEffectModuleApi: (\n    memberName: string\n  ) => (node: ts.Node) => Nano.Nano<ts.SourceFile, TypeParserIssue, never>\n  effectGen: (\n    node: ts.Node\n  ) => Nano.Nano<\n    {\n      node: ts.Node\n      effectModule: ts.Expression\n      generatorFunction: ts.FunctionExpression\n      body: ts.Block\n    },\n    TypeParserIssue\n  >\n  effectFnUntracedGen: (\n    node: ts.Node\n  ) => Nano.Nano<\n    {\n      node: ts.Node\n      effectModule: ts.Node\n      generatorFunction: ts.FunctionExpression\n      body: ts.Block\n    },\n    TypeParserIssue\n  >\n  effectFnGen: (\n    node: ts.Node\n  ) => Nano.Nano<\n    {\n      node: ts.Node\n      generatorFunction: ts.FunctionExpression\n      effectModule: ts.Node\n      body: ts.Block\n    },\n    TypeParserIssue\n  >\n  unnecessaryEffectGen: (\n    node: ts.Node\n  ) => Nano.Nano<\n    { node: ts.Node; body: ts.Block; yieldedExpression: ts.Node; replacementNode: Nano.Nano<ts.Node, never, never> },\n    TypeParserIssue\n  >\n  effectSchemaType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; I: ts.Type; R: ts.Type }, TypeParserIssue>\n  contextTag: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ Identifier: ts.Type; Service: ts.Type }, TypeParserIssue>\n  pipeableType: (type: ts.Type, atLocation: ts.Node) => Nano.Nano<ts.Type, TypeParserIssue, never>\n  pipeCall: (\n    node: ts.Node\n  ) => Nano.Nano<\n    { node: ts.CallExpression; subject: ts.Expression; args: Array<ts.Expression>; kind: \"pipe\" | \"pipeable\" },\n    TypeParserIssue,\n    never\n  >\n  scopeType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<ts.Type, TypeParserIssue>\n  promiseLike: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ type: ts.Type }, TypeParserIssue>\n  extendsEffectService: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      args: ts.NodeArray<ts.Expression>\n      Identifier: ts.Type\n      Service: ts.Type\n      accessors: boolean | undefined\n      dependencies: ts.NodeArray<ts.Expression> | undefined\n      keyStringLiteral: ts.StringLiteral | undefined\n      options: ts.Expression\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsContextTag: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      args: ts.NodeArray<ts.Expression>\n      Identifier: ts.Type\n      keyStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsEffectTag: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      args: ts.NodeArray<ts.Expression>\n      Identifier: ts.Type\n      Service: ts.Type\n      keyStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsSchemaClass: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsSchemaTaggedClass: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      keyStringLiteral: ts.StringLiteral | undefined\n      tagStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsSchemaTaggedError: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      keyStringLiteral: ts.StringLiteral | undefined\n      tagStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsSchemaTaggedRequest: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      keyStringLiteral: ts.StringLiteral | undefined\n      tagStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsDataTaggedError: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      keyStringLiteral: ts.StringLiteral | undefined\n      Data: ts.Node\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsDataTaggedClass: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      keyStringLiteral: ts.StringLiteral | undefined\n      Data: ts.Node\n    },\n    TypeParserIssue,\n    never\n  >\n}\nexport const TypeParser = Nano.Tag<TypeParser>(\"@effect/language-service/TypeParser\")\n\nexport const nanoLayer = <A, E, R>(\n  fa: Nano.Nano<A, E, R>\n) =>\n  Nano.gen(function*() {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n\n    return yield* pipe(\n      fa,\n      Nano.provideService(TypeParser, make(ts, tsUtils, typeChecker, typeCheckerUtils, program))\n    )\n  })\n\nexport class TypeParserIssue {\n  readonly _tag = \"@effect/language-service/TypeParserIssue\"\n  static issue = Nano.fail(new TypeParserIssue())\n}\n\nexport function typeParserIssue(\n  _message: string,\n  _type?: ts.Type | undefined,\n  _node?: ts.Node | undefined\n): Nano.Nano<never, TypeParserIssue, never> {\n  return TypeParserIssue.issue\n}\n\nexport function make(\n  ts: TypeScriptApi.TypeScriptApi,\n  tsUtils: TypeScriptUtils.TypeScriptUtils,\n  typeChecker: TypeCheckerApi.TypeCheckerApi,\n  typeCheckerUtils: TypeCheckerUtils.TypeCheckerUtils,\n  program: TypeScriptApi.TypeScriptProgram\n): TypeParser {\n  const getSourceFilePackageInfo = Nano.cachedBy(\n    Nano.fn(\"TypeParser.getSourceFilePackageInfo\")(function*(sourceFile: ts.SourceFile) {\n      return tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile)\n    }),\n    `TypeParser.getSourceFilePackageInfo`,\n    (sourceFile) => sourceFile\n  )\n\n  const getSourceFilesDeclaringSymbolModule = (\n    packageName: string\n  ) =>\n    Nano.cachedBy(\n      Nano.fn(\"TypeParser.getSourceFilesDeclaringSymbolModule\")(function*(symbol: ts.Symbol) {\n        const result: Array<ts.SourceFile> = []\n        if (!symbol.declarations) return yield* typeParserIssue(\"Symbol has no declarations\", undefined, undefined)\n        for (const sourceFile of symbol.declarations) {\n          if (!ts.isSourceFile(sourceFile)) continue\n          const packageInfo = yield* getSourceFilePackageInfo(sourceFile)\n          if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue\n          result.push(sourceFile)\n        }\n        if (result.length > 0) {\n          return result\n        }\n        return yield* typeParserIssue(`Symbol has no source file declarations`, undefined, undefined)\n      }),\n      `TypeParser.getSourceFilesDeclaringSymbolModule(${packageName})`,\n      (symbol) => symbol\n    )\n\n  const isSymbolReferenceToPackageModule = <T, E, R>(\n    givenSymbol: ts.Symbol,\n    packageName: string,\n    checkSourceFile: (sourceFile: ts.SourceFile) => Nano.Nano<T, E, R>\n  ) => {\n    let symbol = givenSymbol\n    while (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = typeChecker.getAliasedSymbol(symbol)\n    }\n    return pipe(\n      getSourceFilesDeclaringSymbolModule(packageName)(symbol),\n      Nano.flatMap((sourceFiles) =>\n        Nano.firstSuccessOf(\n          sourceFiles.map((_) => checkSourceFile(_))\n        )\n      )\n    )\n  }\n\n  const isNodeReferenceToPackageModule = <T, E, R>(\n    givenNode: ts.Node,\n    packageName: string,\n    isCorrectSourceFile: (\n      sourceFile: ts.SourceFile\n    ) => Nano.Nano<T, E, R>\n  ) => {\n    const symbol = typeChecker.getSymbolAtLocation(givenNode)\n    if (!symbol) return typeParserIssue(\"Node has no symbol\", undefined, givenNode)\n    return isSymbolReferenceToPackageModule(symbol, packageName, isCorrectSourceFile)\n  }\n\n  const getSourceFilesDeclaringSymbolExportedUnderPackageModule = (\n    packageName: string,\n    memberName: string\n  ) =>\n    Nano.cachedBy(\n      Nano.fn(\"TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember\")(function*(symbol: ts.Symbol) {\n        const result: Array<{ memberSymbol: ts.Symbol; moduleSymbol: ts.Symbol; sourceFile: ts.SourceFile }> = []\n        if (!symbol.declarations) return yield* typeParserIssue(\"Symbol has no declarations\", undefined, undefined)\n        for (const declaration of symbol.declarations) {\n          const sourceFile = tsUtils.getSourceFileOfNode(declaration)\n          if (!sourceFile) continue\n          const packageInfo = yield* getSourceFilePackageInfo(sourceFile)\n          if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue\n          const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile)\n          if (!moduleSymbol) continue\n          const memberSymbol = typeChecker.tryGetMemberInModuleExports(memberName, moduleSymbol)\n          if (memberSymbol && memberSymbol === symbol) result.push({ memberSymbol, moduleSymbol, sourceFile })\n        }\n        if (result.length > 0) {\n          return result\n        }\n        return yield* typeParserIssue(`Symbol has no declarations`, undefined, undefined)\n      }),\n      `TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember(${packageName}, ${memberName})`,\n      (sym) => sym\n    )\n\n  const isSymbolExportOfPackageModule = <T, E, R>(\n    givenSymbol: ts.Symbol,\n    packageName: string,\n    memberName: string,\n    checkSourceFile: (sourceFile: ts.SourceFile, moduleSymbol: ts.Symbol, memberSymbol: ts.Symbol) => Nano.Nano<T, E, R>\n  ) => {\n    let symbol = givenSymbol\n    while (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = typeChecker.getAliasedSymbol(symbol)\n    }\n    return pipe(\n      getSourceFilesDeclaringSymbolExportedUnderPackageModule(packageName, memberName)(symbol),\n      Nano.flatMap((sourceFiles) =>\n        Nano.firstSuccessOf(\n          sourceFiles.map((_) => checkSourceFile(_.sourceFile, _.moduleSymbol, _.memberSymbol))\n        )\n      )\n    )\n  }\n\n  const isNodeReferenceToExportOfPackageModule = <T, E, R>(\n    givenNode: ts.Node,\n    packageName: string,\n    isCorrectSourceFile: (\n      sourceFile: ts.SourceFile,\n      moduleSymbol: ts.Symbol,\n      memberSymbol: ts.Symbol\n    ) => Nano.Nano<T, E, R>,\n    memberName: string\n  ) => {\n    const symbol = typeChecker.getSymbolAtLocation(givenNode)\n    if (!symbol) return typeParserIssue(\"Node has no symbol\", undefined, givenNode)\n    return isSymbolExportOfPackageModule(symbol, packageName, memberName, isCorrectSourceFile)\n  }\n\n  function covariantTypeArgument(type: ts.Type): Nano.Nano<ts.Type, TypeParserIssue> {\n    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n    // Covariant<A> has only 1 type signature\n    if (signatures.length !== 1) {\n      return typeParserIssue(\"Covariant type has no call signature\", type)\n    }\n    // get the return type\n    return Nano.succeed(typeChecker.getReturnTypeOfSignature(signatures[0]))\n  }\n\n  function contravariantTypeArgument(type: ts.Type): Nano.Nano<ts.Type, TypeParserIssue> {\n    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n    // Contravariant<A> has only 1 type signature\n    if (signatures.length !== 1) {\n      return typeParserIssue(\"Contravariant type has no call signature\", type)\n    }\n    // get the return type\n    return Nano.succeed(typeCheckerUtils.getTypeParameterAtPosition(signatures[0], 0))\n  }\n\n  function invariantTypeArgument(type: ts.Type): Nano.Nano<ts.Type, TypeParserIssue> {\n    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n    // Invariant<A> has only 1 type signature\n    if (signatures.length !== 1) {\n      return typeParserIssue(\"Invariant type has no call signature\", type)\n    }\n    // get the return type\n    return Nano.succeed(typeChecker.getReturnTypeOfSignature(signatures[0]))\n  }\n\n  const pipeableType = Nano.cachedBy(\n    function(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // Pipeable has a pipe property on the type\n      const pipeSymbol = typeChecker.getPropertyOfType(type, \"pipe\")\n      if (!pipeSymbol) {\n        return typeParserIssue(\"Type has no 'pipe' property\", type, atLocation)\n      }\n      // which should be callable with at least one call signature\n      const pipeType = typeChecker.getTypeOfSymbolAtLocation(pipeSymbol, atLocation)\n      const signatures = typeChecker.getSignaturesOfType(pipeType, ts.SignatureKind.Call)\n      if (signatures.length === 0) {\n        return typeParserIssue(\"'pipe' property is not callable\", type, atLocation)\n      }\n      return Nano.succeed(type)\n    },\n    \"TypeParser.pipeableType\",\n    (type) => type\n  )\n\n  const varianceStructCovariantType = <A extends string>(\n    type: ts.Type,\n    atLocation: ts.Node,\n    propertyName: A\n  ) => {\n    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName)\n    if (!propertySymbol) {\n      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation)\n    }\n    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n    return covariantTypeArgument(propertyType)\n  }\n\n  const varianceStructContravariantType = <A extends string>(\n    type: ts.Type,\n    atLocation: ts.Node,\n    propertyName: A\n  ) => {\n    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName)\n    if (!propertySymbol) {\n      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation)\n    }\n    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n    return contravariantTypeArgument(propertyType)\n  }\n\n  const varianceStructInvariantType = <A extends string>(\n    type: ts.Type,\n    atLocation: ts.Node,\n    propertyName: A\n  ) => {\n    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName)\n    if (!propertySymbol) {\n      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation)\n    }\n    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n    return invariantTypeArgument(propertyType)\n  }\n\n  const effectVarianceStruct = (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) =>\n    Nano.map(\n      Nano.all(\n        varianceStructCovariantType(type, atLocation, \"_A\"),\n        varianceStructCovariantType(type, atLocation, \"_E\"),\n        varianceStructCovariantType(type, atLocation, \"_R\")\n      ),\n      ([A, E, R]) => ({ A, E, R })\n    )\n\n  const layerVarianceStruct = (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) =>\n    Nano.map(\n      Nano.all(\n        varianceStructContravariantType(type, atLocation, \"_ROut\"),\n        varianceStructCovariantType(type, atLocation, \"_E\"),\n        varianceStructCovariantType(type, atLocation, \"_RIn\")\n      ),\n      ([ROut, E, RIn]) => ({ ROut, E, RIn })\n    )\n\n  const effectType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.effectType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      let result: Nano.Nano<\n        {\n          A: ts.Type\n          E: ts.Type\n          R: ts.Type\n        },\n        TypeParserIssue,\n        never\n      > = typeParserIssue(\"Type has no effect variance struct\", type, atLocation)\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) =>\n        ts.symbolName(b).indexOf(\"EffectTypeId\") - ts.symbolName(a).indexOf(\"EffectTypeId\")\n      )\n      // has a property symbol which is an effect variance struct\n      for (const propertySymbol of propertiesSymbols) {\n        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n        result = pipe(result, Nano.orElse(() => effectVarianceStruct(propertyType, atLocation)))\n      }\n      return yield* result\n    }),\n    \"TypeParser.effectType\",\n    (type) => type\n  )\n\n  const strictEffectType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.strictEffectType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // symbol name should be Effect\n      if (!(type.symbol && ts.symbolName(type.symbol) === \"Effect\" && !type.aliasSymbol)) {\n        return yield* typeParserIssue(\"Type name should be Effect with no alias symbol\", type, atLocation)\n      }\n      // should be an effect\n      return yield* effectType(type, atLocation)\n    }),\n    \"TypeParser.strictEffectType\",\n    (type) => type\n  )\n\n  const isEffectTypeSourceFile = Nano.cachedBy(\n    Nano.fn(\"TypeParser.isEffectTypeSourceFile\")(function*(\n      sourceFile: ts.SourceFile\n    ) {\n      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile)\n      if (!moduleSymbol) return yield* typeParserIssue(\"Node has no symbol\", undefined, sourceFile)\n      const effectTypeSymbol = typeChecker.tryGetMemberInModuleExports(\"Effect\", moduleSymbol)\n      if (!effectTypeSymbol) return yield* typeParserIssue(\"Effect type not found\", undefined, sourceFile)\n      const type = typeChecker.getDeclaredTypeOfSymbol(effectTypeSymbol)\n      yield* effectType(type, sourceFile)\n      return sourceFile\n    }),\n    \"TypeParser.isEffectTypeSourceFile\",\n    (sourceFile) => sourceFile\n  )\n\n  const isNodeReferenceToEffectModuleApi = (memberName: string) =>\n    Nano.cachedBy(\n      Nano.fn(\"TypeParser.isNodeReferenceToEffectModuleApi\")(function*(\n        node: ts.Node\n      ) {\n        return yield* isNodeReferenceToExportOfPackageModule(node, \"effect\", isEffectTypeSourceFile, memberName)\n      }),\n      `TypeParser.isNodeReferenceToEffectModuleApi(${memberName})`,\n      (node) => node\n    )\n\n  const layerType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.layerType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // should be pipeable\n      yield* pipeableType(type, atLocation)\n\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) =>\n        ts.symbolName(b).indexOf(\"LayerTypeId\") - ts.symbolName(a).indexOf(\"LayerTypeId\")\n      )\n      // has a property symbol which is a layer variance struct\n      for (const propertySymbol of propertiesSymbols) {\n        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n        const varianceArgs = yield* Nano.option(layerVarianceStruct(\n          propertyType,\n          atLocation\n        ))\n        if (Option.isSome(varianceArgs)) {\n          return varianceArgs.value\n        }\n      }\n      return yield* typeParserIssue(\"Type has no layer variance struct\", type, atLocation)\n    }),\n    \"TypeParser.layerType\",\n    (type) => type\n  )\n\n  const fiberType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.fiberType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // there is no better way to check if a type is a fiber right not\n      // so we just check for the existence of the property \"await\" and \"poll\"\n      const awaitSymbol = typeChecker.getPropertyOfType(type, \"await\")\n      const pollSymbol = typeChecker.getPropertyOfType(type, \"poll\")\n      if (!awaitSymbol || !pollSymbol) {\n        return yield* typeParserIssue(\n          \"Type is not a fiber because it does not have 'await' or 'poll' property\",\n          type,\n          atLocation\n        )\n      }\n      // and it is also an effect itself\n      return yield* effectType(type, atLocation)\n    }),\n    \"TypeParser.fiberType\",\n    (type) => type\n  )\n\n  const effectSubtype = Nano.cachedBy(\n    Nano.fn(\"TypeParser.effectSubtype\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // there is no better way to check if a type is a subtype of effect\n      // so we just check for the existence of the property \"_tag\"\n      // which is common for Option, Either, and others\n      // and other datatypes as \"Pool\" have \"get\"\n      const tagSymbol = typeChecker.getPropertyOfType(type, \"_tag\")\n      const getSymbol = typeChecker.getPropertyOfType(type, \"get\")\n      if (!(tagSymbol || getSymbol)) {\n        return yield* typeParserIssue(\n          \"Type is not a subtype of effect because it does not have '_tag' or 'get' property\",\n          type,\n          atLocation\n        )\n      }\n      // and it is also an effect itself\n      return yield* effectType(type, atLocation)\n    }),\n    \"TypeParser.effectSubtype\",\n    (type) => type\n  )\n\n  const importedContextModule = Nano.cachedBy(\n    Nano.fn(\"TypeParser.importedContextModule\")(function*(\n      node: ts.Node\n    ) {\n      const type = typeChecker.getTypeAtLocation(node)\n      // if the type has a property \"Tag\" that is a function\n      const propertySymbol = typeChecker.getPropertyOfType(type, \"Tag\")\n      if (!propertySymbol) {\n        return yield* typeParserIssue(\"Type has no 'Tag' property\", type, node)\n      }\n      // should be an expression\n      if (!ts.isIdentifier(node)) {\n        return yield* typeParserIssue(\"Node is not an identifier\", type, node)\n      }\n      const sourceFile = tsUtils.getSourceFileOfNode(node)\n      if (!sourceFile) {\n        return yield* typeParserIssue(\"Node is not in a source file\", undefined, node)\n      }\n      const contextIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n        sourceFile,\n        \"effect\",\n        \"Context\"\n      )\n      if (!contextIdentifier) {\n        return yield* typeParserIssue(\"Context module not found\", undefined, node)\n      }\n      if (ts.idText(node) !== contextIdentifier) {\n        return yield* typeParserIssue(\"Node is not a context module reference\", undefined, node)\n      }\n      // return the node itself\n      return node\n    }),\n    \"TypeParser.importedContextModule\",\n    (node) => node\n  )\n\n  const importedEffectModule = (node: ts.Node) =>\n    pipe(\n      isNodeReferenceToPackageModule(node, \"effect\", isEffectTypeSourceFile),\n      Nano.map(() => node)\n    )\n\n  const importedDataModule = Nano.cachedBy(\n    Nano.fn(\"TypeParser.importedDataModule\")(function*(\n      node: ts.Node\n    ) {\n      const type = typeChecker.getTypeAtLocation(node)\n      // if the type has a property \"TaggedError\" that is a function\n      const propertySymbol = typeChecker.getPropertyOfType(type, \"TaggedError\")\n      if (!propertySymbol) {\n        return yield* typeParserIssue(\"Type has no 'TaggedError' property\", type, node)\n      }\n      // should be an expression\n      if (!ts.isIdentifier(node)) {\n        return yield* typeParserIssue(\"Node is not an expression\", type, node)\n      }\n      const sourceFile = tsUtils.getSourceFileOfNode(node)\n      if (!sourceFile) {\n        return yield* typeParserIssue(\"Node is not in a source file\", undefined, node)\n      }\n      const dataIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n        sourceFile,\n        \"effect\",\n        \"Data\"\n      )\n      if (!dataIdentifier) {\n        return yield* typeParserIssue(\"Data module not found\", undefined, node)\n      }\n      if (ts.idText(node) !== dataIdentifier) {\n        return yield* typeParserIssue(\"Node is not a data module reference\", undefined, node)\n      }\n      // return the node itself\n      return node\n    }),\n    \"TypeParser.importedDataModule\",\n    (node) => node\n  )\n\n  const effectGen = Nano.cachedBy(\n    function(node: ts.Node) {\n      // Effect.gen(...)\n      if (!ts.isCallExpression(node)) {\n        return typeParserIssue(\"Node is not a call expression\", undefined, node)\n      }\n      // ...\n      if (node.arguments.length === 0) {\n        return typeParserIssue(\"Node has no arguments\", undefined, node)\n      }\n      // firsta argument is a generator function expression\n      const generatorFunction = node.arguments[0]\n      if (!ts.isFunctionExpression(generatorFunction)) {\n        return typeParserIssue(\"Node is not a function expression\", undefined, node)\n      }\n      if (generatorFunction.asteriskToken === undefined) {\n        return typeParserIssue(\"Node is not a generator function\", undefined, node)\n      }\n      // Effect.gen\n      if (!ts.isPropertyAccessExpression(node.expression)) {\n        return typeParserIssue(\"Node is not a property access expression\", undefined, node)\n      }\n      const propertyAccess = node.expression\n      return pipe(\n        isNodeReferenceToEffectModuleApi(\"gen\")(propertyAccess),\n        Nano.map(() => ({\n          node,\n          effectModule: propertyAccess.expression,\n          generatorFunction,\n          body: generatorFunction.body\n        }))\n      )\n    },\n    \"TypeParser.effectGen\",\n    (node) => node\n  )\n\n  const effectFnUntracedGen = Nano.cachedBy(\n    function(node: ts.Node) {\n      // Effect.gen(...)\n      if (!ts.isCallExpression(node)) {\n        return typeParserIssue(\"Node is not a call expression\", undefined, node)\n      }\n      // ...\n      if (node.arguments.length === 0) {\n        return typeParserIssue(\"Node has no arguments\", undefined, node)\n      }\n      // firsta argument is a generator function expression\n      const generatorFunction = node.arguments[0]\n      if (!ts.isFunctionExpression(generatorFunction)) {\n        return typeParserIssue(\"Node is not a function expression\", undefined, node)\n      }\n      if (generatorFunction.asteriskToken === undefined) {\n        return typeParserIssue(\n          \"Node is not a generator function\",\n          undefined,\n          node\n        )\n      }\n      // Effect.gen\n      if (!ts.isPropertyAccessExpression(node.expression)) {\n        return typeParserIssue(\n          \"Node is not a property access expression\",\n          undefined,\n          node\n        )\n      }\n      const propertyAccess = node.expression\n      return pipe(\n        isNodeReferenceToEffectModuleApi(\"fnUntraced\")(propertyAccess),\n        Nano.map(() => ({\n          node,\n          effectModule: propertyAccess.expression,\n          generatorFunction,\n          body: generatorFunction.body\n        }))\n      )\n    },\n    \"TypeParser.effectFnUntracedGen\",\n    (node) => node\n  )\n\n  const effectFnGen = Nano.cachedBy(\n    function(node: ts.Node) {\n      // Effect.fn(...)\n      if (!ts.isCallExpression(node)) {\n        return typeParserIssue(\"Node is not a call expression\", undefined, node)\n      }\n      // ...\n      if (node.arguments.length === 0) {\n        return typeParserIssue(\"Node has no arguments\", undefined, node)\n      }\n      // firsta argument is a generator function expression\n      const generatorFunction = node.arguments[0]\n      if (!ts.isFunctionExpression(generatorFunction)) {\n        return typeParserIssue(\n          \"Node is not a function expression\",\n          undefined,\n          node\n        )\n      }\n      if (generatorFunction.asteriskToken === undefined) {\n        return typeParserIssue(\n          \"Node is not a generator function\",\n          undefined,\n          node\n        )\n      }\n      // either we are using Effect.fn(\"name\")(generatorFunction) or we are using Effect.fn(generatorFunction)\n      const expressionToTest = ts.isCallExpression(node.expression)\n        ? node.expression.expression\n        : node.expression\n      if (!ts.isPropertyAccessExpression(expressionToTest)) {\n        return typeParserIssue(\n          \"Node is not a property access expression\",\n          undefined,\n          node\n        )\n      }\n      const propertyAccess = expressionToTest\n      return pipe(\n        isNodeReferenceToEffectModuleApi(\"fn\")(propertyAccess),\n        Nano.map(() => ({\n          node,\n          generatorFunction,\n          effectModule: propertyAccess.expression,\n          body: generatorFunction.body\n        }))\n      )\n    },\n    \"TypeParser.effectFnGen\",\n    (node) => node\n  )\n\n  const unnecessaryEffectGen = Nano.cachedBy(\n    Nano.fn(\"TypeParser.unnecessaryEffectGen\")(function*(\n      node: ts.Node\n    ) {\n      // ensure is an effect gen with a single statement\n      const { body } = yield* effectGen(node)\n      if (body.statements.length !== 1) {\n        return yield* typeParserIssue(\n          \"Generator body should have a single statement\",\n          undefined,\n          node\n        )\n      }\n\n      let explicitReturn = false\n      let nodeToCheck: ts.Node = body.statements[0]\n      while (nodeToCheck) {\n        // return XXX\n        if (ts.isReturnStatement(nodeToCheck) && nodeToCheck.expression) {\n          nodeToCheck = nodeToCheck.expression\n          explicitReturn = true\n          continue\n        }\n        // expression yield*\n        if (ts.isExpressionStatement(nodeToCheck)) {\n          nodeToCheck = nodeToCheck.expression\n          continue\n        }\n        // yield* XXX\n        if (ts.isYieldExpression(nodeToCheck) && nodeToCheck.asteriskToken && nodeToCheck.expression) {\n          const yieldedExpression = nodeToCheck.expression\n          const type = typeChecker.getTypeAtLocation(yieldedExpression)\n          const { A: successType } = yield* effectType(type, yieldedExpression)\n          let replacementNode: Nano.Nano<ts.Node> = Nano.succeed(yieldedExpression)\n          if (!explicitReturn && !(successType.flags & ts.TypeFlags.VoidLike)) {\n            replacementNode = pipe(\n              Nano.gen(function*() {\n                const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n                  node.getSourceFile(),\n                  \"effect\",\n                  \"Effect\"\n                ) || \"Effect\"\n\n                return ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    ts.factory.createIdentifier(effectIdentifier),\n                    \"asVoid\"\n                  ),\n                  undefined,\n                  [\n                    yieldedExpression\n                  ]\n                )\n              }),\n              Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n            )\n          }\n          return { node, body, yieldedExpression, replacementNode }\n        }\n        // fall through\n        break\n      }\n\n      // fall through case\n      return yield* typeParserIssue(\n        \"Not an handled node\",\n        undefined,\n        node\n      )\n    }),\n    \"TypeParser.unnecessaryEffectGen\",\n    (node) => node\n  )\n\n  const effectSchemaVarianceStruct = (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) =>\n    Nano.map(\n      Nano.all(\n        varianceStructInvariantType(type, atLocation, \"_A\"),\n        varianceStructInvariantType(type, atLocation, \"_I\"),\n        varianceStructCovariantType(type, atLocation, \"_R\")\n      ),\n      ([A, I, R]) => ({ A, I, R })\n    )\n\n  const effectSchemaType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.effectSchemaType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // should be pipeable\n      yield* pipeableType(type, atLocation)\n      // should have an 'ast' property\n      const ast = typeChecker.getPropertyOfType(type, \"ast\")\n      if (!ast) return yield* typeParserIssue(\"Has no 'ast' property\", type, atLocation)\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf(\"TypeId\") - ts.symbolName(a).indexOf(\"TypeId\"))\n      // has a property symbol which is an effect variance struct\n      for (const propertySymbol of propertiesSymbols) {\n        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n        const varianceArgs = yield* Nano.option(effectSchemaVarianceStruct(\n          propertyType,\n          atLocation\n        ))\n        if (Option.isSome(varianceArgs)) {\n          return varianceArgs.value\n        }\n      }\n      return yield* typeParserIssue(\"Type has no schema variance struct\", type, atLocation)\n    }),\n    \"TypeParser.effectSchemaType\",\n    (type) => type\n  )\n\n  const isEffectSchemaTypeSourceFile = Nano.cachedBy(\n    Nano.fn(\"TypeParser.isEffectSchemaTypeSourceFile\")(function*(\n      sourceFile: ts.SourceFile\n    ) {\n      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile)\n      if (!moduleSymbol) return yield* typeParserIssue(\"Node has no symbol\", undefined, sourceFile)\n      const typeSymbol = typeChecker.tryGetMemberInModuleExports(\"Schema\", moduleSymbol)\n      if (!typeSymbol) return yield* typeParserIssue(\"Schema type not found\", undefined, sourceFile)\n      const type = typeChecker.getDeclaredTypeOfSymbol(typeSymbol)\n      yield* effectSchemaType(type, sourceFile)\n      return sourceFile\n    }),\n    \"TypeParser.isEffectSchemaTypeSourceFile\",\n    (sourceFile) => sourceFile\n  )\n\n  const isNodeReferenceToEffectSchemaModuleApi = (memberName: string) =>\n    Nano.cachedBy(\n      Nano.fn(\"TypeParser.isNodeReferenceToEffectSchemaModuleApi\")(function*(\n        node: ts.Node\n      ) {\n        return yield* isNodeReferenceToExportOfPackageModule(node, \"effect\", isEffectSchemaTypeSourceFile, memberName)\n      }),\n      `TypeParser.isNodeReferenceToEffectSchemaModuleApi(${memberName})`,\n      (node) => node\n    )\n\n  const contextTagVarianceStruct = (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) =>\n    Nano.map(\n      Nano.all(\n        varianceStructInvariantType(type, atLocation, \"_Identifier\"),\n        varianceStructInvariantType(type, atLocation, \"_Service\")\n      ),\n      ([Identifier, Service]) => ({ Identifier, Service })\n    )\n\n  const contextTag = Nano.cachedBy(\n    Nano.fn(\"TypeParser.contextTag\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // should be pipeable\n      yield* pipeableType(type, atLocation)\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf(\"TypeId\") - ts.symbolName(a).indexOf(\"TypeId\"))\n      // has a property symbol which is an effect variance struct\n      for (const propertySymbol of propertiesSymbols) {\n        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n        const varianceArgs = yield* Nano.option(contextTagVarianceStruct(\n          propertyType,\n          atLocation\n        ))\n        if (Option.isSome(varianceArgs)) {\n          return varianceArgs.value\n        }\n      }\n      return yield* typeParserIssue(\"Type has no tag variance struct\", type, atLocation)\n    }),\n    \"TypeParser.contextTag\",\n    (type) => type\n  )\n\n  const pipeCall = Nano.cachedBy(\n    function(\n      node: ts.Node\n    ): Nano.Nano<\n      { node: ts.CallExpression; subject: ts.Expression; args: Array<ts.Expression>; kind: \"pipe\" | \"pipeable\" },\n      TypeParserIssue,\n      never\n    > {\n      // expression.pipe(.....)\n      if (\n        ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) &&\n        ts.isIdentifier(node.expression.name) &&\n        ts.idText(node.expression.name) === \"pipe\"\n      ) {\n        return Nano.succeed({\n          node,\n          subject: node.expression.expression,\n          args: Array.from(node.arguments),\n          kind: \"pipeable\"\n        })\n      }\n\n      // pipe(A, B, ...)\n      if (\n        ts.isCallExpression(node) && ts.isIdentifier(node.expression) && ts.idText(node.expression) === \"pipe\" &&\n        node.arguments.length > 0\n      ) {\n        const [subject, ...args] = node.arguments\n        return Nano.succeed({ node, subject, args, kind: \"pipe\" })\n      }\n\n      return typeParserIssue(\"Node is not a pipe call\", undefined, node)\n    },\n    \"TypeParser.pipeCall\",\n    (node) => node\n  )\n\n  const scopeType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.scopeType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // should be pipeable\n      yield* pipeableType(type, atLocation)\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) =>\n        ts.symbolName(b).indexOf(\"ScopeTypeId\") - ts.symbolName(a).indexOf(\"ScopeTypeId\")\n      )\n      // has a property scope type id\n      for (const propertySymbol of propertiesSymbols) {\n        const computedPropertyExpression: ts.ComputedPropertyName = (propertySymbol.valueDeclaration as any).name\n        const symbol = typeChecker.getSymbolAtLocation(computedPropertyExpression.expression)\n        if (symbol && ts.symbolName(symbol) === \"ScopeTypeId\") {\n          return type\n        }\n      }\n      return yield* typeParserIssue(\"Type has no scope type id\", type, atLocation)\n    }),\n    \"TypeParser.scopeType\",\n    (type) => type\n  )\n\n  const promiseLike = Nano.cachedBy(\n    function(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // maybe it is a Promise<A>?\n      const thenProperty = type.getProperty(\"then\")\n      if (!thenProperty) return typeParserIssue(\"not a promise - missing then property\", type, atLocation)\n      const thenType = typeChecker.getTypeOfSymbolAtLocation(thenProperty, atLocation)\n      if (!thenType) return typeParserIssue(\"not a promise - missing then property\", type, atLocation)\n      // .then should be callable\n      for (const callSignature of typeChecker.getSignaturesOfType(thenType, ts.SignatureKind.Call)) {\n        // take the callback argument of then\n        const parameter = callSignature.parameters[0]\n        if (!parameter) continue\n        const parameterType = typeCheckerUtils.getTypeParameterAtPosition(callSignature, 0)\n        if (!parameterType) continue\n        // it can be an union with many types\n        let callbackCallSignatures: Array<ts.Signature> = []\n        let toTest = [parameterType]\n        while (toTest.length > 0) {\n          const type = toTest.shift()\n          if (!type) continue\n          const callSignatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n          callbackCallSignatures = callbackCallSignatures.concat(callSignatures)\n          if (typeCheckerUtils.isUnion(type)) {\n            toTest = toTest.concat(type.types)\n          }\n        }\n        for (const callableType of callbackCallSignatures) {\n          const callbackParameter = callableType.parameters[0]\n          if (!callbackParameter) {\n            continue\n          }\n          const callbackParameterType = typeCheckerUtils.getTypeParameterAtPosition(callableType, 0)\n          if (!callbackParameterType) {\n            continue\n          }\n          return Nano.succeed({\n            type: callbackParameterType\n          })\n        }\n      }\n      return typeParserIssue(\"not a promise\", type, atLocation)\n    },\n    \"TypeParser.promiseLike\",\n    (type) => type\n  )\n\n  const extendsSchemaClass = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsSchemaClass\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Schema.Class<T>(\"name\")({})\n              const schemaCall = expression.expression\n              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {\n                const isEffectSchemaModuleApi = yield* pipe(\n                  isNodeReferenceToEffectSchemaModuleApi(\"Class\")(schemaCall.expression),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectSchemaModuleApi)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode: schemaCall.typeArguments[0]!\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Schema.Class\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsSchemaClass\",\n    (atLocation) => atLocation\n  )\n\n  const extendsSchemaTaggedClass = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsSchemaTaggedClass\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Schema.TaggedClass<T>(\"name\")(\"tag\", {})\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression) && expression.arguments.length > 0) {\n              // Schema.TaggedClass<T>(\"name\")\n              const schemaTaggedClassTCall = expression.expression\n              if (\n                ts.isCallExpression(schemaTaggedClassTCall) && schemaTaggedClassTCall.typeArguments &&\n                schemaTaggedClassTCall.typeArguments.length > 0\n              ) {\n                const selfTypeNode = schemaTaggedClassTCall.typeArguments[0]!\n                const isEffectSchemaModuleApi = yield* pipe(\n                  isNodeReferenceToEffectSchemaModuleApi(\"TaggedClass\")(schemaTaggedClassTCall.expression),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectSchemaModuleApi)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode,\n                    keyStringLiteral: schemaTaggedClassTCall.arguments.length > 0 &&\n                        ts.isStringLiteral(schemaTaggedClassTCall.arguments[0])\n                      ? schemaTaggedClassTCall.arguments[0]\n                      : undefined,\n                    tagStringLiteral: expression.arguments.length > 0 &&\n                        ts.isStringLiteral(expression.arguments[0])\n                      ? expression.arguments[0]\n                      : undefined\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Schema.TaggedClass\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsSchemaTaggedClass\",\n    (atLocation) => atLocation\n  )\n\n  const extendsSchemaTaggedError = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsSchemaTaggedError\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Schema.TaggedError<T>(\"name\")(\"tag\", {})\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Schema.TaggedError<T>(\"name\")\n              const schemaTaggedErrorTCall = expression.expression\n              if (\n                ts.isCallExpression(schemaTaggedErrorTCall) && schemaTaggedErrorTCall.typeArguments &&\n                schemaTaggedErrorTCall.typeArguments.length > 0\n              ) {\n                const selfTypeNode = schemaTaggedErrorTCall.typeArguments[0]!\n                const isEffectSchemaModuleApi = yield* pipe(\n                  isNodeReferenceToEffectSchemaModuleApi(\"TaggedError\")(schemaTaggedErrorTCall.expression),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectSchemaModuleApi)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode,\n                    keyStringLiteral: schemaTaggedErrorTCall.arguments.length > 0 &&\n                        ts.isStringLiteral(schemaTaggedErrorTCall.arguments[0])\n                      ? schemaTaggedErrorTCall.arguments[0]\n                      : undefined,\n                    tagStringLiteral: expression.arguments.length > 0 &&\n                        ts.isStringLiteral(expression.arguments[0])\n                      ? expression.arguments[0]\n                      : undefined\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Schema.TaggedError\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsSchemaTaggedError\",\n    (atLocation) => atLocation\n  )\n\n  const extendsSchemaTaggedRequest = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsSchemaTaggedRequest\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Schema.TaggedRequest<T>(\"name\")(\"tag\", {})\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Schema.TaggedRequest<T>(\"name\")\n              const schemaTaggedRequestTCall = expression.expression\n              if (\n                ts.isCallExpression(schemaTaggedRequestTCall) &&\n                schemaTaggedRequestTCall.typeArguments &&\n                schemaTaggedRequestTCall.typeArguments.length > 0\n              ) {\n                const selfTypeNode = schemaTaggedRequestTCall.typeArguments[0]!\n                const isEffectSchemaModuleApi = yield* pipe(\n                  isNodeReferenceToEffectSchemaModuleApi(\"TaggedRequest\")(schemaTaggedRequestTCall.expression),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectSchemaModuleApi)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode,\n                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0])\n                      ? expression.arguments[0]\n                      : undefined,\n                    keyStringLiteral: schemaTaggedRequestTCall.arguments.length > 0 &&\n                        ts.isStringLiteral(schemaTaggedRequestTCall.arguments[0])\n                      ? schemaTaggedRequestTCall.arguments[0]\n                      : undefined\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Schema.TaggedRequest\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsSchemaTaggedRequest\",\n    (atLocation) => atLocation\n  )\n\n  const extendsDataTaggedError = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsDataTaggedError\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Data.TaggedError(\"name\")<{}>\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Data.TaggedError(\"name\")\n              const dataTaggedErrorCall = expression\n              // Data.TaggedError\n              const dataIdentifier = dataTaggedErrorCall.expression\n              if (\n                ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) &&\n                ts.idText(dataIdentifier.name) === \"TaggedError\"\n              ) {\n                const parsedDataModule = yield* pipe(\n                  importedDataModule(dataIdentifier.expression),\n                  Nano.option\n                )\n                if (Option.isSome(parsedDataModule)) {\n                  // For Data.TaggedError, the structure is: Data.TaggedError(\"name\")<{}>\n                  // The string literal is in the single call expression\n                  return {\n                    className: atLocation.name,\n                    keyStringLiteral: dataTaggedErrorCall.arguments.length > 0 &&\n                        ts.isStringLiteral(dataTaggedErrorCall.arguments[0])\n                      ? dataTaggedErrorCall.arguments[0]\n                      : undefined,\n                    Data: parsedDataModule.value\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Data.TaggedError\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsDataTaggedError\",\n    (atLocation) => atLocation\n  )\n\n  const extendsDataTaggedClass = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsDataTaggedClass\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Data.TaggedClass(\"name\")<{}>\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Data.TaggedClass(\"name\")\n              const dataTaggedClassCall = expression\n              // Data.TaggedClass\n              const dataIdentifier = dataTaggedClassCall.expression\n              if (\n                ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) &&\n                ts.idText(dataIdentifier.name) === \"TaggedClass\"\n              ) {\n                const parsedDataModule = yield* pipe(\n                  importedDataModule(dataIdentifier.expression),\n                  Nano.option\n                )\n                if (Option.isSome(parsedDataModule)) {\n                  // For Data.TaggedClass, the structure is: Data.TaggedClass(\"name\")<{}>\n                  // The string literal is in the single call expression\n                  return {\n                    className: atLocation.name,\n                    keyStringLiteral: dataTaggedClassCall.arguments.length > 0 &&\n                        ts.isStringLiteral(dataTaggedClassCall.arguments[0])\n                      ? dataTaggedClassCall.arguments[0]\n                      : undefined,\n                    Data: parsedDataModule.value\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Data.TaggedClass\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsDataTaggedClass\",\n    (atLocation) => atLocation\n  )\n\n  const extendsContextTag = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsContextTag\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            const wholeCall = typeX.expression\n            if (ts.isCallExpression(wholeCall)) {\n              const contextTagCall = wholeCall.expression\n              if (\n                ts.isCallExpression(contextTagCall) &&\n                wholeCall.typeArguments && wholeCall.typeArguments.length > 0\n              ) {\n                const contextTagIdentifier = contextTagCall.expression\n                const selfTypeNode = wholeCall.typeArguments[0]!\n                if (\n                  ts.isPropertyAccessExpression(contextTagIdentifier) &&\n                  ts.isIdentifier(contextTagIdentifier.name) && ts.idText(contextTagIdentifier.name) === \"Tag\"\n                ) {\n                  const parsedContextModule = yield* pipe(\n                    importedContextModule(contextTagIdentifier.expression),\n                    Nano.option\n                  )\n                  if (Option.isSome(parsedContextModule)) {\n                    const classSym = typeChecker.getSymbolAtLocation(atLocation.name)\n                    if (!classSym) return yield* typeParserIssue(\"Class has no symbol\", undefined, atLocation)\n                    const type = typeChecker.getTypeOfSymbol(classSym)\n                    const tagType = yield* contextTag(type, atLocation)\n                    return {\n                      className: atLocation.name,\n                      selfTypeNode,\n                      keyStringLiteral: ts.isStringLiteral(contextTagCall.arguments[0])\n                        ? contextTagCall.arguments[0]\n                        : undefined,\n                      args: contextTagCall.arguments,\n                      Identifier: tagType.Identifier,\n                      Tag: parsedContextModule.value\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Context.Tag\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsContextTag\",\n    (atLocation) => atLocation\n  )\n\n  const extendsEffectTag = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsEffectTag\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      const classSym = typeChecker.getSymbolAtLocation(atLocation.name)\n      if (!classSym) return yield* typeParserIssue(\"Class has no symbol\", undefined, atLocation)\n      const type = typeChecker.getTypeOfSymbol(classSym)\n      const tagType = yield* contextTag(type, atLocation)\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            const wholeCall = typeX.expression\n            if (ts.isCallExpression(wholeCall)) {\n              const effectTagCall = wholeCall.expression\n              if (\n                ts.isCallExpression(effectTagCall) &&\n                wholeCall.typeArguments && wholeCall.typeArguments.length > 0\n              ) {\n                const effectTagIdentifier = effectTagCall.expression\n                const selfTypeNode = wholeCall.typeArguments[0]!\n                const isEffectTag = yield* pipe(\n                  isNodeReferenceToEffectModuleApi(\"Tag\")(effectTagIdentifier),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectTag)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode,\n                    keyStringLiteral: ts.isStringLiteral(effectTagCall.arguments[0])\n                      ? effectTagCall.arguments[0]\n                      : undefined,\n                    args: effectTagCall.arguments,\n                    Identifier: tagType.Identifier,\n                    Service: tagType.Service\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Effect.Tag\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsEffectTag\",\n    (atLocation) => atLocation\n  )\n\n  const extendsEffectService = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsEffectService\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            const wholeCall = typeX.expression\n            if (ts.isCallExpression(wholeCall)) {\n              const effectServiceCall = wholeCall.expression\n              if (\n                ts.isCallExpression(effectServiceCall) &&\n                effectServiceCall.typeArguments && effectServiceCall.typeArguments.length > 0\n              ) {\n                const effectServiceIdentifier = effectServiceCall.expression\n                const selfTypeNode = effectServiceCall.typeArguments[0]!\n                const isEffectService = yield* pipe(\n                  isNodeReferenceToEffectModuleApi(\"Service\")(effectServiceIdentifier),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectService)) {\n                  const classSym = typeChecker.getSymbolAtLocation(atLocation.name)\n                  if (!classSym) return yield* typeParserIssue(\"Class has no symbol\", undefined, atLocation)\n                  const type = typeChecker.getTypeOfSymbol(classSym)\n                  const parsedContextTag = yield* pipe(\n                    contextTag(type, atLocation),\n                    Nano.option\n                  )\n                  if (Option.isSome(parsedContextTag)) {\n                    // try to parse some settings\n                    let accessors: boolean | undefined = undefined\n                    let dependencies: ts.NodeArray<ts.Expression> | undefined = undefined\n                    if (wholeCall.arguments.length >= 2) {\n                      const args = wholeCall.arguments[1]\n                      if (ts.isObjectLiteralExpression(args)) {\n                        for (const property of args.properties) {\n                          if (\n                            ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) &&\n                            ts.idText(property.name) === \"accessors\" && property.initializer &&\n                            property.initializer.kind === ts.SyntaxKind.TrueKeyword\n                          ) {\n                            accessors = true\n                          }\n                          if (\n                            ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) &&\n                            ts.idText(property.name) === \"dependencies\" && property.initializer &&\n                            ts.isArrayLiteralExpression(property.initializer)\n                          ) {\n                            dependencies = property.initializer.elements\n                          }\n                        }\n                      }\n                    }\n                    return ({\n                      ...parsedContextTag.value,\n                      className: atLocation.name,\n                      selfTypeNode,\n                      args: wholeCall.arguments,\n                      keyStringLiteral: ts.isStringLiteral(wholeCall.arguments[0])\n                        ? wholeCall.arguments[0]\n                        : undefined,\n                      options: wholeCall.arguments[1],\n                      accessors,\n                      dependencies\n                    })\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return yield* typeParserIssue(\"Class does not extend Effect.Service\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsEffectService\",\n    (atLocation) => atLocation\n  )\n\n  return {\n    isNodeReferenceToEffectModuleApi,\n    effectType,\n    strictEffectType,\n    layerType,\n    fiberType,\n    effectSubtype,\n    importedEffectModule,\n    effectGen,\n    effectFnUntracedGen,\n    effectFnGen,\n    unnecessaryEffectGen,\n    effectSchemaType,\n    contextTag,\n    pipeableType,\n    pipeCall,\n    scopeType,\n    promiseLike,\n    extendsEffectTag,\n    extendsEffectService,\n    extendsContextTag,\n    extendsSchemaClass,\n    extendsSchemaTaggedClass,\n    extendsSchemaTaggedError,\n    extendsDataTaggedError,\n    extendsDataTaggedClass,\n    extendsSchemaTaggedRequest\n  }\n}\n","import { pipe } from \"effect/Function\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const generate = Nano.fn(\"writeTagClassAccessors.generate\")(function*(\n  sourceFile: ts.SourceFile,\n  service: ts.Type,\n  className: ts.Identifier,\n  atLocation: ts.ClassDeclaration,\n  involvedMembers: Array<{ property: ts.Symbol; propertyType: ts.Type }>\n) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n  const typeParser = yield* Nano.service(TypeParser.TypeParser)\n  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n  const insertLocation = atLocation.members.length > 0 ? atLocation.members[0].pos : atLocation.end - 1\n\n  const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n    sourceFile,\n    \"effect\",\n    \"Effect\"\n  ) || \"Effect\"\n\n  const createFunctionProperty = (\n    className: ts.Identifier,\n    propertyName: string,\n    type: ts.TypeNode,\n    forceAny: boolean\n  ) => {\n    const arrowBody = ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(effectIdentifier),\n        \"andThen\"\n      ),\n      undefined,\n      [\n        ts.factory.createIdentifier(ts.idText(className)),\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [ts.factory.createParameterDeclaration(\n            undefined,\n            undefined,\n            \"_\",\n            undefined,\n            forceAny ? ts.factory.createTypeReferenceNode(\"any\") : undefined\n          )],\n          undefined,\n          undefined,\n          ts.factory.createCallExpression(\n            ts.factory.createPropertyAccessExpression(\n              ts.factory.createIdentifier(\"_\"),\n              propertyName\n            ),\n            undefined,\n            [\n              ts.factory.createSpreadElement(ts.factory.createIdentifier(\"args\"))\n            ]\n          )\n        )\n      ]\n    )\n    return ts.factory.createPropertyDeclaration(\n      [\n        ts.factory.createModifier(ts.SyntaxKind.StaticKeyword),\n        ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword)\n      ],\n      propertyName,\n      undefined,\n      type,\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [ts.factory.createParameterDeclaration(\n          undefined,\n          ts.factory.createToken(ts.SyntaxKind.DotDotDotToken),\n          \"args\",\n          undefined,\n          forceAny ? ts.factory.createArrayTypeNode(ts.factory.createTypeReferenceNode(\"any\")) : undefined\n        )],\n        undefined,\n        undefined,\n        forceAny ? ts.factory.createAsExpression(arrowBody, ts.factory.createTypeReferenceNode(\"any\")) : arrowBody\n      )\n    )\n  }\n\n  const generateReturnType = (type: ts.Type, atLocation: ts.ClassDeclaration, className: ts.Identifier) =>\n    pipe(\n      typeParser.effectType(type, atLocation),\n      Nano.flatMap((returnedEffect) => {\n        // the type is an effect, so we just need to add the service type to the context type\n        const contextType = (returnedEffect.R.flags & ts.TypeFlags.Never) ?\n          ts.factory.createTypeReferenceNode(ts.idText(className)) :\n          ts.factory.createUnionTypeNode(\n            [\n              ts.factory.createTypeReferenceNode(ts.idText(className)),\n              typeChecker.typeToTypeNode(returnedEffect.R, atLocation, ts.NodeBuilderFlags.NoTruncation)!\n            ]\n          )\n\n        const successType = typeChecker.typeToTypeNode(\n          returnedEffect.A,\n          atLocation,\n          ts.NodeBuilderFlags.NoTruncation\n        )\n        if (!successType) return Nano.fail(\"error generating success type\")\n\n        const failureType = typeChecker.typeToTypeNode(\n          returnedEffect.E,\n          atLocation,\n          ts.NodeBuilderFlags.NoTruncation\n        )\n        if (!failureType) return Nano.fail(\"error generating failure type\")\n\n        const typeNode = ts.factory.createTypeReferenceNode(\n          ts.factory.createQualifiedName(\n            ts.factory.createIdentifier(effectIdentifier),\n            ts.factory.createIdentifier(\"Effect\")\n          ),\n          [successType, failureType, contextType]\n        )\n        return Nano.succeed(typeNode)\n      }),\n      Nano.orElse(() =>\n        pipe(\n          typeParser.promiseLike(type, atLocation),\n          Nano.flatMap(({ type }) => {\n            const successType = typeChecker.typeToTypeNode(\n              type,\n              atLocation,\n              ts.NodeBuilderFlags.NoTruncation\n            )\n            if (!successType) return Nano.fail(\"error generating success type\")\n            return Nano.succeed(ts.factory.createTypeReferenceNode(\n              ts.factory.createQualifiedName(\n                ts.factory.createIdentifier(effectIdentifier),\n                ts.factory.createIdentifier(\"Effect\")\n              ),\n              [\n                successType,\n                ts.factory.createTypeReferenceNode(\n                  ts.factory.createQualifiedName(\n                    ts.factory.createIdentifier(\"Cause\"),\n                    ts.factory.createIdentifier(\"UnknownException\")\n                  )\n                ),\n                ts.factory.createTypeReferenceNode(ts.idText(className))\n              ]\n            ))\n          })\n        )\n      ),\n      Nano.orElse(() => {\n        // fallback to just converting A into a Effect<A, never, Service>\n        const successType = typeChecker.typeToTypeNode(type, atLocation, ts.NodeBuilderFlags.NoTruncation)\n        if (!successType) return Nano.fail(\"error generating success type\")\n        const typeNode = ts.factory.createTypeReferenceNode(\n          ts.factory.createQualifiedName(\n            ts.factory.createIdentifier(effectIdentifier),\n            ts.factory.createIdentifier(\"Effect\")\n          ),\n          [\n            successType,\n            ts.factory.createTypeReferenceNode(\"never\"),\n            ts.factory.createTypeReferenceNode(ts.idText(className))\n          ]\n        )\n\n        return Nano.succeed(typeNode)\n      })\n    )\n\n  const proxySignature = (signature: ts.Signature, atLocation: ts.ClassDeclaration, className: ts.Identifier) =>\n    Nano.gen(function*() {\n      // generate the signature\n      const signatureDeclaration = typeChecker.signatureToSignatureDeclaration(\n        signature,\n        ts.SyntaxKind.FunctionType,\n        atLocation,\n        ts.NodeBuilderFlags.NoTruncation\n      )\n\n      if (!signatureDeclaration) return yield* Nano.fail(\"error generating signature\")\n\n      // wrap the return type as it would be in a Effect.andThen\n      const returnType = yield* generateReturnType(\n        typeChecker.getReturnTypeOfSignature(signature),\n        atLocation,\n        className\n      )\n\n      // construct the new signature\n      return ts.factory.createFunctionTypeNode(\n        signatureDeclaration.typeParameters,\n        signatureDeclaration.parameters,\n        returnType\n      )\n    })\n\n  for (const { property, propertyType } of involvedMembers) {\n    const callSignatures: Array<ts.FunctionTypeNode> = []\n    let propertyDeclaration: ts.PropertyDeclaration | undefined = undefined\n    for (const signature of typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)) {\n      yield* pipe(\n        proxySignature(signature, atLocation, className),\n        Nano.map((sig) => {\n          callSignatures.push(sig)\n        }),\n        Nano.ignore\n      )\n    }\n    // this is a call signature:\n    // static method: <A>(value: A) => Effect<A, never, Service> = (value) => Effect.andThen(Service, _ => _.method(value))\n    const allSignatures = ts.factory.createIntersectionTypeNode(callSignatures)\n    const type = tsUtils.simplifyTypeNode(allSignatures)\n    propertyDeclaration = createFunctionProperty(className, ts.symbolName(property), type, callSignatures.length > 1)\n\n    // then we need to delete the old property (if present)\n    const oldProperty = atLocation.members.filter(ts.isPropertyDeclaration).find((p) => {\n      const symbol = typeChecker.getSymbolAtLocation(p.name)\n      return symbol && ts.symbolName(symbol) === ts.symbolName(property)\n    })\n    if (oldProperty) {\n      const start = ts.getTokenPosOfNode(oldProperty, sourceFile)\n      changeTracker.deleteRange(sourceFile, {\n        pos: start,\n        end: oldProperty.end\n      })\n      changeTracker.insertNodeAt(sourceFile, start, propertyDeclaration)\n    } else {\n      changeTracker.insertNodeAt(sourceFile, insertLocation, propertyDeclaration, { suffix: \"\\n\" })\n    }\n  }\n})\n\nexport const parse = Nano.fn(\"writeTagClassAccessors.parse\")(function*(node: ts.Node) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n  const typeParser = yield* Nano.service(TypeParser.TypeParser)\n  const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n  // only applicable to class declarations\n  if (!ts.isClassDeclaration(node)) return yield* Nano.fail(\"not a class declaration\")\n\n  const { Service, accessors, className } = yield* pipe(\n    typeParser.extendsEffectService(node),\n    Nano.orElse(() => Nano.map(typeParser.extendsEffectTag(node), (_) => ({ accessors: true, ..._ }))),\n    Nano.orElse(() => Nano.fail(\"not a class extending Effect.Service call\"))\n  )\n  if (accessors !== true) return yield* Nano.fail(\"accessors are not enabled in the Effect.Service call\")\n\n  const involvedMembers: Array<{ property: ts.Symbol; propertyType: ts.Type }> = []\n\n  const nonPrimitiveServices = typeCheckerUtils.unrollUnionMembers(Service).filter((_) =>\n    !((_.flags & ts.TypeFlags.Number) || (_.flags & ts.TypeFlags.String) || (_.flags & ts.TypeFlags.Boolean) ||\n      (_.flags & ts.TypeFlags.Literal))\n  )\n\n  if (nonPrimitiveServices.length === 0) return yield* Nano.fail(\"Service type is a primitive type\")\n\n  for (const serviceShape of nonPrimitiveServices) {\n    for (const property of typeChecker.getPropertiesOfType(serviceShape)) {\n      const propertyType = typeChecker.getTypeOfSymbolAtLocation(property, node)\n      const callSignatures = typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)\n      if (callSignatures.length > 0) {\n        const withTypeParameters = callSignatures.filter((_) => _.typeParameters && _.typeParameters.length > 0)\n        if (callSignatures.length > 1 || withTypeParameters.length > 0) involvedMembers.push({ property, propertyType })\n      }\n    }\n  }\n\n  const hash = involvedMembers.map(({ property, propertyType }) => {\n    return ts.symbolName(property) + \": \" + typeChecker.typeToString(propertyType)\n  }).concat([ts.idText(className)]).join(\"\\n\")\n\n  return { Service, className, atLocation: node, hash: LSP.cyrb53(hash), involvedMembers }\n})\n\nexport const writeTagClassAccessors = LSP.createRefactor({\n  name: \"writeTagClassAccessors\",\n  description: \"Implement accessors methods with generics or multiple signatures\",\n  apply: Nano.fn(\"writeTagClassAccessors.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const parseNode = (node: ts.Node) =>\n      pipe(\n        parse(node),\n        Nano.map(({ Service, atLocation, className, involvedMembers }) => ({\n          kind: \"refactor.rewrite.effect.writeTagClassAccessors\",\n          description: \"Implement Service accessors\",\n          apply: pipe(\n            generate(sourceFile, Service, className, atLocation, involvedMembers),\n            Nano.provideService(TypeScriptUtils.TypeScriptUtils, tsUtils),\n            Nano.provideService(TypeParser.TypeParser, typeParser),\n            Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker),\n            Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n          )\n        }))\n      )\n\n    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange)\n\n    return yield* pipe(\n      Nano.firstSuccessOf(parentNodes.map(parseNode)),\n      Nano.orElse(() => Nano.fail(new LSP.RefactorNotApplicableError()))\n    )\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\nimport * as refactor from \"../refactors/writeTagClassAccessors.js\"\n\nexport const accessors = LSP.createCodegen({\n  name: \"accessors\",\n  apply: Nano.fn(\"accessors.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos)\n    if (!nodeAndCommentRange) return yield* Nano.fail(new LSP.CodegenNotApplicableError(\"no node and comment range\"))\n\n    return yield* pipe(\n      refactor.parse(nodeAndCommentRange.node),\n      Nano.map((_) =>\n        ({\n          hash: _.hash,\n          description: \"Generate accessors for the service\",\n          apply: pipe(\n            refactor.generate(sourceFile, _.Service, _.className, _.atLocation, _.involvedMembers),\n            Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n            Nano.provideService(TypeScriptUtils.TypeScriptUtils, tsUtils),\n            Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker),\n            Nano.provideService(TypeParser.TypeParser, typeParser),\n            Nano.provideService(TypeCheckerUtils.TypeCheckerUtils, typeCheckerUtils)\n          )\n        }) satisfies LSP.ApplicableCodegenDefinition\n      ),\n      Nano.orElse((cause) => Nano.fail(new LSP.CodegenNotApplicableError(cause)))\n    )\n  })\n})\n","import { accessors } from \"./codegens/accessors.js\"\n\nexport const codegens = [accessors]\n","import * as Array from \"effect/Array\"\nimport * as Order from \"effect/Order\"\nimport type * as ts from \"typescript\"\nimport { codegens } from \"../codegens\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\n\nexport const effectCodegensComment = LSP.createCompletion({\n  name: \"effectCodegensComment\",\n  apply: Nano.fn(\"effectCodegensComment\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n    // get the source text\n    const sourceText = sourceFile.text\n\n    // autocomplete the comment to disable the diagnostics\n    const match = (/(\\/\\/|\\/\\*(?:\\*?))\\s*(@)\\s*$/id).exec(sourceText.substring(0, position))\n    if (match && match.indices) {\n      const lastIndex = match.indices[2][0]\n      const replacementSpan: ts.TextSpan = {\n        start: lastIndex,\n        length: Math.max(0, position - lastIndex)\n      }\n\n      const allCodegens = Array.sort(Object.values(codegens).map((codegen) => codegen.name), Order.string)\n        .join(\",\")\n      const enableSnippet = \"${1|\" + allCodegens + \"|} $0\"\n\n      return [{\n        name: `@effect-codegens`,\n        kind: ts.ScriptElementKind.string,\n        insertText: \"@effect-codegens \" + enableSnippet,\n        isSnippet: true,\n        replacementSpan\n      }]\n    }\n\n    return []\n  })\n})\n","import * as KeyBuilder from \"../core/KeyBuilder.js\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const effectDataClasses = LSP.createCompletion({\n  name: \"effectDataClasses\",\n  apply: Nano.fn(\"effectDataClasses\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position)\n    if (!maybeInfos) return []\n    const { accessedObject, className, replacementSpan } = maybeInfos\n\n    // first, given the position, we go back\n    const effectDataIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Data\"\n    ) || \"Data\"\n\n    // ensure accessed is an identifier\n    if (effectDataIdentifier !== ts.idText(accessedObject)) return []\n    const name = ts.idText(className)\n\n    // create the expected identifier\n    const errorTagKey = (yield* KeyBuilder.createString(sourceFile, name, \"error\")) || name\n\n    return [{\n      name: `TaggedError(\"${name}\")`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${effectDataIdentifier}.TaggedError(\"${errorTagKey}\")<{${\"${0}\"}}>{}`,\n      replacementSpan,\n      isSnippet: true\n    }, {\n      name: `TaggedClass(\"${name}\")`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${effectDataIdentifier}.TaggedClass(\"${name}\")<{${\"${0}\"}}>{}`,\n      replacementSpan,\n      isSnippet: true\n    }] satisfies Array<LSP.CompletionEntryDefinition>\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const catchUnfailableEffect = LSP.createDiagnostic({\n  name: \"catchUnfailableEffect\",\n  code: 2,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"catchUnfailableEffect.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // Check if this is a call expression (cold expression)\n      if (ts.isCallExpression(node)) {\n        // Check if the call expression references any of the catch functions\n        const catchFunctions = [\"catchAll\", \"catch\", \"catchIf\", \"catchSome\", \"catchTag\", \"catchTags\"]\n        const isCatchCall = yield* pipe(\n          Nano.firstSuccessOf(\n            catchFunctions.map((catchFn) => typeParser.isNodeReferenceToEffectModuleApi(catchFn)(node.expression))\n          ),\n          Nano.option\n        )\n\n        if (Option.isSome(isCatchCall)) {\n          // Check if the parent is a pipe call\n          const parent = node.parent\n          if (parent && ts.isCallExpression(parent)) {\n            const pipeCallResult = yield* pipe(\n              typeParser.pipeCall(parent),\n              Nano.option\n            )\n\n            if (Option.isSome(pipeCallResult)) {\n              const { args, node: pipeCallNode, subject } = pipeCallResult.value\n\n              // Find the index of this node in the pipe arguments\n              const argIndex = args.findIndex((arg) => arg === node)\n\n              if (argIndex !== -1) {\n                let effectTypeToCheck: ts.Type | undefined\n\n                // Get the effect type based on argument index\n                if (argIndex === 0) {\n                  // If argIndex is 0, get the type from the subject\n                  effectTypeToCheck = typeChecker.getTypeAtLocation(subject)\n                } else {\n                  // If argIndex > 0, get the type from signature type arguments at argIndex\n                  const signature = typeChecker.getResolvedSignature(pipeCallNode)\n                  if (signature) {\n                    const typeArguments = typeChecker.getTypeArgumentsForResolvedSignature(signature)\n                    if (typeArguments && typeArguments.length > argIndex) {\n                      effectTypeToCheck = typeArguments[argIndex]\n                    }\n                  }\n                }\n\n                // Check if the effect type has error type never\n                if (effectTypeToCheck) {\n                  const effectType = yield* pipe(\n                    typeParser.effectType(effectTypeToCheck, node),\n                    Nano.option\n                  )\n\n                  // Only report if we successfully parsed an effect type and E is never\n                  if (Option.isSome(effectType)) {\n                    const { E } = effectType.value\n\n                    // Only report if E is exactly never\n                    if (E.flags & ts.TypeFlags.Never) {\n                      report({\n                        location: node.expression,\n                        messageText:\n                          `Looks like the previous effect never fails, so probably this error handling will never be triggered.`,\n                        fixes: []\n                      })\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  })\n})\n","/**\n * @since 2.0.0\n */\nimport * as RA from \"./Array.js\"\nimport type { NonEmptyReadonlyArray } from \"./Array.js\"\nimport type { Either } from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport { dual, identity, pipe } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport { format, type Inspectable, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport type { NonEmptyIterable } from \"./NonEmptyIterable.js\"\nimport type { Option } from \"./Option.js\"\nimport * as O from \"./Option.js\"\nimport * as Order from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty, type Predicate, type Refinement } from \"./Predicate.js\"\nimport type { Covariant, NoInfer } from \"./Types.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/Chunk\") as TypeId\n\n/**\n * @category symbol\n * @since 2.0.0\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Chunk<out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  readonly length: number\n  /** @internal */\n  right: Chunk<A>\n  /** @internal */\n  left: Chunk<A>\n  /** @internal */\n  backing: Backing<A>\n  /** @internal */\n  depth: number\n}\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport interface NonEmptyChunk<out A> extends Chunk<A>, NonEmptyIterable<A> {}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface ChunkTypeLambda extends TypeLambda {\n  readonly type: Chunk<this[\"Target\"]>\n}\n\ntype Backing<A> =\n  | IArray<A>\n  | IConcat<A>\n  | ISingleton<A>\n  | IEmpty\n  | ISlice<A>\n\ninterface IArray<A> {\n  readonly _tag: \"IArray\"\n  readonly array: ReadonlyArray<A>\n}\n\ninterface IConcat<A> {\n  readonly _tag: \"IConcat\"\n  readonly left: Chunk<A>\n  readonly right: Chunk<A>\n}\n\ninterface ISingleton<A> {\n  readonly _tag: \"ISingleton\"\n  readonly a: A\n}\n\ninterface IEmpty {\n  readonly _tag: \"IEmpty\"\n}\n\ninterface ISlice<A> {\n  readonly _tag: \"ISlice\"\n  readonly chunk: Chunk<A>\n  readonly offset: number\n  readonly length: number\n}\n\nfunction copy<A>(\n  src: ReadonlyArray<A>,\n  srcPos: number,\n  dest: Array<A>,\n  destPos: number,\n  len: number\n) {\n  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {\n    dest[destPos + i - srcPos] = src[i]!\n  }\n  return dest\n}\n\nconst emptyArray: ReadonlyArray<never> = []\n\n/**\n * Compares the two chunks of equal length using the specified function\n *\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <A>(isEquivalent: Equivalence.Equivalence<A>): Equivalence.Equivalence<Chunk<A>> =>\n  Equivalence.make((self, that) =>\n    self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet(that, i)))\n  )\n\nconst _equivalence = getEquivalence(Equal.equals)\n\nconst ChunkProto: Omit<Chunk<unknown>, \"backing\" | \"depth\" | \"left\" | \"length\" | \"right\"> = {\n  [TypeId]: {\n    _A: (_: never) => _\n  },\n  toString<A>(this: Chunk<A>) {\n    return format(this.toJSON())\n  },\n  toJSON<A>(this: Chunk<A>) {\n    return {\n      _id: \"Chunk\",\n      values: toReadonlyArray(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]<A>(this: Chunk<A>) {\n    return this.toJSON()\n  },\n  [Equal.symbol]<A>(this: Chunk<A>, that: unknown): boolean {\n    return isChunk(that) && _equivalence(this, that)\n  },\n  [Hash.symbol]<A>(this: Chunk<A>): number {\n    return Hash.cached(this, Hash.array(toReadonlyArray(this)))\n  },\n  [Symbol.iterator]<A>(this: Chunk<A>): Iterator<A> {\n    switch (this.backing._tag) {\n      case \"IArray\": {\n        return this.backing.array[Symbol.iterator]()\n      }\n      case \"IEmpty\": {\n        return emptyArray[Symbol.iterator]()\n      }\n      default: {\n        return toReadonlyArray(this)[Symbol.iterator]()\n      }\n    }\n  },\n  pipe<A>(this: Chunk<A>) {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst makeChunk = <A>(backing: Backing<A>): Chunk<A> => {\n  const chunk = Object.create(ChunkProto)\n  chunk.backing = backing\n  switch (backing._tag) {\n    case \"IEmpty\": {\n      chunk.length = 0\n      chunk.depth = 0\n      chunk.left = chunk\n      chunk.right = chunk\n      break\n    }\n    case \"IConcat\": {\n      chunk.length = backing.left.length + backing.right.length\n      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth)\n      chunk.left = backing.left\n      chunk.right = backing.right\n      break\n    }\n    case \"IArray\": {\n      chunk.length = backing.array.length\n      chunk.depth = 0\n      chunk.left = _empty\n      chunk.right = _empty\n      break\n    }\n    case \"ISingleton\": {\n      chunk.length = 1\n      chunk.depth = 0\n      chunk.left = _empty\n      chunk.right = _empty\n      break\n    }\n    case \"ISlice\": {\n      chunk.length = backing.length\n      chunk.depth = backing.chunk.depth + 1\n      chunk.left = _empty\n      chunk.right = _empty\n      break\n    }\n  }\n  return chunk\n}\n\n/**\n * Checks if `u` is a `Chunk<unknown>`\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const isChunk: {\n  /**\n   * Checks if `u` is a `Chunk<unknown>`\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(u: Iterable<A>): u is Chunk<A>\n  /**\n   * Checks if `u` is a `Chunk<unknown>`\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  (u: unknown): u is Chunk<unknown>\n} = (u: unknown): u is Chunk<unknown> => hasProperty(u, TypeId)\n\nconst _empty = makeChunk<never>({ _tag: \"IEmpty\" })\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty: <A = never>() => Chunk<A> = () => _empty\n\n/**\n * Builds a `NonEmptyChunk` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <As extends readonly [any, ...ReadonlyArray<any>]>(...as: As): NonEmptyChunk<As[number]> =>\n  unsafeFromNonEmptyArray(as)\n\n/**\n * Builds a `NonEmptyChunk` from a single element.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = <A>(a: A): NonEmptyChunk<A> => makeChunk({ _tag: \"ISingleton\", a }) as any\n\n/**\n * Creates a new `Chunk` from an iterable collection of values.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = <A>(self: Iterable<A>): Chunk<A> =>\n  isChunk(self) ? self : unsafeFromArray(RA.fromIterable(self))\n\nconst copyToArray = <A>(self: Chunk<A>, array: Array<any>, initial: number): void => {\n  switch (self.backing._tag) {\n    case \"IArray\": {\n      copy(self.backing.array, 0, array, initial, self.length)\n      break\n    }\n    case \"IConcat\": {\n      copyToArray(self.left, array, initial)\n      copyToArray(self.right, array, initial + self.left.length)\n      break\n    }\n    case \"ISingleton\": {\n      array[initial] = self.backing.a\n      break\n    }\n    case \"ISlice\": {\n      let i = 0\n      let j = initial\n      while (i < self.length) {\n        array[j] = unsafeGet(self, i)\n        i += 1\n        j += 1\n      }\n      break\n    }\n  }\n}\n\nconst toArray_ = <A>(self: Chunk<A>): Array<A> => toReadonlyArray(self).slice()\n\n/**\n * Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty\n * (`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the\n * non-empty property is preserved.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray: <S extends Chunk<any>>(\n  self: S\n) => S extends NonEmptyChunk<any> ? RA.NonEmptyArray<Chunk.Infer<S>> : Array<Chunk.Infer<S>> = toArray_ as any\n\nconst toReadonlyArray_ = <A>(self: Chunk<A>): ReadonlyArray<A> => {\n  switch (self.backing._tag) {\n    case \"IEmpty\": {\n      return emptyArray\n    }\n    case \"IArray\": {\n      return self.backing.array\n    }\n    default: {\n      const arr = new Array<A>(self.length)\n      copyToArray(self, arr, 0)\n      self.backing = {\n        _tag: \"IArray\",\n        array: arr\n      }\n      self.left = _empty\n      self.right = _empty\n      self.depth = 0\n      return arr\n    }\n  }\n}\n\n/**\n * Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is\n * non-empty (`NonEmptyChunk`), the function will return a\n * `NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toReadonlyArray: <S extends Chunk<any>>(\n  self: S\n) => S extends NonEmptyChunk<any> ? RA.NonEmptyReadonlyArray<Chunk.Infer<S>> : ReadonlyArray<Chunk.Infer<S>> =\n  toReadonlyArray_ as any\n\nconst reverseChunk = <A>(self: Chunk<A>): Chunk<A> => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n    case \"ISingleton\":\n      return self\n    case \"IArray\": {\n      return makeChunk({ _tag: \"IArray\", array: RA.reverse(self.backing.array) })\n    }\n    case \"IConcat\": {\n      return makeChunk({ _tag: \"IConcat\", left: reverse(self.backing.right), right: reverse(self.backing.left) })\n    }\n    case \"ISlice\":\n      return unsafeFromArray(RA.reverse(toReadonlyArray(self)))\n  }\n}\n\n/**\n * Reverses the order of elements in a `Chunk`.\n * Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const chunk = Chunk.make(1, 2, 3)\n * const result = Chunk.reverse(chunk)\n *\n * console.log(result)\n * // { _id: 'Chunk', values: [ 3, 2, 1 ] }\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reverse: <S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>> = reverseChunk as any\n\n/**\n * This function provides a safe way to read a value at a particular index from a `Chunk`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const get: {\n  /**\n   * This function provides a safe way to read a value at a particular index from a `Chunk`.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  (index: number): <A>(self: Chunk<A>) => Option<A>\n  /**\n   * This function provides a safe way to read a value at a particular index from a `Chunk`.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, index: number): Option<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, index: number): Option<A> =>\n    index < 0 || index >= self.length ? O.none() : O.some(unsafeGet(self, index))\n)\n\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeFromArray = <A>(self: ReadonlyArray<A>): Chunk<A> =>\n  self.length === 0 ? empty() : self.length === 1 ? of(self[0]) : makeChunk({ _tag: \"IArray\", array: self })\n\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeFromNonEmptyArray = <A>(self: NonEmptyReadonlyArray<A>): NonEmptyChunk<A> =>\n  unsafeFromArray(self) as any\n\n/**\n * Gets an element unsafely, will throw on out of bounds\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet: {\n  /**\n   * Gets an element unsafely, will throw on out of bounds\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  (index: number): <A>(self: Chunk<A>) => A\n  /**\n   * Gets an element unsafely, will throw on out of bounds\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <A>(self: Chunk<A>, index: number): A\n} = dual(2, <A>(self: Chunk<A>, index: number): A => {\n  switch (self.backing._tag) {\n    case \"IEmpty\": {\n      throw new Error(`Index out of bounds`)\n    }\n    case \"ISingleton\": {\n      if (index !== 0) {\n        throw new Error(`Index out of bounds`)\n      }\n      return self.backing.a\n    }\n    case \"IArray\": {\n      if (index >= self.length || index < 0) {\n        throw new Error(`Index out of bounds`)\n      }\n      return self.backing.array[index]!\n    }\n    case \"IConcat\": {\n      return index < self.left.length\n        ? unsafeGet(self.left, index)\n        : unsafeGet(self.right, index - self.left.length)\n    }\n    case \"ISlice\": {\n      return unsafeGet(self.backing.chunk, index + self.backing.offset)\n    }\n  }\n})\n\n/**\n * Appends the specified element to the end of the `Chunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append: {\n  /**\n   * Appends the specified element to the end of the `Chunk`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>\n  /**\n   * Appends the specified element to the end of the `Chunk`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>\n} = dual(2, <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2> => appendAll(self, of(a)))\n\n/**\n * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend: {\n  /**\n   * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>\n  /**\n   * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>\n} = dual(2, <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B> => appendAll(of(elem), self))\n\n/**\n * Takes the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nexport const take: {\n  /**\n   * Takes the first up to `n` elements from the chunk\n   *\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Takes the first up to `n` elements from the chunk\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, n: number): Chunk<A> => {\n  if (n <= 0) {\n    return _empty\n  } else if (n >= self.length) {\n    return self\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\": {\n        return makeChunk({\n          _tag: \"ISlice\",\n          chunk: self.backing.chunk,\n          length: n,\n          offset: self.backing.offset\n        })\n      }\n      case \"IConcat\": {\n        if (n > self.left.length) {\n          return makeChunk({\n            _tag: \"IConcat\",\n            left: self.left,\n            right: take(self.right, n - self.left.length)\n          })\n        }\n\n        return take(self.left, n)\n      }\n      default: {\n        return makeChunk({\n          _tag: \"ISlice\",\n          chunk: self,\n          offset: 0,\n          length: n\n        })\n      }\n    }\n  }\n})\n\n/**\n * Drops the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nexport const drop: {\n  /**\n   * Drops the first up to `n` elements from the chunk\n   *\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Drops the first up to `n` elements from the chunk\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, n: number): Chunk<A> => {\n  if (n <= 0) {\n    return self\n  } else if (n >= self.length) {\n    return _empty\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\": {\n        return makeChunk({\n          _tag: \"ISlice\",\n          chunk: self.backing.chunk,\n          offset: self.backing.offset + n,\n          length: self.backing.length - n\n        })\n      }\n      case \"IConcat\": {\n        if (n > self.left.length) {\n          return drop(self.right, n - self.left.length)\n        }\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: drop(self.left, n),\n          right: self.right\n        })\n      }\n      default: {\n        return makeChunk({\n          _tag: \"ISlice\",\n          chunk: self,\n          offset: n,\n          length: self.length - n\n        })\n      }\n    }\n  }\n})\n\n/**\n * Drops the last `n` elements.\n *\n * @since 2.0.0\n */\nexport const dropRight: {\n  /**\n   * Drops the last `n` elements.\n   *\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Drops the last `n` elements.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, n: number): Chunk<A> => take(self, Math.max(0, self.length - n)))\n\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n */\nexport const dropWhile: {\n  /**\n   * Drops all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * Drops all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A> => {\n  const arr = toReadonlyArray(self)\n  const len = arr.length\n  let i = 0\n  while (i < len && predicate(arr[i]!)) {\n    i++\n  }\n  return drop(self, i)\n})\n\n/**\n * Prepends the specified prefix chunk to the beginning of the specified chunk.\n * If either chunk is non-empty, the result is also a non-empty chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n *\n * console.log(result)\n * // [ \"a\", \"b\", 1, 2 ]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll: {\n  /**\n   * Prepends the specified prefix chunk to the beginning of the specified chunk.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ \"a\", \"b\", 1, 2 ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>\n  /**\n   * Prepends the specified prefix chunk to the beginning of the specified chunk.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ \"a\", \"b\", 1, 2 ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>\n  /**\n   * Prepends the specified prefix chunk to the beginning of the specified chunk.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ \"a\", \"b\", 1, 2 ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>\n  /**\n   * Prepends the specified prefix chunk to the beginning of the specified chunk.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ \"a\", \"b\", 1, 2 ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>\n} = dual(2, <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): Chunk<A | B> => appendAll(that, self))\n\n/**\n * Concatenates two chunks, combining their elements.\n * If either chunk is non-empty, the result is also a non-empty chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n *\n * console.log(result)\n * // [ 1, 2, \"a\", \"b\" ]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll: {\n  /**\n   * Concatenates two chunks, combining their elements.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ 1, 2, \"a\", \"b\" ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>\n  /**\n   * Concatenates two chunks, combining their elements.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ 1, 2, \"a\", \"b\" ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>\n  /**\n   * Concatenates two chunks, combining their elements.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ 1, 2, \"a\", \"b\" ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>\n  /**\n   * Concatenates two chunks, combining their elements.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ 1, 2, \"a\", \"b\" ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>\n} = dual(2, <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B> => {\n  if (self.backing._tag === \"IEmpty\") {\n    return that\n  }\n  if (that.backing._tag === \"IEmpty\") {\n    return self\n  }\n  const diff = that.depth - self.depth\n  if (Math.abs(diff) <= 1) {\n    return makeChunk</**\n     * Concatenates two chunks, combining their elements.\n     * If either chunk is non-empty, the result is also a non-empty chunk.\n     *\n     * **Example**\n     *\n     * ```ts\n     * import { Chunk } from \"effect\"\n     *\n     * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n     *\n     * console.log(result)\n     * // [ 1, 2, \"a\", \"b\" ]\n     * ```\n     *\n     * @category concatenating\n     * @since 2.0.0\n     */\n    A | B>({ _tag: \"IConcat\", left: self, right: that });\n  } else if (diff < -1) {\n    if (self.left.depth >= self.right.depth) {\n      const nr = appendAll(self.right, that)\n      return makeChunk({ _tag: \"IConcat\", left: self.left, right: nr })\n    } else {\n      const nrr = appendAll(self.right.right, that)\n      if (nrr.depth === self.depth - 3) {\n        const nr = makeChunk({ _tag: \"IConcat\", left: self.right.left, right: nrr })\n        return makeChunk({ _tag: \"IConcat\", left: self.left, right: nr })\n      } else {\n        const nl = makeChunk({ _tag: \"IConcat\", left: self.left, right: self.right.left })\n        return makeChunk({ _tag: \"IConcat\", left: nl, right: nrr })\n      }\n    }\n  } else {\n    if (that.right.depth >= that.left.depth) {\n      const nl = appendAll(self, that.left)\n      return makeChunk({ _tag: \"IConcat\", left: nl, right: that.right })\n    } else {\n      const nll = appendAll(self, that.left.left)\n      if (nll.depth === that.depth - 3) {\n        const nl = makeChunk({ _tag: \"IConcat\", left: nll, right: that.left.right })\n        return makeChunk({ _tag: \"IConcat\", left: nl, right: that.right })\n      } else {\n        const nr = makeChunk({ _tag: \"IConcat\", left: that.left.right, right: that.right })\n        return makeChunk({ _tag: \"IConcat\", left: nll, right: nr })\n      }\n    }\n  }\n})\n\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMap: {\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>\n} = dual(\n  2,\n  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B> => unsafeFromArray(RA.filterMap(self, f))\n)\n\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter: {\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A> => unsafeFromArray(RA.filter(self, predicate))\n)\n\n/**\n * Transforms all elements of the chunk for as long as the specified function returns some value\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMapWhile: {\n  /**\n   * Transforms all elements of the chunk for as long as the specified function returns some value\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>\n  /**\n   * Transforms all elements of the chunk for as long as the specified function returns some value\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>\n} = dual(2, <A, B>(self: Chunk<A>, f: (a: A) => Option<B>) => unsafeFromArray(RA.filterMapWhile(self, f)))\n\n/**\n * Filter out optional values\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const compact = <A>(self: Chunk<Option<A>>): Chunk<A> => filterMap(self, identity)\n\n/**\n * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap: {\n  /**\n   * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <S extends Chunk<any>, T extends Chunk<any>>(f: (a: Chunk.Infer<S>, i: number) => T): (self: S) => Chunk.AndNonEmpty<S, T, Chunk.Infer<T>>\n  /**\n   * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => NonEmptyChunk<B>): NonEmptyChunk<B>\n  /**\n   * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>): Chunk<B>\n} = dual(2, <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>) => {\n  if (self.backing._tag === \"ISingleton\") {\n    return f(self.backing.a, 0)\n  }\n  let out: Chunk<B> = _empty\n  let i = 0\n  for (const k of self) {\n    out = appendAll(out, f(k, i++))\n  }\n  return out\n})\n\n/**\n * Iterates over each element of a `Chunk` and applies a function to it.\n *\n * **Details**\n *\n * This function processes every element of the given `Chunk`, calling the\n * provided function `f` on each element. It does not return a new value;\n * instead, it is primarily used for side effects, such as logging or\n * accumulating data in an external variable.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const forEach: {\n  /**\n   * Iterates over each element of a `Chunk` and applies a function to it.\n   *\n   * **Details**\n   *\n   * This function processes every element of the given `Chunk`, calling the\n   * provided function `f` on each element. It does not return a new value;\n   * instead, it is primarily used for side effects, such as logging or\n   * accumulating data in an external variable.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void\n  /**\n   * Iterates over each element of a `Chunk` and applies a function to it.\n   *\n   * **Details**\n   *\n   * This function processes every element of the given `Chunk`, calling the\n   * provided function `f` on each element. It does not return a new value;\n   * instead, it is primarily used for side effects, such as logging or\n   * accumulating data in an external variable.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void\n} = dual(2, <A, B>(self: Chunk<A>, f: (a: A) => B): void => toReadonlyArray(self).forEach(f))\n\n/**\n * Flattens a chunk of chunks into a single chunk by concatenating all chunks.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatten: <S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S> = flatMap(identity) as any\n\n/**\n * Groups elements in chunks of up to `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const chunksOf: {\n  /**\n   * Groups elements in chunks of up to `n` elements.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>\n  /**\n   * Groups elements in chunks of up to `n` elements.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>\n} = dual(2, <A>(self: Chunk<A>, n: number) => {\n  const gr: Array<Chunk<A>> = []\n  let current: Array<A> = []\n  toReadonlyArray(self).forEach((a) => {\n    current.push(a)\n    if (current.length >= n) {\n      gr.push(unsafeFromArray(current))\n      current = []\n    }\n  })\n  if (current.length > 0) {\n    gr.push(unsafeFromArray(current))\n  }\n  return unsafeFromArray(gr)\n})\n\n/**\n * Creates a Chunk of unique values that are included in all given Chunks.\n *\n * The order and references of result values are determined by the Chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const intersection: {\n  /**\n   * Creates a Chunk of unique values that are included in all given Chunks.\n   *\n   * The order and references of result values are determined by the Chunk.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>\n  /**\n   * Creates a Chunk of unique values that are included in all given Chunks.\n   *\n   * The order and references of result values are determined by the Chunk.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>\n} = dual(\n  2,\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B> =>\n    unsafeFromArray(RA.intersection(toReadonlyArray(self), toReadonlyArray(that)))\n)\n\n/**\n * Determines if the chunk is empty.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEmpty = <A>(self: Chunk<A>): boolean => self.length === 0\n\n/**\n * Determines if the chunk is not empty.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isNonEmpty = <A>(self: Chunk<A>): self is NonEmptyChunk<A> => self.length > 0\n\n/**\n * Returns the first element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const head: <A>(self: Chunk<A>) => Option<A> = get(0)\n\n/**\n * Returns the first element of this chunk.\n *\n * It will throw an error if the chunk is empty.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeHead = <A>(self: Chunk<A>): A => unsafeGet(self, 0)\n\n/**\n * Returns the first element of this non empty chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A = unsafeHead\n\n/**\n * Returns the last element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const last = <A>(self: Chunk<A>): Option<A> => get(self, self.length - 1)\n\n/**\n * Returns the last element of this chunk.\n *\n * It will throw an error if the chunk is empty.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeLast = <A>(self: Chunk<A>): A => unsafeGet(self, self.length - 1)\n\n/**\n * Returns the last element of this non empty chunk.\n *\n * @since 3.4.0\n * @category elements\n */\nexport const lastNonEmpty: <A>(self: NonEmptyChunk<A>) => A = unsafeLast\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Chunk {\n  /**\n   * @since 2.0.0\n   */\n  export type Infer<S extends Chunk<any>> = S extends Chunk<infer A> ? A : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type With<S extends Chunk<any>, A> = S extends NonEmptyChunk<any> ? NonEmptyChunk<A> : Chunk<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type OrNonEmpty<S extends Chunk<any>, T extends Chunk<any>, A> = S extends NonEmptyChunk<any> ?\n    NonEmptyChunk<A>\n    : T extends NonEmptyChunk<any> ? NonEmptyChunk<A>\n    : Chunk<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type AndNonEmpty<S extends Chunk<any>, T extends Chunk<any>, A> = S extends NonEmptyChunk<any> ?\n    T extends NonEmptyChunk<any> ? NonEmptyChunk<A>\n    : Chunk<A> :\n    Chunk<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type Flatten<T extends Chunk<Chunk<any>>> = T extends NonEmptyChunk<NonEmptyChunk<infer A>> ? NonEmptyChunk<A>\n    : T extends Chunk<Chunk<infer A>> ? Chunk<A>\n    : never\n}\n\n/**\n * Transforms the elements of a chunk using the specified mapping function.\n * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n *\n * console.log(result)\n * // { _id: 'Chunk', values: [ 2, 3 ] }\n * ```\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Transforms the elements of a chunk using the specified mapping function.\n   * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n   *\n   * console.log(result)\n   * // { _id: 'Chunk', values: [ 2, 3 ] }\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>\n  /**\n   * Transforms the elements of a chunk using the specified mapping function.\n   * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n   *\n   * console.log(result)\n   * // { _id: 'Chunk', values: [ 2, 3 ] }\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>\n  /**\n   * Transforms the elements of a chunk using the specified mapping function.\n   * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n   *\n   * console.log(result)\n   * // { _id: 'Chunk', values: [ 2, 3 ] }\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>\n} = dual(2, <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B> =>\n  self.backing._tag === \"ISingleton\" ?\n    of(f(self.backing.a, 0)) :\n    unsafeFromArray(pipe(toReadonlyArray(self), RA.map((a, i) => f(a, i)))))\n\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const mapAccum: {\n  /**\n   * Statefully maps over the chunk, producing new elements of type `B`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>]\n  /**\n   * Statefully maps over the chunk, producing new elements of type `B`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>]\n} = dual(3, <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>] => {\n  const [s1, as] = RA.mapAccum(self, s, f)\n  return [s1, unsafeFromArray(as)]\n})\n\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition: {\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: (a: A, i: number) => a is B): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>]\n} = dual(\n  2,\n  <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>] =>\n    pipe(\n      RA.partition(toReadonlyArray(self), predicate),\n      ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]\n    )\n)\n\n/**\n * Partitions the elements of this chunk into two chunks using f.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  /**\n   * Partitions the elements of this chunk into two chunks using f.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]\n  /**\n   * Partitions the elements of this chunk into two chunks using f.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]\n} = dual(2, <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>] =>\n  pipe(\n    RA.partitionMap(toReadonlyArray(self), f),\n    ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]\n  ))\n\n/**\n * Partitions the elements of this chunk into two chunks.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate = <A, B>(self: Chunk<Either<B, A>>): [Chunk<A>, Chunk<B>] =>\n  pipe(\n    RA.separate(toReadonlyArray(self)),\n    ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]\n  )\n\n/**\n * Retireves the size of the chunk\n *\n * @since 2.0.0\n * @category elements\n */\nexport const size = <A>(self: Chunk<A>): number => self.length\n\n/**\n * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n *\n * @since 2.0.0\n * @category sorting\n */\nexport const sort: {\n  /**\n   * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n   *\n   * @since 2.0.0\n   * @category sorting\n   */\n  <B>(O: Order.Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n   *\n   * @since 2.0.0\n   * @category sorting\n   */\n  <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A>\n} = dual(\n  2,\n  <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A> => unsafeFromArray(RA.sort(toReadonlyArray(self), O))\n)\n\n/**\n * @since 2.0.0\n * @category sorting\n */\nexport const sortWith: {\n  /**\n   * @since 2.0.0\n   * @category sorting\n   */\n  <A, B>(f: (a: A) => B, order: Order.Order<B>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * @since 2.0.0\n   * @category sorting\n   */\n  <A, B>(self: Chunk<A>, f: (a: A) => B, order: Order.Order<B>): Chunk<A>\n} = dual(\n  3,\n  <A, B>(self: Chunk<A>, f: (a: A) => B, order: Order.Order<B>): Chunk<A> => sort(self, Order.mapInput(order, f))\n)\n\n/**\n *  Returns two splits of this chunk at the specified index.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const splitAt: {\n  /**\n   *  Returns two splits of this chunk at the specified index.\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]\n  /**\n   *  Returns two splits of this chunk at the specified index.\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]\n} = dual(2, <A>(self: Chunk<A>, n: number): [Chunk<A>, Chunk<A>] => [take(self, n), drop(self, n)])\n\n/**\n * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitNonEmptyAt: {\n  /**\n   * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` must be `>= 1`.\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]\n  /**\n   * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` must be `>= 1`.\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]\n} = dual(2, <A>(self: NonEmptyChunk<A>, n: number): [Chunk<A>, Chunk<A>] => {\n  const _n = Math.max(1, Math.floor(n))\n  return _n >= self.length ?\n    [self, empty()] :\n    [take(self, _n), drop(self, _n)]\n})\n\n/**\n * Splits this chunk into `n` equally sized chunks.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const split: {\n  /**\n   * Splits this chunk into `n` equally sized chunks.\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>\n  /**\n   * Splits this chunk into `n` equally sized chunks.\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>\n} = dual(2, <A>(self: Chunk<A>, n: number) => chunksOf(self, Math.ceil(self.length / Math.floor(n))))\n\n/**\n * Splits this chunk on the first element that matches this predicate.\n * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitWhere: {\n  /**\n   * Splits this chunk on the first element that matches this predicate.\n   * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]\n  /**\n   * Splits this chunk on the first element that matches this predicate.\n   * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]\n} = dual(2, <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>] => {\n  let i = 0\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      break\n    } else {\n      i++\n    }\n  }\n  return splitAt(self, i)\n})\n\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const tail = <A>(self: Chunk<A>): Option<Chunk<A>> => self.length > 0 ? O.some(drop(self, 1)) : O.none()\n\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const tailNonEmpty = <A>(self: NonEmptyChunk<A>): Chunk<A> => drop(self, 1)\n\n/**\n * Takes the last `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const takeRight: {\n  /**\n   * Takes the last `n` elements.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Takes the last `n` elements.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, n: number): Chunk<A> => drop(self, self.length - n))\n\n/**\n * Takes all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const takeWhile: {\n  /**\n   * Takes all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>\n  /**\n   * Takes all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * Takes all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>\n  /**\n   * Takes all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A> => {\n  const out: Array<A> = []\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      out.push(a)\n    } else {\n      break\n    }\n  }\n  return unsafeFromArray(out)\n})\n\n/**\n * Creates a Chunks of unique values, in order, from all given Chunks.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const union: {\n  /**\n   * Creates a Chunks of unique values, in order, from all given Chunks.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>\n  /**\n   * Creates a Chunks of unique values, in order, from all given Chunks.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>\n} = dual(\n  2,\n  <A, B>(self: Chunk<A>, that: Chunk<B>) => unsafeFromArray(RA.union(toReadonlyArray(self), toReadonlyArray(that)))\n)\n\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const dedupe = <A>(self: Chunk<A>): Chunk<A> => unsafeFromArray(RA.dedupe(toReadonlyArray(self)))\n\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const dedupeAdjacent = <A>(self: Chunk<A>): Chunk<A> => unsafeFromArray(RA.dedupeAdjacent(self))\n\n/**\n * Takes a `Chunk` of pairs and return two corresponding `Chunk`s.\n *\n * Note: The function is reverse of `zip`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const unzip = <A, B>(self: Chunk<readonly [A, B]>): [Chunk<A>, Chunk<B>] => {\n  const [left, right] = RA.unzip(self)\n  return [unsafeFromArray(left), unsafeFromArray(right)]\n}\n\n/**\n * Zips this chunk pointwise with the specified chunk using the specified combiner.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith: {\n  /**\n   * Zips this chunk pointwise with the specified chunk using the specified combiner.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>\n  /**\n   * Zips this chunk pointwise with the specified chunk using the specified combiner.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>\n} = dual(\n  3,\n  <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C> =>\n    unsafeFromArray(RA.zipWith(self, that, f))\n)\n\n/**\n * Zips this chunk pointwise with the specified chunk.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * Zips this chunk pointwise with the specified chunk.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>\n  /**\n   * Zips this chunk pointwise with the specified chunk.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]> => zipWith(self, that, (a, b) => [a, b])\n)\n\n/**\n * Delete the element at the specified index, creating a new `Chunk`.\n *\n * @since 2.0.0\n */\nexport const remove: {\n  /**\n   * Delete the element at the specified index, creating a new `Chunk`.\n   *\n   * @since 2.0.0\n   */\n  (i: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Delete the element at the specified index, creating a new `Chunk`.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, i: number): Chunk<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, i: number): Chunk<A> => {\n    if (i < 0 || i >= self.length) return self\n    return unsafeFromArray(RA.remove(toReadonlyArray(self), i))\n  }\n)\n\n/**\n * @since 3.16.0\n */\nexport const removeOption: {\n  /**\n   * @since 3.16.0\n   */\n  (i: number): <A>(self: Chunk<A>) => Option<Chunk<A>>\n  /**\n   * @since 3.16.0\n   */\n  <A>(self: Chunk<A>, i: number): Option<Chunk<A>>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, i: number): Option<Chunk<A>> => {\n    if (i < 0 || i >= self.length) return O.none()\n    return O.some(unsafeFromArray(RA.remove(toReadonlyArray(self), i)))\n  }\n)\n\n/**\n * @since 2.0.0\n */\nexport const modifyOption: {\n  /**\n   * @since 2.0.0\n   */\n  <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Option<Chunk<A | B>>\n  /**\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Option<Chunk<A | B>>\n} = dual(\n  3,\n  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Option<Chunk<A | B>> => {\n    if (i < 0 || i >= self.length) return O.none()\n    return O.some(unsafeFromArray(RA.modify(toReadonlyArray(self), i, f)))\n  }\n)\n\n/**\n * Apply a function to the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const modify: {\n  /**\n   * Apply a function to the element at the specified index, creating a new `Chunk`,\n   * or returning the input if the index is out of bounds.\n   *\n   * @since 2.0.0\n   */\n  <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>\n  /**\n   * Apply a function to the element at the specified index, creating a new `Chunk`,\n   * or returning the input if the index is out of bounds.\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>\n} = dual(\n  3,\n  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B> => O.getOrElse(modifyOption(self, i, f), () => self)\n)\n\n/**\n * Change the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const replace: {\n  /**\n   * Change the element at the specified index, creating a new `Chunk`,\n   * or returning the input if the index is out of bounds.\n   *\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>\n  /**\n   * Change the element at the specified index, creating a new `Chunk`,\n   * or returning the input if the index is out of bounds.\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>\n} = dual(3, <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A> => modify(self, i, () => b))\n\n/**\n * @since 2.0.0\n */\nexport const replaceOption: {\n  /**\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A>(self: Chunk<A>) => Option<Chunk<B | A>>\n  /**\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, i: number, b: B): Option<Chunk<B | A>>\n} = dual(3, <A, B>(self: Chunk<A>, i: number, b: B): Option<Chunk<B | A>> => modifyOption(self, i, () => b))\n\n/**\n * Return a Chunk of length n with element i initialized with f(i).\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy: {\n  /**\n   * Return a Chunk of length n with element i initialized with f(i).\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>\n  /**\n   * Return a Chunk of length n with element i initialized with f(i).\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>\n} = dual(2, (n, f) => fromIterable(RA.makeBy(n, f)))\n\n/**\n * Create a non empty `Chunk` containing a range of integers, including both endpoints.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start: number, end: number): NonEmptyChunk<number> =>\n  start <= end ? makeBy(end - start + 1, (i) => start + i) : of(start)\n\n// -------------------------------------------------------------------------------------\n// re-exports from ReadonlyArray\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains: {\n  // -------------------------------------------------------------------------------------\n  // re-exports from ReadonlyArray\n  // -------------------------------------------------------------------------------------\n\n  /**\n   * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(a: A): (self: Chunk<A>) => boolean\n  // -------------------------------------------------------------------------------------\n  // re-exports from ReadonlyArray\n  // -------------------------------------------------------------------------------------\n\n  /**\n   * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, a: A): boolean\n} = RA.contains\n\n/**\n * Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith: <A>(\n  isEquivalent: (self: A, that: A) => boolean\n) => {\n  (a: A): (self: Chunk<A>) => boolean\n  (self: Chunk<A>, a: A): boolean\n} = RA.containsWith\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>\n} = RA.findFirst\n\n/**\n * Return the first index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirstIndex: {\n  /**\n   * Return the first index for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>\n  /**\n   * Return the first index for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>\n} = RA.findFirstIndex\n\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast: {\n  /**\n   * Find the last element for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>\n  /**\n   * Find the last element for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>\n  /**\n   * Find the last element for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>\n  /**\n   * Find the last element for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>\n} = RA.findLast\n\n/**\n * Return the last index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLastIndex: {\n  /**\n   * Return the last index for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>\n  /**\n   * Return the last index for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>\n} = RA.findLastIndex\n\n/**\n * Check if a predicate holds true for every `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const every: {\n  /**\n   * Check if a predicate holds true for every `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>\n  /**\n   * Check if a predicate holds true for every `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean\n  /**\n   * Check if a predicate holds true for every `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>\n  /**\n   * Check if a predicate holds true for every `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B> =>\n    RA.fromIterable(self).every(refinement)\n)\n\n/**\n * Check if a predicate holds true for some `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some: {\n  /**\n   * Check if a predicate holds true for some `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>\n  /**\n   * Check if a predicate holds true for some `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A> => RA.fromIterable(self).some(predicate)\n)\n\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const join: {\n  /**\n   * Joins the elements together with \"sep\" in the middle.\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  (sep: string): (self: Chunk<string>) => string\n  /**\n   * Joins the elements together with \"sep\" in the middle.\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  (self: Chunk<string>, sep: string): string\n} = RA.join\n\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  /**\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B\n  /**\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = RA.reduce\n\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduceRight: {\n  /**\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B\n  /**\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = RA.reduceRight\n\n/**\n * Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Chunk`.\n *\n * @since 3.2.0\n */\nexport const differenceWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (that: Chunk<A>): (self: Chunk<A>) => Chunk<A>\n  (self: Chunk<A>, that: Chunk<A>): Chunk<A>\n} => {\n  return dual(\n    2,\n    (self: Chunk<A>, that: Chunk<A>): Chunk<A> => unsafeFromArray(RA.differenceWith(isEquivalent)(that, self))\n  )\n}\n\n/**\n * Creates a `Chunk` of values not included in the other given `Chunk`.\n * The order and references of result values are determined by the first `Chunk`.\n *\n * @since 3.2.0\n */\nexport const difference: {\n  /**\n   * Creates a `Chunk` of values not included in the other given `Chunk`.\n   * The order and references of result values are determined by the first `Chunk`.\n   *\n   * @since 3.2.0\n   */\n  <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * Creates a `Chunk` of values not included in the other given `Chunk`.\n   * The order and references of result values are determined by the first `Chunk`.\n   *\n   * @since 3.2.0\n   */\n  <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A> => unsafeFromArray(RA.difference(that, self))\n)\n","/** @internal */\nexport const SIZE = 5\n\n/** @internal */\nexport const BUCKET_SIZE = Math.pow(2, SIZE)\n\n/** @internal */\nexport const MASK = BUCKET_SIZE - 1\n\n/** @internal */\nexport const MAX_INDEX_NODE = BUCKET_SIZE / 2\n\n/** @internal */\nexport const MIN_ARRAY_NODE = BUCKET_SIZE / 4\n","import { MASK } from \"./config.js\"\n\n/**\n * Hamming weight.\n *\n * Taken from: http://jsperf.com/hamming-weight\n *\n * @internal\n */\nexport function popcount(x: number) {\n  x -= (x >> 1) & 0x55555555\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n  x = (x + (x >> 4)) & 0x0f0f0f0f\n  x += x >> 8\n  x += x >> 16\n  return x & 0x7f\n}\n\n/** @internal */\nexport function hashFragment(shift: number, h: number) {\n  return (h >>> shift) & MASK\n}\n\n/** @internal */\nexport function toBitmap(x: number) {\n  return 1 << x\n}\n\n/** @internal */\nexport function fromBitmap(bitmap: number, bit: number) {\n  return popcount(bitmap & (bit - 1))\n}\n","/** @internal */\nexport interface Stack<out A> {\n  readonly value: A\n  readonly previous: Stack<A> | undefined\n}\n\nexport const make = <A>(value: A, previous?: Stack<A>): Stack<A> => ({\n  value,\n  previous\n})\n","/** @internal */\nexport function arrayUpdate<A>(mutate: boolean, at: number, v: A, arr: Array<A>) {\n  let out = arr\n  if (!mutate) {\n    const len = arr.length\n    out = new Array(len)\n    for (let i = 0; i < len; ++i) out[i] = arr[i]!\n  }\n  out[at] = v\n  return out\n}\n\n/** @internal */\nexport function arraySpliceOut<A>(mutate: boolean, at: number, arr: Array<A>) {\n  const newLen = arr.length - 1\n  let i = 0\n  let g = 0\n  let out = arr\n  if (mutate) {\n    i = g = at\n  } else {\n    out = new Array(newLen)\n    while (i < at) out[g++] = arr[i++]!\n  }\n  ++i\n  while (i <= newLen) out[g++] = arr[i++]!\n  if (mutate) {\n    out.length = newLen\n  }\n  return out\n}\n\n/** @internal */\nexport function arraySpliceIn<A>(mutate: boolean, at: number, v: A, arr: Array<A>) {\n  const len = arr.length\n  if (mutate) {\n    let i = len\n    while (i >= at) arr[i--] = arr[i]!\n    arr[at] = v\n    return arr\n  }\n  let i = 0,\n    g = 0\n  const out = new Array<A>(len + 1)\n  while (i < at) out[g++] = arr[i++]!\n  out[at] = v\n  while (i < len) out[++g] = arr[i++]!\n  return out\n}\n","import { equals } from \"../../Equal.js\"\nimport type { HashMap } from \"../../HashMap.js\"\nimport * as O from \"../../Option.js\"\nimport { isTagged } from \"../../Predicate.js\"\nimport * as Stack from \"../stack.js\"\nimport { arraySpliceIn, arraySpliceOut, arrayUpdate } from \"./array.js\"\nimport { fromBitmap, hashFragment, toBitmap } from \"./bitwise.js\"\nimport { MAX_INDEX_NODE, MIN_ARRAY_NODE, SIZE } from \"./config.js\"\n\n/** @internal */\nexport type Node<K, V> =\n  | EmptyNode<K, V>\n  | LeafNode<K, V>\n  | CollisionNode<K, V>\n  | IndexedNode<K, V>\n  | ArrayNode<K, V>\n\n/** @internal */\nexport interface SizeRef {\n  value: number // mutable by design\n}\n\n/** @internal */\nexport class EmptyNode<out K, out V> {\n  readonly _tag = \"EmptyNode\"\n\n  modify(\n    edit: number,\n    _shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    const v = f(O.none())\n    if (O.isNone(v)) return new EmptyNode()\n    ++size.value\n    return new LeafNode(edit, hash, key, v)\n  }\n}\n\n/** @internal */\nexport function isEmptyNode(a: unknown): a is EmptyNode<unknown, unknown> {\n  return isTagged(a, \"EmptyNode\")\n}\n\n/** @internal */\nexport function isLeafNode<K, V>(\n  node: Node<K, V>\n): node is EmptyNode<K, V> | LeafNode<K, V> | CollisionNode<K, V> {\n  return isEmptyNode(node) || node._tag === \"LeafNode\" || node._tag === \"CollisionNode\"\n}\n\n/** @internal */\nexport function canEditNode<K, V>(node: Node<K, V>, edit: number): boolean {\n  return isEmptyNode(node) ? false : edit === node.edit\n}\n\n/** @internal */\nexport class LeafNode<out K, out V> {\n  readonly _tag = \"LeafNode\"\n\n  constructor(\n    readonly edit: number,\n    readonly hash: number,\n    readonly key: K,\n    public value: O.Option<V>\n  ) {}\n\n  modify(\n    edit: number,\n    shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    if (equals(key, this.key)) {\n      const v = f(this.value)\n      if (v === this.value) return this\n      else if (O.isNone(v)) {\n        --size.value\n        return new EmptyNode()\n      }\n      if (canEditNode(this, edit)) {\n        this.value = v\n        return this\n      }\n      return new LeafNode(edit, hash, key, v)\n    }\n    const v = f(O.none())\n    if (O.isNone(v)) return this\n    ++size.value\n    return mergeLeaves(\n      edit,\n      shift,\n      this.hash,\n      this,\n      hash,\n      new LeafNode(edit, hash, key, v)\n    )\n  }\n}\n\n/** @internal */\nexport class CollisionNode<out K, out V> {\n  readonly _tag = \"CollisionNode\"\n\n  constructor(\n    readonly edit: number,\n    readonly hash: number,\n    readonly children: Array<Node<K, V>>\n  ) {}\n\n  modify(\n    edit: number,\n    shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    if (hash === this.hash) {\n      const canEdit = canEditNode(this, edit)\n      const list = this.updateCollisionList(\n        canEdit,\n        edit,\n        this.hash,\n        this.children,\n        f,\n        key,\n        size\n      )\n      if (list === this.children) return this\n\n      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]! // collapse single element collision list\n    }\n    const v = f(O.none())\n    if (O.isNone(v)) return this\n    ++size.value\n    return mergeLeaves(\n      edit,\n      shift,\n      this.hash,\n      this,\n      hash,\n      new LeafNode(edit, hash, key, v)\n    )\n  }\n\n  updateCollisionList(\n    mutate: boolean,\n    edit: number,\n    hash: number,\n    list: Array<Node<K, V>>,\n    f: HashMap.UpdateFn<V>,\n    key: K,\n    size: SizeRef\n  ) {\n    const len = list.length\n    for (let i = 0; i < len; ++i) {\n      const child = list[i]!\n      if (\"key\" in child && equals(key, child.key)) {\n        const value = child.value\n        const newValue = f(value)\n        if (newValue === value) return list\n        if (O.isNone(newValue)) {\n          --size.value\n          return arraySpliceOut(mutate, i, list)\n        }\n        return arrayUpdate(mutate, i, new LeafNode(edit, hash, key, newValue), list)\n      }\n    }\n\n    const newValue = f(O.none())\n    if (O.isNone(newValue)) return list\n    ++size.value\n    return arrayUpdate(mutate, len, new LeafNode(edit, hash, key, newValue), list)\n  }\n}\n\n/** @internal */\nexport class IndexedNode<out K, out V> {\n  readonly _tag = \"IndexedNode\"\n\n  constructor(\n    readonly edit: number,\n    public mask: number,\n    public children: Array<Node<K, V>>\n  ) {}\n\n  modify(\n    edit: number,\n    shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    const mask = this.mask\n    const children = this.children\n    const frag = hashFragment(shift, hash)\n    const bit = toBitmap(frag)\n    const indx = fromBitmap(mask, bit)\n    const exists = mask & bit\n    const canEdit = canEditNode(this, edit)\n\n    if (!exists) {\n      const _newChild = new EmptyNode<K, V>().modify(edit, shift + SIZE, f, hash, key, size)\n      if (!_newChild) return this\n      return children.length >= MAX_INDEX_NODE ?\n        expand(edit, frag, _newChild, mask, children) :\n        new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children))\n    }\n\n    const current = children[indx]!\n    const child = current.modify(edit, shift + SIZE, f, hash, key, size)\n\n    if (current === child) return this\n    let bitmap = mask\n    let newChildren\n    if (isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit\n      if (!bitmap) return new EmptyNode()\n      if (children.length <= 2 && isLeafNode(children[indx ^ 1]!)) {\n        return children[indx ^ 1]! // collapse\n      }\n\n      newChildren = arraySpliceOut(canEdit, indx, children)\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children)\n    }\n\n    if (canEdit) {\n      this.mask = bitmap\n      this.children = newChildren\n      return this\n    }\n\n    return new IndexedNode(edit, bitmap, newChildren)\n  }\n}\n\n/** @internal */\nexport class ArrayNode<out K, out V> {\n  readonly _tag = \"ArrayNode\"\n\n  constructor(\n    readonly edit: number,\n    public size: number,\n    public children: Array<Node<K, V>>\n  ) {}\n\n  modify(\n    edit: number,\n    shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    let count = this.size\n    const children = this.children\n    const frag = hashFragment(shift, hash)\n    const child = children[frag]\n    const newChild = (child || new EmptyNode<K, V>()).modify(\n      edit,\n      shift + SIZE,\n      f,\n      hash,\n      key,\n      size\n    )\n\n    if (child === newChild) return this\n\n    const canEdit = canEditNode(this, edit)\n    let newChildren\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ++count\n      newChildren = arrayUpdate(canEdit, frag, newChild, children)\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      --count\n      if (count <= MIN_ARRAY_NODE) {\n        return pack(edit, count, frag, children)\n      }\n      newChildren = arrayUpdate(canEdit, frag, new EmptyNode<K, V>(), children)\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children)\n    }\n\n    if (canEdit) {\n      this.size = count\n      this.children = newChildren\n      return this\n    }\n    return new ArrayNode(edit, count, newChildren)\n  }\n}\n\nfunction pack<K, V>(\n  edit: number,\n  count: number,\n  removed: number,\n  elements: Array<Node<K, V>>\n) {\n  const children = new Array<Node<K, V>>(count - 1)\n  let g = 0\n  let bitmap = 0\n  for (let i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      const elem = elements[i]\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem\n        bitmap |= 1 << i\n      }\n    }\n  }\n  return new IndexedNode(edit, bitmap, children)\n}\n\nfunction expand<K, V>(\n  edit: number,\n  frag: number,\n  child: Node<K, V>,\n  bitmap: number,\n  subNodes: Array<Node<K, V>>\n) {\n  const arr = []\n  let bit = bitmap\n  let count = 0\n  for (let i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++]!\n    bit >>>= 1\n  }\n  arr[frag] = child\n  return new ArrayNode(edit, count + 1, arr)\n}\n\nfunction mergeLeavesInner<K, V>(\n  edit: number,\n  shift: number,\n  h1: number,\n  n1: Node<K, V>,\n  h2: number,\n  n2: Node<K, V>\n): Node<K, V> | ((child: Node<K, V>) => Node<K, V>) {\n  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1])\n  const subH1 = hashFragment(shift, h1)\n  const subH2 = hashFragment(shift, h2)\n\n  if (subH1 === subH2) {\n    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child])\n  } else {\n    const children = subH1 < subH2 ? [n1, n2] : [n2, n1]\n    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children)\n  }\n}\n\nfunction mergeLeaves<K, V>(\n  edit: number,\n  shift: number,\n  h1: number,\n  n1: Node<K, V>,\n  h2: number,\n  n2: Node<K, V>\n): Node<K, V> {\n  let stack: Stack.Stack<(node: Node<K, V>) => Node<K, V>> | undefined = undefined\n  let currentShift = shift\n\n  while (true) {\n    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2)\n\n    if (typeof res === \"function\") {\n      stack = Stack.make(res, stack)\n      currentShift = currentShift + SIZE\n    } else {\n      let final = res\n      while (stack != null) {\n        final = stack.value(final)\n        stack = stack.previous\n      }\n      return final\n    }\n  }\n}\n","import * as Equal from \"../Equal.js\"\nimport * as Dual from \"../Function.js\"\nimport { identity, pipe } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport type * as HM from \"../HashMap.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport { fromBitmap, hashFragment, toBitmap } from \"./hashMap/bitwise.js\"\nimport { SIZE } from \"./hashMap/config.js\"\nimport * as Node from \"./hashMap/node.js\"\n\nconst HashMapSymbolKey = \"effect/HashMap\"\n\n/** @internal */\nexport const HashMapTypeId: HM.TypeId = Symbol.for(HashMapSymbolKey) as HM.TypeId\n\ntype TraversalFn<K, V, A> = (k: K, v: V) => A\n\ntype Cont<K, V, A> =\n  | [\n    len: number,\n    children: Array<Node.Node<K, V>>,\n    i: number,\n    f: TraversalFn<K, V, A>,\n    cont: Cont<K, V, A>\n  ]\n  | undefined\n\ninterface VisitResult<K, V, A> {\n  value: A\n  cont: Cont<K, V, A>\n}\n\n/** @internal */\nexport interface HashMapImpl<out K, out V> extends HM.HashMap<K, V> {\n  _editable: boolean // mutable by design\n  _edit: number // mutable by design\n  _root: Node.Node<K, V> // mutable by design\n  _size: number // mutable by design\n}\n\nconst HashMapProto: HM.HashMap<unknown, unknown> = {\n  [HashMapTypeId]: HashMapTypeId,\n  [Symbol.iterator]<K, V>(this: HashMapImpl<K, V>): Iterator<[K, V]> {\n    return new HashMapIterator(this, (k, v) => [k, v])\n  },\n  [Hash.symbol](this: HM.HashMap<unknown, unknown>): number {\n    let hash = Hash.hash(HashMapSymbolKey)\n    for (const item of this) {\n      hash ^= pipe(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])))\n    }\n    return Hash.cached(this, hash)\n  },\n  [Equal.symbol]<K, V>(this: HashMapImpl<K, V>, that: unknown): boolean {\n    if (isHashMap(that)) {\n      if ((that as HashMapImpl<K, V>)._size !== this._size) {\n        return false\n      }\n      for (const item of this) {\n        const elem = pipe(\n          that as HM.HashMap<K, V>,\n          getHash(item[0], Hash.hash(item[0]))\n        )\n        if (Option.isNone(elem)) {\n          return false\n        } else {\n          if (!Equal.equals(item[1], elem.value)) {\n            return false\n          }\n        }\n      }\n      return true\n    }\n    return false\n  },\n  toString<K, V>(this: HashMapImpl<K, V>) {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"HashMap\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst makeImpl = <K, V>(\n  editable: boolean,\n  edit: number,\n  root: Node.Node<K, V>,\n  size: number\n): HashMapImpl<K, V> => {\n  const map = Object.create(HashMapProto)\n  map._editable = editable\n  map._edit = edit\n  map._root = root\n  map._size = size\n  return map\n}\n\nclass HashMapIterator<in out K, in out V, out T> implements IterableIterator<T> {\n  v: Option.Option<VisitResult<K, V, T>>\n\n  constructor(readonly map: HashMapImpl<K, V>, readonly f: TraversalFn<K, V, T>) {\n    this.v = visitLazy(this.map._root, this.f, undefined)\n  }\n\n  next(): IteratorResult<T> {\n    if (Option.isNone(this.v)) {\n      return { done: true, value: undefined }\n    }\n    const v0 = this.v.value\n    this.v = applyCont(v0.cont)\n    return { done: false, value: v0.value }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return new HashMapIterator(this.map, this.f)\n  }\n}\n\nconst applyCont = <K, V, A>(cont: Cont<K, V, A>): Option.Option<VisitResult<K, V, A>> =>\n  cont\n    ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4])\n    : Option.none()\n\nconst visitLazy = <K, V, A>(\n  node: Node.Node<K, V>,\n  f: TraversalFn<K, V, A>,\n  cont: Cont<K, V, A> = undefined\n): Option.Option<VisitResult<K, V, A>> => {\n  switch (node._tag) {\n    case \"LeafNode\": {\n      if (Option.isSome(node.value)) {\n        return Option.some({\n          value: f(node.key, node.value.value),\n          cont\n        })\n      }\n      return applyCont(cont)\n    }\n    case \"CollisionNode\":\n    case \"ArrayNode\":\n    case \"IndexedNode\": {\n      const children = node.children\n      return visitLazyChildren(children.length, children, 0, f, cont)\n    }\n    default: {\n      return applyCont(cont)\n    }\n  }\n}\n\nconst visitLazyChildren = <K, V, A>(\n  len: number,\n  children: Array<Node.Node<K, V>>,\n  i: number,\n  f: TraversalFn<K, V, A>,\n  cont: Cont<K, V, A>\n): Option.Option<VisitResult<K, V, A>> => {\n  while (i < len) {\n    const child = children[i++]\n    if (child && !Node.isEmptyNode(child)) {\n      return visitLazy(child, f, [len, children, i, f, cont])\n    }\n  }\n  return applyCont(cont)\n}\n\nconst _empty = makeImpl<never, never>(false, 0, new Node.EmptyNode(), 0)\n\n/** @internal */\nexport const empty = <K = never, V = never>(): HM.HashMap<K, V> => _empty\n\n/** @internal */\nexport const make = <Entries extends ReadonlyArray<readonly [any, any]>>(\n  ...entries: Entries\n): HM.HashMap<\n  Entries[number] extends readonly [infer K, any] ? K : never,\n  Entries[number] extends readonly [any, infer V] ? V : never\n> => fromIterable(entries)\n\n/** @internal */\nexport const fromIterable = <K, V>(entries: Iterable<readonly [K, V]>): HM.HashMap<K, V> => {\n  const map = beginMutation(empty<K, V>())\n  for (const entry of entries) {\n    set(map, entry[0], entry[1])\n  }\n  return endMutation(map)\n}\n\n/** @internal */\nexport const isHashMap: {\n  <K, V>(u: Iterable<readonly [K, V]>): u is HM.HashMap<K, V>\n  (u: unknown): u is HM.HashMap<unknown, unknown>\n} = (u: unknown): u is HM.HashMap<unknown, unknown> => hasProperty(u, HashMapTypeId)\n\n/** @internal */\nexport const isEmpty = <K, V>(self: HM.HashMap<K, V>): boolean =>\n  self && Node.isEmptyNode((self as HashMapImpl<K, V>)._root)\n\n/** @internal */\nexport const get = Dual.dual<\n  <K1 extends K, K>(key: K1) => <V>(self: HM.HashMap<K, V>) => Option.Option<V>,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1) => Option.Option<V>\n>(2, (self, key) => getHash(self, key, Hash.hash(key)))\n\n/** @internal */\nexport const getHash = Dual.dual<\n  <K1 extends K, K>(key: K1, hash: number) => <V>(self: HM.HashMap<K, V>) => Option.Option<V>,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1, hash: number) => Option.Option<V>\n>(3, <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1, hash: number) => {\n  let node = (self as HashMapImpl<K, V>)._root\n  let shift = 0\n\n  while (true) {\n    switch (node._tag) {\n      case \"LeafNode\": {\n        return Equal.equals(key, node.key) ? node.value : Option.none()\n      }\n      case \"CollisionNode\": {\n        if (hash === node.hash) {\n          const children = node.children\n          for (let i = 0, len = children.length; i < len; ++i) {\n            const child = children[i]!\n            if (\"key\" in child && Equal.equals(key, child.key)) {\n              return child.value\n            }\n          }\n        }\n        return Option.none()\n      }\n      case \"IndexedNode\": {\n        const frag = hashFragment(shift, hash)\n        const bit = toBitmap(frag)\n        if (node.mask & bit) {\n          node = node.children[fromBitmap(node.mask, bit)]!\n          shift += SIZE\n          break\n        }\n        return Option.none()\n      }\n      case \"ArrayNode\": {\n        node = node.children[hashFragment(shift, hash)]!\n        if (node) {\n          shift += SIZE\n          break\n        }\n        return Option.none()\n      }\n      default:\n        return Option.none()\n    }\n  }\n})\n\n/** @internal */\nexport const unsafeGet = Dual.dual<\n  <K1 extends K, K>(key: K1) => <V>(self: HM.HashMap<K, V>) => V,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1) => V\n>(2, (self, key) => {\n  const element = getHash(self, key, Hash.hash(key))\n  if (Option.isNone(element)) {\n    throw new Error(\"Expected map to contain key\")\n  }\n  return element.value\n})\n\n/** @internal */\nexport const has = Dual.dual<\n  <K1 extends K, K>(key: K1) => <V>(self: HM.HashMap<K, V>) => boolean,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1) => boolean\n>(2, (self, key) => Option.isSome(getHash(self, key, Hash.hash(key))))\n\n/** @internal */\nexport const hasHash = Dual.dual<\n  <K1 extends K, K>(key: K1, hash: number) => <V>(self: HM.HashMap<K, V>) => boolean,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1, hash: number) => boolean\n>(3, (self, key, hash) => Option.isSome(getHash(self, key, hash)))\n\n/** @internal */\nexport const hasBy = Dual.dual<\n  <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean) => (self: HM.HashMap<K, V>) => boolean,\n  <K, V>(self: HM.HashMap<K, V>, predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean) => boolean\n>(2, (self, predicate) => Option.isSome(findFirst(self, predicate)))\n\n/** @internal */\nexport const set = Dual.dual<\n  <K, V>(key: K, value: V) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K, value: V) => HM.HashMap<K, V>\n>(3, (self, key, value) => modifyAt(self, key, () => Option.some(value)))\n\n/** @internal */\nexport const setTree = Dual.dual<\n  <K, V>(newRoot: Node.Node<K, V>, newSize: number) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, newRoot: Node.Node<K, V>, newSize: number) => HM.HashMap<K, V>\n>(3, <K, V>(self: HM.HashMap<K, V>, newRoot: Node.Node<K, V>, newSize: number) => {\n  if ((self as HashMapImpl<K, V>)._editable) {\n    ;(self as HashMapImpl<K, V>)._root = newRoot\n    ;(self as HashMapImpl<K, V>)._size = newSize\n    return self\n  }\n  return newRoot === (self as HashMapImpl<K, V>)._root\n    ? self\n    : makeImpl(\n      (self as HashMapImpl<K, V>)._editable,\n      (self as HashMapImpl<K, V>)._edit,\n      newRoot,\n      newSize\n    )\n})\n\n/** @internal */\nexport const keys = <K, V>(self: HM.HashMap<K, V>): IterableIterator<K> =>\n  new HashMapIterator(self as HashMapImpl<K, V>, (key) => key)\n\n/** @internal */\nexport const values = <K, V>(self: HM.HashMap<K, V>): IterableIterator<V> =>\n  new HashMapIterator(self as HashMapImpl<K, V>, (_, value) => value)\n\n/** @internal */\nexport const entries = <K, V>(self: HM.HashMap<K, V>): IterableIterator<[K, V]> =>\n  new HashMapIterator(self as HashMapImpl<K, V>, (key, value) => [key, value])\n\n/** @internal */\nexport const size = <K, V>(self: HM.HashMap<K, V>): number => (self as HashMapImpl<K, V>)._size\n\n/** @internal */\nexport const countBy = Dual.dual<\n  <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean) => (self: HM.HashMap<K, V>) => number,\n  <K, V>(self: HM.HashMap<K, V>, predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean) => number\n>(2, (self, f) => {\n  let count = 0\n  for (const [k, a] of self) {\n    if (f(a, k)) {\n      count++\n    }\n  }\n  return count\n})\n\n/** @internal */\nexport const beginMutation = <K, V>(self: HM.HashMap<K, V>): HM.HashMap<K, V> =>\n  makeImpl(\n    true,\n    (self as HashMapImpl<K, V>)._edit + 1,\n    (self as HashMapImpl<K, V>)._root,\n    (self as HashMapImpl<K, V>)._size\n  )\n\n/** @internal */\nexport const endMutation = <K, V>(self: HM.HashMap<K, V>): HM.HashMap<K, V> => {\n  ;(self as HashMapImpl<K, V>)._editable = false\n  return self\n}\n\n/** @internal */\nexport const mutate = Dual.dual<\n  <K, V>(f: (self: HM.HashMap<K, V>) => void) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, f: (self: HM.HashMap<K, V>) => void) => HM.HashMap<K, V>\n>(2, (self, f) => {\n  const transient = beginMutation(self)\n  f(transient)\n  return endMutation(transient)\n})\n\n/** @internal */\nexport const modifyAt = Dual.dual<\n  <K, V>(key: K, f: HM.HashMap.UpdateFn<V>) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K, f: HM.HashMap.UpdateFn<V>) => HM.HashMap<K, V>\n>(3, (self, key, f) => modifyHash(self, key, Hash.hash(key), f))\n\n/** @internal */\nexport const modifyHash = Dual.dual<\n  <K, V>(key: K, hash: number, f: HM.HashMap.UpdateFn<V>) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K, hash: number, f: HM.HashMap.UpdateFn<V>) => HM.HashMap<K, V>\n>(4, <K, V>(self: HM.HashMap<K, V>, key: K, hash: number, f: HM.HashMap.UpdateFn<V>) => {\n  const size = { value: (self as HashMapImpl<K, V>)._size }\n  const newRoot = (self as HashMapImpl<K, V>)._root.modify(\n    (self as HashMapImpl<K, V>)._editable ?\n      (self as HashMapImpl<K, V>)._edit :\n      NaN,\n    0,\n    f,\n    hash,\n    key,\n    size\n  )\n  return pipe(self, setTree(newRoot, size.value))\n})\n\n/** @internal */\nexport const modify = Dual.dual<\n  <K, V>(key: K, f: (v: V) => V) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K, f: (v: V) => V) => HM.HashMap<K, V>\n>(3, (self, key, f) => modifyAt(self, key, Option.map(f)))\n\n/** @internal */\nexport const union = Dual.dual<\n  <K1, V1>(\n    that: HM.HashMap<K1, V1>\n  ) => <K0, V0>(self: HM.HashMap<K0, V0>) => HM.HashMap<K0 | K1, V0 | V1>,\n  <K0, V0, K1, V1>(\n    self: HM.HashMap<K0, V0>,\n    that: HM.HashMap<K1, V1>\n  ) => HM.HashMap<K0 | K1, V0 | V1>\n>(2, <K0, V0, K1, V1>(self: HM.HashMap<K0, V0>, that: HM.HashMap<K1, V1>) => {\n  const result: HM.HashMap<K0 | K1, V0 | V1> = beginMutation(self)\n  forEach(that, (v, k) => set(result, k, v))\n  return endMutation(result)\n})\n\n/** @internal */\nexport const remove = Dual.dual<\n  <K>(key: K) => <V>(self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K) => HM.HashMap<K, V>\n>(2, (self, key) => modifyAt(self, key, Option.none))\n\n/** @internal */\nexport const removeMany = Dual.dual<\n  <K>(keys: Iterable<K>) => <V>(self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, keys: Iterable<K>) => HM.HashMap<K, V>\n>(2, (self, keys) =>\n  mutate(self, (map) => {\n    for (const key of keys) {\n      remove(key)(map)\n    }\n  }))\n\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = Dual.dual<\n  <A, V, K>(f: (value: V, key: K) => A) => (self: HM.HashMap<K, V>) => HM.HashMap<K, A>,\n  <K, V, A>(self: HM.HashMap<K, V>, f: (value: V, key: K) => A) => HM.HashMap<K, A>\n>(2, (self, f) =>\n  reduce(\n    self,\n    empty(),\n    (map, value, key) => set(map, key, f(value, key))\n  ))\n\n/** @internal */\nexport const flatMap = Dual.dual<\n  <A, K, B>(\n    f: (value: A, key: K) => HM.HashMap<K, B>\n  ) => (self: HM.HashMap<K, A>) => HM.HashMap<K, B>,\n  <K, A, B>(self: HM.HashMap<K, A>, f: (value: A, key: K) => HM.HashMap<K, B>) => HM.HashMap<K, B>\n>(\n  2,\n  (self, f) =>\n    reduce(self, empty(), (zero, value, key) =>\n      mutate(\n        zero,\n        (map) => forEach(f(value, key), (value, key) => set(map, key, value))\n      ))\n)\n\n/** @internal */\nexport const forEach = Dual.dual<\n  <V, K>(f: (value: V, key: K) => void) => (self: HM.HashMap<K, V>) => void,\n  <V, K>(self: HM.HashMap<K, V>, f: (value: V, key: K) => void) => void\n>(2, (self, f) => reduce(self, void 0 as void, (_, value, key) => f(value, key)))\n\n/** @internal */\nexport const reduce = Dual.dual<\n  <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z) => (self: HM.HashMap<K, V>) => Z,\n  <Z, V, K>(self: HM.HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z) => Z\n>(3, <Z, V, K>(self: HM.HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z) => {\n  const root = (self as HashMapImpl<K, V>)._root\n  if (root._tag === \"LeafNode\") {\n    return Option.isSome(root.value) ? f(zero, root.value.value, root.key) : zero\n  }\n  if (root._tag === \"EmptyNode\") {\n    return zero\n  }\n  const toVisit = [root.children]\n  let children\n  while ((children = toVisit.pop())) {\n    for (let i = 0, len = children.length; i < len;) {\n      const child = children[i++]\n      if (child && !Node.isEmptyNode(child)) {\n        if (child._tag === \"LeafNode\") {\n          if (Option.isSome(child.value)) {\n            zero = f(zero, child.value.value, child.key)\n          }\n        } else {\n          toVisit.push(child.children)\n        }\n      }\n    }\n  }\n  return zero\n})\n\n/** @internal */\nexport const filter: {\n  <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HM.HashMap<K, A>) => HM.HashMap<K, B>\n  <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HM.HashMap<K, A>) => HM.HashMap<K, A>\n  <K, A, B extends A>(self: HM.HashMap<K, A>, f: (a: A, k: K) => a is B): HM.HashMap<K, B>\n  <K, A>(self: HM.HashMap<K, A>, f: (a: A, k: K) => boolean): HM.HashMap<K, A>\n} = Dual.dual(\n  2,\n  <K, A>(self: HM.HashMap<K, A>, f: (a: A, k: K) => boolean): HM.HashMap<K, A> =>\n    mutate(empty(), (map) => {\n      for (const [k, a] of self) {\n        if (f(a, k)) {\n          set(map, k, a)\n        }\n      }\n    })\n)\n\n/** @internal */\nexport const compact = <K, A>(self: HM.HashMap<K, Option.Option<A>>) => filterMap(self, identity)\n\n/** @internal */\nexport const filterMap = Dual.dual<\n  <A, K, B>(\n    f: (value: A, key: K) => Option.Option<B>\n  ) => (self: HM.HashMap<K, A>) => HM.HashMap<K, B>,\n  <K, A, B>(self: HM.HashMap<K, A>, f: (value: A, key: K) => Option.Option<B>) => HM.HashMap<K, B>\n>(2, (self, f) =>\n  mutate(empty(), (map) => {\n    for (const [k, a] of self) {\n      const option = f(a, k)\n      if (Option.isSome(option)) {\n        set(map, k, option.value)\n      }\n    }\n  }))\n\n/** @internal */\nexport const findFirst: {\n  <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HM.HashMap<K, A>) => Option.Option<[K, B]>\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HM.HashMap<K, A>) => Option.Option<[K, A]>\n  <K, A, B extends A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option.Option<[K, B]>\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option.Option<[K, A]>\n} = Dual.dual(\n  2,\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option.Option<[K, A]> => {\n    for (const ka of self) {\n      if (predicate(ka[1], ka[0])) {\n        return Option.some(ka)\n      }\n    }\n    return Option.none()\n  }\n)\n\n/** @internal */\nexport const some: {\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HM.HashMap<K, A>) => boolean\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean\n} = Dual.dual(\n  2,\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean => {\n    for (const ka of self) {\n      if (predicate(ka[1], ka[0])) {\n        return true\n      }\n    }\n    return false\n  }\n)\n\n/** @internal */\nexport const every: {\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HM.HashMap<K, A>) => boolean\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean\n} = Dual.dual(\n  2,\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean => !some(self, (a, k) => !predicate(a, k))\n)\n","import * as Equal from \"../Equal.js\"\nimport { dual } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport type { HashMap } from \"../HashMap.js\"\nimport type * as HS from \"../HashSet.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type { Predicate, Refinement } from \"../Predicate.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport * as HM from \"./hashMap.js\"\n\nconst HashSetSymbolKey = \"effect/HashSet\"\n\n/** @internal */\nexport const HashSetTypeId: HS.TypeId = Symbol.for(HashSetSymbolKey) as HS.TypeId\n\n/** @internal */\nexport interface HashSetImpl<out A> extends HS.HashSet<A> {\n  readonly _keyMap: HashMap<A, unknown>\n}\n\nconst HashSetProto: Omit<HashSetImpl<unknown>, \"_keyMap\"> = {\n  [HashSetTypeId]: HashSetTypeId,\n  [Symbol.iterator]<A>(this: HashSetImpl<A>): Iterator<A> {\n    return HM.keys(this._keyMap)\n  },\n  [Hash.symbol]<A>(this: HashSetImpl<A>): number {\n    return Hash.cached(\n      this,\n      Hash.combine(Hash.hash(this._keyMap))(Hash.hash(HashSetSymbolKey))\n    )\n  },\n  [Equal.symbol]<A>(this: HashSetImpl<A>, that: unknown): boolean {\n    if (isHashSet(that)) {\n      return (\n        HM.size(this._keyMap) === HM.size((that as HashSetImpl<A>)._keyMap) &&\n        Equal.equals(this._keyMap, (that as HashSetImpl<A>)._keyMap)\n      )\n    }\n    return false\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"HashSet\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const makeImpl = <A>(keyMap: HashMap<A, unknown>): HashSetImpl<A> => {\n  const set = Object.create(HashSetProto)\n  set._keyMap = keyMap\n  return set\n}\n\n/** @internal */\nexport const isHashSet: {\n  <A>(u: Iterable<A>): u is HS.HashSet<A>\n  (u: unknown): u is HS.HashSet<unknown>\n} = (u: unknown): u is HS.HashSet<unknown> => hasProperty(u, HashSetTypeId)\n\nconst _empty = makeImpl<never>(HM.empty())\n\n/** @internal */\nexport const empty = <A = never>(): HS.HashSet<A> => _empty\n\n/** @internal */\nexport const fromIterable = <A>(elements: Iterable<A>): HS.HashSet<A> => {\n  const set = beginMutation(empty<A>())\n  for (const value of elements) {\n    add(set, value)\n  }\n  return endMutation(set)\n}\n\n/** @internal */\nexport const make = <As extends ReadonlyArray<any>>(...elements: As): HS.HashSet<As[number]> => {\n  const set = beginMutation(empty<As[number]>())\n  for (const value of elements) {\n    add(set, value)\n  }\n  return endMutation(set)\n}\n\n/** @internal */\nexport const has = dual<\n  <A>(value: A) => (self: HS.HashSet<A>) => boolean,\n  <A>(self: HS.HashSet<A>, value: A) => boolean\n>(2, <A>(self: HS.HashSet<A>, value: A) => HM.has((self as HashSetImpl<A>)._keyMap, value))\n\n/** @internal */\nexport const some = dual<\n  <A>(f: Predicate<A>) => (self: HS.HashSet<A>) => boolean,\n  <A>(self: HS.HashSet<A>, f: Predicate<A>) => boolean\n>(2, (self, f) => {\n  let found = false\n  for (const value of self) {\n    found = f(value)\n    if (found) {\n      break\n    }\n  }\n  return found\n})\n\n/** @internal */\nexport const every: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HS.HashSet<A>) => self is HS.HashSet<B>\n  <A>(predicate: Predicate<A>): (self: HS.HashSet<A>) => boolean\n  <A, B extends A>(self: HS.HashSet<A>, refinement: Refinement<A, B>): self is HS.HashSet<B>\n  <A>(self: HS.HashSet<A>, predicate: Predicate<A>): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: HS.HashSet<A>, refinement: Refinement<A, B>): self is HS.HashSet<B> =>\n    !some(self, (a) => !refinement(a))\n)\n\n/** @internal */\nexport const isSubset = dual<\n  <A>(that: HS.HashSet<A>) => (self: HS.HashSet<A>) => boolean,\n  <A>(self: HS.HashSet<A>, that: HS.HashSet<A>) => boolean\n>(2, (self, that) => every(self, (value) => has(that, value)))\n\n/** @internal */\nexport const values = <A>(self: HS.HashSet<A>): IterableIterator<A> => HM.keys((self as HashSetImpl<A>)._keyMap)\n\n/** @internal */\nexport const size = <A>(self: HS.HashSet<A>): number => HM.size((self as HashSetImpl<A>)._keyMap)\n\n/** @internal */\nexport const beginMutation = <A>(self: HS.HashSet<A>): HS.HashSet<A> =>\n  makeImpl(HM.beginMutation((self as HashSetImpl<A>)._keyMap))\n\n/** @internal */\nexport const endMutation = <A>(self: HS.HashSet<A>): HS.HashSet<A> => {\n  ;((self as HashSetImpl<A>)._keyMap as HM.HashMapImpl<A, unknown>)._editable = false\n  return self\n}\n\n/** @internal */\nexport const mutate = dual<\n  <A>(f: (set: HS.HashSet<A>) => void) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, f: (set: HS.HashSet<A>) => void) => HS.HashSet<A>\n>(2, (self, f) => {\n  const transient = beginMutation(self)\n  f(transient)\n  return endMutation(transient)\n})\n\n/** @internal */\nexport const add = dual<\n  <A>(value: A) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, value: A) => HS.HashSet<A>\n>(\n  2,\n  <A>(self: HS.HashSet<A>, value: A) =>\n    ((self as HashSetImpl<A>)._keyMap as HM.HashMapImpl<A, unknown>)._editable\n      ? (HM.set(value as A, true as unknown)((self as HashSetImpl<A>)._keyMap), self)\n      : makeImpl(HM.set(value as A, true as unknown)((self as HashSetImpl<A>)._keyMap))\n)\n\n/** @internal */\nexport const remove = dual<\n  <A>(value: A) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, value: A) => HS.HashSet<A>\n>(\n  2,\n  <A>(self: HS.HashSet<A>, value: A) =>\n    (((self as HashSetImpl<A>)._keyMap) as HM.HashMapImpl<A, unknown>)._editable\n      ? (HM.remove(value)((self as HashSetImpl<A>)._keyMap), self)\n      : makeImpl(HM.remove(value)((self as HashSetImpl<A>)._keyMap))\n)\n\n/** @internal */\nexport const difference = dual<\n  <A>(that: Iterable<A>) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, that: Iterable<A>) => HS.HashSet<A>\n>(2, (self, that) =>\n  mutate(self, (set) => {\n    for (const value of that) {\n      remove(set, value)\n    }\n  }))\n\n/** @internal */\nexport const intersection = dual<\n  <A>(that: Iterable<A>) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, that: Iterable<A>) => HS.HashSet<A>\n>(2, (self, that) =>\n  mutate(empty(), (set) => {\n    for (const value of that) {\n      if (has(value)(self)) {\n        add(value)(set)\n      }\n    }\n  }))\n\n/** @internal */\nexport const union = dual<\n  <A>(that: Iterable<A>) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, that: Iterable<A>) => HS.HashSet<A>\n>(2, (self, that) =>\n  mutate(empty(), (set) => {\n    forEach(self, (value) => add(set, value))\n    for (const value of that) {\n      add(set, value)\n    }\n  }))\n\n/** @internal */\nexport const toggle = dual<\n  <A>(value: A) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, value: A) => HS.HashSet<A>\n>(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value))\n\n/** @internal */\nexport const map = dual<\n  <A, B>(f: (a: A) => B) => (self: HS.HashSet<A>) => HS.HashSet<B>,\n  <A, B>(self: HS.HashSet<A>, f: (a: A) => B) => HS.HashSet<B>\n>(2, (self, f) =>\n  mutate(empty(), (set) => {\n    forEach(self, (a) => {\n      const b = f(a)\n      if (!has(set, b)) {\n        add(set, b)\n      }\n    })\n  }))\n\n/** @internal */\nexport const flatMap = dual<\n  <A, B>(f: (a: A) => Iterable<B>) => (self: HS.HashSet<A>) => HS.HashSet<B>,\n  <A, B>(self: HS.HashSet<A>, f: (a: A) => Iterable<B>) => HS.HashSet<B>\n>(2, (self, f) =>\n  mutate(empty(), (set) => {\n    forEach(self, (a) => {\n      for (const b of f(a)) {\n        if (!has(set, b)) {\n          add(set, b)\n        }\n      }\n    })\n  }))\n\n/** @internal */\nexport const forEach = dual<\n  <A>(f: (value: A) => void) => (self: HS.HashSet<A>) => void,\n  <A>(self: HS.HashSet<A>, f: (value: A) => void) => void\n>(2, <A>(self: HS.HashSet<A>, f: (value: A) => void) =>\n  HM.forEach(\n    (self as HashSetImpl<A>)._keyMap,\n    (_, k) => f(k)\n  ))\n\n/** @internal */\nexport const reduce = dual<\n  <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z) => (self: HS.HashSet<A>) => Z,\n  <A, Z>(self: HS.HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z) => Z\n>(3, <A, Z>(self: HS.HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z) =>\n  HM.reduce(\n    (self as HashSetImpl<A>)._keyMap,\n    zero,\n    (z, _, a) => f(z, a)\n  ))\n\n/** @internal */\nexport const filter: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HS.HashSet<A>) => HS.HashSet<B>\n  <A>(predicate: Predicate<NoInfer<A>>): (self: HS.HashSet<A>) => HS.HashSet<A>\n  <A, B extends A>(self: HS.HashSet<A>, refinement: Refinement<A, B>): HS.HashSet<B>\n  <A>(self: HS.HashSet<A>, predicate: Predicate<A>): HS.HashSet<A>\n} = dual(2, <A>(self: HS.HashSet<A>, f: Predicate<A>) => {\n  return mutate(empty(), (set) => {\n    const iterator = values(self)\n    let next: IteratorResult<A, any>\n    while (!(next = iterator.next()).done) {\n      const value = next.value\n      if (f(value)) {\n        add(set, value)\n      }\n    }\n  })\n})\n\n/** @internal */\nexport const partition: {\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>\n  ): (self: HS.HashSet<A>) => [excluded: HS.HashSet<Exclude<A, B>>, satisfying: HS.HashSet<B>]\n  <A>(\n    predicate: Predicate<NoInfer<A>>\n  ): (self: HS.HashSet<A>) => [excluded: HS.HashSet<A>, satisfying: HS.HashSet<A>]\n  <A, B extends A>(\n    self: HS.HashSet<A>,\n    refinement: Refinement<A, B>\n  ): [excluded: HS.HashSet<Exclude<A, B>>, satisfying: HS.HashSet<B>]\n  <A>(self: HS.HashSet<A>, predicate: Predicate<A>): [excluded: HS.HashSet<A>, satisfying: HS.HashSet<A>]\n} = dual(2, <A>(self: HS.HashSet<A>, predicate: Predicate<A>): [excluded: HS.HashSet<A>, satisfying: HS.HashSet<A>] => {\n  const iterator = values(self)\n  let next: IteratorResult<A, any>\n  const right = beginMutation(empty<A>())\n  const left = beginMutation(empty<A>())\n  while (!(next = iterator.next()).done) {\n    const value = next.value\n    if (predicate(value)) {\n      add(right, value)\n    } else {\n      add(left, value)\n    }\n  }\n  return [endMutation(left), endMutation(right)]\n})\n","/**\n * # HashSet\n *\n * An immutable `HashSet` provides a collection of unique values with efficient\n * lookup, insertion and removal. Once created, a `HashSet` cannot be modified;\n * any operation that would alter the set instead returns a new `HashSet` with\n * the changes. This immutability offers benefits like predictable state\n * management and easier reasoning about your code.\n *\n * ## What Problem Does It Solve?\n *\n * `HashSet` solves the problem of maintaining an unsorted collection where each\n * value appears exactly once, with fast operations for checking membership and\n * adding/removing values.\n *\n * ## When to Use\n *\n * Use `HashSet` when you need:\n *\n * - A collection with no duplicate values\n * - Efficient membership testing (**`O(1)`** average complexity)\n * - Set operations like union, intersection, and difference\n * - An immutable data structure that preserves functional programming patterns\n *\n * ## Advanced Features\n *\n * HashSet provides operations for:\n *\n * - Transforming sets with map and flatMap\n * - Filtering elements with filter\n * - Combining sets with union, intersection and difference\n * - Performance optimizations via mutable operations in controlled contexts\n *\n * ## Performance Characteristics\n *\n * - **Lookup** operations ({@link module:HashSet.has}): **`O(1)`** average time\n *   complexity\n * - **Insertion** operations ({@link module:HashSet.add}): **`O(1)`** average time\n *   complexity\n * - **Removal** operations ({@link module:HashSet.remove}): **`O(1)`** average\n *   time complexity\n * - **Set** operations ({@link module:HashSet.union},\n *   {@link module:HashSet.intersection}): **`O(n)`** where n is the size of the\n *   smaller set\n * - **Iteration**: **`O(n)`** where n is the size of the set\n *\n * The HashSet data structure implements the following traits:\n *\n * - {@link Iterable}: allows iterating over the values in the set\n * - {@link Equal}: allows comparing two sets for value-based equality\n * - {@link Pipeable}: allows chaining operations with the pipe operator\n * - {@link Inspectable}: allows inspecting the contents of the set\n *\n * ## Operations Reference\n *\n * | Category     | Operation                           | Description                                 | Complexity |\n * | ------------ | ----------------------------------- | ------------------------------------------- | ---------- |\n * | constructors | {@link module:HashSet.empty}        | Creates an empty HashSet                    | O(1)       |\n * | constructors | {@link module:HashSet.fromIterable} | Creates a HashSet from an iterable          | O(n)       |\n * | constructors | {@link module:HashSet.make}         | Creates a HashSet from multiple values      | O(n)       |\n * |              |                                     |                                             |            |\n * | elements     | {@link module:HashSet.has}          | Checks if a value exists in the set         | O(1) avg   |\n * | elements     | {@link module:HashSet.some}         | Checks if any element satisfies a predicate | O(n)       |\n * | elements     | {@link module:HashSet.every}        | Checks if all elements satisfy a predicate  | O(n)       |\n * | elements     | {@link module:HashSet.isSubset}     | Checks if a set is a subset of another      | O(n)       |\n * |              |                                     |                                             |            |\n * | getters      | {@link module:HashSet.values}       | Gets an iterator of all values              | O(1)       |\n * | getters      | {@link module:HashSet.toValues}     | Gets an array of all values                 | O(n)       |\n * | getters      | {@link module:HashSet.size}         | Gets the number of elements                 | O(1)       |\n * |              |                                     |                                             |            |\n * | mutations    | {@link module:HashSet.add}          | Adds a value to the set                     | O(1) avg   |\n * | mutations    | {@link module:HashSet.remove}       | Removes a value from the set                | O(1) avg   |\n * | mutations    | {@link module:HashSet.toggle}       | Toggles a value's presence                  | O(1) avg   |\n * |              |                                     |                                             |            |\n * | operations   | {@link module:HashSet.difference}   | Computes set difference (A - B)             | O(n)       |\n * | operations   | {@link module:HashSet.intersection} | Computes set intersection (A ∩ B)           | O(n)       |\n * | operations   | {@link module:HashSet.union}        | Computes set union (A ∪ B)                  | O(n)       |\n * |              |                                     |                                             |            |\n * | mapping      | {@link module:HashSet.map}          | Transforms each element                     | O(n)       |\n * |              |                                     |                                             |            |\n * | sequencing   | {@link module:HashSet.flatMap}      | Transforms and flattens elements            | O(n)       |\n * |              |                                     |                                             |            |\n * | traversing   | {@link module:HashSet.forEach}      | Applies a function to each element          | O(n)       |\n * |              |                                     |                                             |            |\n * | folding      | {@link module:HashSet.reduce}       | Reduces the set to a single value           | O(n)       |\n * |              |                                     |                                             |            |\n * | filtering    | {@link module:HashSet.filter}       | Keeps elements that satisfy a predicate     | O(n)       |\n * |              |                                     |                                             |            |\n * | partitioning | {@link module:HashSet.partition}    | Splits into two sets by a predicate         | O(n)       |\n *\n * ## Notes\n *\n * ### Composability with the Effect Ecosystem:\n *\n * This `HashSet` is designed to work seamlessly within the Effect ecosystem. It\n * implements the {@link Iterable}, {@link Equal}, {@link Pipeable}, and\n * {@link Inspectable} traits from Effect. This ensures compatibility with other\n * Effect data structures and functionalities. For example, you can easily use\n * Effect's `pipe` method to chain operations on the `HashSet`.\n *\n * **Equality of Elements with Effect's {@link Equal `Equal`} Trait:**\n *\n * This `HashSet` relies on Effect's {@link Equal} trait to determine the\n * uniqueness of elements within the set. The way equality is checked depends on\n * the type of the elements:\n *\n * - **Primitive Values:** For primitive JavaScript values like strings, numbers,\n *   booleans, `null`, and `undefined`, equality is determined by their value\n *   (similar to the `===` operator).\n * - **Objects and Custom Types:** For objects and other custom types, equality is\n *   determined by whether those types implement the {@link Equal} interface\n *   themselves. If an element type implements `Equal`, the `HashSet` will\n *   delegate to that implementation to perform the equality check. This allows\n *   you to define custom logic for determining when two instances of your\n *   objects should be considered equal based on their properties, rather than\n *   just their object identity.\n *\n * ```ts\n * import { Equal, Hash, HashSet } from \"effect\"\n *\n * class Person implements Equal.Equal {\n *   constructor(\n *     readonly id: number, // Unique identifier\n *     readonly name: string,\n *     readonly age: number\n *   ) {}\n *\n *   // Define equality based on id, name, and age\n *   [Equal.symbol](that: Equal.Equal): boolean {\n *     if (that instanceof Person) {\n *       return (\n *         Equal.equals(this.id, that.id) &&\n *         Equal.equals(this.name, that.name) &&\n *         Equal.equals(this.age, that.age)\n *       )\n *     }\n *     return false\n *   }\n *\n *   // Generate a hash code based on the unique id\n *   [Hash.symbol](): number {\n *     return Hash.hash(this.id)\n *   }\n * }\n *\n * // Creating a HashSet with objects that implement the Equal interface\n * const set = HashSet.empty().pipe(\n *   HashSet.add(new Person(1, \"Alice\", 30)),\n *   HashSet.add(new Person(1, \"Alice\", 30))\n * )\n *\n * // HashSet recognizes them as equal, so only one element is stored\n * console.log(HashSet.size(set))\n * // Output: 1\n * ```\n *\n * **Simplifying Equality and Hashing with `Data` and `Schema`:**\n *\n * Effect's {@link Data} and {@link Schema `Schema.Data`} modules offer powerful\n * ways to automatically handle the implementation of both the {@link Equal} and\n * {@link Hash} traits for your custom data structures.\n *\n * - **`Data` Module:** By using constructors like `Data.struct`, `Data.tuple`,\n *   `Data.array`, or `Data.case` to define your data types, Effect\n *   automatically generates the necessary implementations for value-based\n *   equality and consistent hashing. This significantly reduces boilerplate and\n *   ensures correctness.\n *\n * ```ts\n * import { HashSet, Data, Equal } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Data.* implements the `Equal` traits for us\n * const person1 = Data.struct({ id: 1, name: \"Alice\", age: 30 })\n * const person2 = Data.struct({ id: 1, name: \"Alice\", age: 30 })\n *\n * assert(Equal.equals(person1, person2))\n *\n * const set = HashSet.empty().pipe(\n *   HashSet.add(person1),\n *   HashSet.add(person2)\n * )\n *\n * // HashSet recognizes them as equal, so only one element is stored\n * console.log(HashSet.size(set)) // Output: 1\n * ```\n *\n * - **`Schema` Module:** When defining data schemas using the {@link Schema}\n *   module, you can use `Schema.Data` to automatically include the `Equal` and\n *   `Hash` traits in the decoded objects. This is particularly important when\n *   working with `HashSet`. **For decoded objects to be correctly recognized as\n *   equal within a `HashSet`, ensure that the schema for those objects is\n *   defined using `Schema.Data`.**\n *\n * ```ts\n * import { Equal, HashSet, Schema } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Schema.Data implements the `Equal` traits for us\n * const PersonSchema = Schema.Data(\n *   Schema.Struct({\n *     id: Schema.Number,\n *     name: Schema.String,\n *     age: Schema.Number\n *   })\n * )\n *\n * const Person = Schema.decode(PersonSchema)\n *\n * const person1 = Person({ id: 1, name: \"Alice\", age: 30 })\n * const person2 = Person({ id: 1, name: \"Alice\", age: 30 })\n *\n * assert(Equal.equals(person1, person2)) // Output: true\n *\n * const set = HashSet.empty().pipe(\n *   HashSet.add(person1),\n *   HashSet.add(person2)\n * )\n *\n * // HashSet thanks to Schema.Data implementation of the `Equal` trait, recognizes the two Person as equal, so only one element is stored\n * console.log(HashSet.size(set)) // Output: 1\n * ```\n *\n * ### Interoperability with the JavaScript Runtime:\n *\n * To interoperate with the regular JavaScript runtime, Effect's `HashSet`\n * provides methods to access its elements in formats readily usable by\n * JavaScript APIs: {@link values `HashSet.values`},\n * {@link toValues `HashSet.toValues`}\n *\n * ```ts\n * import { HashSet } from \"effect\"\n *\n * const hashSet: HashSet.HashSet<number> = HashSet.make(1, 2, 3)\n *\n * // Using HashSet.values to convert HashSet.HashSet<A> to IterableIterator<A>\n * const iterable: IterableIterator<number> = HashSet.values(hashSet)\n *\n * console.log(...iterable) // Logs:  1 2 3\n *\n * // Using HashSet.toValues to convert HashSet.HashSet<A> to Array<A>\n * const array: Array<number> = HashSet.toValues(hashSet)\n *\n * console.log(array) // Logs: [ 1, 2, 3 ]\n * ```\n *\n * Be mindful of performance implications (both time and space complexity) when\n * frequently converting between Effect's immutable HashSet and mutable\n * JavaScript data structures, especially for large collections.\n *\n * @module HashSet\n * @since 2.0.0\n */\n\nimport type { Equal } from \"./Equal.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as HS from \"./internal/hashSet.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport type { NoInfer } from \"./Types.js\"\n\nconst TypeId: unique symbol = HS.HashSetTypeId as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @memberof HashSet\n * @since 2.0.0\n * @category models\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet } from \"effect\"\n *\n * let numberSet: HashSet.HashSet<number>\n * ```\n *\n * @interface\n */\nexport interface HashSet<out A> extends Iterable<A>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n}\n\n/**\n * @memberof HashSet\n * @since 2.0.0\n * @category refinements\n */\nexport const isHashSet: {\n  /**\n   * Type guard function to determine if a given iterable is a `HashSet`.\n   *\n   * This overload preserves the type of the iterable's elements.\n   *\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   *\n   * const numberIterable: Iterable<1 | 2 | 3> = [1, 2, 3]\n   *\n   * if (\n   *   // if passed an Iterable<A> the type guard that preserves the type parameter <A>\n   *   HashSet.isHashSet(numberIterable)\n   * ) {\n   *   const HashSet: HashSet.HashSet<1 | 2 | 3> = numberIterable\n   * }\n   * ```\n   *\n   * @param u - The iterable input to be checked.\n   * @returns A boolean indicating whether the provided iterable is a `HashSet`.\n   */\n  <A>(u: Iterable<A>): u is HashSet<A>\n\n  /**\n   * Type guard function that checks if the provided value is a `HashSet` of\n   * unknown type.\n   *\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // Check if a value is a HashSet\n   * const set = HashSet.make(1, 2, 3)\n   *\n   * assert.equal(HashSet.isHashSet(set), true) // true\n   * assert.equal(HashSet.isHashSet(HashSet.empty()), true)\n   *\n   * // Works with any type\n   * assert.equal(HashSet.isHashSet(null), false) // false\n   * assert.equal(HashSet.isHashSet({}), false) // false\n   * assert.equal(HashSet.isHashSet([1, 2, 3]), false) // false\n   * ```\n   *\n   * @param u - The value to check.\n   * @returns A boolean indicating whether the value is a `HashSet<unknown>`.\n   */\n  (u: unknown): u is HashSet<unknown>\n} = HS.isHashSet\n\n/**\n * Creates an empty `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     // Provide a type argument to create a HashSet of a specific type\n *     HashSet.empty<number>(),\n *     HashSet.add(1),\n *     HashSet.add(1), // Notice the duplicate\n *     HashSet.add(2),\n *     HashSet.toValues\n *   )\n * ) // Output: [1, 2]\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.make} {@link module:HashSet.fromIterable}\n */\nexport const empty: <A = never>() => HashSet<A> = HS.empty\n\n/**\n * Creates a new `HashSet` from an iterable collection of values.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the iterable\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * // Creating a HashSet from an Array\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.\n *     HashSet.fromIterable,\n *     HashSet.toValues\n *   )\n * ) // Output: [1, 2, 3, 4, 5]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from a Set\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     new Set([\"apple\", \"banana\", \"orange\", \"apple\"]), // Set<string> is an Iterable<string>\n *     HashSet.fromIterable,\n *     HashSet.toValues\n *   )\n * ) // Output: [\"apple\", \"banana\", \"orange\"]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from a Generator\n * import { HashSet } from \"effect\"\n *\n * // Generator functions return iterables\n * function* fibonacci(n: number): Generator<number, void, unknown> {\n *   let [a, b] = [0, 1]\n *   for (let i = 0; i < n; i++) {\n *     yield a\n *     ;[a, b] = [b, a + b]\n *   }\n * }\n *\n * // Create a HashSet from the first 10 Fibonacci numbers\n * const fibonacciSet = HashSet.fromIterable(fibonacci(10))\n *\n * console.log(HashSet.toValues(fibonacciSet))\n * // Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order\n * ```\n *\n * @example\n *\n * ```ts\n * //  Creating a HashSet from another HashSet\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     // since HashSet implements the Iterable interface, we can use it to create a new HashSet\n *     HashSet.make(1, 2, 3, 4),\n *     HashSet.fromIterable,\n *     HashSet.toValues // turns the HashSet back into an array\n *   )\n * ) // Output: [1, 2, 3, 4]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from other Effect's data structures like Chunk\n * import { Chunk, HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     Chunk.make(1, 2, 3, 4), // Iterable<number>\n *     HashSet.fromIterable,\n *     HashSet.toValues // turns the HashSet back into an array\n *   )\n * ) // Outputs: [1, 2, 3, 4]\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.empty} {@link module:HashSet.make}\n */\nexport const fromIterable: <A>(elements: Iterable<A>) => HashSet<A> = HS.fromIterable\n\n/**\n * Construct a new `HashSet` from a variable number of values.\n *\n * Time complexity: **`O(n)`** where n is the number of elements\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * import { Equal, Hash, HashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * class Character implements Equal.Equal {\n *   readonly name: string\n *   readonly trait: string\n *\n *   constructor(name: string, trait: string) {\n *     this.name = name\n *     this.trait = trait\n *   }\n *\n *   // Define equality based on name, and trait\n *   [Equal.symbol](that: Equal.Equal): boolean {\n *     if (that instanceof Character) {\n *       return (\n *         Equal.equals(this.name, that.name) &&\n *         Equal.equals(this.trait, that.trait)\n *       )\n *     }\n *     return false\n *   }\n *\n *   // Generate a hash code based on the sum of the character's name and trait\n *   [Hash.symbol](): number {\n *     return Hash.hash(this.name + this.trait)\n *   }\n *\n *   static readonly of = (name: string, trait: string): Character => {\n *     return new Character(name, trait)\n *   }\n * }\n *\n * assert.strictEqual(\n *   Equal.equals(\n *     HashSet.make(\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ),\n *     // Is the same as adding each character to an empty set\n *     pipe(\n *       HashSet.empty(),\n *       HashSet.add(Character.of(\"Alice\", \"Curious\")),\n *       HashSet.add(Character.of(\"Alice\", \"Curious\")), // Alice tried to attend twice!\n *       HashSet.add(Character.of(\"White Rabbit\", \"Always late\")),\n *       HashSet.add(Character.of(\"Mad Hatter\", \"Tea enthusiast\"))\n *     )\n *   ),\n *   true,\n *   \"`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal\"\n * )\n *\n * assert.strictEqual(\n *   Equal.equals(\n *     HashSet.make(\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ),\n *     HashSet.fromIterable([\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ])\n *   ),\n *   true,\n *   \"`HashSet.make` and `HashSet.fromIterable` should be equal\"\n * )\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.fromIterable} {@link module:HashSet.empty}\n */\nexport const make: <As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]> = HS.make\n\n/**\n * Checks if the specified value exists in the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false\n *\n * // or with `data-first` API\n * HashSet.has(HashSet.make(0, 1, 2), 3) // false\n * ```\n *\n * @returns A `boolean` signaling the presence of the value in the HashSet\n * @see Other `HashSet` elements are {@link module:HashSet.some} {@link module:HashSet.every} {@link module:HashSet.isSubset}\n */\nexport const has: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet, pipe } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(pipe(set, HashSet.has(0)), true)\n   * assert.equal(pipe(set, HashSet.has(1)), true)\n   * assert.equal(pipe(set, HashSet.has(2)), true)\n   * assert.equal(pipe(set, HashSet.has(3)), false)\n   * ```\n   */\n  <A>(value: A): (self: HashSet<A>) => boolean\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet, pipe } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(HashSet.has(set, 0), true)\n   * assert.equal(HashSet.has(set, 1), true)\n   * assert.equal(HashSet.has(set, 2), true)\n   * assert.equal(HashSet.has(set, 3), false)\n   * ```\n   */\n  <A>(self: HashSet<A>, value: A): boolean\n} = HS.has\n\n/**\n * Check if a predicate holds true for some `HashSet` element.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   set,\n *   HashSet.some((n) => n > 0)\n * ) // true\n *\n * // or piped with the pipe function\n * set.pipe(HashSet.some((n) => n > 0)) // true\n *\n * // or with `data-first` API\n * HashSet.some(set, (n) => n > 0) // true\n * ```\n *\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.every} {@link module:HashSet.isSubset}\n */\nexport const some: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet, pipe } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(\n   *   pipe(\n   *     set,\n   *     HashSet.some((n) => n > 0)\n   *   ),\n   *   true\n   * )\n   *\n   * assert.equal(\n   *   pipe(\n   *     set,\n   *     HashSet.some((n) => n > 2)\n   *   ),\n   *   false\n   * )\n   * ```\n   */\n  <A>(f: Predicate<A>): (self: HashSet<A>) => boolean\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(\n   *   HashSet.some(set, (n) => n > 0),\n   *   true\n   * )\n   *\n   * assert.equal(\n   *   HashSet.some(set, (n) => n > 2),\n   *   false\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, f: Predicate<A>): boolean\n} = HS.some\n\n/**\n * Check if a predicate holds true for every `HashSet` element.\n *\n * Time complexity is **`O(n)`** as it needs to traverse the whole HashSet\n * collection\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax with Refinement\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * const numberOrString = HashSet.make(1, \"1\", \"one\", \"uno\")\n *\n * // with `data-last`, a.k.a. `pipeable` API and `Refinement`\n * pipe(\n *   numberOrString, // HashSet.HashSet<number | string>\n *   HashSet.every(Predicate.isString)\n * ) // HashSet.HashSet<string>\n *\n * // or piped with the pipe function and  `Refinement`\n * numberOrString // HashSet.HashSet<number | string>\n *   .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>\n *\n * // or with `data-first` API and `Refinement`\n * HashSet.every(\n *   numberOrString, // HashSet.HashSet<number | string>\n *   Predicate.isString\n * ) // HashSet.HashSet<string>\n * ```\n *\n * @example\n *\n * ```ts\n * // Syntax with Predicate\n * import { HashSet, pipe } from \"effect\"\n *\n * const set = HashSet.make(1, 2, 3)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   set,\n *   HashSet.every((n) => n >= 0)\n * ) // true\n *\n * // or piped with the pipe function\n * set.pipe(HashSet.every((n) => n >= 0)) // true\n *\n * // or with `data-first` API\n * HashSet.every(set, (n) => n >= 0) // true\n * ```\n *\n * @returns A boolean once it has evaluated that whole collection fulfill the\n *   Predicate function\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.isSubset}\n */\nexport const every: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { Effect, HashSet, pipe, Predicate } from \"effect\"\n   *\n   * const numberOrString: HashSet.HashSet<number | string> = HashSet.make(\n   *   1,\n   *   \"1\",\n   *   \"one\",\n   *   \"uno\"\n   * )\n   *\n   * assert.equal(\n   *   pipe(\n   *     numberOrString, // HashSet.HashSet<number | string>\n   *     HashSet.every(Predicate.isString)\n   *   ), // HashSet.HashSet<string>\n   *   false\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>\n  ): (self: HashSet<A>) => self is HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet, pipe } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(\n   *   pipe(\n   *     set,\n   *     HashSet.every((n) => n >= 0)\n   *   ),\n   *   true\n   * )\n   * ```\n   */\n  <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { Effect, HashSet, pipe, Predicate } from \"effect\"\n   *\n   * const numberOrString: HashSet.HashSet<number | string> = HashSet.make(\n   *   1,\n   *   \"1\",\n   *   \"one\",\n   *   \"uno\"\n   * )\n   *\n   * assert.equal(\n   *   HashSet.every(\n   *     numberOrString, // HashSet.HashSet<number | string>\n   *     Predicate.isString\n   *   ), // HashSet.HashSet<string>\n   *   false\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    self: HashSet<A>,\n    refinement: Refinement<A, B>\n  ): self is HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(\n   *   HashSet.every(set, (n) => n >= 0),\n   *   true\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, predicate: Predicate<A>): boolean\n} = HS.every\n\n/**\n * Returns `true` if and only if every element in the this `HashSet` is an\n * element of the second set,\n *\n * **NOTE**: the hash and equal of both sets must be the same.\n *\n * Time complexity analysis is of **`O(n)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const set1 = HashSet.make(0, 1)\n * const set2 = HashSet.make(1, 2)\n * const set3 = HashSet.make(0, 1, 2)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(set1, HashSet.isSubset(set2)) // false\n * pipe(set1, HashSet.isSubset(set3)) // true\n *\n * // or piped with the pipe function\n * set1.pipe(HashSet.isSubset(set2)) // false\n * set1.pipe(HashSet.isSubset(set3)) // true\n *\n * // or with `data-first` API\n * HashSet.isSubset(set1, set2) // false\n * HashSet.isSubset(set1, set3) // true)\n * ```\n *\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.every}\n */\nexport const isSubset: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.equal(\n   *   pipe(\n   *     HashSet.make(0, 1), //\n   *     HashSet.isSubset(HashSet.make(1, 2))\n   *   ),\n   *   false\n   * )\n   *\n   * assert.equal(\n   *   pipe(\n   *     HashSet.make(0, 1), //\n   *     HashSet.isSubset(HashSet.make(0, 1, 2))\n   *   ),\n   *   true\n   * )\n   * ```\n   */\n  <A>(that: HashSet<A>): (self: HashSet<A>) => boolean\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.equal(HashSet.isSubset(set1, set2), false)\n   *\n   * assert.equal(HashSet.isSubset(set1, set3), true)\n   * ```\n   */\n  <A>(self: HashSet<A>, that: HashSet<A>): boolean\n} = HS.isSubset\n\n/**\n * Returns an `IterableIterator` of the values in the `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n *\n * const numberIterable = pipe(\n *   HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>\n *   HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>\n * )\n *\n * for (const number of numberIterable) {\n *   console.log(number) // it will logs: 0, 1, 2\n * }\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.toValues} {@link module:HashSet.size}\n */\nexport const values: <A>(self: HashSet<A>) => IterableIterator<A> = HS.values\n\n/**\n * Returns an `Array` of the values within the `HashSet`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * @memberof HashSet\n * @since 3.13.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n * import { deepStrictEqual } from \"node:assert/strict\"\n *\n * deepStrictEqual(\n *   pipe(\n *     HashSet.make(0, 1, 1, 2), // HashSet<number>\n *     HashSet.toValues // takes an HashSet<A> and returns an Array<A>\n *   ),\n *   Array.of(0, 1, 2)\n * )\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.size}\n */\nexport const toValues = <A>(self: HashSet<A>): Array<A> => Array.from(values(self))\n\n/**\n * Calculates the number of values in the `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * assert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)\n *\n * assert.deepStrictEqual(\n *   pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),\n *   4\n * )\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.toValues}\n */\nexport const size: <A>(self: HashSet<A>) => number = HS.size\n\n/**\n * Creates a new mutable version of the `HashSet`\n *\n * When a `HashSet` is mutable, operations like {@link add} and {@link remove}\n * modify the data structure in place instead of creating a new one, which is\n * more efficient when performing multiple operations.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * import { HashSet } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * const UPPER_BOUND = 10_000\n *\n * const immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))\n *\n * // Create a mutable version of the immutableSet\n * const mutableSet = HashSet.beginMutation(immutableSet)\n *\n * for (let i = 1; i < UPPER_BOUND; i++) {\n *   // Operations now modify the set in place instead of creating new instances\n *   // This is more efficient when making multiple changes\n *   const pointerToMutableSet = HashSet.add(mutableSet, i)\n *\n *   // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance\n *   assert(Object.is(mutableSet, pointerToMutableSet))\n *   assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet\n *   assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet\n * }\n *\n * const next = UPPER_BOUND + 1\n * // When done, mark the set as immutable again\n * HashSet.endMutation(mutableSet).pipe(\n *   HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet\n * )\n * assert.equal(HashSet.has(mutableSet, next), false)\n *\n * console.log(HashSet.toValues(immutableSet)) // [0]\n * console.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const beginMutation: <A>(self: HashSet<A>) => HashSet<A> = HS.beginMutation\n\n/**\n * Makes the `HashSet` immutable again.\n *\n * After calling `endMutation`, operations like {@link add} and {@link remove}\n * will create new instances of the `HashSet` instead of modifying the existing\n * one.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * import { HashSet } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Create a mutable set\n * const mutableSet = HashSet.beginMutation(HashSet.empty<number>())\n *\n * // Add some elements to the mutable set\n * HashSet.add(mutableSet, 1)\n * HashSet.add(mutableSet, 2)\n *\n * // Before endMutation, operations modify the set in place\n * const sameSet = HashSet.add(mutableSet, 3)\n * assert(Object.is(mutableSet, sameSet)) // true - same object reference\n * assert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])\n *\n * // Make the set immutable again\n * const immutableSet = HashSet.endMutation(mutableSet)\n *\n * // endMutation returns the same set instance, now made immutable\n * assert(Object.is(mutableSet, immutableSet)) // true - same object reference\n *\n * // After endMutation, operations create new instances\n * const newSet = HashSet.add(immutableSet, 4)\n * assert(!Object.is(immutableSet, newSet)) // false - different object references\n *\n * // The original set remains unchanged\n * assert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])\n *\n * // The new set contains the added element\n * assert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.mutate}\n */\nexport const endMutation: <A>(self: HashSet<A>) => HashSet<A> = HS.endMutation\n\n/**\n * Mutates the `HashSet` within the context of the provided function.\n *\n * You can consider it a functional abstraction on top of the lower-level\n * mutation primitives of {@link module:HashSet.beginMutation} `->` `mutable\n * context` `->` {@link HashSet.endMutation}.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(\n *   HashSet.make(1, 2, 3),\n *   HashSet.mutate((set) => {\n *     HashSet.add(set, 4)\n *     HashSet.remove(set, 1)\n *   })\n * )\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(\n *   HashSet.mutate((set) => {\n *     HashSet.add(set, 4)\n *     HashSet.remove(set, 1)\n *   })\n * )\n *\n * // or with data-first API\n * HashSet.mutate(HashSet.make(1, 2, 3), (set) => {\n *   HashSet.add(set, 4)\n *   HashSet.remove(set, 1)\n * })\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation}\n */\nexport const mutate: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // Create a set with initial values\n   * const immutableSet = HashSet.make(1, 2, 3)\n   *\n   * // Use mutate to perform multiple operations efficiently\n   * const result = pipe(\n   *   immutableSet,\n   *   HashSet.mutate((set) => {\n   *     assert.equal(Object.is(immutableSet, set), false)\n   *\n   *     // The set is temporarily mutable inside this function\n   *     const mod1 = HashSet.add(set, 4)\n   *     const mod2 = HashSet.remove(set, 1)\n   *     assert.equal(Object.is(mod1, mod2), true) // they are the same object by reference\n   *   })\n   * )\n   *\n   * // The original set is unchanged\n   * assert.equal(Object.is(immutableSet, result), false)\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(immutableSet).sort(),\n   *   [1, 2, 3]\n   * )\n   *\n   * // The result contains the mutations\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [2, 3, 4])\n   * ```\n   */\n  <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // Create a set with initial values\n   * const immutableSet = HashSet.make(1, 2, 3)\n   *\n   * // Use mutate with data-first API\n   * const result = HashSet.mutate(immutableSet, (set) => {\n   *   // The set is temporarily mutable inside this function\n   *   HashSet.add(set, 4)\n   *   HashSet.remove(set, 1)\n   * })\n   *\n   * // The original set is unchanged\n   * assert.equal(Object.is(immutableSet, result), false)\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(immutableSet).sort(),\n   *   [1, 2, 3]\n   * )\n   *\n   * // The result contains the mutations\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [2, 3, 4])\n   * ```\n   */\n  <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>\n} = HS.mutate\n\n/**\n * Adds a value to the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @remarks\n * Remember that a `HashSet` is a collection of unique values, so adding a value\n * that already exists in the `HashSet` will not add a duplicate.\n *\n * Remember that HashSet is an immutable data structure, so the `add` function,\n * like all other functions that modify the HashSet, will return a new HashSet\n * with the added value.\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))\n *\n * // or piped with the pipe function\n * HashSet.empty().pipe(HashSet.add(0))\n *\n * // or with data-first API\n * HashSet.add(HashSet.empty(), 0)\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const add: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     HashSet.empty<number>(), // HashSet.HashSet<number>\n   *     HashSet.add(0),\n   *     HashSet.add(1),\n   *     HashSet.add(1),\n   *     HashSet.add(2),\n   *     HashSet.toValues\n   *   ),\n   *   Array.of(0, 1, 2)\n   * )\n   * ```\n   */\n  <A>(value: A): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * const empty = HashSet.empty<number>()\n   * const withZero = HashSet.add(empty, 0)\n   * const withOne = HashSet.add(withZero, 1)\n   * const withTwo = HashSet.add(withOne, 2)\n   * const withTwoTwo = HashSet.add(withTwo, 2)\n   *\n   * assert.deepStrictEqual(HashSet.toValues(withTwoTwo), Array.of(0, 1, 2))\n   * ```\n   */\n  <A>(self: HashSet<A>, value: A): HashSet<A>\n} = HS.add\n\n/**\n * Removes a value from the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.remove(0))\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.remove(0))\n *\n * // or with `data-first` API\n * HashSet.remove(HashSet.make(0, 1, 2), 0)\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const remove: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   * const result = pipe(set, HashSet.remove(0))\n   *\n   * assert.equal(pipe(result, HashSet.has(0)), false) // it has correctly removed 0\n   * assert.equal(pipe(set, HashSet.has(0)), true) // it does not mutate the original set\n   * assert.equal(pipe(result, HashSet.has(1)), true)\n   * assert.equal(pipe(result, HashSet.has(2)), true)\n   * ```\n   */\n  <A>(value: A): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   * const result = HashSet.remove(set, 0)\n   *\n   * assert.equal(HashSet.has(result, 0), false) // it has correctly removed 0\n   * assert.equal(HashSet.has(set, 0), true) // it does not mutate the original set\n   * assert.equal(HashSet.has(result, 1), true)\n   * assert.equal(HashSet.has(result, 2), true)\n   * ```\n   */\n  <A>(self: HashSet<A>, value: A): HashSet<A>\n} = HS.remove\n\n/**\n * Computes the set difference `(A - B)` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same; meaning we cannot compute a difference between a `HashSet\n * of bananas` and a `HashSet of elephants` as they are not the same type and\n * won't implement the Equal trait in the same way.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))\n *\n * // or with data-first API\n * HashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.intersection} {@link module:HashSet.union}\n */\nexport const difference: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const thisSet = HashSet.make(1, 2, 3)\n   * const thatIterable = HashSet.make(3, 4, 5)\n   *\n   * // Compute the difference (elements in thisSet that are not in thatIterable)\n   * const result = pipe(thisSet, HashSet.difference(thatIterable))\n   *\n   * // The result contains only elements from thisSet that are not in thatIterable\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [1, 2])\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(thisSet).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(thatIterable).sort(),\n   *   [3, 4, 5]\n   * )\n   *\n   * // You can also use arrays or other iterables\n   * const diffWithArray = pipe(thisSet, HashSet.difference([3, 4]))\n   * assert.deepStrictEqual(HashSet.toValues(diffWithArray).sort(), [1, 2])\n   * ```\n   */\n  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const thisSet = HashSet.make(1, 2, 3)\n   * const thatIterable = HashSet.make(3, 4, 5)\n   *\n   * // Compute the difference using data-first API\n   * const result = HashSet.difference(thisSet, thatIterable)\n   *\n   * // The result contains only elements from thisSet that are not in thatIterable\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [1, 2])\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(thisSet).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(thatIterable).sort(),\n   *   [3, 4, 5]\n   * )\n   *\n   * // You can also compute the difference in the other direction\n   * const reverseResult = HashSet.difference(thatIterable, thisSet)\n   * assert.deepStrictEqual(HashSet.toValues(reverseResult).sort(), [4, 5])\n   * ```\n   */\n  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>\n} = HS.difference\n\n/**\n * Returns a `HashSet` of values which are present in both this set and that\n * `Iterable<A>`. Computes set intersection (A ∩ B)\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the smaller\n * set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))\n *\n * // or with data-first API\n * HashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.union}\n */\nexport const intersection: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const set1 = HashSet.make(1, 2, 3)\n   * const set2 = HashSet.make(2, 3, 4)\n   *\n   * // Compute the intersection (elements that are in both sets)\n   * const result = pipe(set1, HashSet.intersection(set2))\n   *\n   * // The result contains only elements that are in both sets\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [2, 3])\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(set1).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(HashSet.toValues(set2).sort(), [2, 3, 4])\n   *\n   * // You can also use arrays or other iterables\n   * const intersectWithArray = pipe(set1, HashSet.intersection([2, 3, 5]))\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(intersectWithArray).sort(),\n   *   [2, 3]\n   * )\n   * ```\n   */\n  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const set1 = HashSet.make(1, 2, 3)\n   * const set2 = HashSet.make(2, 3, 4)\n   *\n   * // Compute the intersection using data-first API\n   * const result = HashSet.intersection(set1, set2)\n   *\n   * // The result contains only elements that are in both sets\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [2, 3])\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(set1).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(HashSet.toValues(set2).sort(), [2, 3, 4])\n   *\n   * // You can also use arrays or other iterables\n   * const intersectWithArray = HashSet.intersection(set1, [2, 3, 5])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(intersectWithArray).sort(),\n   *   [2, 3]\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>\n} = HS.intersection\n\n/**\n * Computes the set union `( self ∪ that )` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))\n *\n * // or with data-first API\n * HashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.intersection}\n */\nexport const union: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const selfSet = HashSet.make(1, 2, 3)\n   * const thatIterable = HashSet.make(3, 4, 5)\n   *\n   * // Compute the union (all elements from both sets)\n   * const result = pipe(selfSet, HashSet.union(thatIterable))\n   *\n   * // The result contains all elements from both sets (without duplicates)\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(result).sort(),\n   *   [1, 2, 3, 4, 5]\n   * )\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(selfSet).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(thatIterable).sort(),\n   *   [3, 4, 5]\n   * )\n   *\n   * // You can also use arrays or other iterables\n   * const unionWithArray = pipe(selfSet, HashSet.union([4, 5, 6]))\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(unionWithArray).sort(),\n   *   [1, 2, 3, 4, 5, 6]\n   * )\n   * ```\n   */\n  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const selfSet = HashSet.make(1, 2, 3)\n   * const thatIterable = HashSet.make(3, 4, 5)\n   *\n   * // Compute the union using data-first API\n   * const result = HashSet.union(selfSet, thatIterable)\n   *\n   * // The result contains all elements from both sets (without duplicates)\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(result).sort(),\n   *   [1, 2, 3, 4, 5]\n   * )\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(selfSet).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(thatIterable).sort(),\n   *   [3, 4, 5]\n   * )\n   *\n   * // You can also use arrays or other iterables\n   * const unionWithArray = HashSet.union(selfSet, [4, 5, 6])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(unionWithArray).sort(),\n   *   [1, 2, 3, 4, 5, 6]\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>\n} = HS.union\n\n/**\n * Checks if a value is present in the `HashSet`. If it is present, the value\n * will be removed from the `HashSet`, otherwise the value will be added to the\n * `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.toggle(0))\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.toggle(0))\n *\n * // or with `data-first` API\n * HashSet.toggle(HashSet.make(0, 1, 2), 0)\n * ```\n *\n * @returns A new `HashSet` where the toggled value is being either added or\n *   removed based on the initial `HashSet` state.\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const toggle: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // arrange\n   * let set = HashSet.make(0, 1, 2)\n   *\n   * // assert 1: 0 is in the set\n   * assert.equal(pipe(set, HashSet.has(0)), true)\n   *\n   * // act 2: toggle 0 once on the set\n   * set = pipe(set, HashSet.toggle(0))\n   *\n   * // assert 2: 0 is not in the set any longer\n   * assert.equal(pipe(set, HashSet.has(0)), false)\n   *\n   * // act 3: toggle 0 once again on the set\n   * set = pipe(set, HashSet.toggle(0))\n   *\n   * // assert 3: 0 in now back in the set\n   * assert.equal(pipe(set, HashSet.has(0)), true)\n   * ```\n   */\n  <A>(value: A): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // arrange\n   * let set = HashSet.make(0, 1, 2)\n   *\n   * // assert 1: 0 is in the set\n   * assert.equal(HashSet.has(set, 0), true)\n   *\n   * // act 2: toggle 0 once on the set\n   * set = HashSet.toggle(set, 0)\n   *\n   * // assert 2: 0 is not in the set any longer\n   * assert.equal(HashSet.has(set, 0), false)\n   *\n   * // act 3: toggle 0 once again on the set\n   * set = HashSet.toggle(set, 0)\n   *\n   * // assert 3: 0 in now back in the set\n   * assert.equal(HashSet.has(set, 0), true)\n   * ```\n   */\n  <A>(self: HashSet<A>, value: A): HashSet<A>\n} = HS.toggle\n\n/**\n * Maps over the values of the `HashSet` using the specified function.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category mapping\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n *   HashSet.map(String) // HashSet.HashSet<string>\n * )\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.map(String))\n *\n * // or with `data-first` API\n * HashSet.map(HashSet.make(0, 1, 2), String)\n * ```\n */\nexport const map: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     HashSet.make(0, 1, 2), //    HashSet.HashSet<number>\n   *     HashSet.map((n) => String(n + 1)) // HashSet.HashSet<String>\n   *   ),\n   *   HashSet.make(\"1\", \"2\", \"3\")\n   * )\n   * ```\n   */\n  <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   HashSet.map(\n   *     HashSet.make(0, 1, 2), //    HashSet.HashSet<number>\n   *     (n) => String(n + 1)\n   *   ), // HashSet.HashSet<String>\n   *   HashSet.make(\"1\", \"2\", \"3\")\n   * )\n   * ```\n   */\n  <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>\n} = HS.map\n\n/**\n * Chains over the values of the `HashSet` using the specified function.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category sequencing\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n *   HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n * )\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2) // HashSet.HashSet<number>\n *   .pipe(\n *     HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n *   )\n *\n * // or with `data-first` API\n * HashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))\n * ```\n */\nexport const flatMap: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, List } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     HashSet.make(0, 1, 2),\n   *     HashSet.flatMap((n) => List.of(String(n * n))) // needs to return an Iterable\n   *   ),\n   *   HashSet.make(\"0\", \"1\", \"4\")\n   * )\n   * ```\n   */\n  <A, B>(f: (a: A) => Iterable<B>): (self: HashSet<A>) => HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, List } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   HashSet.flatMap(HashSet.make(0, 1, 2), (n) =>\n   *     List.of(String(n * n * n))\n   *   ), // needs to return an Iterable\n   *   HashSet.make(\"0\", \"1\", \"8\")\n   * )\n   * ```\n   */\n  <A, B>(self: HashSet<A>, f: (a: A) => Iterable<B>): HashSet<B>\n} = HS.flatMap\n\n/**\n * Applies the specified function to the values of the `HashSet`.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category traversing\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2\n *\n * // or with `data-first` API\n * HashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2\n * ```\n */\nexport const forEach: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const result: Array<number> = []\n   *\n   * pipe(\n   *   HashSet.make(0, 1, 2),\n   *   HashSet.forEach((n): void => {\n   *     result.push(n)\n   *   })\n   * )\n   *\n   * assert.deepStrictEqual(result, [0, 1, 2])\n   * ```\n   */\n  <A>(f: (value: A) => void): (self: HashSet<A>) => void\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const result: Array<number> = []\n   *\n   * HashSet.forEach(HashSet.make(0, 1, 2), (n): void => {\n   *   result.push(n)\n   * })\n   *\n   * assert.deepStrictEqual(result, [0, 1, 2])\n   * ```\n   */\n  <A>(self: HashSet<A>, f: (value: A) => void): void\n} = HS.forEach\n\n/**\n * Reduces the specified state over the values of the `HashSet`.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category folding\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const sum = (a: number, b: number): number => a + b\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))\n *\n * // or with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))\n *\n * // or with `data-first` API\n * HashSet.reduce(HashSet.make(0, 1, 2), 0, sum)\n * ```\n */\nexport const reduce: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.equal(\n   *   pipe(\n   *     HashSet.make(0, 1, 2),\n   *     HashSet.reduce(10, (accumulator, value) => accumulator + value)\n   *   ),\n   *   13\n   * )\n   * ```\n   */\n  <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.equal(\n   *   HashSet.reduce(\n   *     HashSet.make(0, 1, 2),\n   *     -3,\n   *     (accumulator, value) => accumulator + value\n   *   ),\n   *   0\n   * )\n   * ```\n   */\n  <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z\n} = HS.reduce\n\n/**\n * Filters values out of a `HashSet` using the specified predicate.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category filtering\n * @example\n *\n * ```ts\n * // Syntax with  Predicate\n * import { HashSet, type Predicate, pipe } from \"effect\"\n *\n * const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(-2, -1, 0, 1, 2),\n *   HashSet.filter(filterPositiveNumbers)\n * )\n *\n * // or with the pipe method\n * HashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))\n *\n * // or with `data-first` API\n * HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)\n * ```\n *\n * @example\n *\n * ```ts\n * /// Syntax with Refinement\n * import { HashSet, pipe } from \"effect\"\n *\n * const stringRefinement = (value: unknown): value is string =>\n *   typeof value === \"string\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // // HashSet.HashSet<number | string>\n *   HashSet.filter(stringRefinement)\n * ) // HashSet.HashSet<string>\n *\n * // or with the pipe method\n * HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\") // HashSet.HashSet<number | string>\n *   .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>\n *\n * // or with `data-first` API\n * HashSet.filter(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // HashSet.HashSet<number | string>\n *   stringRefinement\n * ) // HashSet.HashSet<string>\n * ```\n */\nexport const filter: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const numbersAndStringsHashSet: HashSet.HashSet<number | string> =\n   *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\")\n   *\n   * const stringRefinement: Predicate.Refinement<\n   *   string | number,\n   *   string\n   * > = (value) => typeof value === \"string\"\n   *\n   * const stringHashSet: HashSet.HashSet<string> = pipe(\n   *   numbersAndStringsHashSet,\n   *   HashSet.filter(stringRefinement)\n   * )\n   *\n   * assert.equal(\n   *   pipe(stringHashSet, HashSet.every(Predicate.isString)),\n   *   true\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>\n  ): (self: HashSet<A>) => HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, type Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     HashSet.make(-2, -1, 0, 1, 2),\n   *     HashSet.filter(filterPositiveNumbers)\n   *   ),\n   *   HashSet.make(1, 2)\n   * )\n   * ```\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const numbersAndStringsHashSet: HashSet.HashSet<number | string> =\n   *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\")\n   *\n   * const stringRefinement: Predicate.Refinement<\n   *   string | number,\n   *   string\n   * > = (value) => typeof value === \"string\"\n   *\n   * const stringHashSet: HashSet.HashSet<string> = HashSet.filter(\n   *   numbersAndStringsHashSet,\n   *   stringRefinement\n   * )\n   *\n   * assert.equal(HashSet.every(stringHashSet, Predicate.isString), true)\n   * ```\n   */\n  <A, B extends A>(\n    self: HashSet<A>,\n    refinement: Refinement<A, B>\n  ): HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, type Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers),\n   *   HashSet.make(1, 2)\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>\n} = HS.filter\n\n/**\n * Partition the values of a `HashSet` using the specified predicate.\n *\n * If a value matches the predicate, it will be placed into the `HashSet` on the\n * right side of the resulting `Tuple`, otherwise the value will be placed into\n * the left side.\n *\n * Time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category partitioning\n * @example\n *\n * ```ts\n * // Syntax with Predicate\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2, 3, 4, 5),\n *   HashSet.partition((n) => n % 2 === 0)\n * )\n *\n * // or with the pipe method\n * HashSet.make(0, 1, 2, 3, 4, 5).pipe(\n *   HashSet.partition((n) => n % 2 === 0)\n * )\n *\n * // or with `data-first` API\n * HashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)\n * ```\n *\n * @example\n *\n * ```ts\n * // Syntax with Refinement\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * const stringRefinement: Predicate.Refinement<string | number, string> = (\n *   value\n * ) => typeof value === \"string\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n *   HashSet.partition(stringRefinement)\n * )\n *\n * // or with the pipe method\n * HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\").pipe(\n *   HashSet.partition(stringRefinement)\n * )\n *\n * // or with `data-first` API\n * HashSet.partition(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n *   stringRefinement\n * )\n * ```\n */\nexport const partition: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const numbersAndStringsHashSet: HashSet.HashSet<number | string> =\n   *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\")\n   *\n   * const stringRefinement: Predicate.Refinement<\n   *   string | number,\n   *   string\n   * > = (value) => typeof value === \"string\"\n   *\n   * const [\n   *   excluded, // HashSet.HashSet<number>\n   *   satisfying // HashSet.HashSet<string>\n   * ] = pipe(numbersAndStringsHashSet, HashSet.partition(stringRefinement))\n   *\n   * assert.equal(pipe(satisfying, HashSet.every(Predicate.isString)), true)\n   * assert.equal(pipe(excluded, HashSet.every(Predicate.isNumber)), true)\n   *\n   * assert.deepStrictEqual(excluded, HashSet.make(1, 2, 3, 4))\n   * assert.deepStrictEqual(\n   *   satisfying,\n   *   HashSet.make(\"unos\", \"two\", \"trois\", \"vier\")\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>\n  ): (\n    self: HashSet<A>\n  ) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const [excluded, satisfying] = pipe(\n   *   HashSet.make(0, 1, 2, 3, 4, 5),\n   *   HashSet.partition((n) => n % 2 === 0)\n   * )\n   *\n   * assert.deepStrictEqual(excluded, HashSet.make(1, 3, 5))\n   * assert.deepStrictEqual(satisfying, HashSet.make(0, 2, 4))\n   * ```\n   */\n  <A>(\n    predicate: Predicate<NoInfer<A>>\n  ): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const numbersAndStringsHashSet: HashSet.HashSet<number | string> =\n   *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\")\n   *\n   * const stringRefinement: Predicate.Refinement<\n   *   string | number,\n   *   string\n   * > = (value) => typeof value === \"string\"\n   *\n   * const [\n   *   excluded, // HashSet.HashSet<number>\n   *   satisfying // HashSet.HashSet<string>\n   * ] = HashSet.partition(numbersAndStringsHashSet, stringRefinement)\n   *\n   * assert.equal(HashSet.every(satisfying, Predicate.isString), true)\n   * assert.equal(HashSet.every(excluded, Predicate.isNumber), true)\n   *\n   * assert.deepStrictEqual(excluded, HashSet.make(1, 2, 3, 4))\n   * assert.deepStrictEqual(\n   *   satisfying,\n   *   HashSet.make(\"unos\", \"two\", \"trois\", \"vier\")\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    self: HashSet<A>,\n    refinement: Refinement<A, B>\n  ): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const [excluded, satisfying] = HashSet.partition(\n   *   HashSet.make(0, 1, 2, 3, 4, 5),\n   *   (n) => n % 2 === 0\n   * )\n   *\n   * assert.deepStrictEqual(excluded, HashSet.make(1, 3, 5))\n   * assert.deepStrictEqual(satisfying, HashSet.make(0, 2, 4))\n   * ```\n   */\n  <A>(\n    self: HashSet<A>,\n    predicate: Predicate<A>\n  ): [excluded: HashSet<A>, satisfying: HashSet<A>]\n} = HS.partition\n","import * as Equal from \"../Equal.js\"\nimport * as Hash from \"../Hash.js\"\nimport type * as Types from \"../Types.js\"\nimport { StructuralPrototype } from \"./effectable.js\"\n\n/** @internal */\nexport const ArrayProto: Equal.Equal = Object.assign(Object.create(Array.prototype), {\n  [Hash.symbol](this: Array<any>) {\n    return Hash.cached(this, Hash.array(this))\n  },\n  [Equal.symbol](this: Array<any>, that: Equal.Equal) {\n    if (Array.isArray(that) && this.length === that.length) {\n      return this.every((v, i) => Equal.equals(v, (that as Array<any>)[i]))\n    } else {\n      return false\n    }\n  }\n})\n\n/** @internal */\nexport const Structural: new<A>(\n  args: Types.Equals<Omit<A, keyof Equal.Equal>, {}> extends true ? void\n    : { readonly [P in keyof A as P extends keyof Equal.Equal ? never : P]: A[P] }\n) => {} = (function() {\n  function Structural(this: any, args: any) {\n    if (args) {\n      Object.assign(this, args)\n    }\n  }\n  Structural.prototype = StructuralPrototype\n  return Structural as any\n})()\n\n/** @internal */\nexport const struct = <As extends Readonly<Record<string, any>>>(as: As): As =>\n  Object.assign(Object.create(StructuralPrototype), as)\n","/** @internal */\nexport const OP_DIE = \"Die\" as const\n\n/** @internal */\nexport type OP_DIE = typeof OP_DIE\n\n/** @internal */\nexport const OP_EMPTY = \"Empty\" as const\n\n/** @internal */\nexport type OP_EMPTY = typeof OP_EMPTY\n\n/** @internal */\nexport const OP_FAIL = \"Fail\" as const\n\n/** @internal */\nexport type OP_FAIL = typeof OP_FAIL\n\n/** @internal */\nexport const OP_INTERRUPT = \"Interrupt\" as const\n\n/** @internal */\nexport type OP_INTERRUPT = typeof OP_INTERRUPT\n\n/** @internal */\nexport const OP_PARALLEL = \"Parallel\" as const\n\n/** @internal */\nexport type OP_PARALLEL = typeof OP_PARALLEL\n\n/** @internal */\nexport const OP_SEQUENTIAL = \"Sequential\" as const\n\n/** @internal */\nexport type OP_SEQUENTIAL = typeof OP_SEQUENTIAL\n","import * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as FiberId from \"../FiberId.js\"\nimport { constFalse, constTrue, dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport { NodeInspectSymbol, stringifyCircular, toJSON } from \"../Inspectable.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type { Predicate, Refinement } from \"../Predicate.js\"\nimport { hasProperty, isFunction } from \"../Predicate.js\"\nimport type { AnySpan, Span } from \"../Tracer.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport { getBugErrorMessage } from \"./errors.js\"\nimport * as OpCodes from \"./opCodes/cause.js\"\n\n// -----------------------------------------------------------------------------\n// Models\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst CauseSymbolKey = \"effect/Cause\"\n\n/** @internal */\nexport const CauseTypeId: Cause.CauseTypeId = Symbol.for(\n  CauseSymbolKey\n) as Cause.CauseTypeId\n\nconst variance = {\n  /* c8 ignore next */\n  _E: (_: never) => _\n}\n\n/** @internal */\nconst proto = {\n  [CauseTypeId]: variance,\n  [Hash.symbol](this: Cause.Cause<any>): number {\n    return pipe(\n      Hash.hash(CauseSymbolKey),\n      Hash.combine(Hash.hash(flattenCause(this))),\n      Hash.cached(this)\n    )\n  },\n  [Equal.symbol](this: Cause.Cause<any>, that: unknown): boolean {\n    return isCause(that) && causeEquals(this, that)\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  toJSON<E>(this: Cause.Cause<E>) {\n    switch (this._tag) {\n      case \"Empty\":\n        return { _id: \"Cause\", _tag: this._tag }\n      case \"Die\":\n        return { _id: \"Cause\", _tag: this._tag, defect: toJSON(this.defect) }\n      case \"Interrupt\":\n        return { _id: \"Cause\", _tag: this._tag, fiberId: this.fiberId.toJSON() }\n      case \"Fail\":\n        return { _id: \"Cause\", _tag: this._tag, failure: toJSON(this.error) }\n      case \"Sequential\":\n      case \"Parallel\":\n        return { _id: \"Cause\", _tag: this._tag, left: toJSON(this.left), right: toJSON(this.right) }\n    }\n  },\n  toString<E>(this: Cause.Cause<E>) {\n    return pretty(this)\n  },\n  [NodeInspectSymbol]<E>(this: Cause.Cause<E>) {\n    return this.toJSON()\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Constructors\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const empty: Cause.Cause<never> = (() => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_EMPTY\n  return o\n})()\n\n/** @internal */\nexport const fail = <E>(error: E): Cause.Cause<E> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_FAIL\n  o.error = error\n  return o\n}\n\n/** @internal */\nexport const die = (defect: unknown): Cause.Cause<never> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_DIE\n  o.defect = defect\n  return o\n}\n\n/** @internal */\nexport const interrupt = (fiberId: FiberId.FiberId): Cause.Cause<never> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_INTERRUPT\n  o.fiberId = fiberId\n  return o\n}\n\n/** @internal */\nexport const parallel = <E, E2>(left: Cause.Cause<E>, right: Cause.Cause<E2>): Cause.Cause<E | E2> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_PARALLEL\n  o.left = left\n  o.right = right\n  return o\n}\n\n/** @internal */\nexport const sequential = <E, E2>(left: Cause.Cause<E>, right: Cause.Cause<E2>): Cause.Cause<E | E2> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_SEQUENTIAL\n  o.left = left\n  o.right = right\n  return o\n}\n\n// -----------------------------------------------------------------------------\n// Refinements\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const isCause = (u: unknown): u is Cause.Cause<unknown> => hasProperty(u, CauseTypeId)\n\n/** @internal */\nexport const isEmptyType = <E>(self: Cause.Cause<E>): self is Cause.Empty => self._tag === OpCodes.OP_EMPTY\n\n/** @internal */\nexport const isFailType = <E>(self: Cause.Cause<E>): self is Cause.Fail<E> => self._tag === OpCodes.OP_FAIL\n\n/** @internal */\nexport const isDieType = <E>(self: Cause.Cause<E>): self is Cause.Die => self._tag === OpCodes.OP_DIE\n\n/** @internal */\nexport const isInterruptType = <E>(self: Cause.Cause<E>): self is Cause.Interrupt => self._tag === OpCodes.OP_INTERRUPT\n\n/** @internal */\nexport const isSequentialType = <E>(self: Cause.Cause<E>): self is Cause.Sequential<E> =>\n  self._tag === OpCodes.OP_SEQUENTIAL\n\n/** @internal */\nexport const isParallelType = <E>(self: Cause.Cause<E>): self is Cause.Parallel<E> => self._tag === OpCodes.OP_PARALLEL\n\n// -----------------------------------------------------------------------------\n// Getters\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const size = <E>(self: Cause.Cause<E>): number => reduceWithContext(self, void 0, SizeCauseReducer)\n\n/** @internal */\nexport const isEmpty = <E>(self: Cause.Cause<E>): boolean => {\n  if (self._tag === OpCodes.OP_EMPTY) {\n    return true\n  }\n  return reduce(self, true, (acc, cause) => {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY: {\n        return Option.some(acc)\n      }\n      case OpCodes.OP_DIE:\n      case OpCodes.OP_FAIL:\n      case OpCodes.OP_INTERRUPT: {\n        return Option.some(false)\n      }\n      default: {\n        return Option.none()\n      }\n    }\n  })\n}\n\n/** @internal */\nexport const isFailure = <E>(self: Cause.Cause<E>): boolean => Option.isSome(failureOption(self))\n\n/** @internal */\nexport const isDie = <E>(self: Cause.Cause<E>): boolean => Option.isSome(dieOption(self))\n\n/** @internal */\nexport const isInterrupted = <E>(self: Cause.Cause<E>): boolean => Option.isSome(interruptOption(self))\n\n/** @internal */\nexport const isInterruptedOnly = <E>(self: Cause.Cause<E>): boolean =>\n  reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self)\n\n/** @internal */\nexport const failures = <E>(self: Cause.Cause<E>): Chunk.Chunk<E> =>\n  Chunk.reverse(\n    reduce<Chunk.Chunk<E>, E>(\n      self,\n      Chunk.empty<E>(),\n      (list, cause) =>\n        cause._tag === OpCodes.OP_FAIL ?\n          Option.some(pipe(list, Chunk.prepend(cause.error))) :\n          Option.none()\n    )\n  )\n\n/** @internal */\nexport const defects = <E>(self: Cause.Cause<E>): Chunk.Chunk<unknown> =>\n  Chunk.reverse(\n    reduce<Chunk.Chunk<unknown>, E>(\n      self,\n      Chunk.empty<unknown>(),\n      (list, cause) =>\n        cause._tag === OpCodes.OP_DIE ?\n          Option.some(pipe(list, Chunk.prepend(cause.defect))) :\n          Option.none()\n    )\n  )\n\n/** @internal */\nexport const interruptors = <E>(self: Cause.Cause<E>): HashSet.HashSet<FiberId.FiberId> =>\n  reduce(self, HashSet.empty<FiberId.FiberId>(), (set, cause) =>\n    cause._tag === OpCodes.OP_INTERRUPT ?\n      Option.some(pipe(set, HashSet.add(cause.fiberId))) :\n      Option.none())\n\n/** @internal */\nexport const failureOption = <E>(self: Cause.Cause<E>): Option.Option<E> =>\n  find<E, E>(self, (cause) =>\n    cause._tag === OpCodes.OP_FAIL ?\n      Option.some(cause.error) :\n      Option.none())\n\n/** @internal */\nexport const failureOrCause = <E>(self: Cause.Cause<E>): Either.Either<Cause.Cause<never>, E> => {\n  const option = failureOption(self)\n  switch (option._tag) {\n    case \"None\": {\n      // no `E` inside this `Cause`, so it can be safely cast to `never`\n      return Either.right(self as Cause.Cause<never>)\n    }\n    case \"Some\": {\n      return Either.left(option.value)\n    }\n  }\n}\n\n/** @internal */\nexport const dieOption = <E>(self: Cause.Cause<E>): Option.Option<unknown> =>\n  find(self, (cause) =>\n    cause._tag === OpCodes.OP_DIE ?\n      Option.some(cause.defect) :\n      Option.none())\n\n/** @internal */\nexport const flipCauseOption = <E>(self: Cause.Cause<Option.Option<E>>): Option.Option<Cause.Cause<E>> =>\n  match(self, {\n    onEmpty: Option.some<Cause.Cause<E>>(empty),\n    onFail: Option.map(fail),\n    onDie: (defect) => Option.some(die(defect)),\n    onInterrupt: (fiberId) => Option.some(interrupt(fiberId)),\n    onSequential: Option.mergeWith(sequential),\n    onParallel: Option.mergeWith(parallel)\n  })\n\n/** @internal */\nexport const interruptOption = <E>(self: Cause.Cause<E>): Option.Option<FiberId.FiberId> =>\n  find(self, (cause) =>\n    cause._tag === OpCodes.OP_INTERRUPT ?\n      Option.some(cause.fiberId) :\n      Option.none())\n\n/** @internal */\nexport const keepDefects = <E>(self: Cause.Cause<E>): Option.Option<Cause.Cause<never>> =>\n  match(self, {\n    onEmpty: Option.none(),\n    onFail: () => Option.none(),\n    onDie: (defect) => Option.some(die(defect)),\n    onInterrupt: () => Option.none(),\n    onSequential: Option.mergeWith(sequential),\n    onParallel: Option.mergeWith(parallel)\n  })\n\n/** @internal */\nexport const keepDefectsAndElectFailures = <E>(self: Cause.Cause<E>): Option.Option<Cause.Cause<never>> =>\n  match(self, {\n    onEmpty: Option.none(),\n    onFail: (failure) => Option.some(die(failure)),\n    onDie: (defect) => Option.some(die(defect)),\n    onInterrupt: () => Option.none(),\n    onSequential: Option.mergeWith(sequential),\n    onParallel: Option.mergeWith(parallel)\n  })\n\n/** @internal */\nexport const linearize = <E>(self: Cause.Cause<E>): HashSet.HashSet<Cause.Cause<E>> =>\n  match(self, {\n    onEmpty: HashSet.empty(),\n    onFail: (error) => HashSet.make(fail(error)),\n    onDie: (defect) => HashSet.make(die(defect)),\n    onInterrupt: (fiberId) => HashSet.make(interrupt(fiberId)),\n    onSequential: (leftSet, rightSet) =>\n      HashSet.flatMap(leftSet, (leftCause) => HashSet.map(rightSet, (rightCause) => sequential(leftCause, rightCause))),\n    onParallel: (leftSet, rightSet) =>\n      HashSet.flatMap(leftSet, (leftCause) => HashSet.map(rightSet, (rightCause) => parallel(leftCause, rightCause)))\n  })\n\n/** @internal */\nexport const stripFailures = <E>(self: Cause.Cause<E>): Cause.Cause<never> =>\n  match(self, {\n    onEmpty: empty,\n    onFail: () => empty,\n    onDie: die,\n    onInterrupt: interrupt,\n    onSequential: sequential,\n    onParallel: parallel\n  })\n\n/** @internal */\nexport const electFailures = <E>(self: Cause.Cause<E>): Cause.Cause<never> =>\n  match(self, {\n    onEmpty: empty,\n    onFail: die,\n    onDie: die,\n    onInterrupt: interrupt,\n    onSequential: sequential,\n    onParallel: parallel\n  })\n\n/** @internal */\nexport const stripSomeDefects = dual<\n  (pf: (defect: unknown) => Option.Option<unknown>) => <E>(self: Cause.Cause<E>) => Option.Option<Cause.Cause<E>>,\n  <E>(self: Cause.Cause<E>, pf: (defect: unknown) => Option.Option<unknown>) => Option.Option<Cause.Cause<E>>\n>(\n  2,\n  <E>(self: Cause.Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause.Cause<E>> =>\n    match(self, {\n      onEmpty: Option.some<Cause.Cause<E>>(empty),\n      onFail: (error) => Option.some(fail(error)),\n      onDie: (defect) => {\n        const option = pf(defect)\n        return Option.isSome(option) ? Option.none() : Option.some(die(defect))\n      },\n      onInterrupt: (fiberId) => Option.some(interrupt(fiberId)),\n      onSequential: Option.mergeWith(sequential),\n      onParallel: Option.mergeWith(parallel)\n    })\n)\n\n// -----------------------------------------------------------------------------\n// Mapping\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const as = dual<\n  <E2>(error: E2) => <E>(self: Cause.Cause<E>) => Cause.Cause<E2>,\n  <E, E2>(self: Cause.Cause<E>, error: E2) => Cause.Cause<E2>\n>(2, (self, error) => map(self, () => error))\n\n/** @internal */\nexport const map = dual<\n  <E, E2>(f: (e: E) => E2) => (self: Cause.Cause<E>) => Cause.Cause<E2>,\n  <E, E2>(self: Cause.Cause<E>, f: (e: E) => E2) => Cause.Cause<E2>\n>(2, (self, f) => flatMap(self, (e) => fail(f(e))))\n\n// -----------------------------------------------------------------------------\n// Sequencing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const flatMap = dual<\n  <E, E2>(f: (e: E) => Cause.Cause<E2>) => (self: Cause.Cause<E>) => Cause.Cause<E2>,\n  <E, E2>(self: Cause.Cause<E>, f: (e: E) => Cause.Cause<E2>) => Cause.Cause<E2>\n>(2, (self, f) =>\n  match(self, {\n    onEmpty: empty,\n    onFail: (error) => f(error),\n    onDie: (defect) => die(defect),\n    onInterrupt: (fiberId) => interrupt(fiberId),\n    onSequential: (left, right) => sequential(left, right),\n    onParallel: (left, right) => parallel(left, right)\n  }))\n\n/** @internal */\nexport const flatten = <E>(self: Cause.Cause<Cause.Cause<E>>): Cause.Cause<E> => flatMap(self, identity)\n\n/** @internal */\nexport const andThen: {\n  <E, E2>(f: (e: E) => Cause.Cause<E2>): (self: Cause.Cause<E>) => Cause.Cause<E2>\n  <E2>(f: Cause.Cause<E2>): <E>(self: Cause.Cause<E>) => Cause.Cause<E2>\n  <E, E2>(self: Cause.Cause<E>, f: (e: E) => Cause.Cause<E2>): Cause.Cause<E2>\n  <E, E2>(self: Cause.Cause<E>, f: Cause.Cause<E2>): Cause.Cause<E2>\n} = dual(\n  2,\n  <E, E2>(self: Cause.Cause<E>, f: ((e: E) => Cause.Cause<E2>) | Cause.Cause<E2>): Cause.Cause<E2> =>\n    isFunction(f) ? flatMap(self, f) : flatMap(self, () => f)\n)\n\n// -----------------------------------------------------------------------------\n// Equality\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const contains = dual<\n  <E2>(that: Cause.Cause<E2>) => <E>(self: Cause.Cause<E>) => boolean,\n  <E, E2>(self: Cause.Cause<E>, that: Cause.Cause<E2>) => boolean\n>(2, (self, that) => {\n  if (that._tag === OpCodes.OP_EMPTY || self === that) {\n    return true\n  }\n  return reduce(self, false, (accumulator, cause) => {\n    return Option.some(accumulator || causeEquals(cause, that))\n  })\n})\n\n/** @internal */\nconst causeEquals = (left: Cause.Cause<unknown>, right: Cause.Cause<unknown>): boolean => {\n  let leftStack: Chunk.Chunk<Cause.Cause<unknown>> = Chunk.of(left)\n  let rightStack: Chunk.Chunk<Cause.Cause<unknown>> = Chunk.of(right)\n  while (Chunk.isNonEmpty(leftStack) && Chunk.isNonEmpty(rightStack)) {\n    const [leftParallel, leftSequential] = pipe(\n      Chunk.headNonEmpty(leftStack),\n      reduce(\n        [HashSet.empty<unknown>(), Chunk.empty<Cause.Cause<unknown>>()] as const,\n        ([parallel, sequential], cause) => {\n          const [par, seq] = evaluateCause(cause)\n          return Option.some(\n            [\n              pipe(parallel, HashSet.union(par)),\n              pipe(sequential, Chunk.appendAll(seq))\n            ] as const\n          )\n        }\n      )\n    )\n    const [rightParallel, rightSequential] = pipe(\n      Chunk.headNonEmpty(rightStack),\n      reduce(\n        [HashSet.empty<unknown>(), Chunk.empty<Cause.Cause<unknown>>()] as const,\n        ([parallel, sequential], cause) => {\n          const [par, seq] = evaluateCause(cause)\n          return Option.some(\n            [\n              pipe(parallel, HashSet.union(par)),\n              pipe(sequential, Chunk.appendAll(seq))\n            ] as const\n          )\n        }\n      )\n    )\n    if (!Equal.equals(leftParallel, rightParallel)) {\n      return false\n    }\n    leftStack = leftSequential\n    rightStack = rightSequential\n  }\n  return true\n}\n\n// -----------------------------------------------------------------------------\n// Flattening\n// -----------------------------------------------------------------------------\n\n/**\n * Flattens a cause to a sequence of sets of causes, where each set represents\n * causes that fail in parallel and sequential sets represent causes that fail\n * after each other.\n *\n * @internal\n */\nconst flattenCause = (cause: Cause.Cause<unknown>): Chunk.Chunk<HashSet.HashSet<unknown>> => {\n  return flattenCauseLoop(Chunk.of(cause), Chunk.empty())\n}\n\n/** @internal */\nconst flattenCauseLoop = (\n  causes: Chunk.Chunk<Cause.Cause<unknown>>,\n  flattened: Chunk.Chunk<HashSet.HashSet<unknown>>\n): Chunk.Chunk<HashSet.HashSet<unknown>> => {\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = pipe(\n      causes,\n      Arr.reduce(\n        [HashSet.empty<unknown>(), Chunk.empty<Cause.Cause<unknown>>()] as const,\n        ([parallel, sequential], cause) => {\n          const [par, seq] = evaluateCause(cause)\n          return [\n            pipe(parallel, HashSet.union(par)),\n            pipe(sequential, Chunk.appendAll(seq))\n          ]\n        }\n      )\n    )\n    const updated = HashSet.size(parallel) > 0 ?\n      pipe(flattened, Chunk.prepend(parallel)) :\n      flattened\n    if (Chunk.isEmpty(sequential)) {\n      return Chunk.reverse(updated)\n    }\n    causes = sequential\n    flattened = updated\n  }\n  throw new Error(getBugErrorMessage(\"Cause.flattenCauseLoop\"))\n}\n\n// -----------------------------------------------------------------------------\n// Finding\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const find = dual<\n  <E, Z>(pf: (cause: Cause.Cause<E>) => Option.Option<Z>) => (self: Cause.Cause<E>) => Option.Option<Z>,\n  <E, Z>(self: Cause.Cause<E>, pf: (cause: Cause.Cause<E>) => Option.Option<Z>) => Option.Option<Z>\n>(2, <E, Z>(self: Cause.Cause<E>, pf: (cause: Cause.Cause<E>) => Option.Option<Z>) => {\n  const stack: Array<Cause.Cause<E>> = [self]\n  while (stack.length > 0) {\n    const item = stack.pop()!\n    const option = pf(item)\n    switch (option._tag) {\n      case \"None\": {\n        switch (item._tag) {\n          case OpCodes.OP_SEQUENTIAL:\n          case OpCodes.OP_PARALLEL: {\n            stack.push(item.right)\n            stack.push(item.left)\n            break\n          }\n        }\n        break\n      }\n      case \"Some\": {\n        return option\n      }\n    }\n  }\n  return Option.none()\n})\n\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const filter: {\n  <E, EB extends E>(\n    refinement: Refinement<Cause.Cause<NoInfer<E>>, Cause.Cause<EB>>\n  ): (self: Cause.Cause<E>) => Cause.Cause<EB>\n  <E>(predicate: Predicate<Cause.Cause<NoInfer<E>>>): (self: Cause.Cause<E>) => Cause.Cause<E>\n  <E, EB extends E>(self: Cause.Cause<E>, refinement: Refinement<Cause.Cause<E>, Cause.Cause<EB>>): Cause.Cause<EB>\n  <E>(self: Cause.Cause<E>, predicate: Predicate<Cause.Cause<E>>): Cause.Cause<E>\n} = dual(\n  2,\n  <E>(self: Cause.Cause<E>, predicate: Predicate<Cause.Cause<E>>): Cause.Cause<E> =>\n    reduceWithContext(self, void 0, FilterCauseReducer(predicate))\n)\n\n// -----------------------------------------------------------------------------\n// Evaluation\n// -----------------------------------------------------------------------------\n\n/**\n * Takes one step in evaluating a cause, returning a set of causes that fail\n * in parallel and a list of causes that fail sequentially after those causes.\n *\n * @internal\n */\nconst evaluateCause = (\n  self: Cause.Cause<unknown>\n): [HashSet.HashSet<unknown>, Chunk.Chunk<Cause.Cause<unknown>>] => {\n  let cause: Cause.Cause<unknown> | undefined = self\n  const stack: Array<Cause.Cause<unknown>> = []\n  let _parallel = HashSet.empty<unknown>()\n  let _sequential = Chunk.empty<Cause.Cause<unknown>>()\n  while (cause !== undefined) {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY: {\n        if (stack.length === 0) {\n          return [_parallel, _sequential]\n        }\n        cause = stack.pop()\n        break\n      }\n      case OpCodes.OP_FAIL: {\n        _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.error))\n        if (stack.length === 0) {\n          return [_parallel, _sequential]\n        }\n        cause = stack.pop()\n        break\n      }\n      case OpCodes.OP_DIE: {\n        _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.defect))\n        if (stack.length === 0) {\n          return [_parallel, _sequential]\n        }\n        cause = stack.pop()\n        break\n      }\n      case OpCodes.OP_INTERRUPT: {\n        _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.fiberId as unknown))\n        if (stack.length === 0) {\n          return [_parallel, _sequential]\n        }\n        cause = stack.pop()\n        break\n      }\n      case OpCodes.OP_SEQUENTIAL: {\n        switch (cause.left._tag) {\n          case OpCodes.OP_EMPTY: {\n            cause = cause.right\n            break\n          }\n          case OpCodes.OP_SEQUENTIAL: {\n            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right))\n            break\n          }\n          case OpCodes.OP_PARALLEL: {\n            cause = parallel(\n              sequential(cause.left.left, cause.right),\n              sequential(cause.left.right, cause.right)\n            )\n            break\n          }\n          default: {\n            _sequential = Chunk.prepend(_sequential, cause.right)\n            cause = cause.left\n            break\n          }\n        }\n        break\n      }\n      case OpCodes.OP_PARALLEL: {\n        stack.push(cause.right)\n        cause = cause.left\n        break\n      }\n    }\n  }\n  throw new Error(getBugErrorMessage(\"Cause.evaluateCauseLoop\"))\n}\n\n// -----------------------------------------------------------------------------\n// Reducing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst SizeCauseReducer: Cause.CauseReducer<unknown, unknown, number> = {\n  emptyCase: () => 0,\n  failCase: () => 1,\n  dieCase: () => 1,\n  interruptCase: () => 1,\n  sequentialCase: (_, left, right) => left + right,\n  parallelCase: (_, left, right) => left + right\n}\n\n/** @internal */\nconst IsInterruptedOnlyCauseReducer: Cause.CauseReducer<unknown, unknown, boolean> = {\n  emptyCase: constTrue,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: constTrue,\n  sequentialCase: (_, left, right) => left && right,\n  parallelCase: (_, left, right) => left && right\n}\n\n/** @internal */\nconst FilterCauseReducer = <E>(\n  predicate: Predicate<Cause.Cause<E>>\n): Cause.CauseReducer<unknown, E, Cause.Cause<E>> => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  sequentialCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return sequential(left, right)\n      }\n      return left\n    }\n    if (predicate(right)) {\n      return right\n    }\n    return empty\n  },\n  parallelCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return parallel(left, right)\n      }\n      return left\n    }\n    if (predicate(right)) {\n      return right\n    }\n    return empty\n  }\n})\n\n/** @internal */\ntype CauseCase = SequentialCase | ParallelCase\n\nconst OP_SEQUENTIAL_CASE = \"SequentialCase\"\n\nconst OP_PARALLEL_CASE = \"ParallelCase\"\n\n/** @internal */\ninterface SequentialCase {\n  readonly _tag: typeof OP_SEQUENTIAL_CASE\n}\n\n/** @internal */\ninterface ParallelCase {\n  readonly _tag: typeof OP_PARALLEL_CASE\n}\n\n/** @internal */\nexport const match = dual<\n  <Z, E>(\n    options: {\n      readonly onEmpty: Z\n      readonly onFail: (error: E) => Z\n      readonly onDie: (defect: unknown) => Z\n      readonly onInterrupt: (fiberId: FiberId.FiberId) => Z\n      readonly onSequential: (left: Z, right: Z) => Z\n      readonly onParallel: (left: Z, right: Z) => Z\n    }\n  ) => (self: Cause.Cause<E>) => Z,\n  <Z, E>(\n    self: Cause.Cause<E>,\n    options: {\n      readonly onEmpty: Z\n      readonly onFail: (error: E) => Z\n      readonly onDie: (defect: unknown) => Z\n      readonly onInterrupt: (fiberId: FiberId.FiberId) => Z\n      readonly onSequential: (left: Z, right: Z) => Z\n      readonly onParallel: (left: Z, right: Z) => Z\n    }\n  ) => Z\n>(2, (self, { onDie, onEmpty, onFail, onInterrupt, onParallel, onSequential }) => {\n  return reduceWithContext(self, void 0, {\n    emptyCase: () => onEmpty,\n    failCase: (_, error) => onFail(error),\n    dieCase: (_, defect) => onDie(defect),\n    interruptCase: (_, fiberId) => onInterrupt(fiberId),\n    sequentialCase: (_, left, right) => onSequential(left, right),\n    parallelCase: (_, left, right) => onParallel(left, right)\n  })\n})\n\n/** @internal */\nexport const reduce = dual<\n  <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause.Cause<E>) => Option.Option<Z>) => (self: Cause.Cause<E>) => Z,\n  <Z, E>(self: Cause.Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause.Cause<E>) => Option.Option<Z>) => Z\n>(3, <Z, E>(self: Cause.Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause.Cause<E>) => Option.Option<Z>) => {\n  let accumulator: Z = zero\n  let cause: Cause.Cause<E> | undefined = self\n  const causes: Array<Cause.Cause<E>> = []\n  while (cause !== undefined) {\n    const option = pf(accumulator, cause)\n    accumulator = Option.isSome(option) ? option.value : accumulator\n    switch (cause._tag) {\n      case OpCodes.OP_SEQUENTIAL: {\n        causes.push(cause.right)\n        cause = cause.left\n        break\n      }\n      case OpCodes.OP_PARALLEL: {\n        causes.push(cause.right)\n        cause = cause.left\n        break\n      }\n      default: {\n        cause = undefined\n        break\n      }\n    }\n    if (cause === undefined && causes.length > 0) {\n      cause = causes.pop()!\n    }\n  }\n  return accumulator\n})\n\n/** @internal */\nexport const reduceWithContext = dual<\n  <C, E, Z>(context: C, reducer: Cause.CauseReducer<C, E, Z>) => (self: Cause.Cause<E>) => Z,\n  <C, E, Z>(self: Cause.Cause<E>, context: C, reducer: Cause.CauseReducer<C, E, Z>) => Z\n>(3, <C, E, Z>(self: Cause.Cause<E>, context: C, reducer: Cause.CauseReducer<C, E, Z>) => {\n  const input: Array<Cause.Cause<E>> = [self]\n  const output: Array<Either.Either<Z, CauseCase>> = []\n  while (input.length > 0) {\n    const cause = input.pop()!\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY: {\n        output.push(Either.right(reducer.emptyCase(context)))\n        break\n      }\n      case OpCodes.OP_FAIL: {\n        output.push(Either.right(reducer.failCase(context, cause.error)))\n        break\n      }\n      case OpCodes.OP_DIE: {\n        output.push(Either.right(reducer.dieCase(context, cause.defect)))\n        break\n      }\n      case OpCodes.OP_INTERRUPT: {\n        output.push(Either.right(reducer.interruptCase(context, cause.fiberId)))\n        break\n      }\n      case OpCodes.OP_SEQUENTIAL: {\n        input.push(cause.right)\n        input.push(cause.left)\n        output.push(Either.left({ _tag: OP_SEQUENTIAL_CASE }))\n        break\n      }\n      case OpCodes.OP_PARALLEL: {\n        input.push(cause.right)\n        input.push(cause.left)\n        output.push(Either.left({ _tag: OP_PARALLEL_CASE }))\n        break\n      }\n    }\n  }\n  const accumulator: Array<Z> = []\n  while (output.length > 0) {\n    const either = output.pop()!\n    switch (either._tag) {\n      case \"Left\": {\n        switch (either.left._tag) {\n          case OP_SEQUENTIAL_CASE: {\n            const left = accumulator.pop()!\n            const right = accumulator.pop()!\n            const value = reducer.sequentialCase(context, left, right)\n            accumulator.push(value)\n            break\n          }\n          case OP_PARALLEL_CASE: {\n            const left = accumulator.pop()!\n            const right = accumulator.pop()!\n            const value = reducer.parallelCase(context, left, right)\n            accumulator.push(value)\n            break\n          }\n        }\n        break\n      }\n      case \"Right\": {\n        accumulator.push(either.right)\n        break\n      }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\n      \"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues\"\n    )\n  }\n  return accumulator.pop()!\n})\n\n// -----------------------------------------------------------------------------\n// Pretty Printing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const pretty = <E>(cause: Cause.Cause<E>, options?: {\n  readonly renderErrorCause?: boolean | undefined\n}): string => {\n  if (isInterruptedOnly(cause)) {\n    return \"All fibers interrupted without errors.\"\n  }\n  return prettyErrors<E>(cause).map(function(e) {\n    if (options?.renderErrorCause !== true || e.cause === undefined) {\n      return e.stack\n    }\n    return `${e.stack} {\\n${renderErrorCause(e.cause as PrettyError, \"  \")}\\n}`\n  }).join(\"\\n\")\n}\n\nconst renderErrorCause = (cause: PrettyError, prefix: string) => {\n  const lines = cause.stack!.split(\"\\n\")\n  let stack = `${prefix}[cause]: ${lines[0]}`\n  for (let i = 1, len = lines.length; i < len; i++) {\n    stack += `\\n${prefix}${lines[i]}`\n  }\n  if (cause.cause) {\n    stack += ` {\\n${renderErrorCause(cause.cause as PrettyError, `${prefix}  `)}\\n${prefix}}`\n  }\n  return stack\n}\n\n/** @internal */\nexport class PrettyError extends globalThis.Error implements Cause.PrettyError {\n  span: undefined | Span = undefined\n  constructor(originalError: unknown) {\n    const originalErrorIsObject = typeof originalError === \"object\" && originalError !== null\n    const prevLimit = Error.stackTraceLimit\n    Error.stackTraceLimit = 1\n    super(\n      prettyErrorMessage(originalError),\n      originalErrorIsObject && \"cause\" in originalError && typeof originalError.cause !== \"undefined\"\n        ? { cause: new PrettyError(originalError.cause) }\n        : undefined\n    )\n    if (this.message === \"\") {\n      this.message = \"An error has occurred\"\n    }\n    Error.stackTraceLimit = prevLimit\n    this.name = originalError instanceof Error ? originalError.name : \"Error\"\n    if (originalErrorIsObject) {\n      if (spanSymbol in originalError) {\n        this.span = originalError[spanSymbol] as Span\n      }\n      Object.keys(originalError).forEach((key) => {\n        if (!(key in this)) {\n          // @ts-expect-error\n          this[key] = originalError[key]\n        }\n      })\n    }\n    this.stack = prettyErrorStack(\n      `${this.name}: ${this.message}`,\n      originalError instanceof Error && originalError.stack\n        ? originalError.stack\n        : \"\",\n      this.span\n    )\n  }\n}\n\n/**\n * A utility function for generating human-readable error messages from a generic error of type `unknown`.\n *\n * Rules:\n *\n * 1) If the input `u` is already a string, it's considered a message.\n * 2) If `u` is an Error instance with a message defined, it uses the message.\n * 3) If `u` has a user-defined `toString()` method, it uses that method.\n * 4) Otherwise, it uses `Inspectable.stringifyCircular` to produce a string representation and uses it as the error message,\n *   with \"Error\" added as a prefix.\n *\n * @internal\n */\nexport const prettyErrorMessage = (u: unknown): string => {\n  // 1)\n  if (typeof u === \"string\") {\n    return u\n  }\n  // 2)\n  if (typeof u === \"object\" && u !== null && u instanceof Error) {\n    return u.message\n  }\n  // 3)\n  try {\n    if (\n      hasProperty(u, \"toString\") &&\n      isFunction(u[\"toString\"]) &&\n      u[\"toString\"] !== Object.prototype.toString &&\n      u[\"toString\"] !== globalThis.Array.prototype.toString\n    ) {\n      return u[\"toString\"]()\n    }\n  } catch {\n    // something's off, rollback to json\n  }\n  // 4)\n  return stringifyCircular(u)\n}\n\nconst locationRegex = /\\((.*)\\)/g\n\n/** @internal */\nexport const spanToTrace = globalValue(\"effect/Tracer/spanToTrace\", () => new WeakMap())\n\nconst prettyErrorStack = (message: string, stack: string, span?: Span | undefined): string => {\n  const out: Array<string> = [message]\n  const lines = stack.startsWith(message) ? stack.slice(message.length).split(\"\\n\") : stack.split(\"\\n\")\n\n  for (let i = 1; i < lines.length; i++) {\n    if (lines[i].includes(\" at new BaseEffectError\") || lines[i].includes(\" at new YieldableError\")) {\n      i++\n      continue\n    }\n    if (lines[i].includes(\"Generator.next\")) {\n      break\n    }\n    if (lines[i].includes(\"effect_internal_function\")) {\n      break\n    }\n    out.push(\n      lines[i]\n        .replace(/at .*effect_instruction_i.*\\((.*)\\)/, \"at $1\")\n        .replace(/EffectPrimitive\\.\\w+/, \"<anonymous>\")\n    )\n  }\n\n  if (span) {\n    let current: Span | AnySpan | undefined = span\n    let i = 0\n    while (current && current._tag === \"Span\" && i < 10) {\n      const stackFn = spanToTrace.get(current)\n      if (typeof stackFn === \"function\") {\n        const stack = stackFn()\n        if (typeof stack === \"string\") {\n          const locationMatchAll = stack.matchAll(locationRegex)\n          let match = false\n          for (const [, location] of locationMatchAll) {\n            match = true\n            out.push(`    at ${current.name} (${location})`)\n          }\n          if (!match) {\n            out.push(`    at ${current.name} (${stack.replace(/^at /, \"\")})`)\n          }\n        } else {\n          out.push(`    at ${current.name}`)\n        }\n      } else {\n        out.push(`    at ${current.name}`)\n      }\n      current = Option.getOrUndefined(current.parent)\n      i++\n    }\n  }\n\n  return out.join(\"\\n\")\n}\n\n/** @internal */\nexport const spanSymbol = Symbol.for(\"effect/SpanAnnotation\")\n\n/** @internal */\nexport const prettyErrors = <E>(cause: Cause.Cause<E>): Array<PrettyError> =>\n  reduceWithContext(cause, void 0, {\n    emptyCase: (): Array<PrettyError> => [],\n    dieCase: (_, unknownError) => {\n      return [new PrettyError(unknownError)]\n    },\n    failCase: (_, error) => {\n      return [new PrettyError(error)]\n    },\n    interruptCase: () => [],\n    parallelCase: (_, l, r) => [...l, ...r],\n    sequentialCase: (_, l, r) => [...l, ...r]\n  })\n","/** @internal */\nexport class SingleShotGen<T, A> implements Generator<T, A> {\n  called = false\n\n  constructor(readonly self: T) {\n  }\n\n  next(a: A): IteratorResult<T, A> {\n    return this.called ?\n      ({\n        value: a,\n        done: true\n      }) :\n      (this.called = true,\n        ({\n          value: this.self,\n          done: false\n        }))\n  }\n\n  return(a: A): IteratorResult<T, A> {\n    return ({\n      value: a,\n      done: true\n    })\n  }\n\n  throw(e: unknown): IteratorResult<T, A> {\n    throw e\n  }\n\n  [Symbol.iterator](): Generator<T, A> {\n    return new SingleShotGen<T, A>(this.self)\n  }\n}\n","import * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Deferred from \"../Deferred.js\"\nimport type * as Differ from \"../Differ.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as ExecutionStrategy from \"../ExecutionStrategy.js\"\nimport type * as Exit from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport type * as FiberStatus from \"../FiberStatus.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport type * as HashSet from \"../HashSet.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as List from \"../List.js\"\nimport type * as LogLevel from \"../LogLevel.js\"\nimport type * as LogSpan from \"../LogSpan.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, isObject, isPromiseLike, type Predicate, type Refinement } from \"../Predicate.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as BlockedRequests from \"../RequestBlock.js\"\nimport type * as RequestResolver from \"../RequestResolver.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport type { NoInfer, NotFunction } from \"../Types.js\"\nimport { internalCall, YieldWrap } from \"../Utils.js\"\nimport * as blockedRequests_ from \"./blockedRequests.js\"\nimport * as internalCause from \"./cause.js\"\nimport * as deferred from \"./deferred.js\"\nimport * as internalDiffer from \"./differ.js\"\nimport { CommitPrototype, effectVariance, StructuralCommitPrototype } from \"./effectable.js\"\nimport { getBugErrorMessage } from \"./errors.js\"\nimport type * as FiberRuntime from \"./fiberRuntime.js\"\nimport type * as fiberScope from \"./fiberScope.js\"\nimport * as DeferredOpCodes from \"./opCodes/deferred.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport * as runtimeFlags_ from \"./runtimeFlags.js\"\nimport { SingleShotGen } from \"./singleShotGen.js\"\n\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n\n/**\n * @internal\n */\nexport const blocked = <A, E>(\n  blockedRequests: BlockedRequests.RequestBlock,\n  _continue: Effect.Effect<A, E>\n): Effect.Blocked<A, E> => {\n  const effect = new EffectPrimitive(\"Blocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  effect.effect_instruction_i1 = _continue\n  return effect\n}\n\n/**\n * @internal\n */\nexport const runRequestBlock = (\n  blockedRequests: BlockedRequests.RequestBlock\n): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(\"RunBlocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  return effect\n}\n\n/** @internal */\nexport const EffectTypeId: Effect.EffectTypeId = Symbol.for(\"effect/Effect\") as Effect.EffectTypeId\n\n/** @internal */\nexport type Primitive =\n  | Async\n  | Commit\n  | Failure\n  | OnFailure\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | Success\n  | Sync\n  | UpdateRuntimeFlags\n  | While\n  | FromIterator\n  | WithRuntime\n  | Yield\n  | OpTag\n  | Blocked\n  | RunBlocked\n  | Either.Either<any, any>\n  | Option.Option<any>\n\n/** @internal */\nexport type Continuation =\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | OnFailure\n  | While\n  | FromIterator\n  | RevertFlags\n\n/** @internal */\nexport class RevertFlags {\n  readonly _op = OpCodes.OP_REVERT_FLAGS\n  constructor(\n    readonly patch: RuntimeFlagsPatch.RuntimeFlagsPatch,\n    readonly op: Primitive & { _op: OpCodes.OP_UPDATE_RUNTIME_FLAGS }\n  ) {\n  }\n}\n\nclass EffectPrimitive {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {}\n  [Equal.symbol](this: {}, that: unknown) {\n    return this === that\n  }\n  [Hash.symbol](this: {}) {\n    return Hash.cached(this, Hash.random(this))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Effect\",\n      _op: this._op,\n      effect_instruction_i0: toJSON(this.effect_instruction_i0),\n      effect_instruction_i1: toJSON(this.effect_instruction_i1),\n      effect_instruction_i2: toJSON(this.effect_instruction_i2)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveFailure {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Failure\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get cause() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      cause: (this.cause as any).toJSON()\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveSuccess {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Success\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get value() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      value: toJSON(this.value)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nexport type Op<Tag extends string, Body = {}> = Effect.Effect<never> & Body & {\n  readonly _op: Tag\n}\n\n/** @internal */\nexport interface Async extends\n  Op<OpCodes.OP_ASYNC, {\n    effect_instruction_i0(resume: (effect: Primitive) => void): void\n    readonly effect_instruction_i1: FiberId.FiberId\n  }>\n{}\n\n/** @internal */\nexport interface Blocked<out E = any, out A = any> extends\n  Op<\"Blocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n    readonly effect_instruction_i1: Effect.Effect<A, E>\n  }>\n{}\n\n/** @internal */\nexport interface RunBlocked extends\n  Op<\"RunBlocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n  }>\n{}\n\n/** @internal */\nexport interface Failure extends\n  Op<OpCodes.OP_FAILURE, {\n    readonly effect_instruction_i0: Cause.Cause<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OpTag extends Op<OpCodes.OP_TAG, {}> {}\n\n/** @internal */\nexport interface Commit extends\n  Op<OpCodes.OP_COMMIT, {\n    commit(): Effect.Effect<unknown, unknown, unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OnFailure extends\n  Op<OpCodes.OP_ON_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnSuccess extends\n  Op<OpCodes.OP_ON_SUCCESS, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnStep extends Op<\"OnStep\", { readonly effect_instruction_i0: Primitive }> {}\n\n/** @internal */\nexport interface OnSuccessAndFailure extends\n  Op<OpCodes.OP_ON_SUCCESS_AND_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n    effect_instruction_i2(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Success extends\n  Op<OpCodes.OP_SUCCESS, {\n    readonly effect_instruction_i0: unknown\n  }>\n{}\n\n/** @internal */\nexport interface Sync extends\n  Op<OpCodes.OP_SYNC, {\n    effect_instruction_i0(): unknown\n  }>\n{}\n\n/** @internal */\nexport interface UpdateRuntimeFlags extends\n  Op<OpCodes.OP_UPDATE_RUNTIME_FLAGS, {\n    readonly effect_instruction_i0: RuntimeFlagsPatch.RuntimeFlagsPatch\n    readonly effect_instruction_i1?: (oldRuntimeFlags: RuntimeFlags.RuntimeFlags) => Primitive\n  }>\n{}\n\n/** @internal */\nexport interface While extends\n  Op<OpCodes.OP_WHILE, {\n    effect_instruction_i0(): boolean\n    effect_instruction_i1(): Primitive\n    effect_instruction_i2(a: unknown): void\n  }>\n{}\n\n/** @internal */\nexport interface FromIterator extends\n  Op<OpCodes.OP_ITERATOR, {\n    effect_instruction_i0: Iterator<YieldWrap<Primitive>, any>\n  }>\n{}\n\n/** @internal */\nexport interface WithRuntime extends\n  Op<OpCodes.OP_WITH_RUNTIME, {\n    effect_instruction_i0(fiber: FiberRuntime.FiberRuntime<unknown, unknown>, status: FiberStatus.Running): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Yield extends Op<OpCodes.OP_YIELD> {}\n\n/** @internal */\nexport const isEffect = (u: unknown): u is Effect.Effect<unknown, unknown, unknown> => hasProperty(u, EffectTypeId)\n\n/* @internal */\nexport const withFiberRuntime = <A, E = never, R = never>(\n  withRuntime: (fiber: FiberRuntime.FiberRuntime<A, E>, status: FiberStatus.Running) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME) as any\n  effect.effect_instruction_i0 = withRuntime\n  return effect\n}\n\n/* @internal */\nexport const acquireUseRelease: {\n  <A2, E2, R2, A, X, R3>(\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): <E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2 | E, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, X, R3>(\n    acquire: Effect.Effect<A, E, R>,\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): Effect.Effect<A2, E | E2, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, X, R3>(\n  acquire: Effect.Effect<A, E, R>,\n  use: (a: A) => Effect.Effect<A2, E2, R2>,\n  release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n): Effect.Effect<A2, E | E2, R | R2 | R3> =>\n  uninterruptibleMask((restore) =>\n    flatMap(\n      acquire,\n      (a) =>\n        flatMap(exit(suspend(() => restore(use(a)))), (exit): Effect.Effect<A2, E | E2, R | R2 | R3> => {\n          return suspend(() => release(a, exit)).pipe(\n            matchCauseEffect({\n              onFailure: (cause) => {\n                switch (exit._tag) {\n                  case OpCodes.OP_FAILURE:\n                    return failCause(internalCause.sequential(exit.effect_instruction_i0, cause))\n                  case OpCodes.OP_SUCCESS:\n                    return failCause(cause)\n                }\n              },\n              onSuccess: () => exit\n            })\n          )\n        })\n    )\n  ))\n\n/* @internal */\nexport const as: {\n  <B>(value: B): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R> => flatMap(self, () => succeed(value))\n)\n\n/* @internal */\nexport const asVoid = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, E, R> => as(self, void 0)\n\n/* @internal */\nexport const custom: {\n  <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X }) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n  <X, Y, A, E, R>(\n    i0: X,\n    i1: Y,\n    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y }) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n  <X, Y, Z, A, E, R>(\n    i0: X,\n    i1: Y,\n    i2: Z,\n    body: (\n      this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z }\n    ) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n} = function() {\n  const wrapper = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  switch (arguments.length) {\n    case 2: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.commit = arguments[1]\n      break\n    }\n    case 3: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.commit = arguments[2]\n      break\n    }\n    case 4: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.effect_instruction_i2 = arguments[2]\n      wrapper.commit = arguments[3]\n      break\n    }\n    default: {\n      throw new Error(getBugErrorMessage(\"you're not supposed to end up here\"))\n    }\n  }\n  return wrapper\n}\n\n/* @internal */\nexport const unsafeAsync = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n  let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n  effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n    cancelerRef = register(resume)\n  }\n  effect.effect_instruction_i1 = blockingOn\n  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_)\n}\n\n/* @internal */\nexport const asyncInterrupt = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => suspend(() => unsafeAsync(register, blockingOn))\n\nconst async_ = <A, E = never, R = never>(\n  resume: (\n    callback: (_: Effect.Effect<A, E, R>) => void,\n    signal: AbortSignal\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  return custom(resume, function() {\n    let backingResume: ((_: Effect.Effect<A, E, R>) => void) | undefined = undefined\n    let pendingEffect: Effect.Effect<A, E, R> | undefined = undefined\n    function proxyResume(effect: Effect.Effect<A, E, R>) {\n      if (backingResume) {\n        backingResume(effect)\n      } else if (pendingEffect === undefined) {\n        pendingEffect = effect\n      }\n    }\n    const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n    effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n      backingResume = resume\n      if (pendingEffect) {\n        resume(pendingEffect)\n      }\n    }\n    effect.effect_instruction_i1 = blockingOn\n    let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n    let controllerRef: AbortController | void = undefined\n    if (this.effect_instruction_i0.length !== 1) {\n      controllerRef = new AbortController()\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef!.signal))\n    } else {\n      cancelerRef = internalCall(() => (this.effect_instruction_i0 as any)(proxyResume))\n    }\n    return (cancelerRef || controllerRef) ?\n      onInterrupt(effect, (_) => {\n        if (controllerRef) {\n          controllerRef.abort()\n        }\n        return cancelerRef ?? void_\n      }) :\n      effect\n  })\n}\nexport {\n  /** @internal */\n  async_ as async\n}\n\n/* @internal */\nexport const catchAllCause = dual<\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A2 | A, E2, R2 | R>\n>(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = f\n  return effect\n})\n\n/* @internal */\nexport const catchAll: {\n  <E, A2, E2, R2>(\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => matchEffect(self, { onFailure: f, onSuccess: succeed })\n)\n\n/* @internal */\nexport const catchIf: {\n  <E, EB extends E, A2, E2, R2>(\n    refinement: Refinement<NoInfer<E>, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <E, A2, E2, R2>(\n    predicate: Predicate<NoInfer<E>>,\n    f: (e: NoInfer<E>) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>\n  <A, E, R, EB extends E, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Refinement<E, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate<E>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A | A2, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate<E>,\n  f: (e: E) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E | E2, R | R2> =>\n  catchAllCause(self, (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return predicate(either.left) ? f(either.left) : failCause(cause)\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const catchSome = dual<\n  <E, A2, E2, R2>(\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Effect.Effect<A2 | A, E | E2, R2 | R>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n) =>\n  catchAllCause(self, (cause): Effect.Effect<A2 | A, E | E2, R2 | R> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return pipe(pf(either.left), Option.getOrElse(() => failCause(cause)))\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const checkInterruptible = <A, E, R>(\n  f: (isInterruptible: boolean) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((_, status) => f(runtimeFlags_.interruption(status.runtimeFlags)))\n\nconst originalSymbol = Symbol.for(\"effect/OriginalAnnotation\")\n\n/* @internal */\nexport const originalInstance = <E>(obj: E): E => {\n  if (hasProperty(obj, originalSymbol)) {\n    // @ts-expect-error\n    return obj[originalSymbol]\n  }\n  return obj\n}\n\n/* @internal */\nexport const capture = <E>(obj: E & object, span: Option.Option<Tracer.Span>): E => {\n  if (Option.isSome(span)) {\n    return new Proxy(obj, {\n      has(target, p) {\n        return p === internalCause.spanSymbol || p === originalSymbol || p in target\n      },\n      get(target, p) {\n        if (p === internalCause.spanSymbol) {\n          return span.value\n        }\n        if (p === originalSymbol) {\n          return obj\n        }\n        // @ts-expect-error\n        return target[p]\n      }\n    })\n  }\n  return obj\n}\n\n/* @internal */\nexport const die = (defect: unknown): Effect.Effect<never> =>\n  isObject(defect) && !(internalCause.spanSymbol in defect) ?\n    withFiberRuntime((fiber) => failCause(internalCause.die(capture(defect, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.die(defect))\n\n/* @internal */\nexport const dieMessage = (message: string): Effect.Effect<never> =>\n  failCauseSync(() => internalCause.die(new RuntimeException(message)))\n\n/* @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Effect.Effect<never> => flatMap(sync(evaluate), die)\n\n/* @internal */\nexport const either = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Either.Either<A, E>, never, R> =>\n  matchEffect(self, {\n    onFailure: (e) => succeed(Either.left(e)),\n    onSuccess: (a) => succeed(Either.right(a))\n  })\n\n/* @internal */\nexport const exit = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Exit.Exit<A, E>, never, R> =>\n  matchCause(self, {\n    onFailure: exitFailCause,\n    onSuccess: exitSucceed\n  })\n\n/* @internal */\nexport const fail = <E>(error: E): Effect.Effect<never, E> =>\n  isObject(error) && !(internalCause.spanSymbol in error) ?\n    withFiberRuntime((fiber) => failCause(internalCause.fail(capture(error, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.fail(error))\n\n/* @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Effect.Effect<never, E> => flatMap(sync(evaluate), fail)\n\n/* @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Effect.Effect<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/* @internal */\nexport const failCauseSync = <E>(\n  evaluate: LazyArg<Cause.Cause<E>>\n): Effect.Effect<never, E> => flatMap(sync(evaluate), failCause)\n\n/* @internal */\nexport const fiberId: Effect.Effect<FiberId.FiberId> = withFiberRuntime((state) => succeed(state.id()))\n\n/* @internal */\nexport const fiberIdWith = <A, E, R>(\n  f: (descriptor: FiberId.Runtime) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((state) => f(state.id()))\n\n/* @internal */\nexport const flatMap = dual<\n  <A, B, E1, R1>(\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>,\n  <A, E, R, B, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => Effect.Effect<B, E | E1, R | R1>\n>(\n  2,\n  (self, f) => {\n    const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS) as any\n    effect.effect_instruction_i0 = self\n    effect.effect_instruction_i1 = f\n    return effect\n  }\n)\n\n/* @internal */\nexport const andThen: {\n  <A, X>(\n    f: (a: NoInfer<A>) => X\n  ): <E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <X>(\n    f: NotFunction<X>\n  ): <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: NoInfer<A>) => X\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: NotFunction<X>\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n} = dual(2, (self, f) =>\n  flatMap(self, (a) => {\n    const b = typeof f === \"function\" ? (f as any)(a) : f\n    if (isEffect(b)) {\n      return b\n    } else if (isPromiseLike(b)) {\n      return unsafeAsync<any, Cause.UnknownException>((resume) => {\n        b.then((a) => resume(succeed(a)), (e) =>\n          resume(fail(new UnknownException(e, \"An unknown error occurred in Effect.andThen\"))))\n      })\n    }\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const step = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Exit.Exit<A, E> | Effect.Blocked<A, E>, never, R> => {\n  const effect = new EffectPrimitive(\"OnStep\") as any\n  effect.effect_instruction_i0 = self\n  return effect\n}\n\n/* @internal */\nexport const flatten = <A, E1, R1, E, R>(\n  self: Effect.Effect<Effect.Effect<A, E1, R1>, E, R>\n): Effect.Effect<A, E | E1, R | R1> => flatMap(self, identity)\n\n/* @internal */\nexport const flip = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<E, A, R> =>\n  matchEffect(self, { onFailure: succeed, onSuccess: fail })\n\n/* @internal */\nexport const matchCause: {\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, never, R>\n  <A, E, R, A2, A3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): Effect.Effect<A2 | A3, never, R>\n} = dual(2, <A, E, R, A2, A3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => A2\n    readonly onSuccess: (a: A) => A3\n  }\n): Effect.Effect<A2 | A3, never, R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => succeed(options.onFailure(cause)),\n    onSuccess: (a) => succeed(options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const matchCauseEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS_AND_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = options.onFailure\n  effect.effect_instruction_i2 = options.onSuccess\n  return effect\n})\n\n/* @internal */\nexport const matchEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(internalCause.electFailures(cause))\n      }\n      const failures = internalCause.failures(cause)\n      if (failures.length > 0) {\n        return options.onFailure(Chunk.unsafeHead(failures))\n      }\n      return failCause(cause as Cause.Cause<never>)\n    },\n    onSuccess: options.onSuccess\n  }))\n\n/* @internal */\nexport const forEachSequential: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<Array<B>, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      const ret = Arr.allocate<B>(arr.length)\n      let i = 0\n      return as(\n        whileLoop({\n          while: () => i < arr.length,\n          body: () => f(arr[i], i),\n          step: (b) => {\n            ret[i++] = b\n          }\n        }),\n        ret as Array<B>\n      )\n    })\n)\n\n/* @internal */\nexport const forEachSequentialDiscard: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<void, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      let i = 0\n      return whileLoop({\n        while: () => i < arr.length,\n        body: () => f(arr[i], i),\n        step: () => {\n          i++\n        }\n      })\n    })\n)\n\n/* @internal */\nexport const if_ = dual<\n  <A1, E1, R1, A2, E2, R2>(\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => <E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean\n  ) => Effect.Effect<A1 | A2, E | E1 | E2, R | R1 | R2>,\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>\n>(\n  (args) => typeof args[0] === \"boolean\" || isEffect(args[0]),\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ): Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R> =>\n    isEffect(self)\n      ? flatMap(self, (b): Effect.Effect<A1 | A2, E1 | E2, R1 | R2> => (b ? options.onTrue() : options.onFalse()))\n      : self\n      ? options.onTrue()\n      : options.onFalse()\n)\n\n/* @internal */\nexport const interrupt: Effect.Effect<never> = flatMap(fiberId, (fiberId) => interruptWith(fiberId))\n\n/* @internal */\nexport const interruptWith = (fiberId: FiberId.FiberId): Effect.Effect<never> =>\n  failCause(internalCause.interrupt(fiberId))\n\n/* @internal */\nexport const interruptible = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(runtimeFlags_.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const interruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(runtimeFlags_.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      runtimeFlags_.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\n/* @internal */\nexport const intoDeferred: {\n  <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<boolean, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R> =>\n    uninterruptibleMask((restore) =>\n      flatMap(\n        exit(restore(self)),\n        (exit) => deferredDone(deferred, exit)\n      )\n    )\n)\n\n/* @internal */\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R> =>\n    flatMap(self, (a) => sync(() => f(a)))\n)\n\n/* @internal */\nexport const mapBoth: {\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>\n  <A, E, R, E2, A2>(\n    self: Effect.Effect<A, E, R>,\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Effect.Effect<A2, E2, R>\n} = dual(2, <A, E, R, E2, A2>(\n  self: Effect.Effect<A, E, R>,\n  options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n): Effect.Effect<A2, E2, R> =>\n  matchEffect(self, {\n    onFailure: (e) => failSync(() => options.onFailure(e)),\n    onSuccess: (a) => sync(() => options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const mapError: {\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R> =>\n    matchCauseEffect(self, {\n      onFailure: (cause) => {\n        const either = internalCause.failureOrCause(cause)\n        switch (either._tag) {\n          case \"Left\": {\n            return failSync(() => f(either.left))\n          }\n          case \"Right\": {\n            return failCause(either.right)\n          }\n        }\n      },\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const onError: {\n  <E, X, R2>(\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(self, (exit) => exitIsSuccess(exit) ? void_ : cleanup(exit.effect_instruction_i0)))\n\n/* @internal */\nexport const onExit: {\n  <A, E, X, R2>(\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  uninterruptibleMask((restore) =>\n    matchCauseEffect(restore(self), {\n      onFailure: (cause1) => {\n        const result = exitFailCause(cause1)\n        return matchCauseEffect(cleanup(result), {\n          onFailure: (cause2) => exitFailCause(internalCause.sequential(cause1, cause2)),\n          onSuccess: () => result\n        })\n      },\n      onSuccess: (success) => {\n        const result = exitSucceed(success)\n        return zipRight(cleanup(result), result)\n      }\n    })\n  ))\n\n/* @internal */\nexport const onInterrupt: {\n  <X, R2>(\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(\n    self,\n    exitMatch({\n      onFailure: (cause) =>\n        internalCause.isInterruptedOnly(cause)\n          ? asVoid(cleanup(internalCause.interruptors(cause)))\n          : void_,\n      onSuccess: () => void_\n    })\n  ))\n\n/* @internal */\nexport const orElse: {\n  <A2, E2, R2>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => attemptOrElse(self, that, succeed)\n)\n\n/* @internal */\nexport const orDie = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, never, R> => orDieWith(self, identity)\n\n/* @internal */\nexport const orDieWith: {\n  <E>(f: (error: E) => unknown): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R> =>\n    matchEffect(self, {\n      onFailure: (e) => die(f(e)),\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const partitionMap: <A, A1, A2>(\n  elements: Iterable<A>,\n  f: (a: A) => Either.Either<A2, A1>\n) => [left: Array<A1>, right: Array<A2>] = Arr.partitionMap\n/* @internal */\nexport const runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags> = withFiberRuntime((_, status) =>\n  succeed(status.runtimeFlags)\n)\n\n/* @internal */\nexport const succeed = <A>(value: A): Effect.Effect<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/* @internal */\nexport const suspend = <A, E, R>(evaluate: LazyArg<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  effect.commit = evaluate\n  return effect\n}\n\n/* @internal */\nexport const sync = <A>(thunk: LazyArg<A>): Effect.Effect<A> => {\n  const effect = new EffectPrimitive(OpCodes.OP_SYNC) as any\n  effect.effect_instruction_i0 = thunk\n  return effect\n}\n\n/* @internal */\nexport const tap = dual<\n  {\n    <A, X>(\n      f: (a: NoInfer<A>) => X\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, X, E1, R1>(\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n    <X>(\n      f: NotFunction<X>\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <X, E1, R1>(\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n  },\n  {\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => X\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: NotFunction<X>\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n  }\n>(\n  (args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && \"onlyEffect\" in args[1]),\n  <A, E, R, X>(self: Effect.Effect<A, E, R>, f: X) =>\n    flatMap(self, (a) => {\n      const b = typeof f === \"function\" ? (f as any)(a) : f\n      if (isEffect(b)) {\n        return as(b, a)\n      } else if (isPromiseLike(b)) {\n        return unsafeAsync<any, Cause.UnknownException>((resume) => {\n          b.then((_) => resume(succeed(a)), (e) =>\n            resume(fail(new UnknownException(e, \"An unknown error occurred in Effect.tap\"))))\n        })\n      }\n      return succeed(a)\n    })\n)\n\n/* @internal */\nexport const transplant = <A, E, R>(\n  f: (grafter: <A2, E2, R2>(effect: Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  withFiberRuntime<A, E, R>((state) => {\n    const scopeOverride = state.getFiberRef(currentForkScopeOverride)\n    const scope = pipe(scopeOverride, Option.getOrElse(() => state.scope()))\n    return f(fiberRefLocally(currentForkScopeOverride, Option.some(scope)))\n  })\n\n/* @internal */\nexport const attemptOrElse: {\n  <A2, E2, R2, A, A3, E3, R3>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  that: LazyArg<Effect.Effect<A2, E2, R2>>,\n  onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(Option.getOrThrow(internalCause.keepDefectsAndElectFailures(cause)))\n      }\n      return that()\n    },\n    onSuccess\n  }))\n\n/* @internal */\nexport const uninterruptible: <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(runtimeFlags_.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const uninterruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(runtimeFlags_.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      runtimeFlags_.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\nconst void_: Effect.Effect<void> = succeed(void 0)\nexport {\n  /* @internal */\n  void_ as void\n}\n\n/* @internal */\nexport const updateRuntimeFlags = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = patch\n  effect.effect_instruction_i1 = void 0\n  return effect\n}\n\n/* @internal */\nexport const whenEffect: {\n  <E, R>(\n    condition: Effect.Effect<boolean, E, R>\n  ): <A, E2, R2>(\n    effect: Effect.Effect<A, E2, R2>\n  ) => Effect.Effect<Option.Option<A>, E | E2, R | R2>\n  <A, E2, R2, E, R>(\n    self: Effect.Effect<A, E2, R2>,\n    condition: Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E | E2, R | R2>\n} = dual(2, <A, E2, R2, E, R>(\n  self: Effect.Effect<A, E2, R2>,\n  condition: Effect.Effect<boolean, E, R>\n): Effect.Effect<Option.Option<A>, E | E2, R | R2> =>\n  flatMap(condition, (b) => {\n    if (b) {\n      return pipe(self, map(Option.some))\n    }\n    return succeed(Option.none())\n  }))\n\n/* @internal */\nexport const whileLoop = <A, E, R>(\n  options: {\n    readonly while: LazyArg<boolean>\n    readonly body: LazyArg<Effect.Effect<A, E, R>>\n    readonly step: (a: A) => void\n  }\n): Effect.Effect<void, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WHILE) as any\n  effect.effect_instruction_i0 = options.while\n  effect.effect_instruction_i1 = options.body\n  effect.effect_instruction_i2 = options.step\n  return effect\n}\n\n/* @internal */\nexport const fromIterator = <Eff extends YieldWrap<Effect.Effect<any, any, any>>, AEff>(\n  iterator: LazyArg<Iterator<Eff, AEff, never>>\n): Effect.Effect<\n  AEff,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect.Effect<infer _A, infer E, infer _R>>] ? E : never,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect.Effect<infer _A, infer _E, infer R>>] ? R : never\n> =>\n  suspend(() => {\n    const effect = new EffectPrimitive(OpCodes.OP_ITERATOR) as any\n    effect.effect_instruction_i0 = iterator()\n    return effect\n  })\n\n/* @internal */\nexport const gen: typeof Effect.gen = function() {\n  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0])\n  return fromIterator(() => f(pipe))\n}\n\n/** @internal */\nexport const fnUntraced: Effect.fn.Untraced = (body: Function, ...pipeables: Array<any>) =>\n  Object.defineProperty(\n    pipeables.length === 0\n      ? function(this: any, ...args: Array<any>) {\n        return fromIterator(() => body.apply(this, args))\n      }\n      : function(this: any, ...args: Array<any>) {\n        let effect = fromIterator(() => body.apply(this, args))\n        for (const x of pipeables) {\n          effect = x(effect, ...args)\n        }\n        return effect\n      },\n    \"length\",\n    { value: body.length, configurable: true }\n  )\n\n/* @internal */\nexport const withConcurrency = dual<\n  (concurrency: number | \"unbounded\") => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, concurrency: number | \"unbounded\") => Effect.Effect<A, E, R>\n>(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency))\n\n/* @internal */\nexport const withRequestBatching = dual<\n  (requestBatching: boolean) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, requestBatching: boolean) => Effect.Effect<A, E, R>\n>(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching))\n\n/* @internal */\nexport const withRuntimeFlags = dual<\n  (update: RuntimeFlagsPatch.RuntimeFlagsPatch) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, update: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect.Effect<A, E, R>\n>(2, (self, update) => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = update\n  effect.effect_instruction_i1 = () => self\n  return effect\n})\n\n/** @internal */\nexport const withTracerEnabled = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerEnabled,\n    enabled\n  ))\n\n/** @internal */\nexport const withTracerTiming = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerTimingEnabled,\n    enabled\n  ))\n\n/* @internal */\nexport const yieldNow = (options?: {\n  readonly priority?: number | undefined\n}): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_YIELD) as any\n  return typeof options?.priority !== \"undefined\" ?\n    withSchedulingPriority(effect, options.priority) :\n    effect\n}\n\n/* @internal */\nexport const zip = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [a, b])))\n\n/* @internal */\nexport const zipFlatten: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A extends ReadonlyArray<any>, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[...A, A2], E | E2, R | R2>\n  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<[...A, A2], E | E2, R | R2>\n} = dual(2, <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[...A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [...a, b])))\n\n/* @internal */\nexport const zipLeft: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A, E | E2, R | R2> => flatMap(self, (a) => as(that, a)))\n\n/* @internal */\nexport const zipRight: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A2, E | E2, R | R2> => flatMap(self, () => that))\n\n/* @internal */\nexport const zipWith: {\n  <A2, E2, R2, A, B>(\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E2, R | R2>\n  <A, E, R, A2, E2, R2, B>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): Effect.Effect<B, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2, B>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>,\n  f: (a: A, b: A2) => B\n): Effect.Effect<B, E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => f(a, b))))\n\n/* @internal */\nexport const never: Effect.Effect<never> = asyncInterrupt<never>(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1)\n  return sync(() => clearInterval(interval))\n})\n\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n\n/* @internal */\nexport const interruptFiber = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<Exit.Exit<A, E>> =>\n  flatMap(fiberId, (fiberId) => pipe(self, interruptAsFiber(fiberId)))\n\n/* @internal */\nexport const interruptAsFiber = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Fiber.Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>,\n  <A, E>(self: Fiber.Fiber<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<Exit.Exit<A, E>>\n>(2, (self, fiberId) => flatMap(self.interruptAsFork(fiberId), () => self.await))\n\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const logLevelAll: LogLevel.LogLevel = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelFatal: LogLevel.LogLevel = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelError: LogLevel.LogLevel = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelWarning: LogLevel.LogLevel = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelInfo: LogLevel.LogLevel = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelDebug: LogLevel.LogLevel = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelTrace: LogLevel.LogLevel = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelNone: LogLevel.LogLevel = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const allLogLevels: ReadonlyArray<LogLevel.LogLevel> = [\n  logLevelAll,\n  logLevelTrace,\n  logLevelDebug,\n  logLevelInfo,\n  logLevelWarning,\n  logLevelError,\n  logLevelFatal,\n  logLevelNone\n]\n\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst FiberRefSymbolKey = \"effect/FiberRef\"\n\n/** @internal */\nexport const FiberRefTypeId: FiberRef.FiberRefTypeId = Symbol.for(\n  FiberRefSymbolKey\n) as FiberRef.FiberRefTypeId\n\nconst fiberRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/* @internal */\nexport const fiberRefGet = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<A> =>\n  withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)))\n\n/* @internal */\nexport const fiberRefGetAndSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<A>\n>(2, (self, value) => fiberRefModify(self, (v) => [v, value] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) => fiberRefModify(self, (v) => [v, f(v)] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdateSome = dual<\n  <A>(\n    pf: (a: A) => Option.Option<A>\n  ) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    pf: (a: A) => Option.Option<A>\n  ) => Effect.Effect<A>\n>(2, (self, pf) => fiberRefModify(self, (v) => [v, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefGetWith = dual<\n  <B, E, R, A>(f: (a: A) => Effect.Effect<B, E, R>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, E, R>(self: FiberRef.FiberRef<A>, f: (a: A) => Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n>(2, (self, f) => flatMap(fiberRefGet(self), f))\n\n/* @internal */\nexport const fiberRefSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<void>\n>(2, (self, value) => fiberRefModify(self, () => [void 0, value] as const))\n\n/* @internal */\nexport const fiberRefDelete = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> =>\n  withFiberRuntime((state) => {\n    state.unsafeDeleteFiberRef(self)\n    return void_\n  })\n\n/* @internal */\nexport const fiberRefReset = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> => fiberRefSet(self, self.initial)\n\n/* @internal */\nexport const fiberRefModify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B>,\n  <A, B>(self: FiberRef.FiberRef<A>, f: (a: A) => readonly [B, A]) => Effect.Effect<B>\n>(2, <A, B>(\n  self: FiberRef.FiberRef<A>,\n  f: (a: A) => readonly [B, A]\n): Effect.Effect<B> =>\n  withFiberRuntime((state) => {\n    const [b, a] = f(state.getFiberRef(self) as A)\n    state.setFiberRef(self, a)\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const fiberRefModifySome = <A, B>(\n  self: FiberRef.FiberRef<A>,\n  def: B,\n  f: (a: A) => Option.Option<readonly [B, A]>\n): Effect.Effect<B> => fiberRefModify(self, (v) => Option.getOrElse(f(v), () => [def, v] as const))\n\n/* @internal */\nexport const fiberRefUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<void>\n>(2, (self, f) => fiberRefModify(self, (v) => [void 0, f(v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateSome = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<void>\n>(2, (self, pf) => fiberRefModify(self, (v) => [void 0, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateAndGet = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) =>\n  fiberRefModify(self, (v) => {\n    const result = f(v)\n    return [result, result] as const\n  }))\n\n/* @internal */\nexport const fiberRefUpdateSomeAndGet = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<A>\n>(2, (self, pf) =>\n  fiberRefModify(self, (v) => {\n    const result = Option.getOrElse(pf(v), () => v)\n    return [result, result] as const\n  }))\n\n// circular\n/** @internal */\nconst RequestResolverSymbolKey = \"effect/RequestResolver\"\n\n/** @internal */\nexport const RequestResolverTypeId: RequestResolver.RequestResolverTypeId = Symbol.for(\n  RequestResolverSymbolKey\n) as RequestResolver.RequestResolverTypeId\n\nconst requestResolverVariance = {\n  /* c8 ignore next */\n  _A: (_: unknown) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport class RequestResolverImpl<in A, out R> implements RequestResolver.RequestResolver<A, R> {\n  readonly [RequestResolverTypeId] = requestResolverVariance\n  constructor(\n    readonly runAll: (\n      requests: Array<Array<Request.Entry<A>>>\n    ) => Effect.Effect<void, never, R>,\n    readonly target?: unknown\n  ) {\n  }\n  [Hash.symbol](): number {\n    return Hash.cached(this, this.target ? Hash.hash(this.target) : Hash.random(this))\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return this.target ?\n      isRequestResolver(that) && Equal.equals(this.target, (that as RequestResolverImpl<any, any>).target) :\n      this === that\n  }\n  identified(...ids: Array<unknown>): RequestResolver.RequestResolver<A, R> {\n    return new RequestResolverImpl(this.runAll, Chunk.fromIterable(ids))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isRequestResolver = (u: unknown): u is RequestResolver.RequestResolver<unknown, unknown> =>\n  hasProperty(u, RequestResolverTypeId)\n\n// end\n\n/** @internal */\nexport const resolverLocally = dual<\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => <R, B extends Request.Request<any, any>>(\n    use: RequestResolver.RequestResolver<B, R>\n  ) => RequestResolver.RequestResolver<B, R>,\n  <R, B extends Request.Request<any, any>, A>(\n    use: RequestResolver.RequestResolver<B, R>,\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => RequestResolver.RequestResolver<B, R>\n>(3, <R, B extends Request.Request<any, any>, A>(\n  use: RequestResolver.RequestResolver<B, R>,\n  self: FiberRef.FiberRef<A>,\n  value: A\n): RequestResolver.RequestResolver<B, R> =>\n  new RequestResolverImpl<B, R>(\n    (requests) =>\n      fiberRefLocally(\n        use.runAll(requests),\n        self,\n        value\n      ),\n    Chunk.make(\"Locally\", use, self, value)\n  ))\n\n/** @internal */\nexport const requestBlockLocally = <A>(\n  self: BlockedRequests.RequestBlock,\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock => blockedRequests_.reduce(self, LocallyReducer(ref, value))\n\nconst LocallyReducer = <A>(\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock.Reducer<BlockedRequests.RequestBlock> => ({\n  emptyCase: () => blockedRequests_.empty,\n  parCase: (left, right) => blockedRequests_.par(left, right),\n  seqCase: (left, right) => blockedRequests_.seq(left, right),\n  singleCase: (dataSource, blockedRequest) =>\n    blockedRequests_.single(\n      resolverLocally(dataSource, ref, value),\n      blockedRequest as any\n    )\n})\n\n/* @internal */\nexport const fiberRefLocally: {\n  <A>(self: FiberRef.FiberRef<A>, value: A): <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R>\n} = dual(\n  3,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R> =>\n    acquireUseRelease(\n      zipLeft(fiberRefGet(self), fiberRefSet(self, value)),\n      () => use,\n      (oldValue) => fiberRefSet(self, oldValue)\n    )\n)\n\n/* @internal */\nexport const fiberRefLocallyWith = dual<\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<B, E, R>\n>(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))))\n\n/** @internal */\nexport const fiberRefUnsafeMake = <Value>(\n  initial: Value,\n  options?: {\n    readonly fork?: ((a: Value) => Value) | undefined\n    readonly join?: ((left: Value, right: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: internalDiffer.update(),\n    fork: options?.fork ?? identity,\n    join: options?.join\n  })\n\n/** @internal */\nexport const fiberRefUnsafeMakeHashSet = <A>(\n  initial: HashSet.HashSet<A>\n): FiberRef.FiberRef<HashSet.HashSet<A>> => {\n  const differ = internalDiffer.hashSet<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeReadonlyArray = <A>(\n  initial: ReadonlyArray<A>\n): FiberRef.FiberRef<ReadonlyArray<A>> => {\n  const differ = internalDiffer.readonlyArray(internalDiffer.update<A>())\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeContext = <A>(\n  initial: Context.Context<A>\n): FiberRef.FiberRef<Context.Context<A>> => {\n  const differ = internalDiffer.environment<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakePatch = <Value, Patch>(\n  initial: Value,\n  options: {\n    readonly differ: Differ.Differ<Value, Patch>\n    readonly fork: Patch\n    readonly join?: ((oldV: Value, newV: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> => {\n  const _fiberRef = {\n    ...CommitPrototype,\n    [FiberRefTypeId]: fiberRefVariance,\n    initial,\n    commit() {\n      return fiberRefGet(this)\n    },\n    diff: (oldValue: Value, newValue: Value) => options.differ.diff(oldValue, newValue),\n    combine: (first: Patch, second: Patch) => options.differ.combine(first, second),\n    patch: (patch: Patch) => (oldValue: Value) => options.differ.patch(patch, oldValue),\n    fork: options.fork,\n    join: options.join ?? ((_, n) => n)\n  }\n  return _fiberRef\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeRuntimeFlags = (\n  initial: RuntimeFlags.RuntimeFlags\n): FiberRef.FiberRef<RuntimeFlags.RuntimeFlags> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: runtimeFlags_.differ,\n    fork: runtimeFlags_.differ.empty\n  })\n\n/** @internal */\nexport const currentContext: FiberRef.FiberRef<Context.Context<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentContext\"),\n  () => fiberRefUnsafeMakeContext(Context.empty())\n)\n\n/** @internal */\nexport const currentSchedulingPriority: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"),\n  () => fiberRefUnsafeMake(0)\n)\n\n/** @internal */\nexport const currentMaxOpsBeforeYield: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"),\n  () => fiberRefUnsafeMake(2048)\n)\n\n/** @internal */\nexport const currentLogAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogAnnotation\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentLogLevel: FiberRef.FiberRef<LogLevel.LogLevel> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogLevel\"),\n  () => fiberRefUnsafeMake<LogLevel.LogLevel>(logLevelInfo)\n)\n\n/** @internal */\nexport const currentLogSpan: FiberRef.FiberRef<List.List<LogSpan.LogSpan>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogSpan\"),\n  () => fiberRefUnsafeMake(List.empty<LogSpan.LogSpan>())\n)\n\n/** @internal */\nexport const withSchedulingPriority = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler))\n\n/** @internal */\nexport const withMaxOpsBeforeYield = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler))\n\n/** @internal */\nexport const currentConcurrency: FiberRef.FiberRef<\"unbounded\" | number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentConcurrency\"),\n  () => fiberRefUnsafeMake<\"unbounded\" | number>(\"unbounded\")\n)\n\n/**\n * @internal\n */\nexport const currentRequestBatching = globalValue(\n  Symbol.for(\"effect/FiberRef/currentRequestBatching\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentUnhandledErrorLogLevel: FiberRef.FiberRef<Option.Option<LogLevel.LogLevel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"),\n  () => fiberRefUnsafeMake(Option.some<LogLevel.LogLevel>(logLevelDebug))\n)\n\n/** @internal */\nexport const currentVersionMismatchErrorLogLevel: FiberRef.FiberRef<Option.Option<LogLevel.LogLevel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/versionMismatchErrorLogLevel\"),\n  () => fiberRefUnsafeMake(Option.some<LogLevel.LogLevel>(logLevelWarning))\n)\n\n/** @internal */\nexport const withUnhandledErrorLogLevel = dual<\n  (level: Option.Option<LogLevel.LogLevel>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>) => Effect.Effect<A, E, R>\n>(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level))\n\n/** @internal */\nexport const currentMetricLabels: FiberRef.FiberRef<ReadonlyArray<MetricLabel.MetricLabel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMetricLabels\"),\n  () => fiberRefUnsafeMakeReadonlyArray(Arr.empty())\n)\n\n/* @internal */\nexport const metricLabels: Effect.Effect<ReadonlyArray<MetricLabel.MetricLabel>> = fiberRefGet(\n  currentMetricLabels\n)\n\n/** @internal */\nexport const currentForkScopeOverride: FiberRef.FiberRef<Option.Option<fiberScope.FiberScope>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"),\n  () =>\n    fiberRefUnsafeMake(Option.none(), {\n      fork: () => Option.none() as Option.Option<fiberScope.FiberScope>,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentInterruptedCause: FiberRef.FiberRef<Cause.Cause<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentInterruptedCause\"),\n  () =>\n    fiberRefUnsafeMake(internalCause.empty, {\n      fork: () => internalCause.empty,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentTracerEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerEnabled\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerTimingEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerTiming\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerSpanAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanAnnotations\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentTracerSpanLinks: FiberRef.FiberRef<Chunk.Chunk<Tracer.SpanLink>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanLinks\"),\n  () => fiberRefUnsafeMake(Chunk.empty())\n)\n\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const ScopeTypeId: Scope.ScopeTypeId = Symbol.for(\"effect/Scope\") as Scope.ScopeTypeId\n\n/** @internal */\nexport const CloseableScopeTypeId: Scope.CloseableScopeTypeId = Symbol.for(\n  \"effect/CloseableScope\"\n) as Scope.CloseableScopeTypeId\n\n/* @internal */\nexport const scopeAddFinalizer = (\n  self: Scope.Scope,\n  finalizer: Effect.Effect<unknown>\n): Effect.Effect<void> => self.addFinalizer(() => asVoid(finalizer))\n\n/* @internal */\nexport const scopeAddFinalizerExit = (\n  self: Scope.Scope,\n  finalizer: Scope.Scope.Finalizer\n): Effect.Effect<void> => self.addFinalizer(finalizer)\n\n/* @internal */\nexport const scopeClose = (\n  self: Scope.Scope.Closeable,\n  exit: Exit.Exit<unknown, unknown>\n): Effect.Effect<void> => self.close(exit)\n\n/* @internal */\nexport const scopeFork = (\n  self: Scope.Scope,\n  strategy: ExecutionStrategy.ExecutionStrategy\n): Effect.Effect<Scope.Scope.Closeable> => self.fork(strategy)\n\n// -----------------------------------------------------------------------------\n// Cause\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const causeSquash = <E>(self: Cause.Cause<E>): unknown => {\n  return causeSquashWith(identity)(self)\n}\n\n/** @internal */\nexport const causeSquashWith = dual<\n  <E>(f: (error: E) => unknown) => (self: Cause.Cause<E>) => unknown,\n  <E>(self: Cause.Cause<E>, f: (error: E) => unknown) => unknown\n>(2, (self, f) => {\n  const option = pipe(self, internalCause.failureOption, Option.map(f))\n  switch (option._tag) {\n    case \"None\": {\n      return pipe(\n        internalCause.defects(self),\n        Chunk.head,\n        Option.match({\n          onNone: () => {\n            const interrupts = Arr.fromIterable(internalCause.interruptors(self)).flatMap((fiberId) =>\n              Arr.fromIterable(FiberId.ids(fiberId)).map((id) => `#${id}`)\n            )\n            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0)\n          },\n          onSome: identity\n        })\n      )\n    }\n    case \"Some\": {\n      return option.value\n    }\n  }\n})\n\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const YieldableError: new(message?: string, options?: ErrorOptions) => Cause.YieldableError = (function() {\n  class YieldableError extends globalThis.Error {\n    commit() {\n      return fail(this)\n    }\n    toJSON() {\n      const obj = { ...this }\n      if (this.message) obj.message = this.message\n      if (this.cause) obj.cause = this.cause\n      return obj\n    }\n    [NodeInspectSymbol]() {\n      if (this.toString !== globalThis.Error.prototype.toString) {\n        return this.stack ? `${this.toString()}\\n${this.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : this.toString()\n      } else if (\"Bun\" in globalThis) {\n        return internalCause.pretty(internalCause.fail(this), { renderErrorCause: true })\n      }\n      return this\n    }\n  }\n  // @effect-diagnostics-next-line floatingEffect:off\n  Object.assign(YieldableError.prototype, StructuralCommitPrototype)\n  return YieldableError as any\n})()\n\nconst makeException = <T extends { _tag: string; message?: string }>(\n  proto: Omit<T, keyof Cause.YieldableError | \"_tag\">,\n  tag: T[\"_tag\"]\n): new(message?: string | undefined) => T => {\n  class Base extends YieldableError {\n    readonly _tag = tag\n  }\n  Object.assign(Base.prototype, proto)\n  ;(Base.prototype as any).name = tag\n  return Base as any\n}\n\n/** @internal */\nexport const RuntimeExceptionTypeId: Cause.RuntimeExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/RuntimeException\"\n) as Cause.RuntimeExceptionTypeId\n\n/** @internal */\nexport const RuntimeException = makeException<Cause.RuntimeException>({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\")\n\n/** @internal */\nexport const isRuntimeException = (u: unknown): u is Cause.RuntimeException => hasProperty(u, RuntimeExceptionTypeId)\n\n/** @internal */\nexport const InterruptedExceptionTypeId: Cause.InterruptedExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InterruptedException\"\n) as Cause.InterruptedExceptionTypeId\n\n/** @internal */\nexport const InterruptedException = makeException<Cause.InterruptedException>({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\")\n\n/** @internal */\nexport const isInterruptedException = (u: unknown): u is Cause.InterruptedException =>\n  hasProperty(u, InterruptedExceptionTypeId)\n\n/** @internal */\nexport const IllegalArgumentExceptionTypeId: Cause.IllegalArgumentExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/IllegalArgument\"\n) as Cause.IllegalArgumentExceptionTypeId\n\n/** @internal */\nexport const IllegalArgumentException = makeException<Cause.IllegalArgumentException>({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\")\n\n/** @internal */\nexport const isIllegalArgumentException = (u: unknown): u is Cause.IllegalArgumentException =>\n  hasProperty(u, IllegalArgumentExceptionTypeId)\n\n/** @internal */\nexport const NoSuchElementExceptionTypeId: Cause.NoSuchElementExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/NoSuchElement\"\n) as Cause.NoSuchElementExceptionTypeId\n\n/** @internal */\nexport const NoSuchElementException = makeException<Cause.NoSuchElementException>({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\")\n\n/** @internal */\nexport const isNoSuchElementException = (u: unknown): u is Cause.NoSuchElementException =>\n  hasProperty(u, NoSuchElementExceptionTypeId)\n\n/** @internal */\nexport const InvalidPubSubCapacityExceptionTypeId: Cause.InvalidPubSubCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InvalidPubSubCapacityException\"\n) as Cause.InvalidPubSubCapacityExceptionTypeId\n\n/** @internal */\nexport const InvalidPubSubCapacityException = makeException<Cause.InvalidPubSubCapacityException>({\n  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}, \"InvalidPubSubCapacityException\")\n\n/** @internal */\nexport const ExceededCapacityExceptionTypeId: Cause.ExceededCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/ExceededCapacityException\"\n) as Cause.ExceededCapacityExceptionTypeId\n\n/** @internal */\nexport const ExceededCapacityException = makeException<Cause.ExceededCapacityException>({\n  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}, \"ExceededCapacityException\")\n\n/** @internal */\nexport const isExceededCapacityException = (u: unknown): u is Cause.ExceededCapacityException =>\n  hasProperty(u, ExceededCapacityExceptionTypeId)\n\n/** @internal */\nexport const isInvalidCapacityError = (u: unknown): u is Cause.InvalidPubSubCapacityException =>\n  hasProperty(u, InvalidPubSubCapacityExceptionTypeId)\n\n/** @internal */\nexport const TimeoutExceptionTypeId: Cause.TimeoutExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/Timeout\"\n) as Cause.TimeoutExceptionTypeId\n\n/** @internal */\nexport const TimeoutException = makeException<Cause.TimeoutException>({\n  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}, \"TimeoutException\")\n\n/** @internal */\nexport const timeoutExceptionFromDuration = (duration: Duration.DurationInput): Cause.TimeoutException =>\n  new TimeoutException(`Operation timed out after '${Duration.format(duration)}'`)\n\n/** @internal */\nexport const isTimeoutException = (u: unknown): u is Cause.TimeoutException => hasProperty(u, TimeoutExceptionTypeId)\n\n/** @internal */\nexport const UnknownExceptionTypeId: Cause.UnknownExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/UnknownException\"\n) as Cause.UnknownExceptionTypeId\n\n/** @internal */\nexport const UnknownException: new(cause: unknown, message?: string | undefined) => Cause.UnknownException =\n  (function() {\n    class UnknownException extends YieldableError {\n      readonly _tag = \"UnknownException\"\n      readonly error: unknown\n      constructor(cause: unknown, message?: string) {\n        super(message ?? \"An unknown error occurred\", { cause })\n        this.error = cause\n      }\n    }\n    Object.assign(UnknownException.prototype, {\n      [UnknownExceptionTypeId]: UnknownExceptionTypeId,\n      name: \"UnknownException\"\n    })\n    return UnknownException as any\n  })()\n\n/** @internal */\nexport const isUnknownException = (u: unknown): u is Cause.UnknownException => hasProperty(u, UnknownExceptionTypeId)\n\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const exitIsExit = (u: unknown): u is Exit.Exit<unknown, unknown> =>\n  isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\")\n\n/** @internal */\nexport const exitIsFailure = <A, E>(self: Exit.Exit<A, E>): self is Exit.Failure<A, E> => self._tag === \"Failure\"\n\n/** @internal */\nexport const exitIsSuccess = <A, E>(self: Exit.Exit<A, E>): self is Exit.Success<A, E> => self._tag === \"Success\"\n\n/** @internal */\nexport const exitIsInterrupted = <A, E>(self: Exit.Exit<A, E>): boolean => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return internalCause.isInterrupted(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return false\n  }\n}\n\n/** @internal */\nexport const exitAs = dual<\n  <A2>(value: A2) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E>,\n  <A, E, A2>(self: Exit.Exit<A, E>, value: A2) => Exit.Exit<A2, E>\n>(2, <A, E, A2>(self: Exit.Exit<A, E>, value: A2): Exit.Exit<A2, E> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exitSucceed(value) as Exit.Exit<A2, E>\n    }\n  }\n})\n\n/** @internal */\nexport const exitAsVoid = <A, E>(self: Exit.Exit<A, E>): Exit.Exit<void, E> => exitAs(self, void 0)\n\n/** @internal */\nexport const exitCauseOption = <A, E>(self: Exit.Exit<A, E>): Option.Option<Cause.Cause<E>> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return Option.some(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return Option.none()\n  }\n}\n\n/** @internal */\nexport const exitCollectAll = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  options?: {\n    readonly parallel?: boolean | undefined\n  }\n): Option.Option<Exit.Exit<Array<A>, E>> =>\n  exitCollectAllInternal(exits, options?.parallel ? internalCause.parallel : internalCause.sequential)\n\n/** @internal */\nexport const exitDie = (defect: unknown): Exit.Exit<never> =>\n  exitFailCause(internalCause.die(defect)) as Exit.Exit<never>\n\n/** @internal */\nexport const exitExists: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit.Exit<A, E>) => self is Exit.Exit<B>\n  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit.Exit<A, E>) => boolean\n  <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B>\n  <A, E>(self: Exit.Exit<A, E>, predicate: Predicate<A>): boolean\n} = dual(2, <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return false\n    case OpCodes.OP_SUCCESS:\n      return refinement(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitFail = <E>(error: E): Exit.Exit<never, E> =>\n  exitFailCause(internalCause.fail(error)) as Exit.Exit<never, E>\n\n/** @internal */\nexport const exitFailCause = <E>(cause: Cause.Cause<E>): Exit.Exit<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/** @internal */\nexport const exitFlatMap = dual<\n  <A, A2, E2>(f: (a: A) => Exit.Exit<A2, E2>) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>): Exit.Exit<A2, E | E2> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatMapEffect: {\n  <A, E, A2, E2, R>(\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): (self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  <A, E, A2, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): Effect.Effect<Exit.Exit<A2, E>, E2, R>\n} = dual(2, <A, E, A2, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n): Effect.Effect<Exit.Exit<A2, E>, E2, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatten = <A, E, E2>(\n  self: Exit.Exit<Exit.Exit<A, E>, E2>\n): Exit.Exit<A, E | E2> => pipe(self, exitFlatMap(identity))\n\n/** @internal */\nexport const exitForEachEffect: {\n  <A, B, E2, R>(\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): <E>(self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n  <A, E, B, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n} = dual(2, <A, E, B, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<B, E2, R>\n): Effect.Effect<Exit.Exit<B, E | E2>, never, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exit(f(self.effect_instruction_i0))\n    }\n  }\n})\n\n/** @internal */\nexport const exitFromEither = <R, L>(either: Either.Either<R, L>): Exit.Exit<R, L> => {\n  switch (either._tag) {\n    case \"Left\":\n      return exitFail(either.left)\n    case \"Right\":\n      return exitSucceed(either.right)\n  }\n}\n\n/** @internal */\nexport const exitFromOption = <A>(option: Option.Option<A>): Exit.Exit<A, void> => {\n  switch (option._tag) {\n    case \"None\":\n      return exitFail(void 0)\n    case \"Some\":\n      return exitSucceed(option.value)\n  }\n}\n\n/** @internal */\nexport const exitGetOrElse = dual<\n  <E, A2>(orElse: (cause: Cause.Cause<E>) => A2) => <A>(self: Exit.Exit<A, E>) => A | A2,\n  <A, E, A2>(self: Exit.Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2) => A | A2\n>(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return orElse(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return self.effect_instruction_i0\n  }\n})\n\n/** @internal */\nexport const exitInterrupt = (fiberId: FiberId.FiberId): Exit.Exit<never> =>\n  exitFailCause(internalCause.interrupt(fiberId))\n\n/** @internal */\nexport const exitMap = dual<\n  <A, B>(f: (a: A) => B) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<B, E>,\n  <A, E, B>(self: Exit.Exit<A, E>, f: (a: A) => B) => Exit.Exit<B, E>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(f(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapBoth = dual<\n  <E, A, E2, A2>(\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<A2, E2>,\n  <A, E, E2, A2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => Exit.Exit<A2, E2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(onFailure)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(onSuccess(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapError = dual<\n  <E, E2>(f: (e: E) => E2) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <A, E, E2>(self: Exit.Exit<A, E>, f: (e: E) => E2) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(f)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMapErrorCause = dual<\n  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <E, A, E2>(self: Exit.Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(f(self.effect_instruction_i0))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatch = dual<\n  <E, A, Z1, Z2>(options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => (self: Exit.Exit<A, E>) => Z1 | Z2,\n  <A, E, Z1, Z2>(self: Exit.Exit<A, E>, options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => Z1 | Z2\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatchEffect = dual<\n  <E, A2, E2, R, A, A3, E3, R2>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Effect.Effect<A2 | A3, E2 | E3, R | R2>,\n  <A, E, A2, E2, R, A3, E3, R2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => Effect.Effect<A2 | A3, E2 | E3, R | R2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitSucceed = <A>(value: A): Exit.Exit<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/** @internal */\nexport const exitVoid: Exit.Exit<void> = exitSucceed(void 0)\n\n/** @internal */\nexport const exitZip = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipPar = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipWith = dual<\n  <B, E2, A, C, E>(\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<C, E | E2>,\n  <A, E, B, E2, C>(\n    self: Exit.Exit<A, E>,\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => Exit.Exit<C, E | E2>\n>(3, (\n  self,\n  that,\n  { onFailure, onSuccess }\n) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitFailCause(self.effect_instruction_i0)\n        case OpCodes.OP_FAILURE: {\n          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0))\n        }\n      }\n    }\n    case OpCodes.OP_SUCCESS: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0))\n        case OpCodes.OP_FAILURE:\n          return exitFailCause(that.effect_instruction_i0)\n      }\n    }\n  }\n})\n\nconst exitCollectAllInternal = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  combineCauses: (causeA: Cause.Cause<E>, causeB: Cause.Cause<E>) => Cause.Cause<E>\n): Option.Option<Exit.Exit<Array<A>, E>> => {\n  const list = Chunk.fromIterable(exits)\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none()\n  }\n  return pipe(\n    Chunk.tailNonEmpty(list),\n    Arr.reduce(\n      pipe(Chunk.headNonEmpty(list), exitMap<A, Chunk.Chunk<A>>(Chunk.of)),\n      (accumulator, current) =>\n        pipe(\n          accumulator,\n          exitZipWith(current, {\n            onSuccess: (list, value) => pipe(list, Chunk.prepend(value)),\n            onFailure: combineCauses\n          })\n        )\n    ),\n    exitMap(Chunk.reverse),\n    exitMap((chunk) => Chunk.toReadonlyArray(chunk) as Array<A>),\n    Option.some\n  )\n}\n\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const deferredUnsafeMake = <A, E = never>(fiberId: FiberId.FiberId): Deferred.Deferred<A, E> => {\n  const _deferred = {\n    ...CommitPrototype,\n    [deferred.DeferredTypeId]: deferred.deferredVariance,\n    state: MutableRef.make(deferred.pending<A, E>([])),\n    commit() {\n      return deferredAwait(this)\n    },\n    blockingOn: fiberId\n  }\n  return _deferred\n}\n\n/* @internal */\nexport const deferredMake = <A, E = never>(): Effect.Effect<Deferred.Deferred<A, E>> =>\n  flatMap(fiberId, (id) => deferredMakeAs<A, E>(id))\n\n/* @internal */\nexport const deferredMakeAs = <A, E = never>(fiberId: FiberId.FiberId): Effect.Effect<Deferred.Deferred<A, E>> =>\n  sync(() => deferredUnsafeMake<A, E>(fiberId))\n\n/* @internal */\nexport const deferredAwait = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<A, E> =>\n  asyncInterrupt<A, E>((resume) => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return resume(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        // we can push here as the internal state is mutable\n        state.joiners.push(resume)\n        return deferredInterruptJoiner(self, resume)\n      }\n    }\n  }, self.blockingOn)\n\n/* @internal */\nexport const deferredComplete: {\n  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>\n} = dual(\n  2,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean> =>\n    intoDeferred(effect, self)\n)\n\n/* @internal */\nexport const deferredCompleteWith = dual<\n  <A, E>(effect: Effect.Effect<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>) => Effect.Effect<boolean>\n>(2, (self, effect) =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return false\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        MutableRef.set(self.state, deferred.done(effect))\n        for (let i = 0, len = state.joiners.length; i < len; i++) {\n          state.joiners[i](effect)\n        }\n        return true\n      }\n    }\n  }))\n\n/* @internal */\nexport const deferredDone = dual<\n  <A, E>(exit: Exit.Exit<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, exit: Exit.Exit<A, E>) => Effect.Effect<boolean>\n>(2, (self, exit) => deferredCompleteWith(self, exit))\n\n/* @internal */\nexport const deferredFail = dual<\n  <E>(error: E) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, error: E) => Effect.Effect<boolean>\n>(2, (self, error) => deferredCompleteWith(self, fail(error)))\n\n/* @internal */\nexport const deferredFailSync = dual<\n  <E>(evaluate: LazyArg<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<E>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)))\n\n/* @internal */\nexport const deferredFailCause = dual<\n  <E>(cause: Cause.Cause<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, cause: Cause.Cause<E>) => Effect.Effect<boolean>\n>(2, (self, cause) => deferredCompleteWith(self, failCause(cause)))\n\n/* @internal */\nexport const deferredFailCauseSync = dual<\n  <E>(evaluate: LazyArg<Cause.Cause<E>>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)))\n\n/* @internal */\nexport const deferredDie = dual<\n  (defect: unknown) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, defect: unknown) => Effect.Effect<boolean>\n>(2, (self, defect) => deferredCompleteWith(self, die(defect)))\n\n/* @internal */\nexport const deferredDieSync = dual<\n  (evaluate: LazyArg<unknown>) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<unknown>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)))\n\n/* @internal */\nexport const deferredInterrupt = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  flatMap(fiberId, (fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredInterruptWith = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<boolean>\n>(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredIsDone = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE)\n\n/* @internal */\nexport const deferredPoll = <A, E>(\n  self: Deferred.Deferred<A, E>\n): Effect.Effect<Option.Option<Effect.Effect<A, E>>> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return Option.some(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        return Option.none()\n      }\n    }\n  })\n\n/* @internal */\nexport const deferredSucceed = dual<\n  <A>(value: A) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, value: A) => Effect.Effect<boolean>\n>(2, (self, value) => deferredCompleteWith(self, succeed(value)))\n\n/* @internal */\nexport const deferredSync = dual<\n  <A>(evaluate: LazyArg<A>) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<A>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)))\n\n/** @internal */\nexport const deferredUnsafeDone = <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): void => {\n  const state = MutableRef.get(self.state)\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(self.state, deferred.done(effect))\n    for (let i = 0, len = state.joiners.length; i < len; i++) {\n      state.joiners[i](effect)\n    }\n  }\n}\n\nconst deferredInterruptJoiner = <A, E>(\n  self: Deferred.Deferred<A, E>,\n  joiner: (effect: Effect.Effect<A, E>) => void\n): Effect.Effect<void> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n      const index = state.joiners.indexOf(joiner)\n      if (index >= 0) {\n        // we can splice here as the internal state is mutable\n        state.joiners.splice(index, 1)\n      }\n    }\n  })\n\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\n\nconst constContext = withFiberRuntime((fiber) => exitSucceed(fiber.currentContext))\n\n/* @internal */\nexport const context = <R>(): Effect.Effect<Context.Context<R>, never, R> => constContext as any\n\n/* @internal */\nexport const contextWith = <R0, A>(\n  f: (context: Context.Context<R0>) => A\n): Effect.Effect<A, never, R0> => map(context<R0>(), f)\n\n/* @internal */\nexport const contextWithEffect = <R2, A, E, R>(\n  f: (context: Context.Context<R2>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R | R2> => flatMap(context<R2>(), f)\n\n/* @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) => Effect.Effect<A, E>\n>(2, <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) =>\n  fiberRefLocally(\n    currentContext,\n    context\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const provideSomeContext = dual<\n  <R>(context: Context.Context<R>) => <A, E, R1>(self: Effect.Effect<A, E, R1>) => Effect.Effect<A, E, Exclude<R1, R>>,\n  <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) => Effect.Effect<A, E, Exclude<R1, R>>\n>(2, <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) =>\n  fiberRefLocallyWith(\n    currentContext,\n    (parent) => Context.merge(parent, context)\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const mapInputContext = dual<\n  <R2, R>(\n    f: (context: Context.Context<R2>) => Context.Context<R>\n  ) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2>,\n  <A, E, R, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (context: Context.Context<R2>) => Context.Context<R>\n  ) => Effect.Effect<A, E, R2>\n>(2, <A, E, R, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (context: Context.Context<R2>) => Context.Context<R>\n) => contextWithEffect((context: Context.Context<R2>) => provideContext(self, f(context))))\n\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const filterEffectOrElse: {\n  <A, E2, R2, A2, E3, R3>(\n    options: {\n      readonly predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n      readonly orElse: (a: NoInfer<A>) => Effect.Effect<A2, E3, R3>\n    }\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E | E2 | E3, R | R2 | R3>\n  <A, E, R, E2, R2, A2, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n      readonly orElse: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ): Effect.Effect<A | A2, E | E2 | E3, R | R2 | R3>\n} = dual(2, <A, E, R, E2, R2, A2, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n    readonly orElse: (a: A) => Effect.Effect<A2, E3, R3>\n  }\n): Effect.Effect<A | A2, E | E2 | E3, R | R2 | R3> =>\n  flatMap(\n    self,\n    (a) =>\n      flatMap(\n        options.predicate(a),\n        (pass): Effect.Effect<A | A2, E3, R3> => pass ? succeed(a) : options.orElse(a)\n      )\n  ))\n\n/** @internal */\nexport const filterEffectOrFail: {\n  <A, E2, R2, E3>(\n    options: {\n      readonly predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n      readonly orFailWith: (a: NoInfer<A>) => E3\n    }\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2 | E3, R | R2>\n  <A, E, R, E2, R2, E3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n      readonly orFailWith: (a: A) => E3\n    }\n  ): Effect.Effect<A, E | E2 | E3, R | R2>\n} = dual(2, <A, E, R, E2, R2, E3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n    readonly orFailWith: (a: A) => E3\n  }\n): Effect.Effect<A, E | E2 | E3, R | R2> =>\n  filterEffectOrElse(self, {\n    predicate: options.predicate,\n    orElse: (a) => fail(options.orFailWith(a))\n  }))\n\n// -----------------------------------------------------------------------------\n// Tracing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const currentSpanFromFiber = <A, E>(fiber: Fiber.RuntimeFiber<A, E>): Option.Option<Tracer.Span> => {\n  const span = fiber.currentSpan\n  return span !== undefined && span._tag === \"Span\" ? Option.some(span) : Option.none()\n}\n\nconst NoopSpanProto: Omit<Tracer.Span, \"parent\" | \"name\" | \"context\"> = {\n  _tag: \"Span\",\n  spanId: \"noop\",\n  traceId: \"noop\",\n  sampled: false,\n  status: {\n    _tag: \"Ended\",\n    startTime: BigInt(0),\n    endTime: BigInt(0),\n    exit: exitVoid\n  },\n  attributes: new Map(),\n  links: [],\n  kind: \"internal\",\n  attribute() {},\n  event() {},\n  end() {},\n  addLinks() {}\n}\n\n/** @internal */\nexport const noopSpan = (options: {\n  readonly name: string\n  readonly parent: Option.Option<Tracer.AnySpan>\n  readonly context: Context.Context<never>\n}): Tracer.Span => Object.assign(Object.create(NoopSpanProto), options)\n","/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport * as core from \"./internal/core.js\"\nimport * as internal from \"./internal/data.js\"\nimport { StructuralPrototype } from \"./internal/effectable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as Types from \"./Types.js\"\nimport type { Unify } from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Case {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Constructor<A, Tag extends keyof A = never> {\n    (\n      args: Types.Equals<Omit<A, Tag>, {}> extends true ? void\n        : { readonly [P in keyof A as P extends Tag ? never : P]: A[P] }\n    ): A\n  }\n}\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * const alice = Data.struct({ name: \"Alice\", age: 30 })\n *\n * const bob = Data.struct({ name: \"Bob\", age: 40 })\n *\n * assert.deepStrictEqual(Equal.equals(alice, alice), true)\n * assert.deepStrictEqual(Equal.equals(alice, Data.struct({ name: \"Alice\", age: 30 })), true)\n *\n * assert.deepStrictEqual(Equal.equals(alice, { name: \"Alice\", age: 30 }), false)\n * assert.deepStrictEqual(Equal.equals(alice, bob), false)\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const struct: <A extends Record<string, any>>(a: A) => { readonly [P in keyof A]: A[P] } = internal.struct\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unsafeStruct = <A extends Record<string, any>>(as: A): { readonly [P in keyof A]: A[P] } =>\n  Object.setPrototypeOf(as, StructuralPrototype)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * const alice = Data.tuple(\"Alice\", 30)\n *\n * const bob = Data.tuple(\"Bob\", 40)\n *\n * assert.deepStrictEqual(Equal.equals(alice, alice), true)\n * assert.deepStrictEqual(Equal.equals(alice, Data.tuple(\"Alice\", 30)), true)\n *\n * assert.deepStrictEqual(Equal.equals(alice, [\"Alice\", 30]), false)\n * assert.deepStrictEqual(Equal.equals(alice, bob), false)\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const tuple = <As extends ReadonlyArray<any>>(...as: As): Readonly<As> => unsafeArray(as)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * const alice = Data.struct({ name: \"Alice\", age: 30 })\n * const bob = Data.struct({ name: \"Bob\", age: 40 })\n *\n * const persons = Data.array([alice, bob])\n *\n * assert.deepStrictEqual(\n *   Equal.equals(\n *     persons,\n *     Data.array([\n *       Data.struct({ name: \"Alice\", age: 30 }),\n *       Data.struct({ name: \"Bob\", age: 40 })\n *     ])\n *   ),\n *   true\n * )\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const array = <As extends ReadonlyArray<any>>(as: As): Readonly<As> => unsafeArray(as.slice(0) as unknown as As)\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unsafeArray = <As extends ReadonlyArray<any>>(as: As): Readonly<As> =>\n  Object.setPrototypeOf(as, internal.ArrayProto)\n\nconst _case = <A>(): Case.Constructor<A> => (args) =>\n  (args === undefined ? Object.create(StructuralPrototype) : struct(args)) as any\n\nexport {\n  /**\n   * Provides a constructor for the specified `Case`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Data, Equal } from \"effect\"\n   *\n   * interface Person {\n   *   readonly name: string\n   * }\n   *\n   * // Creating a constructor for the specified Case\n   * const Person = Data.case<Person>()\n   *\n   * // Creating instances of Person\n   * const mike1 = Person({ name: \"Mike\" })\n   * const mike2 = Person({ name: \"Mike\" })\n   * const john = Person({ name: \"John\" })\n   *\n   * // Checking equality\n   * assert.deepStrictEqual(Equal.equals(mike1, mike2), true)\n   * assert.deepStrictEqual(Equal.equals(mike1, john), false)\n   *\n   * ```\n   * @since 2.0.0\n   * @category constructors\n   */\n  _case as case\n}\n\n/**\n * Provides a tagged constructor for the specified `Case`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data } from \"effect\"\n *\n * interface Person {\n *   readonly _tag: \"Person\" // the tag\n *   readonly name: string\n * }\n *\n * const Person = Data.tagged<Person>(\"Person\")\n *\n * const mike = Person({ name: \"Mike\" })\n *\n * assert.deepEqual(mike, { _tag: \"Person\", name: \"Mike\" })\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const tagged = <A extends { readonly _tag: string }>(\n  tag: A[\"_tag\"]\n): Case.Constructor<A, \"_tag\"> =>\n(args) => {\n  const value = args === undefined ? Object.create(StructuralPrototype) : struct(args)\n  value._tag = tag\n  return value\n}\n\n/**\n * Provides a constructor for a Case Class.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * class Person extends Data.Class<{ readonly name: string }> {}\n *\n * // Creating instances of Person\n * const mike1 = new Person({ name: \"Mike\" })\n * const mike2 = new Person({ name: \"Mike\" })\n * const john = new Person({ name: \"John\" })\n *\n * // Checking equality\n * assert.deepStrictEqual(Equal.equals(mike1, mike2), true)\n * assert.deepStrictEqual(Equal.equals(mike1, john), false)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const Class: new<A extends Record<string, any> = {}>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A]: A[P] }\n) => Readonly<A> = internal.Structural as any\n\n/**\n * Provides a Tagged constructor for a Case Class.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * class Person extends Data.TaggedClass(\"Person\")<{ readonly name: string }> {}\n *\n * // Creating instances of Person\n * const mike1 = new Person({ name: \"Mike\" })\n * const mike2 = new Person({ name: \"Mike\" })\n * const john = new Person({ name: \"John\" })\n *\n * // Checking equality\n * assert.deepStrictEqual(Equal.equals(mike1, mike2), true)\n * assert.deepStrictEqual(Equal.equals(mike1, john), false)\n *\n * assert.deepStrictEqual(mike1._tag, \"Person\")\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const TaggedClass = <Tag extends string>(\n  tag: Tag\n): new<A extends Record<string, any> = {}>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P] }\n) => Readonly<A> & { readonly _tag: Tag } => {\n  class Base extends Class<any> {\n    readonly _tag = tag\n  }\n  return Base as any\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Structural: new<A>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A]: A[P] }\n) => {} = internal.Structural as any\n\n/**\n * Create a tagged enum data type, which is a union of `Data` structs.\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data } from \"effect\"\n *\n * type HttpError = Data.TaggedEnum<{\n *   BadRequest: { readonly status: 400, readonly message: string }\n *   NotFound: { readonly status: 404, readonly message: string }\n * }>\n *\n * // Equivalent to:\n * type HttpErrorPlain =\n *   | {\n *     readonly _tag: \"BadRequest\"\n *     readonly status: 400\n *     readonly message: string\n *   }\n *   | {\n *     readonly _tag: \"NotFound\"\n *     readonly status: 404\n *     readonly message: string\n *   }\n * ```\n *\n * @since 2.0.0\n * @category models\n */\nexport type TaggedEnum<\n  A extends Record<string, Record<string, any>> & UntaggedChildren<A>\n> = keyof A extends infer Tag ?\n  Tag extends keyof A ? Types.Simplify<{ readonly _tag: Tag } & { readonly [K in keyof A[Tag]]: A[Tag][K] }>\n  : never\n  : never\n\ntype ChildrenAreTagged<A> = keyof A extends infer K ? K extends keyof A ? \"_tag\" extends keyof A[K] ? true\n    : false\n  : never\n  : never\n\ntype UntaggedChildren<A> = true extends ChildrenAreTagged<A>\n  ? \"It looks like you're trying to create a tagged enum, but one or more of its members already has a `_tag` property.\"\n  : unknown\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TaggedEnum {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface WithGenerics<Count extends number> {\n    readonly taggedEnum: { readonly _tag: string }\n    readonly numberOfGenerics: Count\n\n    readonly A: unknown\n    readonly B: unknown\n    readonly C: unknown\n    readonly D: unknown\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Kind<\n    Z extends WithGenerics<number>,\n    A = unknown,\n    B = unknown,\n    C = unknown,\n    D = unknown\n  > = (Z & {\n    readonly A: A\n    readonly B: B\n    readonly C: C\n    readonly D: D\n  })[\"taggedEnum\"]\n\n  /**\n   * @since 2.0.0\n   */\n  export type Args<\n    A extends { readonly _tag: string },\n    K extends A[\"_tag\"],\n    E = Extract<A, { readonly _tag: K }>\n  > = { readonly [K in keyof E as K extends \"_tag\" ? never : K]: E[K] } extends infer T ? {} extends T ? void : T\n    : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type Value<\n    A extends { readonly _tag: string },\n    K extends A[\"_tag\"]\n  > = Extract<A, { readonly _tag: K }>\n\n  /**\n   * @since 3.1.0\n   */\n  export type Constructor<A extends { readonly _tag: string }> = Types.Simplify<\n    & {\n      readonly [Tag in A[\"_tag\"]]: Case.Constructor<Extract<A, { readonly _tag: Tag }>, \"_tag\">\n    }\n    & {\n      readonly $is: <Tag extends A[\"_tag\"]>(tag: Tag) => (u: unknown) => u is Extract<A, { readonly _tag: Tag }>\n      readonly $match: {\n        <\n          const Cases extends {\n            readonly [Tag in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: Tag }>) => any\n          }\n        >(\n          cases: Cases & { [K in Exclude<keyof Cases, A[\"_tag\"]>]: never }\n        ): (value: A) => Unify<ReturnType<Cases[A[\"_tag\"]]>>\n        <\n          const Cases extends {\n            readonly [Tag in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: Tag }>) => any\n          }\n        >(\n          value: A,\n          cases: Cases & { [K in Exclude<keyof Cases, A[\"_tag\"]>]: never }\n        ): Unify<ReturnType<Cases[A[\"_tag\"]]>>\n      }\n    }\n  >\n\n  /**\n   * @since 3.2.0\n   */\n  export interface GenericMatchers<Z extends WithGenerics<number>> {\n    readonly $is: <Tag extends Z[\"taggedEnum\"][\"_tag\"]>(\n      tag: Tag\n    ) => {\n      <T extends TaggedEnum.Kind<Z, any, any, any, any>>(\n        u: T\n      ): u is T & { readonly _tag: Tag }\n      (u: unknown): u is Extract<TaggedEnum.Kind<Z>, { readonly _tag: Tag }>\n    }\n    readonly $match: {\n      <\n        A,\n        B,\n        C,\n        D,\n        Cases extends {\n          readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: (\n            args: Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>\n          ) => any\n        }\n      >(\n        cases: Cases & { [K in Exclude<keyof Cases, Z[\"taggedEnum\"][\"_tag\"]>]: never }\n      ): (self: TaggedEnum.Kind<Z, A, B, C, D>) => Unify<ReturnType<Cases[Z[\"taggedEnum\"][\"_tag\"]]>>\n      <\n        A,\n        B,\n        C,\n        D,\n        Cases extends {\n          readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: (\n            args: Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>\n          ) => any\n        }\n      >(\n        self: TaggedEnum.Kind<Z, A, B, C, D>,\n        cases: Cases & { [K in Exclude<keyof Cases, Z[\"taggedEnum\"][\"_tag\"]>]: never }\n      ): Unify<ReturnType<Cases[Z[\"taggedEnum\"][\"_tag\"]]>>\n    }\n  }\n}\n\n/**\n * Create a constructor for a tagged union of `Data` structs.\n *\n * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n * the constructor.\n *\n * @example\n * ```ts\n * import { Data } from \"effect\"\n *\n * const { BadRequest, NotFound } = Data.taggedEnum<\n *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n * >()\n *\n * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n * ```\n *\n * @example\n * import { Data } from \"effect\"\n *\n * type MyResult<E, A> = Data.TaggedEnum<{\n *   Failure: { readonly error: E }\n *   Success: { readonly value: A }\n * }>\n * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n * }\n * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n *\n * const success = Success({ value: 1 })\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const taggedEnum: {\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <Z extends TaggedEnum.WithGenerics<1>>(): Types.Simplify<\n    {\n      readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A>(\n        args: TaggedEnum.Args<\n          TaggedEnum.Kind<Z, A>,\n          Tag,\n          Extract<TaggedEnum.Kind<Z, A>, { readonly _tag: Tag }>\n        >\n      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A>, Tag>\n    } & TaggedEnum.GenericMatchers<Z>\n  >\n\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <Z extends TaggedEnum.WithGenerics<2>>(): Types.Simplify<\n    {\n      readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B>(\n        args: TaggedEnum.Args<\n          TaggedEnum.Kind<Z, A, B>,\n          Tag,\n          Extract<TaggedEnum.Kind<Z, A, B>, { readonly _tag: Tag }>\n        >\n      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B>, Tag>\n    } & TaggedEnum.GenericMatchers<Z>\n  >\n\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <Z extends TaggedEnum.WithGenerics<3>>(): Types.Simplify<\n    {\n      readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B, C>(\n        args: TaggedEnum.Args<\n          TaggedEnum.Kind<Z, A, B, C>,\n          Tag,\n          Extract<TaggedEnum.Kind<Z, A, B, C>, { readonly _tag: Tag }>\n        >\n      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C>, Tag>\n    } & TaggedEnum.GenericMatchers<Z>\n  >\n\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <Z extends TaggedEnum.WithGenerics<4>>(): Types.Simplify<\n    {\n      readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B, C, D>(\n        args: TaggedEnum.Args<\n          TaggedEnum.Kind<Z, A, B, C, D>,\n          Tag,\n          Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>\n        >\n      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C, D>, Tag>\n    } & TaggedEnum.GenericMatchers<Z>\n  >\n\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A extends { readonly _tag: string }>(): TaggedEnum.Constructor<A>\n} = () =>\n  new Proxy({}, {\n    get(_target, tag, _receiver) {\n      if (tag === \"$is\") {\n        return Predicate.isTagged\n      } else if (tag === \"$match\") {\n        return taggedMatch\n      }\n      return tagged(tag as string)\n    }\n  }) as any\n\nfunction taggedMatch<\n  A extends { readonly _tag: string },\n  Cases extends {\n    readonly [K in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: K }>) => any\n  }\n>(self: A, cases: Cases): ReturnType<Cases[A[\"_tag\"]]>\nfunction taggedMatch<\n  A extends { readonly _tag: string },\n  Cases extends {\n    readonly [K in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: K }>) => any\n  }\n>(cases: Cases): (value: A) => ReturnType<Cases[A[\"_tag\"]]>\nfunction taggedMatch<\n  A extends { readonly _tag: string },\n  Cases extends {\n    readonly [K in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: K }>) => any\n  }\n>(): any {\n  if (arguments.length === 1) {\n    const cases = arguments[0] as Cases\n    return function(value: A): ReturnType<Cases[A[\"_tag\"]]> {\n      return cases[value._tag as A[\"_tag\"]](value as any)\n    }\n  }\n  const value = arguments[0] as A\n  const cases = arguments[1] as Cases\n  return cases[value._tag as A[\"_tag\"]](value as any)\n}\n\n/**\n * Provides a constructor for a Case Class.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const Error: new<A extends Record<string, any> = {}>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A]: A[P] }\n) => Cause.YieldableError & Readonly<A> = (function() {\n  const plainArgsSymbol = Symbol.for(\"effect/Data/Error/plainArgs\")\n  const O = {\n    BaseEffectError: class extends core.YieldableError {\n      constructor(args: any) {\n        super(args?.message, args?.cause ? { cause: args.cause } : undefined)\n        if (args) {\n          Object.assign(this, args)\n          // @effect-diagnostics-next-line floatingEffect:off\n          Object.defineProperty(this, plainArgsSymbol, { value: args, enumerable: false })\n        }\n      }\n      toJSON() {\n        return { ...(this as any)[plainArgsSymbol], ...this }\n      }\n    } as any\n  }\n  return O.BaseEffectError\n})()\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const TaggedError = <Tag extends string>(tag: Tag): new<A extends Record<string, any> = {}>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P] }\n) => Cause.YieldableError & { readonly _tag: Tag } & Readonly<A> => {\n  const O = {\n    BaseEffectError: class extends Error<{}> {\n      readonly _tag = tag\n    }\n  }\n  ;(O.BaseEffectError.prototype as any).name = tag\n  return O.BaseEffectError as any\n}\n","import type * as Encoding from \"../../Encoding.js\"\nimport { hasProperty, isString } from \"../../Predicate.js\"\nimport type { Mutable } from \"../../Types.js\"\n\n/** @internal */\nexport const DecodeExceptionTypeId: Encoding.DecodeExceptionTypeId = Symbol.for(\n  \"effect/Encoding/errors/Decode\"\n) as Encoding.DecodeExceptionTypeId\n\n/** @internal */\nexport const DecodeException = (input: string, message?: string): Encoding.DecodeException => {\n  const out: Mutable<Encoding.DecodeException> = {\n    _tag: \"DecodeException\",\n    [DecodeExceptionTypeId]: DecodeExceptionTypeId,\n    input\n  }\n  if (isString(message)) {\n    out.message = message\n  }\n  return out\n}\n\n/** @internal */\nexport const isDecodeException = (u: unknown): u is Encoding.DecodeException => hasProperty(u, DecodeExceptionTypeId)\n\n/** @internal */\nexport const EncodeExceptionTypeId: Encoding.EncodeExceptionTypeId = Symbol.for(\n  \"effect/Encoding/errors/Encode\"\n) as Encoding.EncodeExceptionTypeId\n\n/** @internal */\nexport const EncodeException = (input: string, message?: string): Encoding.EncodeException => {\n  const out: Mutable<Encoding.EncodeException> = {\n    _tag: \"EncodeException\",\n    [EncodeExceptionTypeId]: EncodeExceptionTypeId,\n    input\n  }\n  if (isString(message)) {\n    out.message = message\n  }\n  return out\n}\n\n/** @internal */\nexport const isEncodeException = (u: unknown): u is Encoding.EncodeException => hasProperty(u, EncodeExceptionTypeId)\n\n/** @interal */\nexport const encoder = new TextEncoder()\n\n/** @interal */\nexport const decoder = new TextDecoder()\n","import * as Either from \"../../Either.js\"\nimport type * as Encoding from \"../../Encoding.js\"\nimport { DecodeException } from \"./common.js\"\n\n/** @internal */\nexport const encode = (bytes: Uint8Array) => {\n  const length = bytes.length\n\n  let result = \"\"\n  let i: number\n\n  for (i = 2; i < length; i += 3) {\n    result += base64abc[bytes[i - 2] >> 2]\n    result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)]\n    result += base64abc[((bytes[i - 1] & 0x0f) << 2) | (bytes[i] >> 6)]\n    result += base64abc[bytes[i] & 0x3f]\n  }\n\n  if (i === length + 1) {\n    // 1 octet yet to write\n    result += base64abc[bytes[i - 2] >> 2]\n    result += base64abc[(bytes[i - 2] & 0x03) << 4]\n    result += \"==\"\n  }\n\n  if (i === length) {\n    // 2 octets yet to write\n    result += base64abc[bytes[i - 2] >> 2]\n    result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)]\n    result += base64abc[(bytes[i - 1] & 0x0f) << 2]\n    result += \"=\"\n  }\n\n  return result\n}\n\n/** @internal */\nexport const decode = (str: string): Either.Either<Uint8Array, Encoding.DecodeException> => {\n  const stripped = stripCrlf(str)\n  const length = stripped.length\n  if (length % 4 !== 0) {\n    return Either.left(\n      DecodeException(stripped, `Length must be a multiple of 4, but is ${length}`)\n    )\n  }\n\n  const index = stripped.indexOf(\"=\")\n  if (index !== -1 && ((index < length - 2) || (index === length - 2 && stripped[length - 1] !== \"=\"))) {\n    return Either.left(\n      DecodeException(stripped, \"Found a '=' character, but it is not at the end\")\n    )\n  }\n\n  try {\n    const missingOctets = stripped.endsWith(\"==\") ? 2 : stripped.endsWith(\"=\") ? 1 : 0\n    const result = new Uint8Array(3 * (length / 4) - missingOctets)\n    for (let i = 0, j = 0; i < length; i += 4, j += 3) {\n      const buffer = getBase64Code(stripped.charCodeAt(i)) << 18 |\n        getBase64Code(stripped.charCodeAt(i + 1)) << 12 |\n        getBase64Code(stripped.charCodeAt(i + 2)) << 6 |\n        getBase64Code(stripped.charCodeAt(i + 3))\n\n      result[j] = buffer >> 16\n      result[j + 1] = (buffer >> 8) & 0xff\n      result[j + 2] = buffer & 0xff\n    }\n\n    return Either.right(result)\n  } catch (e) {\n    return Either.left(\n      DecodeException(stripped, e instanceof Error ? e.message : \"Invalid input\")\n    )\n  }\n}\n\n/** @internal */\nexport const stripCrlf = (str: string) => str.replace(/[\\n\\r]/g, \"\")\n\n/** @internal */\nfunction getBase64Code(charCode: number) {\n  if (charCode >= base64codes.length) {\n    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`)\n  }\n\n  const code = base64codes[charCode]\n  if (code === 255) {\n    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`)\n  }\n\n  return code\n}\n\n/** @internal */\nconst base64abc = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"+\",\n  \"/\"\n]\n\n/** @internal */\nconst base64codes = [\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  62,\n  255,\n  255,\n  255,\n  63,\n  52,\n  53,\n  54,\n  55,\n  56,\n  57,\n  58,\n  59,\n  60,\n  61,\n  255,\n  255,\n  255,\n  0,\n  255,\n  255,\n  255,\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n  20,\n  21,\n  22,\n  23,\n  24,\n  25,\n  255,\n  255,\n  255,\n  255,\n  255,\n  255,\n  26,\n  27,\n  28,\n  29,\n  30,\n  31,\n  32,\n  33,\n  34,\n  35,\n  36,\n  37,\n  38,\n  39,\n  40,\n  41,\n  42,\n  43,\n  44,\n  45,\n  46,\n  47,\n  48,\n  49,\n  50,\n  51\n]\n","import * as Either from \"../../Either.js\"\nimport type * as Encoding from \"../../Encoding.js\"\nimport * as Base64 from \"./base64.js\"\nimport { DecodeException } from \"./common.js\"\n\n/** @internal */\nexport const encode = (data: Uint8Array) =>\n  Base64.encode(data).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\")\n\n/** @internal */\nexport const decode = (str: string): Either.Either<Uint8Array, Encoding.DecodeException> => {\n  const stripped = Base64.stripCrlf(str)\n  const length = stripped.length\n  if (length % 4 === 1) {\n    return Either.left(\n      DecodeException(stripped, `Length should be a multiple of 4, but is ${length}`)\n    )\n  }\n\n  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {\n    return Either.left(DecodeException(stripped, \"Invalid input\"))\n  }\n\n  // Some variants allow or require omitting the padding '=' signs\n  let sanitized = length % 4 === 2 ? `${stripped}==` : length % 4 === 3 ? `${stripped}=` : stripped\n  sanitized = sanitized.replace(/-/g, \"+\").replace(/_/g, \"/\")\n\n  return Base64.decode(sanitized)\n}\n","/**\n * This module provides encoding & decoding functionality for:\n *\n * - base64 (RFC4648)\n * - base64 (URL)\n * - hex\n *\n * @since 2.0.0\n */\nimport * as Either from \"./Either.js\"\nimport * as Base64 from \"./internal/encoding/base64.js\"\nimport * as Base64Url from \"./internal/encoding/base64Url.js\"\nimport * as Common from \"./internal/encoding/common.js\"\nimport * as Hex from \"./internal/encoding/hex.js\"\n\n/**\n * Encodes the given value into a base64 (RFC4648) `string`.\n *\n * @category encoding\n * @since 2.0.0\n */\nexport const encodeBase64: (input: Uint8Array | string) => string = (input) =>\n  typeof input === \"string\" ? Base64.encode(Common.encoder.encode(input)) : Base64.encode(input)\n\n/**\n * Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */\nexport const decodeBase64 = (str: string): Either.Either<Uint8Array, DecodeException> => Base64.decode(str)\n\n/**\n * Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */\nexport const decodeBase64String = (str: string) => Either.map(decodeBase64(str), (_) => Common.decoder.decode(_))\n\n/**\n * Encodes the given value into a base64 (URL) `string`.\n *\n * @category encoding\n * @since 2.0.0\n */\nexport const encodeBase64Url: (input: Uint8Array | string) => string = (input) =>\n  typeof input === \"string\" ? Base64Url.encode(Common.encoder.encode(input)) : Base64Url.encode(input)\n\n/**\n * Decodes a base64 (URL) encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */\nexport const decodeBase64Url = (str: string): Either.Either<Uint8Array, DecodeException> => Base64Url.decode(str)\n\n/**\n * Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */\nexport const decodeBase64UrlString = (str: string) => Either.map(decodeBase64Url(str), (_) => Common.decoder.decode(_))\n\n/**\n * Encodes the given value into a hex `string`.\n *\n * @category encoding\n * @since 2.0.0\n */\nexport const encodeHex: (input: Uint8Array | string) => string = (input) =>\n  typeof input === \"string\" ? Hex.encode(Common.encoder.encode(input)) : Hex.encode(input)\n\n/**\n * Decodes a hex encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */\nexport const decodeHex = (str: string): Either.Either<Uint8Array, DecodeException> => Hex.decode(str)\n\n/**\n * Decodes a hex encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */\nexport const decodeHexString = (str: string) => Either.map(decodeHex(str), (_) => Common.decoder.decode(_))\n\n/**\n * Encodes a UTF-8 `string` into a URI component `string`.\n *\n * @category encoding\n * @since 3.12.0\n */\nexport const encodeUriComponent = (str: string): Either.Either<string, EncodeException> =>\n  Either.try({\n    try: () => encodeURIComponent(str),\n    catch: (e) => EncodeException(str, e instanceof Error ? e.message : \"Invalid input\")\n  })\n\n/**\n * Decodes a URI component `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 3.12.0\n */\nexport const decodeUriComponent = (str: string): Either.Either<string, DecodeException> =>\n  Either.try({\n    try: () => decodeURIComponent(str),\n    catch: (e) => DecodeException(str, e instanceof Error ? e.message : \"Invalid input\")\n  })\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const DecodeExceptionTypeId: unique symbol = Common.DecodeExceptionTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type DecodeExceptionTypeId = typeof DecodeExceptionTypeId\n\n/**\n * Represents a checked exception which occurs when decoding fails.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface DecodeException {\n  readonly _tag: \"DecodeException\"\n  readonly [DecodeExceptionTypeId]: DecodeExceptionTypeId\n  readonly input: string\n  readonly message?: string\n}\n\n/**\n * Creates a checked exception which occurs when decoding fails.\n *\n * @since 2.0.0\n * @category errors\n */\nexport const DecodeException: (input: string, message?: string) => DecodeException = Common.DecodeException\n\n/**\n * Returns `true` if the specified value is an `DecodeException`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isDecodeException: (u: unknown) => u is DecodeException = Common.isDecodeException\n\n/**\n * @since 3.12.0\n * @category symbols\n */\nexport const EncodeExceptionTypeId: unique symbol = Common.EncodeExceptionTypeId\n\n/**\n * @since 3.12.0\n * @category symbols\n */\nexport type EncodeExceptionTypeId = typeof EncodeExceptionTypeId\n\n/**\n * Represents a checked exception which occurs when encoding fails.\n *\n * @since 3.12.0\n * @category models\n */\nexport interface EncodeException {\n  readonly _tag: \"EncodeException\"\n  readonly [EncodeExceptionTypeId]: EncodeExceptionTypeId\n  readonly input: string\n  readonly message?: string\n}\n\n/**\n * Creates a checked exception which occurs when encoding fails.\n *\n * @since 3.12.0\n * @category errors\n */\nexport const EncodeException: (input: string, message?: string) => EncodeException = Common.EncodeException\n\n/**\n * Returns `true` if the specified value is an `EncodeException`, `false` otherwise.\n *\n * @since 3.12.0\n * @category refinements\n */\nexport const isEncodeException: (u: unknown) => u is EncodeException = Common.isEncodeException\n","/**\n * @experimental\n * @since 3.18.0\n */\n\nimport * as Data from \"./Data.js\"\nimport * as Equal from \"./Equal.js\"\nimport { dual } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport { format, NodeInspectSymbol } from \"./Inspectable.js\"\nimport * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport type { Mutable } from \"./Types.js\"\n\n/**\n * Unique identifier for Graph instances.\n *\n * @since 3.18.0\n * @category symbol\n */\nexport const TypeId: \"~effect/Graph\" = \"~effect/Graph\" as const\n\n/**\n * Type identifier for Graph instances.\n *\n * @since 3.18.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * Node index for node identification using plain numbers.\n *\n * @since 3.18.0\n * @category models\n */\nexport type NodeIndex = number\n\n/**\n * Edge index for edge identification using plain numbers.\n *\n * @since 3.18.0\n * @category models\n */\nexport type EdgeIndex = number\n\n/**\n * Edge data containing source, target, and user data.\n *\n * @since 3.18.0\n * @category models\n */\nexport class Edge<E> extends Data.Class<{\n  readonly source: NodeIndex\n  readonly target: NodeIndex\n  readonly data: E\n}> {}\n\n/**\n * Graph type for distinguishing directed and undirected graphs.\n *\n * @since 3.18.0\n * @category models\n */\nexport type Kind = \"directed\" | \"undirected\"\n\n/**\n * Graph prototype interface.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface Proto<out N, out E> extends Iterable<readonly [NodeIndex, N]>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly nodes: Map<NodeIndex, N>\n  readonly edges: Map<EdgeIndex, Edge<E>>\n  readonly adjacency: Map<NodeIndex, Array<EdgeIndex>>\n  readonly reverseAdjacency: Map<NodeIndex, Array<EdgeIndex>>\n  nextNodeIndex: NodeIndex\n  nextEdgeIndex: EdgeIndex\n  isAcyclic: Option.Option<boolean>\n}\n\n/**\n * Immutable graph interface.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface Graph<out N, out E, T extends Kind = \"directed\"> extends Proto<N, E> {\n  readonly type: T\n  readonly mutable: false\n}\n\n/**\n * Mutable graph interface.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface MutableGraph<out N, out E, T extends Kind = \"directed\"> extends Proto<N, E> {\n  readonly type: T\n  readonly mutable: true\n}\n\n/**\n * Directed graph type alias.\n *\n * @since 3.18.0\n * @category models\n */\nexport type DirectedGraph<N, E> = Graph<N, E, \"directed\">\n\n/**\n * Undirected graph type alias.\n *\n * @since 3.18.0\n * @category models\n */\nexport type UndirectedGraph<N, E> = Graph<N, E, \"undirected\">\n\n/**\n * Mutable directed graph type alias.\n *\n * @since 3.18.0\n * @category models\n */\nexport type MutableDirectedGraph<N, E> = MutableGraph<N, E, \"directed\">\n\n/**\n * Mutable undirected graph type alias.\n *\n * @since 3.18.0\n * @category models\n */\nexport type MutableUndirectedGraph<N, E> = MutableGraph<N, E, \"undirected\">\n\n// =============================================================================\n// Proto Objects\n// =============================================================================\n\n/** @internal */\nconst ProtoGraph = {\n  [TypeId]: TypeId,\n  [Symbol.iterator](this: Graph<any, any>) {\n    return this.nodes[Symbol.iterator]()\n  },\n  [NodeInspectSymbol](this: Graph<any, any>) {\n    return this.toJSON()\n  },\n  [Equal.symbol](this: Graph<any, any>, that: Equal.Equal): boolean {\n    if (isGraph(that)) {\n      if (\n        this.nodes.size !== that.nodes.size ||\n        this.edges.size !== that.edges.size ||\n        this.type !== that.type\n      ) {\n        return false\n      }\n      // Compare nodes\n      for (const [nodeIndex, nodeData] of this.nodes) {\n        if (!that.nodes.has(nodeIndex)) {\n          return false\n        }\n        const otherNodeData = that.nodes.get(nodeIndex)!\n        if (!Equal.equals(nodeData, otherNodeData)) {\n          return false\n        }\n      }\n      // Compare edges\n      for (const [edgeIndex, edgeData] of this.edges) {\n        if (!that.edges.has(edgeIndex)) {\n          return false\n        }\n        const otherEdge = that.edges.get(edgeIndex)!\n        if (!Equal.equals(edgeData, otherEdge)) {\n          return false\n        }\n      }\n      return true\n    }\n    return false\n  },\n  [Hash.symbol](this: Graph<any, any>): number {\n    let hash = Hash.string(\"Graph\")\n    hash = hash ^ Hash.string(this.type)\n    hash = hash ^ Hash.number(this.nodes.size)\n    hash = hash ^ Hash.number(this.edges.size)\n    for (const [nodeIndex, nodeData] of this.nodes) {\n      hash = hash ^ (Hash.hash(nodeIndex) + Hash.hash(nodeData))\n    }\n    for (const [edgeIndex, edgeData] of this.edges) {\n      hash = hash ^ (Hash.hash(edgeIndex) + Hash.hash(edgeData))\n    }\n    return hash\n  },\n  toJSON(this: Graph<any, any>) {\n    return {\n      _id: \"Graph\",\n      nodeCount: this.nodes.size,\n      edgeCount: this.edges.size,\n      type: this.type\n    }\n  },\n  toString(this: Graph<any, any>) {\n    return format(this)\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n// =============================================================================\n// Errors\n// =============================================================================\n\n/**\n * Error thrown when a graph operation fails.\n *\n * @since 3.18.0\n * @category errors\n */\nexport class GraphError extends Data.TaggedError(\"GraphError\")<{\n  readonly message: string\n}> {}\n\n/** @internal */\nconst missingNode = (node: number) => new GraphError({ message: `Node ${node} does not exist` })\n\n// =============================================================================\n// Constructors\n// =============================================================================\n\n/** @internal */\nexport const isGraph = (u: unknown): u is Graph<unknown, unknown> => typeof u === \"object\" && u !== null && TypeId in u\n\n/**\n * Creates a directed graph, optionally with initial mutations.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * // Directed graph with initial nodes and edges\n * const graph = Graph.directed<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, \"A->B\")\n *   Graph.addEdge(mutable, b, c, \"B->C\")\n * })\n * ```\n *\n * @since 3.18.0\n * @category constructors\n */\nexport const directed = <N, E>(mutate?: (mutable: MutableDirectedGraph<N, E>) => void): DirectedGraph<N, E> => {\n  const graph: Mutable<DirectedGraph<N, E>> = Object.create(ProtoGraph)\n  graph.type = \"directed\"\n  graph.nodes = new Map()\n  graph.edges = new Map()\n  graph.adjacency = new Map()\n  graph.reverseAdjacency = new Map()\n  graph.nextNodeIndex = 0\n  graph.nextEdgeIndex = 0\n  graph.isAcyclic = Option.some(true)\n  graph.mutable = false\n\n  if (mutate) {\n    const mutable = beginMutation(graph as DirectedGraph<N, E>)\n    mutate(mutable as MutableDirectedGraph<N, E>)\n    return endMutation(mutable)\n  }\n\n  return graph\n}\n\n/**\n * Creates an undirected graph, optionally with initial mutations.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * // Undirected graph with initial nodes and edges\n * const graph = Graph.undirected<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, \"A-B\")\n *   Graph.addEdge(mutable, b, c, \"B-C\")\n * })\n * ```\n *\n * @since 3.18.0\n * @category constructors\n */\nexport const undirected = <N, E>(mutate?: (mutable: MutableUndirectedGraph<N, E>) => void): UndirectedGraph<N, E> => {\n  const graph: Mutable<UndirectedGraph<N, E>> = Object.create(ProtoGraph)\n  graph.type = \"undirected\"\n  graph.nodes = new Map()\n  graph.edges = new Map()\n  graph.adjacency = new Map()\n  graph.reverseAdjacency = new Map()\n  graph.nextNodeIndex = 0\n  graph.nextEdgeIndex = 0\n  graph.isAcyclic = Option.some(true)\n  graph.mutable = false\n\n  if (mutate) {\n    const mutable = beginMutation(graph)\n    mutate(mutable as MutableUndirectedGraph<N, E>)\n    return endMutation(mutable)\n  }\n\n  return graph\n}\n\n// =============================================================================\n// Scoped Mutable API\n// =============================================================================\n\n/**\n * Creates a mutable scope for safe graph mutations by copying the data structure.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>()\n * const mutable = Graph.beginMutation(graph)\n * // Now mutable can be safely modified without affecting original graph\n * ```\n *\n * @since 3.18.0\n * @category mutations\n */\nexport const beginMutation = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T>\n): MutableGraph<N, E, T> => {\n  // Copy adjacency maps with deep cloned arrays\n  const adjacency = new Map<NodeIndex, Array<EdgeIndex>>()\n  const reverseAdjacency = new Map<NodeIndex, Array<EdgeIndex>>()\n\n  for (const [nodeIndex, edges] of graph.adjacency) {\n    adjacency.set(nodeIndex, [...edges])\n  }\n\n  for (const [nodeIndex, edges] of graph.reverseAdjacency) {\n    reverseAdjacency.set(nodeIndex, [...edges])\n  }\n\n  const mutable: Mutable<MutableGraph<N, E, T>> = Object.create(ProtoGraph)\n  mutable.type = graph.type\n  mutable.nodes = new Map(graph.nodes)\n  mutable.edges = new Map(graph.edges)\n  mutable.adjacency = adjacency\n  mutable.reverseAdjacency = reverseAdjacency\n  mutable.nextNodeIndex = graph.nextNodeIndex\n  mutable.nextEdgeIndex = graph.nextEdgeIndex\n  mutable.isAcyclic = graph.isAcyclic\n  mutable.mutable = true\n\n  return mutable\n}\n\n/**\n * Converts a mutable graph back to an immutable graph, ending the mutation scope.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>()\n * const mutable = Graph.beginMutation(graph)\n * // ... perform mutations on mutable ...\n * const newGraph = Graph.endMutation(mutable)\n * ```\n *\n * @since 3.18.0\n * @category mutations\n */\nexport const endMutation = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>\n): Graph<N, E, T> => {\n  const graph: Mutable<Graph<N, E, T>> = Object.create(ProtoGraph)\n  graph.type = mutable.type\n  graph.nodes = new Map(mutable.nodes)\n  graph.edges = new Map(mutable.edges)\n  graph.adjacency = mutable.adjacency\n  graph.reverseAdjacency = mutable.reverseAdjacency\n  graph.nextNodeIndex = mutable.nextNodeIndex\n  graph.nextEdgeIndex = mutable.nextEdgeIndex\n  graph.isAcyclic = mutable.isAcyclic\n  graph.mutable = false\n\n  return graph\n}\n\n/**\n * Performs scoped mutations on a graph, automatically managing the mutation lifecycle.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>()\n * const newGraph = Graph.mutate(graph, (mutable) => {\n *   // Safe mutations go here\n *   // mutable gets automatically converted back to immutable\n * })\n * ```\n *\n * @since 3.18.0\n * @category mutations\n */\nexport const mutate: {\n  /**\n   * Performs scoped mutations on a graph, automatically managing the mutation lifecycle.\n   *\n   * @example\n   * ```ts\n   * import { Graph } from \"effect\"\n   *\n   * const graph = Graph.directed<string, number>()\n   * const newGraph = Graph.mutate(graph, (mutable) => {\n   *   // Safe mutations go here\n   *   // mutable gets automatically converted back to immutable\n   * })\n   * ```\n   *\n   * @since 3.18.0\n   * @category mutations\n   */\n  <N, E, T extends Kind = \"directed\">(f: (mutable: MutableGraph<N, E, T>) => void): (graph: Graph<N, E, T>) => Graph<N, E, T>\n  /**\n   * Performs scoped mutations on a graph, automatically managing the mutation lifecycle.\n   *\n   * @example\n   * ```ts\n   * import { Graph } from \"effect\"\n   *\n   * const graph = Graph.directed<string, number>()\n   * const newGraph = Graph.mutate(graph, (mutable) => {\n   *   // Safe mutations go here\n   *   // mutable gets automatically converted back to immutable\n   * })\n   * ```\n   *\n   * @since 3.18.0\n   * @category mutations\n   */\n  <N, E, T extends Kind = \"directed\">(graph: Graph<N, E, T>, f: (mutable: MutableGraph<N, E, T>) => void): Graph<N, E, T>\n} = dual(2, <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T>,\n  f: (mutable: MutableGraph<N, E, T>) => void\n): Graph<N, E, T> => {\n  const mutable = beginMutation(graph)\n  f(mutable)\n  return endMutation(mutable)\n})\n\n// =============================================================================\n// Basic Node Operations\n// =============================================================================\n\n/**\n * Adds a new node to a mutable graph and returns its index.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const result = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   console.log(nodeA) // NodeIndex with value 0\n *   console.log(nodeB) // NodeIndex with value 1\n * })\n * ```\n *\n * @since 3.18.0\n * @category mutations\n */\nexport const addNode = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  data: N\n): NodeIndex => {\n  const nodeIndex = mutable.nextNodeIndex\n\n  // Add node data\n  mutable.nodes.set(nodeIndex, data)\n\n  // Initialize empty adjacency lists\n  mutable.adjacency.set(nodeIndex, [])\n  mutable.reverseAdjacency.set(nodeIndex, [])\n\n  // Update graph allocators\n  mutable.nextNodeIndex = mutable.nextNodeIndex + 1\n\n  return nodeIndex\n}\n\n/**\n * Gets the data associated with a node index, if it exists.\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   Graph.addNode(mutable, \"Node A\")\n * })\n *\n * const nodeIndex = 0\n * const nodeData = Graph.getNode(graph, nodeIndex)\n *\n * if (Option.isSome(nodeData)) {\n *   console.log(nodeData.value) // \"Node A\"\n * }\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const getNode = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  nodeIndex: NodeIndex\n): Option.Option<N> => graph.nodes.has(nodeIndex) ? Option.some(graph.nodes.get(nodeIndex)!) : Option.none()\n\n/**\n * Checks if a node with the given index exists in the graph.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   Graph.addNode(mutable, \"Node A\")\n * })\n *\n * const nodeIndex = 0\n * const exists = Graph.hasNode(graph, nodeIndex)\n * console.log(exists) // true\n *\n * const nonExistentIndex = 999\n * const notExists = Graph.hasNode(graph, nonExistentIndex)\n * console.log(notExists) // false\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const hasNode = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  nodeIndex: NodeIndex\n): boolean => graph.nodes.has(nodeIndex)\n\n/**\n * Returns the number of nodes in the graph.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const emptyGraph = Graph.directed<string, number>()\n * console.log(Graph.nodeCount(emptyGraph)) // 0\n *\n * const graphWithNodes = Graph.mutate(emptyGraph, (mutable) => {\n *   Graph.addNode(mutable, \"Node A\")\n *   Graph.addNode(mutable, \"Node B\")\n *   Graph.addNode(mutable, \"Node C\")\n * })\n *\n * console.log(Graph.nodeCount(graphWithNodes)) // 3\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const nodeCount = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>\n): number => graph.nodes.size\n\n/**\n * Finds the first node that matches the given predicate.\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   Graph.addNode(mutable, \"Node A\")\n *   Graph.addNode(mutable, \"Node B\")\n *   Graph.addNode(mutable, \"Node C\")\n * })\n *\n * const result = Graph.findNode(graph, (data) => data.startsWith(\"Node B\"))\n * console.log(result) // Option.some(1)\n *\n * const notFound = Graph.findNode(graph, (data) => data === \"Node D\")\n * console.log(notFound) // Option.none()\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const findNode = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  predicate: (data: N) => boolean\n): Option.Option<NodeIndex> => {\n  for (const [index, data] of graph.nodes) {\n    if (predicate(data)) {\n      return Option.some(index)\n    }\n  }\n  return Option.none()\n}\n\n/**\n * Finds all nodes that match the given predicate.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   Graph.addNode(mutable, \"Start A\")\n *   Graph.addNode(mutable, \"Node B\")\n *   Graph.addNode(mutable, \"Start C\")\n * })\n *\n * const result = Graph.findNodes(graph, (data) => data.startsWith(\"Start\"))\n * console.log(result) // [0, 2]\n *\n * const empty = Graph.findNodes(graph, (data) => data === \"Not Found\")\n * console.log(empty) // []\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const findNodes = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  predicate: (data: N) => boolean\n): Array<NodeIndex> => {\n  const results: Array<NodeIndex> = []\n  for (const [index, data] of graph.nodes) {\n    if (predicate(data)) {\n      results.push(index)\n    }\n  }\n  return results\n}\n\n/**\n * Finds the first edge that matches the given predicate.\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const nodeC = Graph.addNode(mutable, \"Node C\")\n *   Graph.addEdge(mutable, nodeA, nodeB, 10)\n *   Graph.addEdge(mutable, nodeB, nodeC, 20)\n * })\n *\n * const result = Graph.findEdge(graph, (data) => data > 15)\n * console.log(result) // Option.some(1)\n *\n * const notFound = Graph.findEdge(graph, (data) => data > 100)\n * console.log(notFound) // Option.none()\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const findEdge = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  predicate: (data: E, source: NodeIndex, target: NodeIndex) => boolean\n): Option.Option<EdgeIndex> => {\n  for (const [edgeIndex, edgeData] of graph.edges) {\n    if (predicate(edgeData.data, edgeData.source, edgeData.target)) {\n      return Option.some(edgeIndex)\n    }\n  }\n  return Option.none()\n}\n\n/**\n * Finds all edges that match the given predicate.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const nodeC = Graph.addNode(mutable, \"Node C\")\n *   Graph.addEdge(mutable, nodeA, nodeB, 10)\n *   Graph.addEdge(mutable, nodeB, nodeC, 20)\n *   Graph.addEdge(mutable, nodeC, nodeA, 30)\n * })\n *\n * const result = Graph.findEdges(graph, (data) => data >= 20)\n * console.log(result) // [1, 2]\n *\n * const empty = Graph.findEdges(graph, (data) => data > 100)\n * console.log(empty) // []\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const findEdges = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  predicate: (data: E, source: NodeIndex, target: NodeIndex) => boolean\n): Array<EdgeIndex> => {\n  const results: Array<EdgeIndex> = []\n  for (const [edgeIndex, edgeData] of graph.edges) {\n    if (predicate(edgeData.data, edgeData.source, edgeData.target)) {\n      results.push(edgeIndex)\n    }\n  }\n  return results\n}\n\n/**\n * Updates a single node's data by applying a transformation function.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   Graph.addNode(mutable, \"Node A\")\n *   Graph.addNode(mutable, \"Node B\")\n *   Graph.updateNode(mutable, 0, (data) => data.toUpperCase())\n * })\n *\n * const nodeData = Graph.getNode(graph, 0)\n * console.log(nodeData) // Option.some(\"NODE A\")\n * ```\n *\n * @since 3.18.0\n * @category transformations\n */\nexport const updateNode = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  index: NodeIndex,\n  f: (data: N) => N\n): void => {\n  if (!mutable.nodes.has(index)) {\n    return\n  }\n\n  const currentData = mutable.nodes.get(index)!\n  const newData = f(currentData)\n  mutable.nodes.set(index, newData)\n}\n\n/**\n * Updates a single edge's data by applying a transformation function.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const result = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const edgeIndex = Graph.addEdge(mutable, nodeA, nodeB, 10)\n *   Graph.updateEdge(mutable, edgeIndex, (data) => data * 2)\n * })\n *\n * const edgeData = Graph.getEdge(result, 0)\n * console.log(edgeData) // Option.some({ source: 0, target: 1, data: 20 })\n * ```\n *\n * @since 3.18.0\n * @category mutations\n */\nexport const updateEdge = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  edgeIndex: EdgeIndex,\n  f: (data: E) => E\n): void => {\n  if (!mutable.edges.has(edgeIndex)) {\n    return\n  }\n\n  const currentEdge = mutable.edges.get(edgeIndex)!\n  const newData = f(currentEdge.data)\n  mutable.edges.set(edgeIndex, {\n    ...currentEdge,\n    data: newData\n  })\n}\n\n/**\n * Creates a new graph with transformed node data using the provided mapping function.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   Graph.addNode(mutable, \"node a\")\n *   Graph.addNode(mutable, \"node b\")\n *   Graph.addNode(mutable, \"node c\")\n *   Graph.mapNodes(mutable, (data) => data.toUpperCase())\n * })\n *\n * const nodeData = Graph.getNode(graph, 0)\n * console.log(nodeData) // Option.some(\"NODE A\")\n * ```\n *\n * @since 3.18.0\n * @category transformations\n */\nexport const mapNodes = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  f: (data: N) => N\n): void => {\n  // Transform existing node data in place\n  for (const [index, data] of mutable.nodes) {\n    const newData = f(data)\n    mutable.nodes.set(index, newData)\n  }\n}\n\n/**\n * Transforms all edge data in a mutable graph using the provided mapping function.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 10)\n *   Graph.addEdge(mutable, b, c, 20)\n *   Graph.mapEdges(mutable, (data) => data * 2)\n * })\n *\n * const edgeData = Graph.getEdge(graph, 0)\n * console.log(edgeData) // Option.some({ source: 0, target: 1, data: 20 })\n * ```\n *\n * @since 3.18.0\n * @category transformations\n */\nexport const mapEdges = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  f: (data: E) => E\n): void => {\n  // Transform existing edge data in place\n  for (const [index, edgeData] of mutable.edges) {\n    const newData = f(edgeData.data)\n    mutable.edges.set(index, {\n      ...edgeData,\n      data: newData\n    })\n  }\n}\n\n/**\n * Reverses all edge directions in a mutable graph by swapping source and target nodes.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 1)  // A -> B\n *   Graph.addEdge(mutable, b, c, 2)  // B -> C\n *   Graph.reverse(mutable)           // Now B -> A, C -> B\n * })\n *\n * const edge0 = Graph.getEdge(graph, 0)\n * console.log(edge0) // Option.some({ source: 1, target: 0, data: 1 }) - B -> A\n * ```\n *\n * @since 3.18.0\n * @category transformations\n */\nexport const reverse = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>\n): void => {\n  // Reverse all edges by swapping source and target\n  for (const [index, edgeData] of mutable.edges) {\n    mutable.edges.set(index, {\n      source: edgeData.target,\n      target: edgeData.source,\n      data: edgeData.data\n    })\n  }\n\n  // Clear and rebuild adjacency lists with reversed directions\n  mutable.adjacency.clear()\n  mutable.reverseAdjacency.clear()\n\n  // Rebuild adjacency lists with reversed directions\n  for (const [edgeIndex, edgeData] of mutable.edges) {\n    // Add to forward adjacency (source -> target)\n    const sourceEdges = mutable.adjacency.get(edgeData.source) || []\n    sourceEdges.push(edgeIndex)\n    mutable.adjacency.set(edgeData.source, sourceEdges)\n\n    // Add to reverse adjacency (target <- source)\n    const targetEdges = mutable.reverseAdjacency.get(edgeData.target) || []\n    targetEdges.push(edgeIndex)\n    mutable.reverseAdjacency.set(edgeData.target, targetEdges)\n  }\n\n  // Invalidate cycle flag since edge directions changed\n  mutable.isAcyclic = Option.none()\n}\n\n/**\n * Filters and optionally transforms nodes in a mutable graph using a predicate function.\n * Nodes that return Option.none are removed along with all their connected edges.\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"active\")\n *   const b = Graph.addNode(mutable, \"inactive\")\n *   const c = Graph.addNode(mutable, \"active\")\n *   Graph.addEdge(mutable, a, b, 1)\n *   Graph.addEdge(mutable, b, c, 2)\n *\n *   // Keep only \"active\" nodes and transform to uppercase\n *   Graph.filterMapNodes(mutable, (data) =>\n *     data === \"active\" ? Option.some(data.toUpperCase()) : Option.none()\n *   )\n * })\n *\n * console.log(Graph.nodeCount(graph)) // 2 (only \"active\" nodes remain)\n * ```\n *\n * @since 3.18.0\n * @category transformations\n */\nexport const filterMapNodes = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  f: (data: N) => Option.Option<N>\n): void => {\n  const nodesToRemove: Array<NodeIndex> = []\n\n  // First pass: identify nodes to remove and transform data for nodes to keep\n  for (const [index, data] of mutable.nodes) {\n    const result = f(data)\n    if (Option.isSome(result)) {\n      // Transform node data\n      mutable.nodes.set(index, result.value)\n    } else {\n      // Mark for removal\n      nodesToRemove.push(index)\n    }\n  }\n\n  // Second pass: remove filtered out nodes and their edges\n  for (const nodeIndex of nodesToRemove) {\n    removeNode(mutable, nodeIndex)\n  }\n}\n\n/**\n * Filters and optionally transforms edges in a mutable graph using a predicate function.\n * Edges that return Option.none are removed from the graph.\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 5)\n *   Graph.addEdge(mutable, b, c, 15)\n *   Graph.addEdge(mutable, c, a, 25)\n *\n *   // Keep only edges with weight >= 10 and double their weight\n *   Graph.filterMapEdges(mutable, (data) =>\n *     data >= 10 ? Option.some(data * 2) : Option.none()\n *   )\n * })\n *\n * console.log(Graph.edgeCount(graph)) // 2 (edges with weight 5 removed)\n * ```\n *\n * @since 3.18.0\n * @category transformations\n */\nexport const filterMapEdges = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  f: (data: E) => Option.Option<E>\n): void => {\n  const edgesToRemove: Array<EdgeIndex> = []\n\n  // First pass: identify edges to remove and transform data for edges to keep\n  for (const [index, edgeData] of mutable.edges) {\n    const result = f(edgeData.data)\n    if (Option.isSome(result)) {\n      // Transform edge data\n      mutable.edges.set(index, {\n        ...edgeData,\n        data: result.value\n      })\n    } else {\n      // Mark for removal\n      edgesToRemove.push(index)\n    }\n  }\n\n  // Second pass: remove filtered out edges\n  for (const edgeIndex of edgesToRemove) {\n    removeEdge(mutable, edgeIndex)\n  }\n}\n\n/**\n * Filters nodes by removing those that don't match the predicate.\n * This function modifies the mutable graph in place.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   Graph.addNode(mutable, \"active\")\n *   Graph.addNode(mutable, \"inactive\")\n *   Graph.addNode(mutable, \"pending\")\n *   Graph.addNode(mutable, \"active\")\n *\n *   // Keep only \"active\" nodes\n *   Graph.filterNodes(mutable, (data) => data === \"active\")\n * })\n *\n * console.log(Graph.nodeCount(graph)) // 2 (only \"active\" nodes remain)\n * ```\n *\n * @since 3.18.0\n * @category transformations\n */\nexport const filterNodes = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  predicate: (data: N) => boolean\n): void => {\n  const nodesToRemove: Array<NodeIndex> = []\n\n  // Identify nodes to remove\n  for (const [index, data] of mutable.nodes) {\n    if (!predicate(data)) {\n      nodesToRemove.push(index)\n    }\n  }\n\n  // Remove filtered out nodes (this also removes connected edges)\n  for (const nodeIndex of nodesToRemove) {\n    removeNode(mutable, nodeIndex)\n  }\n}\n\n/**\n * Filters edges by removing those that don't match the predicate.\n * This function modifies the mutable graph in place.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *\n *   Graph.addEdge(mutable, a, b, 5)\n *   Graph.addEdge(mutable, b, c, 15)\n *   Graph.addEdge(mutable, c, a, 25)\n *\n *   // Keep only edges with weight >= 10\n *   Graph.filterEdges(mutable, (data) => data >= 10)\n * })\n *\n * console.log(Graph.edgeCount(graph)) // 2 (edge with weight 5 removed)\n * ```\n *\n * @since 3.18.0\n * @category transformations\n */\nexport const filterEdges = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  predicate: (data: E) => boolean\n): void => {\n  const edgesToRemove: Array<EdgeIndex> = []\n\n  // Identify edges to remove\n  for (const [index, edgeData] of mutable.edges) {\n    if (!predicate(edgeData.data)) {\n      edgesToRemove.push(index)\n    }\n  }\n\n  // Remove filtered out edges\n  for (const edgeIndex of edgesToRemove) {\n    removeEdge(mutable, edgeIndex)\n  }\n}\n\n// =============================================================================\n// Cycle Flag Management (Internal)\n// =============================================================================\n\n/** @internal */\nconst invalidateCycleFlagOnRemoval = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>\n): void => {\n  // Only invalidate if the graph had cycles (removing edges/nodes cannot introduce cycles in acyclic graphs)\n  // If already unknown (null) or acyclic (true), no need to change\n  if (Option.isSome(mutable.isAcyclic) && mutable.isAcyclic.value === false) {\n    mutable.isAcyclic = Option.none()\n  }\n}\n\n/** @internal */\nconst invalidateCycleFlagOnAddition = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>\n): void => {\n  // Only invalidate if the graph was acyclic (adding edges cannot remove cycles from cyclic graphs)\n  // If already unknown (null) or cyclic (false), no need to change\n  if (Option.isSome(mutable.isAcyclic) && mutable.isAcyclic.value === true) {\n    mutable.isAcyclic = Option.none()\n  }\n}\n\n// =============================================================================\n// Edge Operations\n// =============================================================================\n\n/**\n * Adds a new edge to a mutable graph and returns its index.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const result = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const edge = Graph.addEdge(mutable, nodeA, nodeB, 42)\n *   console.log(edge) // EdgeIndex with value 0\n * })\n * ```\n *\n * @since 3.18.0\n * @category mutations\n */\nexport const addEdge = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  source: NodeIndex,\n  target: NodeIndex,\n  data: E\n): EdgeIndex => {\n  // Validate that both nodes exist\n  if (!mutable.nodes.has(source)) {\n    throw missingNode(source)\n  }\n  if (!mutable.nodes.has(target)) {\n    throw missingNode(target)\n  }\n\n  const edgeIndex = mutable.nextEdgeIndex\n\n  // Create edge data\n  const edgeData = new Edge({ source, target, data })\n  mutable.edges.set(edgeIndex, edgeData)\n\n  // Update adjacency lists\n  const sourceAdjacency = mutable.adjacency.get(source)\n  if (sourceAdjacency !== undefined) {\n    sourceAdjacency.push(edgeIndex)\n  }\n\n  const targetReverseAdjacency = mutable.reverseAdjacency.get(target)\n  if (targetReverseAdjacency !== undefined) {\n    targetReverseAdjacency.push(edgeIndex)\n  }\n\n  // For undirected graphs, add reverse connections\n  if (mutable.type === \"undirected\") {\n    const targetAdjacency = mutable.adjacency.get(target)\n    if (targetAdjacency !== undefined) {\n      targetAdjacency.push(edgeIndex)\n    }\n\n    const sourceReverseAdjacency = mutable.reverseAdjacency.get(source)\n    if (sourceReverseAdjacency !== undefined) {\n      sourceReverseAdjacency.push(edgeIndex)\n    }\n  }\n\n  // Update allocators\n  mutable.nextEdgeIndex = mutable.nextEdgeIndex + 1\n\n  // Only invalidate cycle flag if the graph was acyclic\n  // Adding edges cannot remove cycles from cyclic graphs\n  invalidateCycleFlagOnAddition(mutable)\n\n  return edgeIndex\n}\n\n/**\n * Removes a node and all its incident edges from a mutable graph.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const result = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   Graph.addEdge(mutable, nodeA, nodeB, 42)\n *\n *   // Remove nodeA and all edges connected to it\n *   Graph.removeNode(mutable, nodeA)\n * })\n * ```\n *\n * @since 3.18.0\n * @category mutations\n */\nexport const removeNode = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  nodeIndex: NodeIndex\n): void => {\n  // Check if node exists\n  if (!mutable.nodes.has(nodeIndex)) {\n    return // Node doesn't exist, nothing to remove\n  }\n\n  // Collect all incident edges for removal\n  const edgesToRemove: Array<EdgeIndex> = []\n\n  // Get outgoing edges\n  const outgoingEdges = mutable.adjacency.get(nodeIndex)\n  if (outgoingEdges !== undefined) {\n    for (const edge of outgoingEdges) {\n      edgesToRemove.push(edge)\n    }\n  }\n\n  // Get incoming edges\n  const incomingEdges = mutable.reverseAdjacency.get(nodeIndex)\n  if (incomingEdges !== undefined) {\n    for (const edge of incomingEdges) {\n      edgesToRemove.push(edge)\n    }\n  }\n\n  // Remove all incident edges\n  for (const edgeIndex of edgesToRemove) {\n    removeEdgeInternal(mutable, edgeIndex)\n  }\n\n  // Remove the node itself\n  mutable.nodes.delete(nodeIndex)\n  mutable.adjacency.delete(nodeIndex)\n  mutable.reverseAdjacency.delete(nodeIndex)\n\n  // Only invalidate cycle flag if the graph wasn't already known to be acyclic\n  // Removing nodes cannot introduce cycles in an acyclic graph\n  invalidateCycleFlagOnRemoval(mutable)\n}\n\n/**\n * Removes an edge from a mutable graph.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const result = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const edge = Graph.addEdge(mutable, nodeA, nodeB, 42)\n *\n *   // Remove the edge\n *   Graph.removeEdge(mutable, edge)\n * })\n * ```\n *\n * @since 3.18.0\n * @category mutations\n */\nexport const removeEdge = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  edgeIndex: EdgeIndex\n): void => {\n  const wasRemoved = removeEdgeInternal(mutable, edgeIndex)\n\n  // Only invalidate cycle flag if an edge was actually removed\n  // and only if the graph wasn't already known to be acyclic\n  if (wasRemoved) {\n    invalidateCycleFlagOnRemoval(mutable)\n  }\n}\n\n/** @internal */\nconst removeEdgeInternal = <N, E, T extends Kind = \"directed\">(\n  mutable: MutableGraph<N, E, T>,\n  edgeIndex: EdgeIndex\n): boolean => {\n  // Get edge data\n  const edge = mutable.edges.get(edgeIndex)\n  if (edge === undefined) {\n    return false // Edge doesn't exist, no mutation occurred\n  }\n\n  const { source, target } = edge\n\n  // Remove from adjacency lists\n  const sourceAdjacency = mutable.adjacency.get(source)\n  if (sourceAdjacency !== undefined) {\n    const index = sourceAdjacency.indexOf(edgeIndex)\n    if (index !== -1) {\n      sourceAdjacency.splice(index, 1)\n    }\n  }\n\n  const targetReverseAdjacency = mutable.reverseAdjacency.get(target)\n  if (targetReverseAdjacency !== undefined) {\n    const index = targetReverseAdjacency.indexOf(edgeIndex)\n    if (index !== -1) {\n      targetReverseAdjacency.splice(index, 1)\n    }\n  }\n\n  // For undirected graphs, remove reverse connections\n  if (mutable.type === \"undirected\") {\n    const targetAdjacency = mutable.adjacency.get(target)\n    if (targetAdjacency !== undefined) {\n      const index = targetAdjacency.indexOf(edgeIndex)\n      if (index !== -1) {\n        targetAdjacency.splice(index, 1)\n      }\n    }\n\n    const sourceReverseAdjacency = mutable.reverseAdjacency.get(source)\n    if (sourceReverseAdjacency !== undefined) {\n      const index = sourceReverseAdjacency.indexOf(edgeIndex)\n      if (index !== -1) {\n        sourceReverseAdjacency.splice(index, 1)\n      }\n    }\n  }\n\n  // Remove edge data\n  mutable.edges.delete(edgeIndex)\n\n  return true // Edge was successfully removed\n}\n\n// =============================================================================\n// Edge Query Operations\n// =============================================================================\n\n/**\n * Gets the edge data associated with an edge index, if it exists.\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   Graph.addEdge(mutable, nodeA, nodeB, 42)\n * })\n *\n * const edgeIndex = 0\n * const edgeData = Graph.getEdge(graph, edgeIndex)\n *\n * if (Option.isSome(edgeData)) {\n *   console.log(edgeData.value.data) // 42\n *   console.log(edgeData.value.source) // NodeIndex(0)\n *   console.log(edgeData.value.target) // NodeIndex(1)\n * }\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const getEdge = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  edgeIndex: EdgeIndex\n): Option.Option<Edge<E>> => graph.edges.has(edgeIndex) ? Option.some(graph.edges.get(edgeIndex)!) : Option.none()\n\n/**\n * Checks if an edge exists between two nodes in the graph.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const nodeC = Graph.addNode(mutable, \"Node C\")\n *   Graph.addEdge(mutable, nodeA, nodeB, 42)\n * })\n *\n * const nodeA = 0\n * const nodeB = 1\n * const nodeC = 2\n *\n * const hasAB = Graph.hasEdge(graph, nodeA, nodeB)\n * console.log(hasAB) // true\n *\n * const hasAC = Graph.hasEdge(graph, nodeA, nodeC)\n * console.log(hasAC) // false\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const hasEdge = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  source: NodeIndex,\n  target: NodeIndex\n): boolean => {\n  const adjacencyList = graph.adjacency.get(source)\n  if (adjacencyList === undefined) {\n    return false\n  }\n\n  // Check if any edge in the adjacency list connects to the target\n  for (const edgeIndex of adjacencyList) {\n    const edge = graph.edges.get(edgeIndex)\n    if (edge !== undefined && edge.target === target) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Returns the number of edges in the graph.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const emptyGraph = Graph.directed<string, number>()\n * console.log(Graph.edgeCount(emptyGraph)) // 0\n *\n * const graphWithEdges = Graph.mutate(emptyGraph, (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const nodeC = Graph.addNode(mutable, \"Node C\")\n *   Graph.addEdge(mutable, nodeA, nodeB, 1)\n *   Graph.addEdge(mutable, nodeB, nodeC, 2)\n *   Graph.addEdge(mutable, nodeC, nodeA, 3)\n * })\n *\n * console.log(Graph.edgeCount(graphWithEdges)) // 3\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const edgeCount = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>\n): number => graph.edges.size\n\n/**\n * Returns the neighboring nodes (targets of outgoing edges) for a given node.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const nodeC = Graph.addNode(mutable, \"Node C\")\n *   Graph.addEdge(mutable, nodeA, nodeB, 1)\n *   Graph.addEdge(mutable, nodeA, nodeC, 2)\n * })\n *\n * const nodeA = 0\n * const nodeB = 1\n * const nodeC = 2\n *\n * const neighborsA = Graph.neighbors(graph, nodeA)\n * console.log(neighborsA) // [NodeIndex(1), NodeIndex(2)]\n *\n * const neighborsB = Graph.neighbors(graph, nodeB)\n * console.log(neighborsB) // []\n * ```\n *\n * @since 3.18.0\n * @category getters\n */\nexport const neighbors = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  nodeIndex: NodeIndex\n): Array<NodeIndex> => {\n  const adjacencyList = graph.adjacency.get(nodeIndex)\n  if (adjacencyList === undefined) {\n    return []\n  }\n\n  const result: Array<NodeIndex> = []\n  for (const edgeIndex of adjacencyList) {\n    const edge = graph.edges.get(edgeIndex)\n    if (edge !== undefined) {\n      result.push(edge.target)\n    }\n  }\n\n  return result\n}\n\n/**\n * Get neighbors of a node in a specific direction for bidirectional traversal.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   Graph.addEdge(mutable, a, b, \"A->B\")\n * })\n *\n * const nodeA = 0\n * const nodeB = 1\n *\n * // Get outgoing neighbors (nodes that nodeA points to)\n * const outgoing = Graph.neighborsDirected(graph, nodeA, \"outgoing\")\n *\n * // Get incoming neighbors (nodes that point to nodeB)\n * const incoming = Graph.neighborsDirected(graph, nodeB, \"incoming\")\n * ```\n *\n * @since 3.18.0\n * @category queries\n */\nexport const neighborsDirected = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  nodeIndex: NodeIndex,\n  direction: Direction\n): Array<NodeIndex> => {\n  const adjacencyMap = direction === \"incoming\"\n    ? graph.reverseAdjacency\n    : graph.adjacency\n\n  const adjacencyList = adjacencyMap.get(nodeIndex)\n  if (adjacencyList === undefined) {\n    return []\n  }\n\n  const result: Array<NodeIndex> = []\n  for (const edgeIndex of adjacencyList) {\n    const edge = graph.edges.get(edgeIndex)\n    if (edge !== undefined) {\n      // For incoming direction, we want the source node instead of target\n      const neighborNode = direction === \"incoming\"\n        ? edge.source\n        : edge.target\n      result.push(neighborNode)\n    }\n  }\n\n  return result\n}\n\n// =============================================================================\n// GraphViz Export\n// =============================================================================\n\n/**\n * Configuration options for GraphViz DOT format generation from graphs.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface GraphVizOptions<N, E> {\n  readonly nodeLabel?: (data: N) => string\n  readonly edgeLabel?: (data: E) => string\n  readonly graphName?: string\n}\n\n/**\n * Exports a graph to GraphViz DOT format for visualization.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const nodeA = Graph.addNode(mutable, \"Node A\")\n *   const nodeB = Graph.addNode(mutable, \"Node B\")\n *   const nodeC = Graph.addNode(mutable, \"Node C\")\n *   Graph.addEdge(mutable, nodeA, nodeB, 1)\n *   Graph.addEdge(mutable, nodeB, nodeC, 2)\n *   Graph.addEdge(mutable, nodeC, nodeA, 3)\n * })\n *\n * const dot = Graph.toGraphViz(graph)\n * console.log(dot)\n * // digraph G {\n * //   \"0\" [label=\"Node A\"];\n * //   \"1\" [label=\"Node B\"];\n * //   \"2\" [label=\"Node C\"];\n * //   \"0\" -> \"1\" [label=\"1\"];\n * //   \"1\" -> \"2\" [label=\"2\"];\n * //   \"2\" -> \"0\" [label=\"3\"];\n * // }\n * ```\n *\n * @since 3.18.0\n * @category utils\n */\nexport const toGraphViz = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  options?: GraphVizOptions<N, E>\n): string => {\n  const {\n    edgeLabel = (data: E) => String(data),\n    graphName = \"G\",\n    nodeLabel = (data: N) => String(data)\n  } = options ?? {}\n\n  const isDirected = graph.type === \"directed\"\n  const graphType = isDirected ? \"digraph\" : \"graph\"\n  const edgeOperator = isDirected ? \"->\" : \"--\"\n\n  const lines: Array<string> = []\n  lines.push(`${graphType} ${graphName} {`)\n\n  // Add nodes\n  for (const [nodeIndex, nodeData] of graph.nodes) {\n    const label = nodeLabel(nodeData).replace(/\"/g, \"\\\\\\\"\")\n    lines.push(`  \"${nodeIndex}\" [label=\"${label}\"];`)\n  }\n\n  // Add edges\n  for (const [, edgeData] of graph.edges) {\n    const label = edgeLabel(edgeData.data).replace(/\"/g, \"\\\\\\\"\")\n    lines.push(`  \"${edgeData.source}\" ${edgeOperator} \"${edgeData.target}\" [label=\"${label}\"];`)\n  }\n\n  lines.push(\"}\")\n  return lines.join(\"\\n\")\n}\n\n// =============================================================================\n// Mermaid Export\n// =============================================================================\n\n/**\n * Mermaid node shape types.\n *\n * @since 3.18.0\n * @category models\n */\nexport type MermaidNodeShape =\n  | \"rectangle\"\n  | \"rounded\"\n  | \"circle\"\n  | \"diamond\"\n  | \"hexagon\"\n  | \"stadium\"\n  | \"subroutine\"\n  | \"cylindrical\"\n\n/**\n * Mermaid diagram direction types.\n *\n * @since 3.18.0\n * @category models\n */\nexport type MermaidDirection = \"TB\" | \"TD\" | \"BT\" | \"LR\" | \"RL\"\n\n/**\n * Mermaid diagram type.\n *\n * @since 3.18.0\n * @category models\n */\nexport type MermaidDiagramType = \"flowchart\" | \"graph\"\n\n/**\n * Configuration options for Mermaid diagram generation.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface MermaidOptions<N, E> {\n  readonly nodeLabel?: (data: N) => string\n  readonly edgeLabel?: (data: E) => string\n  readonly diagramType?: MermaidDiagramType\n  readonly direction?: MermaidDirection\n  readonly nodeShape?: (data: N) => MermaidNodeShape\n}\n\n/** @internal */\nconst escapeMermaidLabel = (label: string): string => {\n  // Escape special characters for Mermaid using HTML entity codes\n  // According to: https://mermaid.js.org/syntax/flowchart.html#special-characters-that-break-syntax\n  return label\n    .replace(/#/g, \"#35;\")\n    .replace(/\"/g, \"#quot;\")\n    .replace(/</g, \"#lt;\")\n    .replace(/>/g, \"#gt;\")\n    .replace(/&/g, \"#amp;\")\n    .replace(/\\[/g, \"#91;\")\n    .replace(/\\]/g, \"#93;\")\n    .replace(/\\{/g, \"#123;\")\n    .replace(/\\}/g, \"#125;\")\n    .replace(/\\(/g, \"#40;\")\n    .replace(/\\)/g, \"#41;\")\n    .replace(/\\|/g, \"#124;\")\n    .replace(/\\\\/g, \"#92;\")\n    .replace(/\\n/g, \"<br/>\");\n}\n\n/** @internal */\nconst formatMermaidNode = (nodeId: string, label: string, shape: MermaidNodeShape): string => {\n  switch (shape) {\n    case \"rectangle\":\n      return `${nodeId}[\"${label}\"]`\n    case \"rounded\":\n      return `${nodeId}(\"${label}\")`\n    case \"circle\":\n      return `${nodeId}((\"${label}\"))`\n    case \"diamond\":\n      return `${nodeId}{\"${label}\"}`\n    case \"hexagon\":\n      return `${nodeId}{{\"${label}\"}}`\n    case \"stadium\":\n      return `${nodeId}([\"${label}\"])`\n    case \"subroutine\":\n      return `${nodeId}[[\"${label}\"]]`\n    case \"cylindrical\":\n      return `${nodeId}[(\"${label}\")]`\n  }\n}\n\n/**\n * Exports a graph to Mermaid diagram format for visualization.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.mutate(Graph.directed<string, number>(), (mutable) => {\n *   const app = Graph.addNode(mutable, \"App\")\n *   const db = Graph.addNode(mutable, \"Database\")\n *   const cache = Graph.addNode(mutable, \"Cache\")\n *   Graph.addEdge(mutable, app, db, 1)\n *   Graph.addEdge(mutable, app, cache, 2)\n * })\n *\n * const mermaid = Graph.toMermaid(graph)\n * console.log(mermaid)\n * // flowchart TD\n * //   0[\"App\"]\n * //   1[\"Database\"]\n * //   2[\"Cache\"]\n * //   0 -->|\"1\"| 1\n * //   0 -->|\"2\"| 2\n * ```\n *\n * @since 3.18.0\n * @category utils\n */\nexport const toMermaid = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  options?: MermaidOptions<N, E>\n): string => {\n  // Extract and validate options with defaults\n  const {\n    diagramType,\n    direction = \"TD\",\n    edgeLabel = (data: E) => String(data),\n    nodeLabel = (data: N) => String(data),\n    nodeShape = () => \"rectangle\" as const\n  } = options ?? {}\n\n  // Auto-detect diagram type if not specified\n  const finalDiagramType = diagramType ??\n    (graph.type === \"directed\" ? \"flowchart\" : \"graph\")\n\n  // Generate diagram header\n  const lines: Array<string> = []\n  lines.push(`${finalDiagramType} ${direction}`)\n\n  // Add nodes\n  for (const [nodeIndex, nodeData] of graph.nodes) {\n    const nodeId = String(nodeIndex)\n    const label = escapeMermaidLabel(nodeLabel(nodeData))\n    const shape = nodeShape(nodeData)\n    const formattedNode = formatMermaidNode(nodeId, label, shape)\n    lines.push(`  ${formattedNode}`)\n  }\n\n  // Add edges\n  const edgeOperator = finalDiagramType === \"flowchart\" ? \"-->\" : \"---\"\n  for (const [, edgeData] of graph.edges) {\n    const sourceId = String(edgeData.source)\n    const targetId = String(edgeData.target)\n    const label = escapeMermaidLabel(edgeLabel(edgeData.data))\n\n    if (label) {\n      lines.push(`  ${sourceId} ${edgeOperator}|\"${label}\"| ${targetId}`)\n    } else {\n      lines.push(`  ${sourceId} ${edgeOperator} ${targetId}`)\n    }\n  }\n\n  return lines.join(\"\\n\")\n}\n\n// =============================================================================\n// Direction Types for Bidirectional Traversal\n// =============================================================================\n\n/**\n * Direction for graph traversal, indicating which edges to follow.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   Graph.addEdge(mutable, a, b, \"A->B\")\n * })\n *\n * // Follow outgoing edges (normal direction)\n * const outgoingNodes = Array.from(Graph.indices(Graph.dfs(graph, { start: [0], direction: \"outgoing\" })))\n *\n * // Follow incoming edges (reverse direction)\n * const incomingNodes = Array.from(Graph.indices(Graph.dfs(graph, { start: [1], direction: \"incoming\" })))\n * ```\n *\n * @since 3.18.0\n * @category models\n */\nexport type Direction = \"outgoing\" | \"incoming\"\n\n// =============================================================================\n\n// =============================================================================\n// Graph Structure Analysis Algorithms (Phase 5A)\n// =============================================================================\n\n/**\n * Checks if the graph is acyclic (contains no cycles).\n *\n * Uses depth-first search to detect back edges, which indicate cycles.\n * For directed graphs, any back edge creates a cycle. For undirected graphs,\n * a back edge that doesn't go to the immediate parent creates a cycle.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * // Acyclic directed graph (DAG)\n * const dag = Graph.directed<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, \"A->B\")\n *   Graph.addEdge(mutable, b, c, \"B->C\")\n * })\n * console.log(Graph.isAcyclic(dag)) // true\n *\n * // Cyclic directed graph\n * const cyclic = Graph.directed<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   Graph.addEdge(mutable, a, b, \"A->B\")\n *   Graph.addEdge(mutable, b, a, \"B->A\") // Creates cycle\n * })\n * console.log(Graph.isAcyclic(cyclic)) // false\n * ```\n *\n * @since 3.18.0\n * @category algorithms\n */\nexport const isAcyclic = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>\n): boolean => {\n  // Use existing cycle flag if available\n  if (Option.isSome(graph.isAcyclic)) {\n    return graph.isAcyclic.value\n  }\n\n  // Stack-safe DFS cycle detection using iterative approach\n  const visited = new Set<NodeIndex>()\n  const recursionStack = new Set<NodeIndex>()\n\n  // Stack entry: [node, neighbors, neighborIndex, isFirstVisit]\n  type DfsStackEntry = [NodeIndex, Array<NodeIndex>, number, boolean]\n\n  // Get all nodes to handle disconnected components\n  for (const startNode of graph.nodes.keys()) {\n    if (visited.has(startNode)) {\n      continue // Already processed this component\n    }\n\n    // Iterative DFS with explicit stack\n    const stack: Array<DfsStackEntry> = [[startNode, [], 0, true]]\n\n    while (stack.length > 0) {\n      const [node, neighbors, neighborIndex, isFirstVisit] = stack[stack.length - 1]\n\n      // First visit to this node\n      if (isFirstVisit) {\n        if (recursionStack.has(node)) {\n          // Back edge found - cycle detected\n          graph.isAcyclic = Option.some(false)\n          return false\n        }\n\n        if (visited.has(node)) {\n          stack.pop()\n          continue\n        }\n\n        visited.add(node)\n        recursionStack.add(node)\n\n        // Get neighbors for this node\n        const nodeNeighbors = Array.from(neighborsDirected(graph, node, \"outgoing\"))\n        stack[stack.length - 1] = [node, nodeNeighbors, 0, false]\n        continue\n      }\n\n      // Process next neighbor\n      if (neighborIndex < neighbors.length) {\n        const neighbor = neighbors[neighborIndex]\n        stack[stack.length - 1] = [node, neighbors, neighborIndex + 1, false]\n\n        if (recursionStack.has(neighbor)) {\n          // Back edge found - cycle detected\n          graph.isAcyclic = Option.some(false)\n          return false\n        }\n\n        if (!visited.has(neighbor)) {\n          stack.push([neighbor, [], 0, true])\n        }\n      } else {\n        // Done with this node - backtrack\n        recursionStack.delete(node)\n        stack.pop()\n      }\n    }\n  }\n\n  // Cache the result\n  graph.isAcyclic = Option.some(true)\n  return true\n}\n\n/**\n * Checks if an undirected graph is bipartite.\n *\n * A bipartite graph is one whose vertices can be divided into two disjoint sets\n * such that no two vertices within the same set are adjacent. Uses BFS coloring\n * to determine bipartiteness.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * // Bipartite graph (alternating coloring possible)\n * const bipartite = Graph.undirected<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   const d = Graph.addNode(mutable, \"D\")\n *   Graph.addEdge(mutable, a, b, \"edge\") // Set 1: {A, C}, Set 2: {B, D}\n *   Graph.addEdge(mutable, b, c, \"edge\")\n *   Graph.addEdge(mutable, c, d, \"edge\")\n * })\n * console.log(Graph.isBipartite(bipartite)) // true\n *\n * // Non-bipartite graph (odd cycle)\n * const triangle = Graph.undirected<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, \"edge\")\n *   Graph.addEdge(mutable, b, c, \"edge\")\n *   Graph.addEdge(mutable, c, a, \"edge\") // Triangle (3-cycle)\n * })\n * console.log(Graph.isBipartite(triangle)) // false\n * ```\n *\n * @since 3.18.0\n * @category algorithms\n */\nexport const isBipartite = <N, E>(\n  graph: Graph<N, E, \"undirected\"> | MutableGraph<N, E, \"undirected\">\n): boolean => {\n  const coloring = new Map<NodeIndex, 0 | 1>()\n  const discovered = new Set<NodeIndex>()\n  let isBipartiteGraph = true\n\n  // Get all nodes to handle disconnected components\n  for (const startNode of graph.nodes.keys()) {\n    if (!discovered.has(startNode)) {\n      // Start BFS coloring from this component\n      const queue: Array<NodeIndex> = [startNode]\n      coloring.set(startNode, 0) // Color start node with 0\n      discovered.add(startNode)\n\n      while (queue.length > 0 && isBipartiteGraph) {\n        const current = queue.shift()!\n        const currentColor = coloring.get(current)!\n        const neighborColor: 0 | 1 = currentColor === 0 ? 1 : 0\n\n        // Get all neighbors for undirected graph\n        const nodeNeighbors = getUndirectedNeighbors(graph, current)\n        for (const neighbor of nodeNeighbors) {\n          if (!discovered.has(neighbor)) {\n            // Color unvisited neighbor with opposite color\n            coloring.set(neighbor, neighborColor)\n            discovered.add(neighbor)\n            queue.push(neighbor)\n          } else {\n            // Check if neighbor has the same color (conflict)\n            if (coloring.get(neighbor) === currentColor) {\n              isBipartiteGraph = false\n              break\n            }\n          }\n        }\n      }\n\n      // Early exit if not bipartite\n      if (!isBipartiteGraph) {\n        break\n      }\n    }\n  }\n\n  return isBipartiteGraph\n}\n\n/**\n * Get neighbors for undirected graphs by checking both adjacency and reverse adjacency.\n * For undirected graphs, we need to find the other endpoint of each edge incident to the node.\n */\nconst getUndirectedNeighbors = <N, E>(\n  graph: Graph<N, E, \"undirected\"> | MutableGraph<N, E, \"undirected\">,\n  nodeIndex: NodeIndex\n): Array<NodeIndex> => {\n  const neighbors = new Set<NodeIndex>()\n\n  // Check edges where this node is the source\n  const adjacencyList = graph.adjacency.get(nodeIndex)\n  if (adjacencyList !== undefined) {\n    for (const edgeIndex of adjacencyList) {\n      const edge = graph.edges.get(edgeIndex)\n      if (edge !== undefined) {\n        // For undirected graphs, the neighbor is the other endpoint\n        const otherNode = edge.source === nodeIndex ? edge.target : edge.source\n        neighbors.add(otherNode)\n      }\n    }\n  }\n\n  return Array.from(neighbors)\n}\n\n/**\n * Find connected components in an undirected graph.\n * Each component is represented as an array of node indices.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.undirected<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   const d = Graph.addNode(mutable, \"D\")\n *   Graph.addEdge(mutable, a, b, \"edge\") // Component 1: A-B\n *   Graph.addEdge(mutable, c, d, \"edge\") // Component 2: C-D\n * })\n *\n * const components = Graph.connectedComponents(graph)\n * console.log(components) // [[0, 1], [2, 3]]\n * ```\n *\n * @since 3.18.0\n * @category algorithms\n */\nexport const connectedComponents = <N, E>(\n  graph: Graph<N, E, \"undirected\"> | MutableGraph<N, E, \"undirected\">\n): Array<Array<NodeIndex>> => {\n  const visited = new Set<NodeIndex>()\n  const components: Array<Array<NodeIndex>> = []\n  for (const startNode of graph.nodes.keys()) {\n    if (!visited.has(startNode)) {\n      // DFS to find all nodes in this component\n      const component: Array<NodeIndex> = []\n      const stack: Array<NodeIndex> = [startNode]\n\n      while (stack.length > 0) {\n        const current = stack.pop()!\n        if (!visited.has(current)) {\n          visited.add(current)\n          component.push(current)\n\n          // Add all unvisited neighbors to stack\n          const nodeNeighbors = getUndirectedNeighbors(graph, current)\n          for (const neighbor of nodeNeighbors) {\n            if (!visited.has(neighbor)) {\n              stack.push(neighbor)\n            }\n          }\n        }\n      }\n\n      components.push(component)\n    }\n  }\n\n  return components\n}\n\n/**\n * Find strongly connected components in a directed graph using Kosaraju's algorithm.\n * Each SCC is represented as an array of node indices.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, string>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, \"A->B\")\n *   Graph.addEdge(mutable, b, c, \"B->C\")\n *   Graph.addEdge(mutable, c, a, \"C->A\") // Creates SCC: A-B-C\n * })\n *\n * const sccs = Graph.stronglyConnectedComponents(graph)\n * console.log(sccs) // [[0, 1, 2]]\n * ```\n *\n * @since 3.18.0\n * @category algorithms\n */\nexport const stronglyConnectedComponents = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>\n): Array<Array<NodeIndex>> => {\n  const visited = new Set<NodeIndex>()\n  const finishOrder: Array<NodeIndex> = []\n  // Iterate directly over node keys\n\n  // Step 1: Stack-safe DFS on original graph to get finish times\n  // Stack entry: [node, neighbors, neighborIndex, isFirstVisit]\n  type DfsStackEntry = [NodeIndex, Array<NodeIndex>, number, boolean]\n\n  for (const startNode of graph.nodes.keys()) {\n    if (visited.has(startNode)) {\n      continue\n    }\n\n    const stack: Array<DfsStackEntry> = [[startNode, [], 0, true]]\n\n    while (stack.length > 0) {\n      const [node, nodeNeighbors, neighborIndex, isFirstVisit] = stack[stack.length - 1]\n\n      if (isFirstVisit) {\n        if (visited.has(node)) {\n          stack.pop()\n          continue\n        }\n\n        visited.add(node)\n        const nodeNeighborsList = neighbors(graph, node)\n        stack[stack.length - 1] = [node, nodeNeighborsList, 0, false]\n        continue\n      }\n\n      // Process next neighbor\n      if (neighborIndex < nodeNeighbors.length) {\n        const neighbor = nodeNeighbors[neighborIndex]\n        stack[stack.length - 1] = [node, nodeNeighbors, neighborIndex + 1, false]\n\n        if (!visited.has(neighbor)) {\n          stack.push([neighbor, [], 0, true])\n        }\n      } else {\n        // Done with this node - add to finish order (post-order)\n        finishOrder.push(node)\n        stack.pop()\n      }\n    }\n  }\n\n  // Step 2: Stack-safe DFS on transpose graph in reverse finish order\n  visited.clear()\n  const sccs: Array<Array<NodeIndex>> = []\n\n  for (let i = finishOrder.length - 1; i >= 0; i--) {\n    const startNode = finishOrder[i]\n    if (visited.has(startNode)) {\n      continue\n    }\n\n    const scc: Array<NodeIndex> = []\n    const stack: Array<NodeIndex> = [startNode]\n\n    while (stack.length > 0) {\n      const node = stack.pop()!\n\n      if (visited.has(node)) {\n        continue\n      }\n\n      visited.add(node)\n      scc.push(node)\n\n      // Use reverse adjacency (transpose graph)\n      const reverseAdjacency = graph.reverseAdjacency.get(node)\n      if (reverseAdjacency !== undefined) {\n        for (const edgeIndex of reverseAdjacency) {\n          const edge = graph.edges.get(edgeIndex)\n          if (edge !== undefined) {\n            const predecessor = edge.source\n            if (!visited.has(predecessor)) {\n              stack.push(predecessor)\n            }\n          }\n        }\n      }\n    }\n\n    sccs.push(scc)\n  }\n\n  return sccs\n}\n\n// =============================================================================\n// Path Finding Algorithms (Phase 5B)\n// =============================================================================\n\n/**\n * Result of a shortest path computation containing the path and total distance.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface PathResult<E> {\n  readonly path: Array<NodeIndex>\n  readonly distance: number\n  readonly costs: Array<E>\n}\n\n/**\n * Configuration for Dijkstra's algorithm.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface DijkstraConfig<E> {\n  source: NodeIndex\n  target: NodeIndex\n  cost: (edgeData: E) => number\n}\n\n/**\n * Configuration for A* algorithm.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface AstarConfig<E, N> {\n  source: NodeIndex\n  target: NodeIndex\n  cost: (edgeData: E) => number\n  heuristic: (sourceNodeData: N, targetNodeData: N) => number\n}\n\n/**\n * Configuration for Bellman-Ford algorithm.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface BellmanFordConfig<E> {\n  source: NodeIndex\n  target: NodeIndex\n  cost: (edgeData: E) => number\n}\n\n/**\n * Find the shortest path between two nodes using Dijkstra's algorithm.\n *\n * Dijkstra's algorithm works with non-negative edge weights and finds the shortest\n * path from a source node to a target node in O((V + E) log V) time complexity.\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 5)\n *   Graph.addEdge(mutable, a, c, 10)\n *   Graph.addEdge(mutable, b, c, 2)\n * })\n *\n * const result = Graph.dijkstra(graph, { source: 0, target: 2, cost: (edgeData) => edgeData })\n * if (Option.isSome(result)) {\n *   console.log(result.value.path) // [0, 1, 2] - shortest path A->B->C\n *   console.log(result.value.distance) // 7 - total distance\n * }\n * ```\n *\n * @since 3.18.0\n * @category algorithms\n */\nexport const dijkstra = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  config: DijkstraConfig<E>\n): Option.Option<PathResult<E>> => {\n  const { cost, source, target } = config\n  // Validate that source and target nodes exist\n  if (!graph.nodes.has(source)) {\n    throw missingNode(source)\n  }\n  if (!graph.nodes.has(target)) {\n    throw missingNode(target)\n  }\n\n  // Early return if source equals target\n  if (source === target) {\n    return Option.some({\n      path: [source],\n      distance: 0,\n      costs: []\n    })\n  }\n\n  // Distance tracking and priority queue simulation\n  const distances = new Map<NodeIndex, number>()\n  const previous = new Map<NodeIndex, { node: NodeIndex; edgeData: E } | null>()\n  const visited = new Set<NodeIndex>()\n\n  // Initialize distances\n  // Iterate directly over node keys\n  for (const node of graph.nodes.keys()) {\n    distances.set(node, node === source ? 0 : Infinity)\n    previous.set(node, null)\n  }\n\n  // Simple priority queue using array (can be optimized with proper heap)\n  const priorityQueue: Array<{ node: NodeIndex; distance: number }> = [\n    { node: source, distance: 0 }\n  ]\n\n  while (priorityQueue.length > 0) {\n    // Find minimum distance node (priority queue extract-min)\n    let minIndex = 0\n    for (let i = 1; i < priorityQueue.length; i++) {\n      if (priorityQueue[i].distance < priorityQueue[minIndex].distance) {\n        minIndex = i\n      }\n    }\n\n    const current = priorityQueue.splice(minIndex, 1)[0]\n    const currentNode = current.node\n\n    // Skip if already visited (can happen with duplicate entries)\n    if (visited.has(currentNode)) {\n      continue\n    }\n\n    visited.add(currentNode)\n\n    // Early termination if we reached the target\n    if (currentNode === target) {\n      break\n    }\n\n    // Get current distance\n    const currentDistance = distances.get(currentNode)!\n\n    // Examine all outgoing edges\n    const adjacencyList = graph.adjacency.get(currentNode)\n    if (adjacencyList !== undefined) {\n      for (const edgeIndex of adjacencyList) {\n        const edge = graph.edges.get(edgeIndex)\n        if (edge !== undefined) {\n          const neighbor = edge.target\n          const weight = cost(edge.data)\n\n          // Validate non-negative weights\n          if (weight < 0) {\n            throw new Error(`Dijkstra's algorithm requires non-negative edge weights, found ${weight}`)\n          }\n\n          const newDistance = currentDistance + weight\n          const neighborDistance = distances.get(neighbor)!\n\n          // Relaxation step\n          if (newDistance < neighborDistance) {\n            distances.set(neighbor, newDistance)\n            previous.set(neighbor, { node: currentNode, edgeData: edge.data })\n\n            // Add to priority queue if not visited\n            if (!visited.has(neighbor)) {\n              priorityQueue.push({ node: neighbor, distance: newDistance })\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Check if target is reachable\n  const targetDistance = distances.get(target)!\n  if (targetDistance === Infinity) {\n    return Option.none() // No path exists\n  }\n\n  // Reconstruct path\n  const path: Array<NodeIndex> = []\n  const costs: Array<E> = []\n  let currentNode: NodeIndex | null = target\n\n  while (currentNode !== null) {\n    path.unshift(currentNode)\n    const prev: { node: NodeIndex; edgeData: E } | null = previous.get(currentNode)!\n    if (prev !== null) {\n      costs.unshift(prev.edgeData)\n      currentNode = prev.node\n    } else {\n      currentNode = null\n    }\n  }\n\n  return Option.some({\n    path,\n    distance: targetDistance,\n    costs\n  })\n}\n\n/**\n * Result of all-pairs shortest path computation.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface AllPairsResult<E> {\n  readonly distances: Map<NodeIndex, Map<NodeIndex, number>>\n  readonly paths: Map<NodeIndex, Map<NodeIndex, Array<NodeIndex> | null>>\n  readonly costs: Map<NodeIndex, Map<NodeIndex, Array<E>>>\n}\n\n/**\n * Find shortest paths between all pairs of nodes using Floyd-Warshall algorithm.\n *\n * Floyd-Warshall algorithm computes shortest paths between all pairs of nodes in O(V³) time.\n * It can handle negative edge weights and detect negative cycles.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 3)\n *   Graph.addEdge(mutable, b, c, 2)\n *   Graph.addEdge(mutable, a, c, 7)\n * })\n *\n * const result = Graph.floydWarshall(graph, (edgeData) => edgeData)\n * const distanceAToC = result.distances.get(0)?.get(2) // 5 (A->B->C)\n * const pathAToC = result.paths.get(0)?.get(2) // [0, 1, 2]\n * ```\n *\n * @since 3.18.0\n * @category algorithms\n */\nexport const floydWarshall = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  cost: (edgeData: E) => number\n): AllPairsResult<E> => {\n  // Get all nodes for Floyd-Warshall algorithm (needs array for nested iteration)\n  const allNodes = Array.from(graph.nodes.keys())\n\n  // Initialize distance matrix\n  const dist = new Map<NodeIndex, Map<NodeIndex, number>>()\n  const next = new Map<NodeIndex, Map<NodeIndex, NodeIndex | null>>()\n  const edgeMatrix = new Map<NodeIndex, Map<NodeIndex, E | null>>()\n\n  // Initialize with infinity for all pairs\n  for (const i of allNodes) {\n    dist.set(i, new Map())\n    next.set(i, new Map())\n    edgeMatrix.set(i, new Map())\n\n    for (const j of allNodes) {\n      dist.get(i)!.set(j, i === j ? 0 : Infinity)\n      next.get(i)!.set(j, null)\n      edgeMatrix.get(i)!.set(j, null)\n    }\n  }\n\n  // Set edge weights\n  for (const [, edgeData] of graph.edges) {\n    const weight = cost(edgeData.data)\n    const i = edgeData.source\n    const j = edgeData.target\n\n    // Use minimum weight if multiple edges exist\n    const currentWeight = dist.get(i)!.get(j)!\n    if (weight < currentWeight) {\n      dist.get(i)!.set(j, weight)\n      next.get(i)!.set(j, j)\n      edgeMatrix.get(i)!.set(j, edgeData.data)\n    }\n  }\n\n  // Floyd-Warshall main loop\n  for (const k of allNodes) {\n    for (const i of allNodes) {\n      for (const j of allNodes) {\n        const distIK = dist.get(i)!.get(k)!\n        const distKJ = dist.get(k)!.get(j)!\n        const distIJ = dist.get(i)!.get(j)!\n\n        if (distIK !== Infinity && distKJ !== Infinity && distIK + distKJ < distIJ) {\n          dist.get(i)!.set(j, distIK + distKJ)\n          next.get(i)!.set(j, next.get(i)!.get(k)!)\n        }\n      }\n    }\n  }\n\n  // Check for negative cycles\n  for (const i of allNodes) {\n    if (dist.get(i)!.get(i)! < 0) {\n      throw new Error(`Negative cycle detected involving node ${i}`)\n    }\n  }\n\n  // Build result paths and edge weights\n  const paths = new Map<NodeIndex, Map<NodeIndex, Array<NodeIndex> | null>>()\n  const resultCosts = new Map<NodeIndex, Map<NodeIndex, Array<E>>>()\n\n  for (const i of allNodes) {\n    paths.set(i, new Map())\n    resultCosts.set(i, new Map())\n\n    for (const j of allNodes) {\n      if (i === j) {\n        paths.get(i)!.set(j, [i])\n        resultCosts.get(i)!.set(j, [])\n      } else if (dist.get(i)!.get(j)! === Infinity) {\n        paths.get(i)!.set(j, null)\n        resultCosts.get(i)!.set(j, [])\n      } else {\n        // Reconstruct path iteratively\n        const path: Array<NodeIndex> = []\n        const weights: Array<E> = []\n        let current = i\n\n        path.push(current)\n        while (current !== j) {\n          const nextNode = next.get(current)!.get(j)!\n          if (nextNode === null) break\n\n          const edgeData = edgeMatrix.get(current)!.get(nextNode)!\n          if (edgeData !== null) {\n            weights.push(edgeData)\n          }\n\n          current = nextNode\n          path.push(current)\n        }\n\n        paths.get(i)!.set(j, path)\n        resultCosts.get(i)!.set(j, weights)\n      }\n    }\n  }\n\n  return {\n    distances: dist,\n    paths,\n    costs: resultCosts\n  }\n}\n\n/**\n * Find the shortest path between two nodes using A* pathfinding algorithm.\n *\n * A* is an extension of Dijkstra's algorithm that uses a heuristic function to guide\n * the search towards the target, potentially finding paths faster than Dijkstra's.\n * The heuristic must be admissible (never overestimate the actual cost).\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.directed<{x: number, y: number}, number>((mutable) => {\n *   const a = Graph.addNode(mutable, {x: 0, y: 0})\n *   const b = Graph.addNode(mutable, {x: 1, y: 0})\n *   const c = Graph.addNode(mutable, {x: 2, y: 0})\n *   Graph.addEdge(mutable, a, b, 1)\n *   Graph.addEdge(mutable, b, c, 1)\n * })\n *\n * // Manhattan distance heuristic\n * const heuristic = (nodeData: {x: number, y: number}, targetData: {x: number, y: number}) =>\n *   Math.abs(nodeData.x - targetData.x) + Math.abs(nodeData.y - targetData.y)\n *\n * const result = Graph.astar(graph, { source: 0, target: 2, cost: (edgeData) => edgeData, heuristic })\n * if (Option.isSome(result)) {\n *   console.log(result.value.path) // [0, 1, 2] - shortest path\n *   console.log(result.value.distance) // 2 - total distance\n * }\n * ```\n *\n * @since 3.18.0\n * @category algorithms\n */\nexport const astar = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  config: AstarConfig<E, N>\n): Option.Option<PathResult<E>> => {\n  const { cost, heuristic, source, target } = config\n  // Validate that source and target nodes exist\n  if (!graph.nodes.has(source)) {\n    throw missingNode(source)\n  }\n  if (!graph.nodes.has(target)) {\n    throw missingNode(target)\n  }\n\n  // Early return if source equals target\n  if (source === target) {\n    return Option.some({\n      path: [source],\n      distance: 0,\n      costs: []\n    })\n  }\n\n  // Get target node data for heuristic calculations\n  const targetNodeData = graph.nodes.get(target)\n  if (targetNodeData === undefined) {\n    throw new Error(`Target node ${target} data not found`)\n  }\n\n  // Distance tracking (g-score) and f-score (g + h)\n  const gScore = new Map<NodeIndex, number>()\n  const fScore = new Map<NodeIndex, number>()\n  const previous = new Map<NodeIndex, { node: NodeIndex; edgeData: E } | null>()\n  const visited = new Set<NodeIndex>()\n\n  // Initialize scores\n  // Iterate directly over node keys\n  for (const node of graph.nodes.keys()) {\n    gScore.set(node, node === source ? 0 : Infinity)\n    fScore.set(node, Infinity)\n    previous.set(node, null)\n  }\n\n  // Calculate initial f-score for source\n  const sourceNodeData = graph.nodes.get(source)\n  if (sourceNodeData !== undefined) {\n    const h = heuristic(sourceNodeData, targetNodeData)\n    fScore.set(source, h)\n  }\n\n  // Priority queue using f-score (total estimated cost)\n  const openSet: Array<{ node: NodeIndex; fScore: number }> = [\n    { node: source, fScore: fScore.get(source)! }\n  ]\n\n  while (openSet.length > 0) {\n    // Find node with lowest f-score\n    let minIndex = 0\n    for (let i = 1; i < openSet.length; i++) {\n      if (openSet[i].fScore < openSet[minIndex].fScore) {\n        minIndex = i\n      }\n    }\n\n    const current = openSet.splice(minIndex, 1)[0]\n    const currentNode = current.node\n\n    // Skip if already visited\n    if (visited.has(currentNode)) {\n      continue\n    }\n\n    visited.add(currentNode)\n\n    // Early termination if we reached the target\n    if (currentNode === target) {\n      break\n    }\n\n    // Get current g-score\n    const currentGScore = gScore.get(currentNode)!\n\n    // Examine all outgoing edges\n    const adjacencyList = graph.adjacency.get(currentNode)\n    if (adjacencyList !== undefined) {\n      for (const edgeIndex of adjacencyList) {\n        const edge = graph.edges.get(edgeIndex)\n        if (edge !== undefined) {\n          const neighbor = edge.target\n          const weight = cost(edge.data)\n\n          // Validate non-negative weights\n          if (weight < 0) {\n            throw new Error(`A* algorithm requires non-negative edge weights, found ${weight}`)\n          }\n\n          const tentativeGScore = currentGScore + weight\n          const neighborGScore = gScore.get(neighbor)!\n\n          // If this path to neighbor is better than any previous one\n          if (tentativeGScore < neighborGScore) {\n            // Update g-score and previous\n            gScore.set(neighbor, tentativeGScore)\n            previous.set(neighbor, { node: currentNode, edgeData: edge.data })\n\n            // Calculate f-score using heuristic\n            const neighborNodeData = graph.nodes.get(neighbor)\n            if (neighborNodeData !== undefined) {\n              const h = heuristic(neighborNodeData, targetNodeData)\n              const f = tentativeGScore + h\n              fScore.set(neighbor, f)\n\n              // Add to open set if not visited\n              if (!visited.has(neighbor)) {\n                openSet.push({ node: neighbor, fScore: f })\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Check if target is reachable\n  const targetGScore = gScore.get(target)!\n  if (targetGScore === Infinity) {\n    return Option.none() // No path exists\n  }\n\n  // Reconstruct path\n  const path: Array<NodeIndex> = []\n  const costs: Array<E> = []\n  let currentNode: NodeIndex | null = target\n\n  while (currentNode !== null) {\n    path.unshift(currentNode)\n    const prev: { node: NodeIndex; edgeData: E } | null = previous.get(currentNode)!\n    if (prev !== null) {\n      costs.unshift(prev.edgeData)\n      currentNode = prev.node\n    } else {\n      currentNode = null\n    }\n  }\n\n  return Option.some({\n    path,\n    distance: targetGScore,\n    costs\n  })\n}\n\n/**\n * Find the shortest path between two nodes using Bellman-Ford algorithm.\n *\n * Bellman-Ford algorithm can handle negative edge weights and detects negative cycles.\n * It has O(VE) time complexity, slower than Dijkstra's but more versatile.\n * Returns Option.none() if a negative cycle is detected that affects the path.\n *\n * @example\n * ```ts\n * import { Graph, Option } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, -1)  // Negative weight allowed\n *   Graph.addEdge(mutable, b, c, 3)\n *   Graph.addEdge(mutable, a, c, 5)\n * })\n *\n * const result = Graph.bellmanFord(graph, { source: 0, target: 2, cost: (edgeData) => edgeData })\n * if (Option.isSome(result)) {\n *   console.log(result.value.path) // [0, 1, 2] - shortest path A->B->C\n *   console.log(result.value.distance) // 2 - total distance\n * }\n * ```\n *\n * @since 3.18.0\n * @category algorithms\n */\nexport const bellmanFord = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  config: BellmanFordConfig<E>\n): Option.Option<PathResult<E>> => {\n  const { cost, source, target } = config\n  // Validate that source and target nodes exist\n  if (!graph.nodes.has(source)) {\n    throw missingNode(source)\n  }\n  if (!graph.nodes.has(target)) {\n    throw missingNode(target)\n  }\n\n  // Early return if source equals target\n  if (source === target) {\n    return Option.some({\n      path: [source],\n      distance: 0,\n      costs: []\n    })\n  }\n\n  // Initialize distances and predecessors\n  const distances = new Map<NodeIndex, number>()\n  const previous = new Map<NodeIndex, { node: NodeIndex; edgeData: E } | null>()\n  // Iterate directly over node keys\n\n  for (const node of graph.nodes.keys()) {\n    distances.set(node, node === source ? 0 : Infinity)\n    previous.set(node, null)\n  }\n\n  // Collect all edges for relaxation\n  const edges: Array<{ source: NodeIndex; target: NodeIndex; weight: number; edgeData: E }> = []\n  for (const [, edgeData] of graph.edges) {\n    const weight = cost(edgeData.data)\n    edges.push({\n      source: edgeData.source,\n      target: edgeData.target,\n      weight,\n      edgeData: edgeData.data\n    })\n  }\n\n  // Relax edges up to V-1 times\n  const nodeCount = graph.nodes.size\n  for (let i = 0; i < nodeCount - 1; i++) {\n    let hasUpdate = false\n\n    for (const edge of edges) {\n      const sourceDistance = distances.get(edge.source)!\n      const targetDistance = distances.get(edge.target)!\n\n      // Relaxation step\n      if (sourceDistance !== Infinity && sourceDistance + edge.weight < targetDistance) {\n        distances.set(edge.target, sourceDistance + edge.weight)\n        previous.set(edge.target, { node: edge.source, edgeData: edge.edgeData })\n        hasUpdate = true\n      }\n    }\n\n    // Early termination if no updates\n    if (!hasUpdate) {\n      break\n    }\n  }\n\n  // Check for negative cycles\n  for (const edge of edges) {\n    const sourceDistance = distances.get(edge.source)!\n    const targetDistance = distances.get(edge.target)!\n\n    if (sourceDistance !== Infinity && sourceDistance + edge.weight < targetDistance) {\n      // Negative cycle detected - check if it affects the path to target\n      const affectedNodes = new Set<NodeIndex>()\n      const queue = [edge.target]\n\n      while (queue.length > 0) {\n        const node = queue.shift()!\n        if (affectedNodes.has(node)) continue\n        affectedNodes.add(node)\n\n        // Add all nodes reachable from this node\n        const adjacencyList = graph.adjacency.get(node)\n        if (adjacencyList !== undefined) {\n          for (const edgeIndex of adjacencyList) {\n            const edge = graph.edges.get(edgeIndex)\n            if (edge !== undefined) {\n              queue.push(edge.target)\n            }\n          }\n        }\n      }\n\n      // If target is affected by negative cycle, return null\n      if (affectedNodes.has(target)) {\n        return Option.none()\n      }\n    }\n  }\n\n  // Check if target is reachable\n  const targetDistance = distances.get(target)!\n  if (targetDistance === Infinity) {\n    return Option.none() // No path exists\n  }\n\n  // Reconstruct path\n  const path: Array<NodeIndex> = []\n  const costs: Array<E> = []\n  let currentNode: NodeIndex | null = target\n\n  while (currentNode !== null) {\n    path.unshift(currentNode)\n    const prev: { node: NodeIndex; edgeData: E } | null = previous.get(currentNode)!\n    if (prev !== null) {\n      costs.unshift(prev.edgeData)\n      currentNode = prev.node\n    } else {\n      currentNode = null\n    }\n  }\n\n  return Option.some({\n    path,\n    distance: targetDistance,\n    costs\n  })\n}\n\n/**\n * Concrete class for iterables that produce [NodeIndex, NodeData] tuples.\n *\n * This class provides a common abstraction for all iterables that return node data,\n * including traversal iterators (DFS, BFS, etc.) and element iterators (nodes, externals).\n * It uses a mapEntry function pattern for flexible iteration and transformation.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   Graph.addEdge(mutable, a, b, 1)\n * })\n *\n * // Both traversal and element iterators return NodeWalker\n * const dfsNodes: Graph.NodeWalker<string> = Graph.dfs(graph, { start: [0] })\n * const allNodes: Graph.NodeWalker<string> = Graph.nodes(graph)\n *\n * // Common interface for working with node iterables\n * function processNodes<N>(nodeIterable: Graph.NodeWalker<N>): Array<number> {\n *   return Array.from(Graph.indices(nodeIterable))\n * }\n *\n * // Access node data using values() or entries()\n * const nodeData = Array.from(Graph.values(dfsNodes)) // [\"A\", \"B\"]\n * const nodeEntries = Array.from(Graph.entries(allNodes)) // [[0, \"A\"], [1, \"B\"]]\n * ```\n *\n * @since 3.18.0\n * @category models\n */\nexport class Walker<T, N> implements Iterable<[T, N]> {\n  // @ts-ignore\n  readonly [Symbol.iterator]: () => Iterator<[T, N]>\n\n  /**\n   * Visits each element and maps it to a value using the provided function.\n   *\n   * Takes a function that receives the index and data,\n   * and returns an iterable of the mapped values. Skips elements that\n   * no longer exist in the graph.\n   *\n   * @example\n   * ```ts\n   * import { Graph } from \"effect\"\n   *\n   * const graph = Graph.directed<string, number>((mutable) => {\n   *   const a = Graph.addNode(mutable, \"A\")\n   *   const b = Graph.addNode(mutable, \"B\")\n   *   Graph.addEdge(mutable, a, b, 1)\n   * })\n   *\n   * const dfs = Graph.dfs(graph, { start: [0] })\n   *\n   * // Map to just the node data\n   * const values = Array.from(dfs.visit((index, data) => data))\n   * console.log(values) // [\"A\", \"B\"]\n   *\n   * // Map to custom objects\n   * const custom = Array.from(dfs.visit((index, data) => ({ id: index, name: data })))\n   * console.log(custom) // [{ id: 0, name: \"A\" }, { id: 1, name: \"B\" }]\n   * ```\n   *\n   * @since 3.18.0\n   * @category iterators\n   */\n  readonly visit: <U>(f: (index: T, data: N) => U) => Iterable<U>\n\n  constructor(\n    /**\n     * Visits each element and maps it to a value using the provided function.\n     *\n     * Takes a function that receives the index and data,\n     * and returns an iterable of the mapped values. Skips elements that\n     * no longer exist in the graph.\n     *\n     * @example\n     * ```ts\n     * import { Graph } from \"effect\"\n     *\n     * const graph = Graph.directed<string, number>((mutable) => {\n     *   const a = Graph.addNode(mutable, \"A\")\n     *   const b = Graph.addNode(mutable, \"B\")\n     *   Graph.addEdge(mutable, a, b, 1)\n     * })\n     *\n     * const dfs = Graph.dfs(graph, { start: [0] })\n     *\n     * // Map to just the node data\n     * const values = Array.from(dfs.visit((index, data) => data))\n     * console.log(values) // [\"A\", \"B\"]\n     *\n     * // Map to custom objects\n     * const custom = Array.from(dfs.visit((index, data) => ({ id: index, name: data })))\n     * console.log(custom) // [{ id: 0, name: \"A\" }, { id: 1, name: \"B\" }]\n     * ```\n     *\n     * @since 3.18.0\n     * @category iterators\n     */\n    visit: <U>(f: (index: T, data: N) => U) => Iterable<U>\n  ) {\n    this.visit = visit\n    this[Symbol.iterator] = visit((index, data) => [index, data] as [T, N])[Symbol.iterator]\n  }\n}\n\n/**\n * Type alias for node iteration using Walker.\n * NodeWalker is represented as Walker<NodeIndex, N>.\n *\n * @since 3.18.0\n * @category models\n */\nexport type NodeWalker<N> = Walker<NodeIndex, N>\n\n/**\n * Type alias for edge iteration using Walker.\n * EdgeWalker is represented as Walker<EdgeIndex, Edge<E>>.\n *\n * @since 3.18.0\n * @category models\n */\nexport type EdgeWalker<E> = Walker<EdgeIndex, Edge<E>>\n\n/**\n * Returns an iterator over the indices in the walker.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   Graph.addEdge(mutable, a, b, 1)\n * })\n *\n * const dfs = Graph.dfs(graph, { start: [0] })\n * const indices = Array.from(Graph.indices(dfs))\n * console.log(indices) // [0, 1]\n * ```\n *\n * @since 3.18.0\n * @category utilities\n */\nexport const indices = <T, N>(walker: Walker<T, N>): Iterable<T> => walker.visit((index, _) => index)\n\n/**\n * Returns an iterator over the values (data) in the walker.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   Graph.addEdge(mutable, a, b, 1)\n * })\n *\n * const dfs = Graph.dfs(graph, { start: [0] })\n * const values = Array.from(Graph.values(dfs))\n * console.log(values) // [\"A\", \"B\"]\n * ```\n *\n * @since 3.18.0\n * @category utilities\n */\nexport const values = <T, N>(walker: Walker<T, N>): Iterable<N> => walker.visit((_, data) => data)\n\n/**\n * Returns an iterator over [index, data] entries in the walker.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   Graph.addEdge(mutable, a, b, 1)\n * })\n *\n * const dfs = Graph.dfs(graph, { start: [0] })\n * const entries = Array.from(Graph.entries(dfs))\n * console.log(entries) // [[0, \"A\"], [1, \"B\"]]\n * ```\n *\n * @since 3.18.0\n * @category utilities\n */\nexport const entries = <T, N>(walker: Walker<T, N>): Iterable<[T, N]> =>\n  walker.visit((index, data) => [index, data] as [T, N])\n\n/**\n * Configuration for graph search iterators.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface SearchConfig {\n  readonly start?: Array<NodeIndex>\n  readonly direction?: Direction\n}\n\n/**\n * Creates a new DFS iterator with optional configuration.\n *\n * The iterator maintains a stack of nodes to visit and tracks discovered nodes.\n * It provides lazy evaluation of the depth-first search.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 1)\n *   Graph.addEdge(mutable, b, c, 1)\n * })\n *\n * // Start from a specific node\n * const dfs1 = Graph.dfs(graph, { start: [0] })\n * for (const nodeIndex of Graph.indices(dfs1)) {\n *   console.log(nodeIndex) // Traverses in DFS order: 0, 1, 2\n * }\n *\n * // Empty iterator (no starting nodes)\n * const dfs2 = Graph.dfs(graph)\n * // Can be used programmatically\n * ```\n *\n * @since 3.18.0\n * @category iterators\n */\nexport const dfs = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  config: SearchConfig = {}\n): NodeWalker<N> => {\n  const start = config.start ?? []\n  const direction = config.direction ?? \"outgoing\"\n\n  // Validate that all start nodes exist\n  for (const nodeIndex of start) {\n    if (!hasNode(graph, nodeIndex)) {\n      throw missingNode(nodeIndex)\n    }\n  }\n\n  return new Walker((f) => ({\n    [Symbol.iterator]: () => {\n      const stack = [...start]\n      const discovered = new Set<NodeIndex>()\n\n      const nextMapped = () => {\n        while (stack.length > 0) {\n          const current = stack.pop()!\n\n          if (discovered.has(current)) {\n            continue\n          }\n\n          discovered.add(current)\n\n          const nodeDataOption = graph.nodes.get(current)\n          if (nodeDataOption === undefined) {\n            continue\n          }\n\n          const neighbors = neighborsDirected(graph, current, direction)\n          for (let i = neighbors.length - 1; i >= 0; i--) {\n            const neighbor = neighbors[i]\n            if (!discovered.has(neighbor)) {\n              stack.push(neighbor)\n            }\n          }\n\n          return { done: false, value: f(current, nodeDataOption) }\n        }\n\n        return { done: true, value: undefined } as const\n      }\n\n      return { next: nextMapped }\n    }\n  }))\n}\n\n/**\n * Creates a new BFS iterator with optional configuration.\n *\n * The iterator maintains a queue of nodes to visit and tracks discovered nodes.\n * It provides lazy evaluation of the breadth-first search.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 1)\n *   Graph.addEdge(mutable, b, c, 1)\n * })\n *\n * // Start from a specific node\n * const bfs1 = Graph.bfs(graph, { start: [0] })\n * for (const nodeIndex of Graph.indices(bfs1)) {\n *   console.log(nodeIndex) // Traverses in BFS order: 0, 1, 2\n * }\n *\n * // Empty iterator (no starting nodes)\n * const bfs2 = Graph.bfs(graph)\n * // Can be used programmatically\n * ```\n *\n * @since 3.18.0\n * @category iterators\n */\nexport const bfs = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  config: SearchConfig = {}\n): NodeWalker<N> => {\n  const start = config.start ?? []\n  const direction = config.direction ?? \"outgoing\"\n\n  // Validate that all start nodes exist\n  for (const nodeIndex of start) {\n    if (!hasNode(graph, nodeIndex)) {\n      throw missingNode(nodeIndex)\n    }\n  }\n\n  return new Walker((f) => ({\n    [Symbol.iterator]: () => {\n      const queue = [...start]\n      const discovered = new Set<NodeIndex>()\n\n      const nextMapped = () => {\n        while (queue.length > 0) {\n          const current = queue.shift()!\n\n          if (!discovered.has(current)) {\n            discovered.add(current)\n\n            const neighbors = neighborsDirected(graph, current, direction)\n            for (const neighbor of neighbors) {\n              if (!discovered.has(neighbor)) {\n                queue.push(neighbor)\n              }\n            }\n\n            const nodeData = getNode(graph, current)\n            if (Option.isSome(nodeData)) {\n              return { done: false, value: f(current, nodeData.value) }\n            }\n            return nextMapped()\n          }\n        }\n\n        return { done: true, value: undefined } as const\n      }\n\n      return { next: nextMapped }\n    }\n  }))\n}\n\n/**\n * Configuration options for topological sort iterator.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface TopoConfig {\n  readonly initials?: Array<NodeIndex>\n}\n\n/**\n * Creates a new topological sort iterator with optional configuration.\n *\n * The iterator uses Kahn's algorithm to lazily produce nodes in topological order.\n * Throws an error if the graph contains cycles.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 1)\n *   Graph.addEdge(mutable, b, c, 1)\n * })\n *\n * // Standard topological sort\n * const topo1 = Graph.topo(graph)\n * for (const nodeIndex of Graph.indices(topo1)) {\n *   console.log(nodeIndex) // 0, 1, 2 (topological order)\n * }\n *\n * // With initial nodes\n * const topo2 = Graph.topo(graph, { initials: [0] })\n *\n * // Throws error for cyclic graph\n * const cyclicGraph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   Graph.addEdge(mutable, a, b, 1)\n *   Graph.addEdge(mutable, b, a, 2) // Creates cycle\n * })\n *\n * try {\n *   Graph.topo(cyclicGraph) // Throws: \"Cannot perform topological sort on cyclic graph\"\n * } catch (error) {\n *   console.log((error as Error).message)\n * }\n * ```\n *\n * @since 3.18.0\n * @category iterators\n */\nexport const topo = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  config: TopoConfig = {}\n): NodeWalker<N> => {\n  // Check if graph is acyclic first\n  if (!isAcyclic(graph)) {\n    throw new Error(\"Cannot perform topological sort on cyclic graph\")\n  }\n\n  const initials = config.initials ?? []\n\n  // Validate that all initial nodes exist\n  for (const nodeIndex of initials) {\n    if (!hasNode(graph, nodeIndex)) {\n      throw missingNode(nodeIndex)\n    }\n  }\n\n  return new Walker((f) => ({\n    [Symbol.iterator]: () => {\n      const inDegree = new Map<NodeIndex, number>()\n      const remaining = new Set<NodeIndex>()\n      const queue = [...initials]\n\n      // Initialize in-degree counts\n      for (const [nodeIndex] of graph.nodes) {\n        inDegree.set(nodeIndex, 0)\n        remaining.add(nodeIndex)\n      }\n\n      // Calculate in-degrees\n      for (const [, edgeData] of graph.edges) {\n        const currentInDegree = inDegree.get(edgeData.target) || 0\n        inDegree.set(edgeData.target, currentInDegree + 1)\n      }\n\n      // Add nodes with zero in-degree to queue if no initials provided\n      if (initials.length === 0) {\n        for (const [nodeIndex, degree] of inDegree) {\n          if (degree === 0) {\n            queue.push(nodeIndex)\n          }\n        }\n      }\n\n      const nextMapped = () => {\n        while (queue.length > 0) {\n          const current = queue.shift()!\n\n          if (remaining.has(current)) {\n            remaining.delete(current)\n\n            // Process outgoing edges, reducing in-degree of targets\n            const neighbors = neighborsDirected(graph, current, \"outgoing\")\n            for (const neighbor of neighbors) {\n              if (remaining.has(neighbor)) {\n                const currentInDegree = inDegree.get(neighbor) || 0\n                const newInDegree = currentInDegree - 1\n                inDegree.set(neighbor, newInDegree)\n\n                // If in-degree becomes 0, add to queue\n                if (newInDegree === 0) {\n                  queue.push(neighbor)\n                }\n              }\n            }\n\n            const nodeData = getNode(graph, current)\n            if (Option.isSome(nodeData)) {\n              return { done: false, value: f(current, nodeData.value) }\n            }\n            return nextMapped()\n          }\n        }\n\n        return { done: true, value: undefined } as const\n      }\n\n      return { next: nextMapped }\n    }\n  }))\n}\n\n/**\n * Creates a new DFS postorder iterator with optional configuration.\n *\n * The iterator maintains a stack with visit state tracking and emits nodes\n * in postorder (after all descendants have been processed). Essential for\n * dependency resolution and tree destruction algorithms.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const root = Graph.addNode(mutable, \"root\")\n *   const child1 = Graph.addNode(mutable, \"child1\")\n *   const child2 = Graph.addNode(mutable, \"child2\")\n *   Graph.addEdge(mutable, root, child1, 1)\n *   Graph.addEdge(mutable, root, child2, 1)\n * })\n *\n * // Postorder: children before parents\n * const postOrder = Graph.dfsPostOrder(graph, { start: [0] })\n * for (const node of postOrder) {\n *   console.log(node) // 1, 2, 0\n * }\n * ```\n *\n * @since 3.18.0\n * @category iterators\n */\nexport const dfsPostOrder = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  config: SearchConfig = {}\n): NodeWalker<N> => {\n  const start = config.start ?? []\n  const direction = config.direction ?? \"outgoing\"\n\n  // Validate that all start nodes exist\n  for (const nodeIndex of start) {\n    if (!hasNode(graph, nodeIndex)) {\n      throw missingNode(nodeIndex)\n    }\n  }\n\n  return new Walker((f) => ({\n    [Symbol.iterator]: () => {\n      const stack: Array<{ node: NodeIndex; visitedChildren: boolean }> = []\n      const discovered = new Set<NodeIndex>()\n      const finished = new Set<NodeIndex>()\n\n      // Initialize stack with start nodes\n      for (let i = start.length - 1; i >= 0; i--) {\n        stack.push({ node: start[i], visitedChildren: false })\n      }\n\n      const nextMapped = () => {\n        while (stack.length > 0) {\n          const current = stack[stack.length - 1]\n\n          if (!discovered.has(current.node)) {\n            discovered.add(current.node)\n            current.visitedChildren = false\n          }\n\n          if (!current.visitedChildren) {\n            current.visitedChildren = true\n            const neighbors = neighborsDirected(graph, current.node, direction)\n\n            for (let i = neighbors.length - 1; i >= 0; i--) {\n              const neighbor = neighbors[i]\n              if (!discovered.has(neighbor) && !finished.has(neighbor)) {\n                stack.push({ node: neighbor, visitedChildren: false })\n              }\n            }\n          } else {\n            const nodeToEmit = stack.pop()!.node\n\n            if (!finished.has(nodeToEmit)) {\n              finished.add(nodeToEmit)\n\n              const nodeData = getNode(graph, nodeToEmit)\n              if (Option.isSome(nodeData)) {\n                return { done: false, value: f(nodeToEmit, nodeData.value) }\n              }\n              return nextMapped()\n            }\n          }\n        }\n\n        return { done: true, value: undefined } as const\n      }\n\n      return { next: nextMapped }\n    }\n  }))\n}\n\n/**\n * Creates an iterator over all node indices in the graph.\n *\n * The iterator produces node indices in the order they were added to the graph.\n * This provides access to all nodes regardless of connectivity.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 1)\n * })\n *\n * const indices = Array.from(Graph.indices(Graph.nodes(graph)))\n * console.log(indices) // [0, 1, 2]\n * ```\n *\n * @since 3.18.0\n * @category iterators\n */\nexport const nodes = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>\n): NodeWalker<N> =>\n  new Walker((f) => ({\n    [Symbol.iterator]() {\n      const nodeMap = graph.nodes\n      const iterator = nodeMap.entries()\n\n      return {\n        next() {\n          const result = iterator.next()\n          if (result.done) {\n            return { done: true, value: undefined }\n          }\n          const [nodeIndex, nodeData] = result.value\n          return { done: false, value: f(nodeIndex, nodeData) }\n        }\n      }\n    }\n  }))\n\n/**\n * Creates an iterator over all edge indices in the graph.\n *\n * The iterator produces edge indices in the order they were added to the graph.\n * This provides access to all edges regardless of connectivity.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const a = Graph.addNode(mutable, \"A\")\n *   const b = Graph.addNode(mutable, \"B\")\n *   const c = Graph.addNode(mutable, \"C\")\n *   Graph.addEdge(mutable, a, b, 1)\n *   Graph.addEdge(mutable, b, c, 2)\n * })\n *\n * const indices = Array.from(Graph.indices(Graph.edges(graph)))\n * console.log(indices) // [0, 1]\n * ```\n *\n * @since 3.18.0\n * @category iterators\n */\nexport const edges = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>\n): EdgeWalker<E> =>\n  new Walker((f) => ({\n    [Symbol.iterator]() {\n      const edgeMap = graph.edges\n      const iterator = edgeMap.entries()\n\n      return {\n        next() {\n          const result = iterator.next()\n          if (result.done) {\n            return { done: true, value: undefined }\n          }\n          const [edgeIndex, edgeData] = result.value\n          return { done: false, value: f(edgeIndex, edgeData) }\n        }\n      }\n    }\n  }))\n\n/**\n * Configuration for externals iterator.\n *\n * @since 3.18.0\n * @category models\n */\nexport interface ExternalsConfig {\n  readonly direction?: Direction\n}\n\n/**\n * Creates an iterator over external nodes (nodes without edges in specified direction).\n *\n * External nodes are nodes that have no outgoing edges (direction=\"outgoing\") or\n * no incoming edges (direction=\"incoming\"). These are useful for finding\n * sources, sinks, or isolated nodes.\n *\n * @example\n * ```ts\n * import { Graph } from \"effect\"\n *\n * const graph = Graph.directed<string, number>((mutable) => {\n *   const source = Graph.addNode(mutable, \"source\")     // 0 - no incoming\n *   const middle = Graph.addNode(mutable, \"middle\")     // 1 - has both\n *   const sink = Graph.addNode(mutable, \"sink\")         // 2 - no outgoing\n *   const isolated = Graph.addNode(mutable, \"isolated\") // 3 - no edges\n *\n *   Graph.addEdge(mutable, source, middle, 1)\n *   Graph.addEdge(mutable, middle, sink, 2)\n * })\n *\n * // Nodes with no outgoing edges (sinks + isolated)\n * const sinks = Array.from(Graph.indices(Graph.externals(graph, { direction: \"outgoing\" })))\n * console.log(sinks) // [2, 3]\n *\n * // Nodes with no incoming edges (sources + isolated)\n * const sources = Array.from(Graph.indices(Graph.externals(graph, { direction: \"incoming\" })))\n * console.log(sources) // [0, 3]\n * ```\n *\n * @since 3.18.0\n * @category iterators\n */\nexport const externals = <N, E, T extends Kind = \"directed\">(\n  graph: Graph<N, E, T> | MutableGraph<N, E, T>,\n  config: ExternalsConfig = {}\n): NodeWalker<N> => {\n  const direction = config.direction ?? \"outgoing\"\n\n  return new Walker((f) => ({\n    [Symbol.iterator]: () => {\n      const nodeMap = graph.nodes\n      const adjacencyMap = direction === \"incoming\"\n        ? graph.reverseAdjacency\n        : graph.adjacency\n\n      const nodeIterator = nodeMap.entries()\n\n      const nextMapped = () => {\n        let current = nodeIterator.next()\n        while (!current.done) {\n          const [nodeIndex, nodeData] = current.value\n          const adjacencyList = adjacencyMap.get(nodeIndex)\n\n          // Node is external if it has no edges in the specified direction\n          if (adjacencyList === undefined || adjacencyList.length === 0) {\n            return { done: false, value: f(nodeIndex, nodeData) }\n          }\n          current = nodeIterator.next()\n        }\n\n        return { done: true, value: undefined } as const\n      }\n\n      return { next: nextMapped }\n    }\n  }))\n}\n","import { pipe } from \"effect\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const classSelfMismatch = LSP.createDiagnostic({\n  name: \"classSelfMismatch\",\n  code: 20,\n  severity: \"error\",\n  apply: Nano.fn(\"classSelfMismatch.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // Check if this is a class declaration that extends Effect.Service, Context.Tag, or Schema classes\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        // Check if this class extends a class that has a Self type parameter\n        const result = yield* pipe(\n          typeParser.extendsEffectService(node),\n          Nano.orElse(() => typeParser.extendsContextTag(node)),\n          Nano.orElse(() => typeParser.extendsEffectTag(node)),\n          Nano.orElse(() => typeParser.extendsSchemaClass(node)),\n          Nano.orElse(() => typeParser.extendsSchemaTaggedClass(node)),\n          Nano.orElse(() => typeParser.extendsSchemaTaggedError(node)),\n          Nano.orElse(() => typeParser.extendsSchemaTaggedRequest(node)),\n          Nano.orElse(() => Nano.void_)\n        )\n\n        if (result) {\n          // Both methods return { selfTypeNode, className } when they match\n          const { className, selfTypeNode } = result\n\n          // Get the actual name from the self type node\n          let actualName = sourceFile.text.substring(selfTypeNode.pos, selfTypeNode.end)\n          if (ts.isTypeReferenceNode(selfTypeNode)) {\n            if (ts.isIdentifier(selfTypeNode.typeName)) {\n              actualName = ts.idText(selfTypeNode.typeName)\n            } else if (ts.isQualifiedName(selfTypeNode.typeName)) {\n              actualName = ts.idText(selfTypeNode.typeName.right)\n            }\n          }\n\n          // Check if the self type matches the class name\n          const expectedName = ts.idText(className)\n          if (actualName !== expectedName) {\n            report({\n              location: selfTypeNode,\n              messageText: `Self type parameter should be '${expectedName}'`,\n              fixes: [{\n                fixName: \"classSelfMismatch_fix\",\n                description: `Replace '${actualName}' with '${expectedName}'`,\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  // Create a new type reference with the correct class name\n                  const typeArgs = ts.isTypeReferenceNode(selfTypeNode) ? selfTypeNode.typeArguments : undefined\n                  const newTypeReference = ts.factory.createTypeReferenceNode(\n                    ts.factory.createIdentifier(expectedName),\n                    typeArgs\n                  )\n\n                  // Replace the incorrect type reference with the correct one\n                  changeTracker.replaceNode(sourceFile, selfTypeNode, newTypeReference)\n                })\n              }]\n            })\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { pipe } from \"effect\"\nimport type ts from \"typescript\"\nimport * as KeyBuilder from \"../core/KeyBuilder.js\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const deterministicKeys = LSP.createDiagnostic({\n  name: \"deterministicKeys\",\n  code: 25,\n  severity: \"off\",\n  apply: Nano.fn(\"deterministicKeys.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeScriptUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    const parseExtendsCustom = Nano.cachedBy(\n      Nano.fn(\"parseExtendsCustom\")(function*(classDeclaration: ts.ClassDeclaration) {\n        if (!options.extendedKeyDetection) {\n          return yield* TypeParser.typeParserIssue(\"Extended key detection is disabled\", undefined, classDeclaration)\n        }\n        if (!classDeclaration.name) {\n          return yield* TypeParser.typeParserIssue(\"Class has no name\", undefined, classDeclaration)\n        }\n        if (!ts.isIdentifier(classDeclaration.name)) {\n          return yield* TypeParser.typeParserIssue(\"Class name is not an identifier\", undefined, classDeclaration)\n        }\n        const heritageClauses = classDeclaration.heritageClauses\n        if (!heritageClauses) {\n          return yield* TypeParser.typeParserIssue(\"Class has no heritage clauses\", undefined, classDeclaration)\n        }\n\n        const nodeToVisit: Array<ts.Node> = [...classDeclaration.heritageClauses]\n        const appendNodeToVisit = (node: ts.Node) => {\n          nodeToVisit.push(node)\n          return undefined\n        }\n\n        while (nodeToVisit.length > 0) {\n          const node = nodeToVisit.shift()!\n          if (ts.isCallExpression(node)) {\n            for (let i = 0; i < node.arguments.length; i++) {\n              const arg = node.arguments[i]\n              if (!ts.isStringLiteral(arg)) continue\n              const resolvedSignature = typeChecker.getResolvedSignature(node)\n              if (resolvedSignature) {\n                const parameter = resolvedSignature.parameters[i]\n                if (!parameter) continue\n                if (parameter.declarations) {\n                  for (const declaration of parameter.declarations) {\n                    const parameterSourceFile = typeScriptUtils.getSourceFileOfNode(declaration)!\n                    const paramText = parameterSourceFile.text.substring(declaration.pos, declaration.end)\n                    if (paramText.toLowerCase().includes(\"@effect-identifier\")) {\n                      return { className: classDeclaration.name, keyStringLiteral: arg, target: \"custom\" as const }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          ts.forEachChild(node, appendNodeToVisit)\n        }\n\n        return yield* TypeParser.typeParserIssue(\n          \"Class does not extend any custom pattern\",\n          undefined,\n          classDeclaration\n        )\n      }),\n      \"deterministicKeys.parseExtendsCustom\",\n      (classDeclaration) => classDeclaration\n    )\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // Check if this is a class declaration that extends Effect.Service, Context.Tag, or Effect.Tag\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        // Try to parse as one of the supported tag/service types\n        // @effect-diagnostics-next-line unnecessaryPipeChain:off\n        const result = yield* pipe(\n          pipe(\n            typeParser.extendsEffectService(node),\n            Nano.orElse(() => typeParser.extendsContextTag(node)),\n            Nano.orElse(() => typeParser.extendsEffectTag(node)),\n            Nano.map(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: \"service\" as const }))\n          ),\n          Nano.orElse(() =>\n            pipe(\n              typeParser.extendsDataTaggedError(node),\n              Nano.orElse(() => typeParser.extendsSchemaTaggedError(node)),\n              Nano.map(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: \"error\" as const }))\n            )\n          ),\n          Nano.orElse(() => parseExtendsCustom(node)),\n          Nano.orElse(() => Nano.void_)\n        )\n\n        if (result && result.keyStringLiteral) {\n          const { className, keyStringLiteral, target } = result\n\n          // Get the class name text\n          const classNameText = ts.idText(className)\n\n          // build the expected identifier\n          const expectedKey = yield* KeyBuilder.createString(sourceFile, classNameText, target)\n          if (!expectedKey) continue\n\n          // Get the actual identifier from the keyStringLiteral\n          const actualIdentifier = keyStringLiteral.text\n\n          // Report diagnostic if they don't match\n          if (actualIdentifier !== expectedKey) {\n            report({\n              location: keyStringLiteral,\n              messageText: `Key should be '${expectedKey}'`,\n              fixes: [{\n                fixName: \"deterministicKeys_fix\",\n                description: `Replace '${actualIdentifier}' with '${expectedKey}'`,\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  // Create a new string literal with the correct identifier\n                  const newStringLiteral = ts.factory.createStringLiteral(expectedKey)\n\n                  // Replace the incorrect string literal with the correct one\n                  changeTracker.replaceNode(sourceFile, keyStringLiteral, newStringLiteral)\n                })\n              }]\n            })\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { hasProperty, isNumber } from \"effect/Predicate\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\ntype ResolvedPackagesCache = Record<string, Record<string, any>>\n\nconst checkedPackagesCache = new Map<string, ResolvedPackagesCache>()\nconst programResolvedCacheSize = new Map<string, number>()\n\nexport const duplicatePackage = LSP.createDiagnostic({\n  name: \"duplicatePackage\",\n  code: 6,\n  severity: \"warning\",\n  apply: Nano.fn(\"duplicatePackage.apply\")(function*(sourceFile, report) {\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    if (sourceFile.statements.length < 1) return\n\n    // whenever we detect the resolution cache size has changed, try again the check\n    // this should mitigate how frequently this rule is triggered\n    let resolvedPackages: ResolvedPackagesCache = checkedPackagesCache.get(sourceFile.fileName) ||\n      {}\n    const newResolvedModuleSize =\n      hasProperty(program, \"resolvedModules\") && hasProperty(program.resolvedModules, \"size\") &&\n        isNumber(program.resolvedModules.size) ?\n        program.resolvedModules.size :\n        0\n    const oldResolvedSize = programResolvedCacheSize.get(sourceFile.fileName) || -1\n    if (newResolvedModuleSize !== oldResolvedSize) {\n      const seenPackages = new Set<string>()\n      resolvedPackages = {}\n      program.getSourceFiles().map((_) => {\n        const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(_)\n        if (!packageInfo) return\n        const packageNameAndVersion = packageInfo.name + \"@\" + packageInfo.version\n        if (seenPackages.has(packageNameAndVersion)) return\n        seenPackages.add(packageNameAndVersion)\n        if (\n          !(packageInfo.name === \"effect\" || packageInfo.hasEffectInPeerDependencies)\n        ) return\n        if (options.allowedDuplicatedPackages.indexOf(packageInfo.name) > -1) return\n        resolvedPackages[packageInfo.name] = resolvedPackages[packageInfo.name] || {}\n        resolvedPackages[packageInfo.name][packageInfo.version] = packageInfo.packageDirectory\n      })\n      checkedPackagesCache.set(sourceFile.fileName, resolvedPackages)\n      programResolvedCacheSize.set(sourceFile.fileName, newResolvedModuleSize)\n    }\n\n    for (const packageName of Object.keys(resolvedPackages)) {\n      if (Object.keys(resolvedPackages[packageName]).length > 1) {\n        const versions = Object.keys(resolvedPackages[packageName])\n        report({\n          location: sourceFile.statements[0],\n          messageText: `Package ${packageName} is referenced multiple times with different versions (${\n            versions.join(\", \")\n          }) and may cause unexpected type errors.\\nCleanup your dependencies and your package lockfile to avoid multiple instances of this package and reload the project.\\nIf this is intended set the LSP config \"allowedDuplicatedPackages\" to ${\n            JSON.stringify(options.allowedDuplicatedPackages.concat([packageName]))\n          }.\\n\\n${\n            versions.map((version) => `- found ${version} at ${resolvedPackages[packageName][version]}`).join(\"\\n\")\n          }`,\n          fixes: []\n        })\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const effectGenUsesAdapter = LSP.createDiagnostic({\n  name: \"effectGenUsesAdapter\",\n  code: 23,\n  severity: \"warning\",\n  apply: Nano.fn(\"effectGenUsesAdapter.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(\n          typeParser.effectGen(node),\n          Nano.map(({ generatorFunction }) => {\n            // Check if the generator function has parameters and if the first parameter (adapter) is used\n            if (generatorFunction.parameters.length > 0) {\n              const adapter = generatorFunction.parameters[0]\n              // Report diagnostic at the adapter parameter location\n              report({\n                location: adapter,\n                messageText: `The adapter of Effect.gen is not required anymore, it is now just an alias of pipe.`,\n                fixes: []\n              })\n            }\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const effectInVoidSuccess = LSP.createDiagnostic({\n  name: \"effectInVoidSuccess\",\n  code: 14,\n  severity: \"warning\",\n  apply: Nano.fn(\"effectInVoidSuccess.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const checkForEffectInVoid = Nano.fn(\"effectInVoidSuccess.checkForEffectInVoid\")(function*(\n      node: ts.Node,\n      expectedType: ts.Type,\n      valueNode: ts.Node,\n      realType: ts.Type\n    ) {\n      const expectedEffect = yield* typeParser.effectType(expectedType, node)\n      const realEffect = yield* typeParser.effectType(realType, valueNode)\n      if (expectedEffect.A.flags & ts.TypeFlags.Void) {\n        const voidValueTypes = typeCheckerUtils.unrollUnionMembers(realEffect.A)\n        const voidedEffect = yield* Nano.firstSuccessOf(\n          voidValueTypes.map((_) => Nano.map(typeParser.strictEffectType(_, node), () => _))\n        )\n        return { voidedEffect }\n      }\n      return yield* Nano.fail(TypeParser.typeParserIssue(\"expectedEffect success is not void\"))\n    })\n\n    const entries = typeCheckerUtils.expectedAndRealType(sourceFile)\n    for (const [node, expectedType, valueNode, realType] of entries) {\n      if (expectedType !== realType) {\n        yield* pipe(\n          checkForEffectInVoid(\n            node,\n            expectedType,\n            valueNode,\n            realType\n          ),\n          Nano.map(({ voidedEffect }) => {\n            report(\n              {\n                location: node,\n                messageText: `There is a nested '${\n                  typeChecker.typeToString(voidedEffect)\n                }' in the 'void' success channel, beware that this could lead to nested Effect<Effect<...>> that won't be executed.`,\n                fixes: []\n              }\n            )\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const floatingEffect = LSP.createDiagnostic({\n  name: \"floatingEffect\",\n  code: 3,\n  severity: \"error\",\n  apply: Nano.fn(\"floatingEffect.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    function isFloatingExpression(node: ts.Node): node is ts.ExpressionStatement {\n      // should be an expression statement\n      if (!ts.isExpressionStatement(node)) return false\n      // parent is either block or source file\n      if (!(ts.isBlock(node.parent) || ts.isSourceFile(node.parent))) return false\n      const expression = node.expression\n      // this.variable = Effect.succeed is a valid expression\n      if (\n        ts.isBinaryExpression(expression) && expression.operatorToken &&\n        (expression.operatorToken.kind === ts.SyntaxKind.EqualsToken ||\n          expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionEqualsToken ||\n          expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandEqualsToken ||\n          expression.operatorToken.kind === ts.SyntaxKind.BarBarEqualsToken)\n      ) return false\n      return true\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (!isFloatingExpression(node)) continue\n\n      const type = typeChecker.getTypeAtLocation(node.expression)\n      // if type is an effect\n      const effect = yield* Nano.option(typeParser.effectType(type, node.expression))\n      if (Option.isSome(effect)) {\n        // and not a fiber (we consider that a valid operation)\n        const allowedFloatingEffects = yield* pipe(\n          typeParser.fiberType(type, node.expression),\n          Nano.orElse(() => typeParser.effectSubtype(type, node.expression)),\n          Nano.option\n        )\n        if (Option.isNone(allowedFloatingEffects)) {\n          // check if strictly an effect or a subtype to change the error message\n          const isStrictEffect = yield* Nano.option(typeParser.strictEffectType(type, node.expression))\n          const name = Option.isSome(isStrictEffect) ? \"Effect\" : \"Effect-able \" + typeChecker.typeToString(type)\n          report({\n            location: node,\n            messageText: `${name} must be yielded or assigned to a variable.`,\n            fixes: []\n          })\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const genericEffectServices = LSP.createDiagnostic({\n  name: \"genericEffectServices\",\n  code: 10,\n  severity: \"warning\",\n  apply: Nano.fn(\"genericEffectServices.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      const typesToCheck: Array<[ts.Type, ts.Node]> = []\n\n      if (ts.isClassDeclaration(node) && node.name && node.typeParameters && node.heritageClauses) {\n        const classSym = typeChecker.getSymbolAtLocation(node.name)\n        if (classSym) {\n          const type = typeChecker.getTypeOfSymbol(classSym)\n          typesToCheck.push([type, node.name!])\n        }\n      } else {\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      }\n\n      // check the types\n      for (const [type, reportAt] of typesToCheck) {\n        yield* pipe(\n          typeParser.contextTag(type, node),\n          Nano.map(() => {\n            report({\n              location: reportAt,\n              messageText:\n                `Effect Services with type parameters are not supported because they cannot be properly discriminated at runtime, which may cause unexpected behavior.`,\n              fixes: []\n            })\n          }),\n          Nano.orElse(() => Nano.sync(() => ts.forEachChild(node, appendNodeToVisit))),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import * as Array from \"effect/Array\"\nimport type ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const importFromBarrel = LSP.createDiagnostic({\n  name: \"importFromBarrel\",\n  code: 12,\n  severity: \"off\",\n  apply: Nano.fn(\"importFromBarrel.apply\")(function*(sourceFile, report) {\n    // requires namespaceImportPackages to be set\n    const languageServicePluginOptions = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n    if (languageServicePluginOptions.namespaceImportPackages.length === 0) return\n\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n\n    const getModuleSpecifier = TypeScriptApi.makeGetModuleSpecifier(ts)\n    const resolveExternalModuleName = TypeCheckerApi.makeResolveExternalModuleName(typeChecker)\n    const packageNamesToCheck = Array.flatten(\n      languageServicePluginOptions.namespaceImportPackages.map((packageName) =>\n        tsUtils.resolveModulePattern(program, sourceFile, packageName)\n      )\n    )\n\n    const isImportedFromBarrelExport = (\n      element: ts.ImportSpecifier\n    ) => {\n      if (!(getModuleSpecifier && resolveExternalModuleName)) return\n\n      const importDeclaration = ts.findAncestor(element, (node) => ts.isImportDeclaration(node))\n      if (!importDeclaration) return\n      if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) return\n      const importClause = importDeclaration.importClause\n      if (!importClause) return\n      const namedBindings = importClause.namedBindings\n      if (!namedBindings) return\n      if (!ts.isNamedImports(namedBindings)) return\n\n      const barrelModuleName = importDeclaration.moduleSpecifier.text\n      if (packageNamesToCheck.indexOf(barrelModuleName.toLowerCase()) === -1) return\n      const moduleSymbol = resolveExternalModuleName(importDeclaration.moduleSpecifier)\n      if (!moduleSymbol) return\n      if (!moduleSymbol.exports) return\n      const sourceFile = tsUtils.getSourceFileOfNode(importDeclaration)\n      if (!sourceFile) return\n\n      const nodeForSymbol = element.propertyName || element.name\n      const aliasSymbol = element.name || element.propertyName\n      const aliasedName = ts.idText(aliasSymbol)\n\n      // we can only check for identifiers\n      if (!ts.isIdentifier(nodeForSymbol)) return\n      const importedName = ts.idText(nodeForSymbol)\n      if (!importedName) return\n      // get the symbol of the re-export\n      const reexportedSymbol = moduleSymbol.exports.get(ts.escapeLeadingUnderscores(importedName))\n      if (!reexportedSymbol) return\n      // if we have only a declaration\n      if (!(reexportedSymbol.declarations && reexportedSymbol.declarations.length === 1)) return\n      // that should be an 'export * as X from \"module\"'\n      const namespaceExport = reexportedSymbol.declarations[0]\n      if (!ts.isNamespaceExport(namespaceExport)) return\n      // parent should be an export declaration\n      const exportDeclaration = namespaceExport.parent\n      if (!ts.isExportDeclaration(exportDeclaration)) return\n      // if we have a module specifier, resolve that symbol\n      if (!exportDeclaration.moduleSpecifier) return\n      const originalModuleSymbol = resolveExternalModuleName(exportDeclaration.moduleSpecifier)\n      if (!originalModuleSymbol) return\n      // the value declaration should be the sourcefile of the original module\n      if (!originalModuleSymbol.valueDeclaration) return\n      const originalSourceFile = tsUtils.getSourceFileOfNode(originalModuleSymbol.valueDeclaration)\n      if (!originalSourceFile) return\n      const unbarrelledFileName = getModuleSpecifier(\n        program.getCompilerOptions(),\n        sourceFile,\n        sourceFile.fileName,\n        originalSourceFile.fileName,\n        program\n      )\n      // need to start with the barrel module name, otherwise its not the same package\n      if (unbarrelledFileName.toLowerCase().indexOf(barrelModuleName.toLowerCase() + \"/\") === -1) return\n      return {\n        unbarrelledFileName,\n        importedName,\n        barrelModuleName,\n        importClause,\n        namedBindings,\n        importDeclaration,\n        aliasedName\n      }\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      const parent = node.parent\n\n      if (!(ts.isImportSpecifier(node) && ts.isNamedImports(parent))) {\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      }\n\n      const result = isImportedFromBarrelExport(node)\n      if (!result) continue\n      const {\n        aliasedName,\n        barrelModuleName,\n        importClause,\n        importDeclaration,\n        namedBindings,\n        unbarrelledFileName\n      } = result\n      // ok, I think now we can report the error\n      report({\n        location: node,\n        messageText: `Importing from barrel module ${barrelModuleName} is not allowed.`,\n        fixes: [\n          {\n            fixName: \"replaceWithUnbarrelledImport\",\n            description: `Import * as ${aliasedName} from ${unbarrelledFileName}`,\n            apply: Nano.gen(function*() {\n              const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n              const newImport = ts.factory.createImportDeclaration(\n                undefined,\n                ts.factory.createImportClause(\n                  importClause.isTypeOnly || node.isTypeOnly,\n                  undefined,\n                  ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasedName))\n                ),\n                ts.factory.createStringLiteral(unbarrelledFileName)\n              )\n\n              if (namedBindings.elements.length === 1) {\n                changeTracker.replaceNode(\n                  sourceFile,\n                  importDeclaration,\n                  newImport\n                )\n              } else {\n                changeTracker.insertNodeAfter(sourceFile, importDeclaration, newImport)\n                changeTracker.replaceNode(\n                  sourceFile,\n                  namedBindings,\n                  ts.factory.updateNamedImports(\n                    namedBindings,\n                    namedBindings.elements.filter((e) => e !== node)\n                  )\n                )\n              }\n            })\n          }\n        ]\n      })\n    }\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const leakingRequirements = LSP.createDiagnostic({\n  name: \"leakingRequirements\",\n  code: 8,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"leakingRequirements.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const parseLeakedRequirements = Nano.cachedBy(\n      Nano.fn(\"leakingServices.checkServiceLeaking\")(\n        function*(service: ts.Type, atLocation: ts.Node) {\n          const properties = typeChecker.getPropertiesOfType(service)\n          // since this is an heuristic, we require at least 2 props\n          if (properties.length < 1) return []\n          // store the accumulated services\n          const memory = new Map<string, ts.Type>()\n          let sharedRequirementsKeys: Array<string> | undefined = undefined\n          let effectMembers = 0\n          for (const property of properties) {\n            // get the context type of the property, either Effect<...> or () => Effect<...>\n            const servicePropertyType = typeChecker.getTypeOfSymbolAtLocation(property, atLocation)\n            let effectContextType: ts.Type | undefined = undefined\n            yield* pipe(\n              typeParser.effectType(servicePropertyType, atLocation),\n              Nano.map((_) => effectContextType = _.R),\n              Nano.orElse(() => {\n                const servicePropertyCallSignatures = typeChecker.getSignaturesOfType(\n                  servicePropertyType,\n                  ts.SignatureKind.Call\n                )\n                if (servicePropertyCallSignatures.length === 1) {\n                  return pipe(\n                    typeParser.effectType(\n                      typeChecker.getReturnTypeOfSignature(servicePropertyCallSignatures[0]),\n                      atLocation\n                    ),\n                    Nano.map((_) => {\n                      effectContextType = _.R\n                    })\n                  )\n                }\n                return Nano.void_\n              }),\n              Nano.ignore\n            )\n            // once we have the type, check the context for shared requirements\n            if (effectContextType) {\n              effectMembers++\n              const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(\n                memory,\n                effectContextType,\n                (type) => {\n                  // exclude never\n                  if (type.flags & ts.TypeFlags.Never) return Nano.succeed(true)\n                  // exclude scope\n                  return pipe(\n                    typeParser.scopeType(type, atLocation),\n                    Nano.map(() => true),\n                    Nano.orElse(() => Nano.succeed(false))\n                  )\n                }\n              )\n              if (!sharedRequirementsKeys) {\n                sharedRequirementsKeys = allIndexes\n              } else {\n                sharedRequirementsKeys = Array.intersection(sharedRequirementsKeys, allIndexes)\n                if (sharedRequirementsKeys.length === 0) return []\n              }\n            }\n          }\n          // ...and those at least 2 props must be or return effects\n          if (sharedRequirementsKeys && sharedRequirementsKeys.length > 0 && effectMembers >= 2) {\n            return sharedRequirementsKeys.map((key) => memory.get(key)!).filter(\n              (type) => {\n                let symbol = type.symbol\n                if (symbol && symbol.flags & ts.SymbolFlags.Alias) {\n                  symbol = typeChecker.getAliasedSymbol(symbol)!\n                }\n                return !(symbol.declarations || []).some((declaration) => {\n                  const declarationSource = tsUtils.getSourceFileOfNode(declaration)\n                  if (!declarationSource) return false\n                  return (declarationSource.text.substring(declaration.pos, declaration.end).toLowerCase().indexOf(\n                    \"@effect-leakable-service\"\n                  ) > -1)\n                })\n              }\n            )\n          }\n          return []\n        }\n      ),\n      \"leakingServices.checkServiceLeaking\",\n      (_, service) => service\n    )\n\n    function reportLeakingRequirements(node: ts.Node, requirements: Array<ts.Type>) {\n      if (requirements.length === 0) return\n      report({\n        location: node,\n        messageText: `This Service is leaking the ${\n          requirements.map((_) => typeChecker.typeToString(_)).join(\" | \")\n        } requirement.\\nIf these requirements cannot be cached and are expected to be provided per method invocation (e.g. HttpServerRequest), you can either safely disable this diagnostic for this line through quickfixes or mark the service declaration with a JSDoc @effect-leakable-service.\\nMore info at https://effect.website/docs/requirements-management/layers/#avoiding-requirement-leakage`,\n        fixes: []\n      })\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // we need to check the type of the class declaration (if any)\n      const typesToCheck: Array<[type: ts.Type, reportNode: ts.Node]> = []\n      if (\n        ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) &&\n        ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === \"GenericTag\"\n      ) {\n        typesToCheck.push([typeChecker.getTypeAtLocation(node), node])\n      } else if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        const classSym = typeChecker.getSymbolAtLocation(node.name)\n        if (classSym) {\n          const type = typeChecker.getTypeOfSymbol(classSym)\n          typesToCheck.push([type, node.name])\n        }\n      } else {\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      }\n\n      // check the types\n      for (const [type, reportAt] of typesToCheck) {\n        yield* pipe(\n          typeParser.contextTag(type, node),\n          Nano.flatMap(({ Service }) =>\n            pipe(\n              parseLeakedRequirements(Service, node),\n              Nano.map((requirements) =>\n                reportLeakingRequirements(reportAt, Array.sort(requirements, typeCheckerUtils.deterministicTypeOrder))\n              )\n            )\n          ),\n          Nano.orElse(() => Nano.sync(() => ts.forEachChild(node, appendNodeToVisit))),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const missedPipeableOpportunity = LSP.createDiagnostic({\n  name: \"missedPipeableOpportunity\",\n  code: 26,\n  severity: \"off\",\n  apply: Nano.fn(\"missedPipeableOpportunity.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    const nodeToVisit: Array<ts.Node> = [sourceFile]\n    const prependNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.unshift(node)\n      return undefined\n    }\n\n    const callChainNodes = new WeakMap<ts.Node, Array<ts.CallExpression>>()\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      if (ts.isCallExpression(node) && node.arguments.length === 1 && node.parent) {\n        // this node contributes to the chain.\n        const parentChain = callChainNodes.get(node.parent) || []\n        callChainNodes.set(node, parentChain.concat(node))\n      } else if (node.parent && callChainNodes.has(node.parent) && ts.isExpression(node)) {\n        // we broke the chain.\n        const parentChain: Array<ts.Expression> = callChainNodes.get(node.parent) || []\n        const originalParentChain = parentChain.slice()\n        parentChain.push(node)\n        while (parentChain.length > options.pipeableMinArgCount) {\n          const subject = parentChain.pop()!\n          const resultType = typeChecker.getTypeAtLocation(subject)\n          const pipeableType = yield* pipe(typeParser.pipeableType(resultType, subject), Nano.orElse(() => Nano.void_))\n          if (pipeableType) {\n            report({\n              location: parentChain[0],\n              messageText: `Nested function calls can be converted to pipeable style for better readability.`,\n              fixes: [{\n                fixName: \"missedPipeableOpportunity_fix\",\n                description: \"Convert to pipe style\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  // Create the new pipe call: innermostCall.pipe(c, b, a)\n                  changeTracker.replaceNode(\n                    sourceFile,\n                    parentChain[0],\n                    ts.factory.createCallExpression(\n                      ts.factory.createPropertyAccessExpression(\n                        subject,\n                        \"pipe\"\n                      ),\n                      undefined,\n                      pipe(\n                        parentChain,\n                        Array.filter(ts.isCallExpression),\n                        Array.map((call) => call.expression),\n                        Array.reverse\n                      )\n                    )\n                  )\n                })\n              }]\n            })\n            // delete the parent chain nodes that were affected by the fix, so we don't report the same issue again.\n            originalParentChain.forEach((node) => callChainNodes.delete(node))\n            break\n          }\n        }\n      }\n\n      // we always visit the children\n      ts.forEachChild(node, prependNodeToVisit)\n    }\n  })\n})\n","import * as ReadonlyArray from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\n\nexport const missingEffectContext = LSP.createDiagnostic({\n  name: \"missingEffectContext\",\n  code: 1,\n  severity: \"error\",\n  apply: Nano.fn(\"missingEffectContext.apply\")(function*(sourceFile, report) {\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const checkForMissingContextTypes = (\n      node: ts.Node,\n      expectedType: ts.Type,\n      valueNode: ts.Node,\n      realType: ts.Type\n    ) =>\n      pipe(\n        Nano.all(\n          typeParser.effectType(expectedType, node),\n          typeParser.effectType(realType, valueNode)\n        ),\n        Nano.map(([expectedEffect, realEffect]) =>\n          typeCheckerUtils.getMissingTypeEntriesInTargetType(\n            realEffect.R,\n            expectedEffect.R\n          )\n        )\n      )\n\n    const sortTypes = ReadonlyArray.sort(typeCheckerUtils.deterministicTypeOrder)\n\n    const entries = LSP.getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors ||\n      typeCheckerUtils.expectedAndRealType(sourceFile)\n    for (const [node, expectedType, valueNode, realType] of entries) {\n      // if the types are different, check for missing context types\n      if (expectedType !== realType) {\n        yield* pipe(\n          checkForMissingContextTypes(\n            node,\n            expectedType,\n            valueNode,\n            realType\n          ),\n          Nano.map((missingTypes) =>\n            missingTypes.length > 0 ?\n              report(\n                {\n                  location: node,\n                  messageText: `Missing '${\n                    sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(\" | \")\n                  }' in the expected Effect context.`,\n                  fixes: []\n                }\n              )\n              : undefined\n          ),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import * as ReadonlyArray from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Order from \"effect/Order\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const missingEffectError = LSP.createDiagnostic({\n  name: \"missingEffectError\",\n  code: 1,\n  severity: \"error\",\n  apply: Nano.fn(\"missingEffectError.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Effect\"\n    ) || \"Effect\"\n\n    const createDieMessage = (message: string) =>\n      ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          ts.factory.createIdentifier(effectModuleIdentifier),\n          \"dieMessage\"\n        ),\n        undefined,\n        [ts.factory.createStringLiteral(message)]\n      )\n\n    const checkForMissingErrorTypes = (\n      node: ts.Node,\n      expectedType: ts.Type,\n      valueNode: ts.Node,\n      realType: ts.Type\n    ) =>\n      pipe(\n        Nano.all(\n          typeParser.effectType(expectedType, node),\n          typeParser.effectType(realType, valueNode)\n        ),\n        Nano.map(([expectedEffect, realEffect]) =>\n          pipe(\n            typeCheckerUtils.getMissingTypeEntriesInTargetType(\n              realEffect.E,\n              expectedEffect.E\n            ),\n            (missingErrorTypes) => ({ missingErrorTypes, expectedErrorType: expectedEffect.E })\n          )\n        )\n      )\n\n    const sortTypes = ReadonlyArray.sort(typeCheckerUtils.deterministicTypeOrder)\n\n    const entries = LSP.getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors ||\n      typeCheckerUtils.expectedAndRealType(sourceFile)\n    for (const [node, expectedType, valueNode, realType] of entries) {\n      // if the types are different, check for missing error types\n      if (expectedType !== realType) {\n        yield* pipe(\n          checkForMissingErrorTypes(\n            node,\n            expectedType,\n            valueNode,\n            realType\n          ),\n          Nano.map((result) => {\n            if (result.missingErrorTypes.length === 0) return\n            const fixes: Array<LSP.ApplicableDiagnosticDefinitionFix> = []\n\n            if (ts.isExpression(valueNode) && result.expectedErrorType.flags & ts.TypeFlags.Never) {\n              fixes.push({\n                fixName: \"missingEffectError_catchAll\",\n                description: \"Catch all errors with Effect.catchAll\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  changeTracker.insertText(\n                    sourceFile,\n                    ts.getTokenPosOfNode(valueNode, sourceFile),\n                    effectModuleIdentifier + \".catchAll(\"\n                  )\n                  changeTracker.insertText(sourceFile, valueNode.end, \", () => \")\n                  changeTracker.insertNodeAt(\n                    sourceFile,\n                    valueNode.end,\n                    createDieMessage(\"TODO: catchAll not implemented\")\n                  )\n                  changeTracker.insertText(sourceFile, valueNode.end, \")\")\n                })\n              })\n            }\n\n            if (ts.isExpression(valueNode)) {\n              const propertyAssignments = pipe(\n                result.missingErrorTypes,\n                ReadonlyArray.map((_) => typeChecker.getPropertyOfType(_, \"_tag\")),\n                ReadonlyArray.filter((_) => !!_),\n                ReadonlyArray.map((_) => typeChecker.getTypeOfSymbolAtLocation(_, valueNode)),\n                ReadonlyArray.filter((_) => !!(_.flags & ts.TypeFlags.Literal)),\n                ReadonlyArray.map((_) => typeChecker.typeToTypeNode(_, undefined, ts.NodeBuilderFlags.NoTruncation)),\n                ReadonlyArray.filter((_) => !!_ && ts.isLiteralTypeNode(_)),\n                ReadonlyArray.map((_) => _.literal),\n                ReadonlyArray.filter((_) => ts.isLiteralExpression(_)),\n                ReadonlyArray.map((_) => _.text),\n                ReadonlyArray.sort(Order.string),\n                ReadonlyArray.map((_) =>\n                  ts.factory.createPropertyAssignment(\n                    ts.factory.createIdentifier(_),\n                    ts.factory.createArrowFunction(\n                      undefined,\n                      undefined,\n                      [],\n                      undefined,\n                      undefined,\n                      createDieMessage(`TODO: catchTags() not implemented for ${_}`)\n                    )\n                  )\n                )\n              )\n              if (propertyAssignments.length === result.missingErrorTypes.length) {\n                fixes.push({\n                  fixName: \"missingEffectError_tagged\",\n                  description: \"Catch unexpected errors with Effect.catchTag\",\n                  apply: Nano.gen(function*() {\n                    const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                    changeTracker.insertText(\n                      sourceFile,\n                      ts.getTokenPosOfNode(valueNode, sourceFile),\n                      effectModuleIdentifier + \".catchTags(\"\n                    )\n                    changeTracker.insertText(sourceFile, valueNode.end, \", \")\n                    changeTracker.insertNodeAt(\n                      sourceFile,\n                      valueNode.end,\n                      ts.factory.createObjectLiteralExpression(propertyAssignments)\n                    )\n                    changeTracker.insertText(sourceFile, valueNode.end, \")\")\n                  })\n                })\n              }\n            }\n\n            const typeNames = sortTypes(result.missingErrorTypes).map((_) => typeChecker.typeToString(_))\n            report(\n              {\n                location: node,\n                messageText: `Missing '${typeNames.join(\" | \")}' in the expected Effect errors.`,\n                fixes\n              }\n            )\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const missingEffectServiceDependency = LSP.createDiagnostic({\n  name: \"missingEffectServiceDependency\",\n  code: 22,\n  severity: \"off\",\n  apply: Nano.fn(\"missingEffectServiceDependency.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // Check if this is a class declaration that extends Effect.Service\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        const serviceResult = yield* pipe(\n          typeParser.extendsEffectService(node),\n          Nano.orElse(() => Nano.void_)\n        )\n\n        if (serviceResult) {\n          const { className, options } = serviceResult\n\n          // Get the class symbol and its type\n          const classSymbol = typeChecker.getSymbolAtLocation(className)\n          if (classSymbol) {\n            const classType = typeChecker.getTypeOfSymbol(classSymbol)\n\n            // Try to get DefaultWithoutDependencies first, then Default\n            const defaultWithoutDepsProperty = typeChecker.getPropertyOfType(classType, \"DefaultWithoutDependencies\")\n            const defaultProperty = defaultWithoutDepsProperty || typeChecker.getPropertyOfType(classType, \"Default\")\n\n            if (defaultProperty) {\n              const defaultType = typeChecker.getTypeOfSymbolAtLocation(defaultProperty, node)\n\n              // Parse the layer type to get RIN\n              const layerResult = yield* pipe(\n                typeParser.layerType(defaultType, node),\n                Nano.orElse(() => Nano.void_)\n              )\n\n              if (layerResult) {\n                // Use a single memory map for both required and provided services\n                const servicesMemory = new Map<string, ts.Type>()\n                const excludeNever = (type: ts.Type) => Nano.succeed((type.flags & ts.TypeFlags.Never) !== 0)\n\n                // Get all required service indexes\n                const { allIndexes: requiredIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(\n                  servicesMemory,\n                  layerResult.RIn,\n                  excludeNever\n                )\n\n                // Process dependencies (treat undefined/null as empty array)\n                const providedIndexes = new Set<string>()\n\n                const optionsType = typeChecker.getTypeAtLocation(options)\n                const dependenciesProperty = typeChecker.getPropertyOfType(optionsType, \"dependencies\")\n                let types: Array<ts.Type> = []\n\n                if (dependenciesProperty) {\n                  const dependenciesTypes = typeChecker.getTypeOfSymbolAtLocation(dependenciesProperty, options)\n                  const numberIndexType = typeChecker.getIndexTypeOfType(dependenciesTypes, ts.IndexKind.Number)\n                  types = numberIndexType ? typeCheckerUtils.unrollUnionMembers(numberIndexType) : []\n                }\n\n                // Process each dependency to get what services they provide\n                for (const depType of types) {\n                  // Try to parse as layer type\n                  const depLayerResult = yield* pipe(\n                    typeParser.layerType(depType, options),\n                    Nano.orElse(() => Nano.void_)\n                  )\n\n                  if (depLayerResult) {\n                    // Add the ROut of this dependency to the same memory map\n                    const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(\n                      servicesMemory,\n                      depLayerResult.ROut,\n                      excludeNever\n                    )\n                    // Collect all provided indexes\n                    for (const index of allIndexes) {\n                      providedIndexes.add(index)\n                    }\n                  }\n                }\n\n                // Find missing services: required indexes not in provided indexes\n                const missingIndexes = requiredIndexes.filter((index) => !providedIndexes.has(index))\n\n                // Report diagnostic if there are missing dependencies\n                if (missingIndexes.length > 0) {\n                  const missingTypes = missingIndexes.map((index) => servicesMemory.get(index)!)\n                  const missingTypeNames = missingTypes.map((t) => typeChecker.typeToString(t))\n\n                  const message = missingTypeNames.length === 1\n                    ? `Service '${missingTypeNames[0]}' is required but not provided by dependencies`\n                    : `Services ${\n                      missingTypeNames.map((s) => `'${s}'`).join(\", \")\n                    } are required but not provided by dependencies`\n\n                  report({\n                    location: className,\n                    messageText: message,\n                    fixes: []\n                  })\n                }\n              }\n            }\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const missingReturnYieldStar = LSP.createDiagnostic({\n  name: \"missingReturnYieldStar\",\n  code: 7,\n  severity: \"error\",\n  apply: Nano.fn(\"missingReturnYieldStar.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // if we yield* an effect with never in success type, maybe we wanted tu return\n      if (\n        ts.isYieldExpression(node) && node.expression &&\n        node.asteriskToken\n      ) {\n        // are we returning an effect with never as success type?\n        const type = typeChecker.getTypeAtLocation(node.expression)\n        const maybeEffect = yield* Nano.option(typeParser.effectType(type, node.expression))\n\n        if (Option.isSome(maybeEffect) && maybeEffect.value.A.flags & ts.TypeFlags.Never) {\n          // go up until we meet the causing generator\n          const generatorFunctionOrReturnStatement = ts.findAncestor(\n            node,\n            (\n              _\n            ) => (ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) ||\n              ts.isReturnStatement(_) || ts.isThrowStatement(_))\n          )\n\n          // we already have a return statement\n          if (\n            generatorFunctionOrReturnStatement && !ts.isReturnStatement(generatorFunctionOrReturnStatement) &&\n            !ts.isThrowStatement(generatorFunctionOrReturnStatement)\n          ) {\n            // .gen should always be the parent ideally\n            if (generatorFunctionOrReturnStatement && generatorFunctionOrReturnStatement.parent) {\n              const effectGenNode = generatorFunctionOrReturnStatement.parent\n              // continue if we hit effect gen-like\n              const effectGenLike = yield* pipe(\n                typeParser.effectGen(effectGenNode),\n                Nano.orElse(() => typeParser.effectFnUntracedGen(effectGenNode)),\n                Nano.orElse(() => typeParser.effectFnGen(effectGenNode)),\n                Nano.option\n              )\n              if (Option.isSome(effectGenLike)) {\n                // emit diagnostic\n                const fix = node.expression ?\n                  [{\n                    fixName: \"missingReturnYieldStar_fix\",\n                    description: \"Add return statement\",\n                    apply: Nano.gen(function*() {\n                      const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                      changeTracker.replaceNode(\n                        sourceFile,\n                        node,\n                        ts.factory.createReturnStatement(\n                          node\n                        )\n                      )\n                    })\n                  }] :\n                  []\n\n                report({\n                  location: node,\n                  messageText:\n                    `It is recommended to use return yield* for Effects that never succeed to signal a definitive exit point for type narrowing and tooling support.`,\n                  fixes: fix\n                })\n              }\n            }\n          }\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const missingStarInYieldEffectGen = LSP.createDiagnostic({\n  name: \"missingStarInYieldEffectGen\",\n  code: 4,\n  severity: \"error\",\n  apply: Nano.fn(\"missingStarInYieldEffectGen.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const brokenGenerators = new Set<number>()\n    const brokenYields = new Set<ts.YieldExpression>()\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // error if yield is not followed by *\n      if (\n        ts.isYieldExpression(node) && node.expression &&\n        node.asteriskToken === undefined\n      ) {\n        // go up until we meet the causing generator\n        const functionStarNode = ts.findAncestor(\n          node,\n          (_) => (ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_))\n        )\n\n        // .gen should always be the parent ideally\n        if (functionStarNode && functionStarNode.parent) {\n          const effectGenNode = functionStarNode.parent\n          // continue if we hit effect gen-like\n          yield* pipe(\n            typeParser.effectGen(effectGenNode),\n            Nano.orElse(() => typeParser.effectFnUntracedGen(effectGenNode)),\n            Nano.orElse(() => typeParser.effectFnGen(effectGenNode)),\n            Nano.map(({ generatorFunction }) => {\n              if (generatorFunction) {\n                brokenGenerators.add(ts.getTokenPosOfNode(generatorFunction, tsUtils.getSourceFileOfNode(node)!))\n              }\n              brokenYields.add(node)\n            }),\n            Nano.ignore\n          )\n        }\n      }\n    }\n\n    // emit diagnostics\n    brokenGenerators.forEach((pos) =>\n      report({\n        location: ({ pos, end: pos + \"function\".length }),\n        messageText: `Seems like you used yield instead of yield* inside this Effect.gen.`,\n        fixes: []\n      })\n    )\n    brokenYields.forEach((node) => {\n      const fix = node.expression ?\n        [{\n          fixName: \"missingStarInYieldEffectGen_fix\",\n          description: \"Replace yield with yield*\",\n          apply: Nano.gen(function*() {\n            const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n            changeTracker.replaceNode(\n              sourceFile,\n              node,\n              ts.factory.createYieldExpression(\n                ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n                node.expression!\n              )\n            )\n          })\n        }] :\n        []\n\n      report({\n        location: node,\n        messageText: `When yielding Effects inside Effect.gen, you should use yield* instead of yield.`,\n        fixes: fix\n      })\n    })\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const multipleEffectProvide = LSP.createDiagnostic({\n  name: \"multipleEffectProvide\",\n  code: 18,\n  severity: \"warning\",\n  apply: Nano.fn(\"multipleEffectProvide.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Effect\"\n    ) || \"Effect\"\n\n    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Layer\"\n    ) || \"Layer\"\n\n    const parseEffectProvideLayer = (node: ts.Node) => {\n      if (\n        ts.isCallExpression(node) &&\n        node.arguments.length > 0\n      ) {\n        const layer = node.arguments[0]\n        const type = typeChecker.getTypeAtLocation(layer)\n        return pipe(\n          typeParser.isNodeReferenceToEffectModuleApi(\"provide\")(node.expression),\n          Nano.flatMap(() => typeParser.layerType(type, layer)),\n          Nano.map(() => ({ layer, node })),\n          Nano.orElse(() => Nano.void_)\n        )\n      }\n      return Nano.void_\n    }\n\n    const parsePipeCall = (node: ts.Node) =>\n      Nano.gen(function*() {\n        const { args } = yield* typeParser.pipeCall(node)\n        let currentChunk = 0\n        const previousLayers: Array<Array<{ layer: ts.Expression; node: ts.CallExpression }>> = [[]]\n        for (const pipeArg of args) {\n          const parsedProvide = yield* (parseEffectProvideLayer(pipeArg))\n          if (parsedProvide) {\n            previousLayers[currentChunk].push(parsedProvide)\n          } else {\n            currentChunk++\n            previousLayers.push([])\n          }\n        }\n        // report for each chunk\n        for (const chunk of previousLayers) {\n          if (chunk.length < 2) continue\n          report({\n            location: chunk[0].node,\n            messageText:\n              \"Avoid chaining Effect.provide calls, as this can lead to service lifecycle issues. Instead, merge layers and provide them in a single call.\",\n            fixes: [{\n              fixName: \"multipleEffectProvide_fix\",\n              description: \"Combine into a single provide\",\n              apply: Nano.gen(function*() {\n                const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n                changeTracker.deleteRange(sourceFile, {\n                  pos: ts.getTokenPosOfNode(chunk[0].node, sourceFile),\n                  end: chunk[chunk.length - 1].node.end\n                })\n                const newNode = ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    ts.factory.createIdentifier(effectModuleIdentifier),\n                    ts.factory.createIdentifier(\"provide\")\n                  ),\n                  undefined,\n                  [ts.factory.createCallExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      ts.factory.createIdentifier(layerModuleIdentifier),\n                      ts.factory.createIdentifier(\"mergeAll\")\n                    ),\n                    undefined,\n                    chunk.map((c) => c.layer)\n                  )]\n                )\n                changeTracker.insertNodeAt(sourceFile, ts.getTokenPosOfNode(chunk[0].node, sourceFile), newNode)\n              })\n            }]\n          })\n        }\n      })\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(parsePipeCall(node), Nano.ignore)\n      }\n    }\n  })\n})\n","import { pipe } from \"effect\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const nonObjectEffectServiceType = LSP.createDiagnostic({\n  name: \"nonObjectEffectServiceType\",\n  code: 24,\n  severity: \"error\",\n  apply: Nano.fn(\"nonObjectEffectServiceType.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    function isPrimitiveType(type: ts.Type): boolean {\n      return typeCheckerUtils.unrollUnionMembers(type).some((type) =>\n        !!(\n          type.flags & ts.TypeFlags.String ||\n          type.flags & ts.TypeFlags.Number ||\n          type.flags & ts.TypeFlags.Boolean ||\n          type.flags & ts.TypeFlags.StringLiteral ||\n          type.flags & ts.TypeFlags.NumberLiteral ||\n          type.flags & ts.TypeFlags.BooleanLiteral ||\n          type.flags & ts.TypeFlags.Undefined ||\n          type.flags & ts.TypeFlags.Null\n        )\n      )\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        const serviceResult = yield* pipe(\n          typeParser.extendsEffectService(node),\n          Nano.orElse(() => Nano.void_)\n        )\n\n        if (serviceResult && serviceResult.options && ts.isObjectLiteralExpression(serviceResult.options)) {\n          const options = serviceResult.options\n\n          for (const property of options.properties) {\n            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {\n              continue\n            }\n\n            const propertyName = ts.idText(property.name)\n            const propertyValue = property.initializer\n\n            const errorToReport = {\n              location: property.name,\n              messageText:\n                \"Effect.Service requires the service type to be an object {} and not a primitive type. \\nConsider wrapping the value in an object, or manually using Context.Tag or Effect.Tag if you want to use a primitive instead.\",\n              fixes: []\n            }\n\n            if (propertyName === \"succeed\") {\n              const valueType = typeChecker.getTypeAtLocation(propertyValue)\n              if (isPrimitiveType(valueType)) {\n                report(errorToReport)\n              }\n            } else if (propertyName === \"sync\") {\n              const valueType = typeChecker.getTypeAtLocation(propertyValue)\n              const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call)\n\n              for (const signature of signatures) {\n                const returnType = typeChecker.getReturnTypeOfSignature(signature)\n                if (isPrimitiveType(returnType)) {\n                  report(errorToReport)\n                  break\n                }\n              }\n            } else if (propertyName === \"effect\" || propertyName === \"scoped\") {\n              const valueType = typeChecker.getTypeAtLocation(propertyValue)\n\n              const effectResult = yield* pipe(\n                typeParser.effectType(valueType, propertyValue),\n                Nano.orElse(() => Nano.void_)\n              )\n\n              if (effectResult) {\n                if (isPrimitiveType(effectResult.A)) {\n                  report(errorToReport)\n                  continue\n                }\n              } else {\n                const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call)\n                for (const signature of signatures) {\n                  const returnType = typeChecker.getReturnTypeOfSignature(signature)\n\n                  const effectReturnResult = yield* pipe(\n                    typeParser.effectType(returnType, propertyValue),\n                    Nano.orElse(() => Nano.void_)\n                  )\n\n                  if (effectReturnResult && isPrimitiveType(effectReturnResult.A)) {\n                    report(errorToReport)\n                    break\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport { codegens } from \"../codegens.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\n\nexport const outdatedEffectCodegen = LSP.createDiagnostic({\n  name: \"outdatedEffectCodegen\",\n  code: 19,\n  severity: \"warning\",\n  apply: Nano.fn(\"outdatedEffectCodegen.apply\")(function*(sourceFile, _report) {\n    const codegensWithRanges = yield* LSP.getCodegensForSourceFile(codegens, sourceFile)\n    for (const { codegen, hash, range } of codegensWithRanges) {\n      yield* pipe(\n        LSP.getEditsForCodegen([codegen], sourceFile, range),\n        Nano.map((applicable) => {\n          if (applicable.hash !== hash) {\n            _report({\n              location: range,\n              messageText: `Codegen ${codegen.name} result is outdated`,\n              fixes: [\n                {\n                  fixName: \"outdatedEffectCodegen_fix\",\n                  description: `Re-run ${codegen.name}`,\n                  apply: applicable.apply\n                },\n                {\n                  fixName: \"outdatedEffectCodegen_ignore\",\n                  description: `Ignore this ${codegen.name} update`,\n                  apply: applicable.ignore\n                }\n              ]\n            })\n          }\n        }),\n        Nano.orElse((e) =>\n          Nano.sync(() => {\n            _report({\n              location: range,\n              messageText: `Codegen ${codegen.name} is not applicable here: ${e.cause}`,\n              fixes: []\n            })\n          })\n        ),\n        Nano.ignore\n      )\n    }\n  })\n})\n","import { pipe } from \"effect\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const overriddenSchemaConstructor = LSP.createDiagnostic({\n  name: \"overriddenSchemaConstructor\",\n  code: 30,\n  severity: \"error\",\n  apply: Nano.fn(\"overriddenSchemaConstructor.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // Check if this is a class declaration with heritage clauses\n      if (ts.isClassDeclaration(node) && node.heritageClauses) {\n        // Check if any heritage clause extends a Schema type\n        let extendsSchema = false\n\n        for (const heritageClause of node.heritageClauses) {\n          if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\n            for (const type of heritageClause.types) {\n              const typeAtLocation = typeChecker.getTypeAtLocation(type.expression)\n              // Check if this type is a valid Schema type\n              const isSchema = yield* pipe(\n                typeParser.effectSchemaType(typeAtLocation, type.expression),\n                Nano.map(() => true),\n                Nano.orElse(() => Nano.succeed(false))\n              )\n\n              if (isSchema) {\n                extendsSchema = true\n                break\n              }\n            }\n          }\n          if (extendsSchema) break\n        }\n\n        // If the class extends a Schema, check for constructor overrides\n        if (extendsSchema) {\n          const members = node.members\n          for (const member of members) {\n            if (ts.isConstructorDeclaration(member)) {\n              // fix to rewrite as a static 'new' method\n              const fixAsStaticNew = {\n                fixName: \"overriddenSchemaConstructor_static\",\n                description: \"Rewrite using the static 'new' pattern\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  const visitor: ts.Visitor = (node) => {\n                    if (\n                      ts.isExpressionStatement(node) &&\n                      ts.isCallExpression(node.expression) && ts.isToken(node.expression.expression) &&\n                      node.expression.expression.kind === ts.SyntaxKind.SuperKeyword\n                    ) {\n                      const constructThis = ts.factory.createNewExpression(\n                        ts.factory.createIdentifier(\"this\"),\n                        undefined,\n                        node.expression.arguments\n                      )\n                      return ts.factory.createVariableStatement(\n                        undefined,\n                        ts.factory.createVariableDeclarationList(\n                          [ts.factory.createVariableDeclaration(\n                            \"_this\",\n                            undefined,\n                            undefined,\n                            constructThis\n                          )],\n                          ts.NodeFlags.Const\n                        )\n                      )\n                    }\n                    if (ts.isToken(node) && node.kind === ts.SyntaxKind.ThisKeyword) {\n                      return ts.factory.createIdentifier(\"_this\")\n                    }\n                    return ts.visitEachChild(node, visitor, ts.nullTransformationContext)\n                  }\n                  const newBody = visitor(member.body!)! as ts.Block\n                  const bodyWithReturn = ts.factory.updateBlock(\n                    newBody,\n                    newBody.statements.concat([\n                      ts.factory.createReturnStatement(ts.factory.createIdentifier(\"_this\"))\n                    ])\n                  )\n\n                  const newMethod = ts.factory.createMethodDeclaration(\n                    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Public | ts.ModifierFlags.Static),\n                    undefined,\n                    \"new\",\n                    undefined,\n                    member.typeParameters,\n                    member.parameters,\n                    member.type,\n                    bodyWithReturn\n                  )\n\n                  changeTracker.replaceNode(sourceFile, member, newMethod)\n                })\n              }\n\n              // Report diagnostic at the constructor location\n              report({\n                location: member,\n                messageText:\n                  \"Classes extending Schema must not override the constructor; this is because it silently breaks the schema decoding behaviour. If that's needed, we recommend instead to use a static 'new' method that constructs the instance.\",\n                fixes: (member.body ? [fixAsStaticNew] : []).concat([{\n                  fixName: \"overriddenSchemaConstructor_fix\",\n                  description: \"Remove the constructor override\",\n                  apply: Nano.gen(function*() {\n                    const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n                    changeTracker.delete(sourceFile, member)\n                  })\n                }])\n              })\n              break\n            }\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const returnEffectInGen = LSP.createDiagnostic({\n  name: \"returnEffectInGen\",\n  code: 11,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"returnEffectInGen.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // start from the return statement\n      if (\n        ts.isReturnStatement(node) && node.expression\n      ) {\n        // fast exit\n        if (ts.isYieldExpression(node.expression)) continue\n\n        // go up until we meet the causing generator/function\n        const generatorOrRegularFunction = ts.findAncestor(\n          node,\n          (\n            _\n          ) => (ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) ||\n            ts.isArrowFunction(_) || ts.isGetAccessor(_))\n        )\n\n        if (\n          !(generatorOrRegularFunction && \"asteriskToken\" in generatorOrRegularFunction &&\n            generatorOrRegularFunction.asteriskToken)\n        ) continue // fast exit\n\n        // are we returning an effect with never as success type?\n        const type = typeChecker.getTypeAtLocation(node.expression)\n        const maybeEffect = yield* Nano.option(typeParser.strictEffectType(type, node.expression))\n\n        if (Option.isSome(maybeEffect)) {\n          // .gen should always be the parent ideally\n          if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {\n            const effectGenNode = generatorOrRegularFunction.parent\n            // continue if we hit effect gen-like\n            yield* pipe(\n              typeParser.effectGen(effectGenNode),\n              Nano.orElse(() => typeParser.effectFnUntracedGen(effectGenNode)),\n              Nano.orElse(() => typeParser.effectFnGen(effectGenNode)),\n              Nano.map(() => {\n                const fix = node.expression ?\n                  [{\n                    fixName: \"returnEffectInGen_fix\",\n                    description: \"Add yield* statement\",\n                    apply: Nano.gen(function*() {\n                      const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                      changeTracker.replaceNode(\n                        sourceFile,\n                        node.expression!,\n                        ts.factory.createYieldExpression(\n                          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n                          node.expression!\n                        )\n                      )\n                    })\n                  }] :\n                  []\n\n                report({\n                  location: node,\n                  messageText:\n                    `You are returning an Effect-able type inside a generator function, and will result in nested Effect<Effect<...>>.\\nMaybe you wanted to return yield* instead?\\nNested Effect-able types may be intended if you plan to later manually flatten or unwrap this Effect, if so you can safely disable this diagnostic for this line through quickfixes.`,\n                  fixes: fix\n                })\n              }),\n              Nano.ignore\n            )\n          }\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const scopeInLayerEffect = LSP.createDiagnostic({\n  name: \"scopeInLayerEffect\",\n  code: 13,\n  severity: \"warning\",\n  apply: Nano.fn(\"scopeInLayerEffect.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Layer\"\n    ) || \"Layer\"\n\n    function parseLayerEffectApiCall(node: ts.Node): { methodIdentifier: ts.Identifier } | undefined {\n      // should be a call expression of a property access like Layer.effect\n      // we first check thats a call, then ensure that the callee is a property access\n      // and that the property is \"effect\"\n      if (!ts.isCallExpression(node)) return\n      const expression = node.expression\n      if (!ts.isPropertyAccessExpression(expression)) return\n      // we check that the api is called on the Layer module\n      const calledModule = expression.expression\n      if (!(ts.isIdentifier(calledModule) && ts.idText(calledModule) === layerModuleIdentifier)) return\n      const methodIdentifier = expression.name\n      // *.effect, *.effectContext, whatever...\n      if (!(ts.isIdentifier(methodIdentifier) && ts.idText(methodIdentifier).toLowerCase().startsWith(\"effect\"))) return\n      return { methodIdentifier }\n    }\n\n    const reportIfLayerRequireScope = (type: ts.Type, node: ts.Node, methodIdentifier: ts.Identifier | undefined) => {\n      const entries: Array<ts.Type> = typeCheckerUtils.unrollUnionMembers(type)\n      return pipe(\n        Nano.firstSuccessOf(entries.map((type) => typeParser.scopeType(type, node))),\n        Nano.map(() =>\n          report({\n            location: node,\n            messageText:\n              `Seems like you are constructing a layer with a scope in the requirements.\\nConsider using \"scoped\" instead to get rid of the scope in the requirements.`,\n            fixes: methodIdentifier ?\n              [{\n                fixName: \"scopeInLayerEffect_scoped\",\n                description: \"Use scoped for Layer creation\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  changeTracker.replaceNode(\n                    sourceFile,\n                    methodIdentifier,\n                    ts.factory.createIdentifier(\"scoped\")\n                  )\n                })\n              }] :\n              []\n          })\n        ),\n        Nano.ignore\n      )\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      const layerEffectApiCall = parseLayerEffectApiCall(node)\n      if (layerEffectApiCall) {\n        const type = typeChecker.getTypeAtLocation(node)\n        yield* pipe(\n          typeParser.layerType(type, node),\n          Nano.flatMap(({ RIn }) => reportIfLayerRequireScope(RIn, node, layerEffectApiCall.methodIdentifier)),\n          Nano.ignore\n        )\n        continue\n      }\n\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        const classSym = typeChecker.getSymbolAtLocation(node.name)\n        if (classSym) {\n          const classType = typeChecker.getTypeOfSymbol(classSym)\n          const defaultLayer = typeChecker.getPropertyOfType(classType, \"Default\")\n          if (defaultLayer) {\n            const type = typeChecker.getTypeOfSymbolAtLocation(defaultLayer, node)\n            yield* pipe(\n              typeParser.layerType(type, node),\n              Nano.flatMap(({ RIn }) => reportIfLayerRequireScope(RIn, node, undefined)),\n              Nano.ignore\n            )\n            continue\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const strictBooleanExpressions = LSP.createDiagnostic({\n  name: \"strictBooleanExpressions\",\n  code: 17,\n  severity: \"off\",\n  apply: Nano.fn(\"strictBooleanExpressions.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const conditionChecks = new WeakMap<ts.Node, boolean>()\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      const nodes: Array<ts.Node> = []\n      if (ts.isIfStatement(node)) {\n        conditionChecks.set(node, true)\n        nodes.push(node.expression)\n      } else if (ts.isWhileStatement(node)) {\n        conditionChecks.set(node, true)\n        nodes.push(node.expression)\n      } else if (ts.isConditionalExpression(node)) {\n        conditionChecks.set(node, true)\n        nodes.push(node.condition)\n      } else if (ts.isPrefixUnaryExpression(node) && node.operator === ts.SyntaxKind.ExclamationToken) {\n        conditionChecks.set(node, true)\n        nodes.push(node.operand)\n      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {\n        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true)\n        nodes.push(node.left)\n        nodes.push(node.right)\n      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {\n        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true)\n        nodes.push(node.left)\n        nodes.push(node.right)\n      }\n\n      for (const nodeToCheck of nodes) {\n        if (!nodeToCheck) continue\n        if (!conditionChecks.has(nodeToCheck.parent)) continue\n\n        const nodeType = typeChecker.getTypeAtLocation(nodeToCheck)\n        const constrainedType = typeChecker.getBaseConstraintOfType(nodeType)\n        let typesToCheck = [constrainedType || nodeType]\n\n        while (typesToCheck.length > 0) {\n          const type = typesToCheck.pop()!\n\n          // unroll union types\n          if (typeCheckerUtils.isUnion(type)) {\n            typesToCheck = typesToCheck.concat(type.types)\n            continue\n          }\n\n          // skip boolean and never types\n          if (type.flags & ts.TypeFlags.Boolean) continue\n          if (type.flags & ts.TypeFlags.Never) continue\n          if (type.flags & ts.TypeFlags.BooleanLiteral) continue\n\n          // report the error\n          const typeName = typeChecker.typeToString(type)\n          report({\n            location: nodeToCheck,\n            messageText: `Unexpected \\`${typeName}\\` type in condition, expected strictly a boolean instead.`,\n            fixes: []\n          })\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const strictEffectProvide = LSP.createDiagnostic({\n  name: \"strictEffectProvide\",\n  code: 27,\n  severity: \"off\",\n  apply: Nano.fn(\"strictEffectProvide.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const parseEffectProvideWithLayer = (node: ts.Node) =>\n      Nano.gen(function*() {\n        // Check if this is a call expression: Effect.provide(...)\n        if (\n          !ts.isCallExpression(node) ||\n          node.arguments.length === 0\n        ) {\n          return yield* TypeParser.typeParserIssue(\"Not an Effect.provide call\")\n        }\n\n        // Check if the expression is from the Effect module\n        yield* typeParser.isNodeReferenceToEffectModuleApi(\"provide\")(node.expression)\n\n        // Check if any argument is a Layer using firstSuccessOf\n        return yield* Nano.firstSuccessOf(\n          node.arguments.map((arg) => {\n            const argType = typeChecker.getTypeAtLocation(arg)\n            return typeParser.layerType(argType, arg)\n          })\n        )\n      })\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        const layerCheck = yield* pipe(parseEffectProvideWithLayer(node), Nano.option)\n        if (Option.isSome(layerCheck)) {\n          report({\n            location: node,\n            messageText:\n              \"Effect.provide with a Layer should only be used at application entry points. If this is an entry point, you can safely disable this diagnostic. Otherwise, using Effect.provide may break scope lifetimes. Compose all layers at your entry point and provide them at once.\",\n            fixes: []\n          })\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const tryCatchInEffectGen = LSP.createDiagnostic({\n  name: \"tryCatchInEffectGen\",\n  code: 15,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"tryCatchInEffectGen.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // Check if this is a try statement\n      if (ts.isTryStatement(node) && node.catchClause) {\n        // Find the containing generator function\n        // go up until we meet the causing generator/function\n        const generatorOrRegularFunction = ts.findAncestor(\n          node,\n          (\n            _\n          ) => (ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) ||\n            ts.isArrowFunction(_) || ts.isGetAccessor(_) || ts.isFunctionLike(_))\n        )\n\n        if (\n          !(generatorOrRegularFunction && \"asteriskToken\" in generatorOrRegularFunction &&\n            generatorOrRegularFunction.asteriskToken)\n        ) continue // fast exit\n\n        if (!generatorOrRegularFunction) continue\n\n        // Check if we're inside Effect.gen or Effect.fn\n        if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {\n          const effectGenNode = generatorOrRegularFunction.parent\n\n          // Check if this generator is inside Effect.gen/Effect.fn\n          yield* pipe(\n            typeParser.effectGen(effectGenNode),\n            Nano.orElse(() => typeParser.effectFnUntracedGen(effectGenNode)),\n            Nano.orElse(() => typeParser.effectFnGen(effectGenNode)),\n            Nano.map(() => {\n              report({\n                location: node,\n                messageText:\n                  \"Avoid using try/catch inside Effect generators. Use Effect's error handling mechanisms instead (e.g., Effect.try, Effect.tryPromise, Effect.catchAll, Effect.catchTag).\",\n                fixes: []\n              })\n            }),\n            Nano.ignore\n          )\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const unnecessaryEffectGen = LSP.createDiagnostic({\n  name: \"unnecessaryEffectGen\",\n  code: 5,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"unnecessaryEffectGen.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(\n          typeParser.unnecessaryEffectGen(node),\n          Nano.map(({ replacementNode }) =>\n            report({\n              location: node,\n              messageText: `This Effect.gen contains a single return statement.`,\n              fixes: [{\n                fixName: \"unnecessaryEffectGen_fix\",\n                description: \"Remove the Effect.gen, and keep the body\",\n                apply: Nano.gen(function*() {\n                  const textChanges = yield* Nano.service(\n                    TypeScriptApi.ChangeTracker\n                  )\n                  textChanges.replaceNode(sourceFile, node, yield* replacementNode)\n                })\n              }]\n            })\n          ),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const unnecessaryPipe = LSP.createDiagnostic({\n  name: \"unnecessaryPipe\",\n  code: 9,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"unnecessaryPipe.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(\n          typeParser.pipeCall(node),\n          Nano.map(({ args, subject }) => {\n            if (args.length === 0) {\n              report({\n                location: node,\n                messageText: `This pipe call contains no arguments.`,\n                fixes: [{\n                  fixName: \"unnecessaryPipe_fix\",\n                  description: \"Remove the pipe call\",\n                  apply: Nano.gen(function*() {\n                    const textChanges = yield* Nano.service(\n                      TypeScriptApi.ChangeTracker\n                    )\n                    textChanges.replaceNode(sourceFile, node, subject)\n                  })\n                }]\n              })\n            }\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const unnecessaryPipeChain = LSP.createDiagnostic({\n  name: \"unnecessaryPipeChain\",\n  code: 16,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"unnecessaryPipeChain.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(\n          typeParser.pipeCall(node),\n          Nano.flatMap((pipeCall) =>\n            Nano.map(typeParser.pipeCall(pipeCall.subject), (innerCall) => ({ pipeCall, innerCall }))\n          ),\n          Nano.map(({ innerCall, pipeCall }) => {\n            report({\n              location: node,\n              messageText: `Chained pipe calls can be simplified to a single pipe call`,\n              fixes: [{\n                fixName: \"unnecessaryPipeChain_fix\",\n                description: \"Rewrite as single pipe call\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(\n                    TypeScriptApi.ChangeTracker\n                  )\n                  switch (innerCall.kind) {\n                    case \"pipe\": {\n                      changeTracker.replaceNode(\n                        sourceFile,\n                        node,\n                        ts.factory.createCallExpression(\n                          ts.factory.createIdentifier(\"pipe\"),\n                          undefined,\n                          [innerCall.subject, ...innerCall.args, ...pipeCall.args]\n                        )\n                      )\n                      break\n                    }\n                    case \"pipeable\": {\n                      changeTracker.replaceNode(\n                        sourceFile,\n                        node,\n                        ts.factory.createCallExpression(\n                          ts.factory.createPropertyAccessExpression(\n                            innerCall.subject,\n                            \"pipe\"\n                          ),\n                          undefined,\n                          [...innerCall.args, ...pipeCall.args]\n                        )\n                      )\n                      break\n                    }\n                  }\n                })\n              }]\n            })\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as writeTagClassAccessors from \"../refactors/writeTagClassAccessors.js\"\n\nexport const unsupportedServiceAccessors = LSP.createDiagnostic({\n  name: \"unsupportedServiceAccessors\",\n  code: 21,\n  severity: \"warning\",\n  apply: Nano.fn(\"unsupportedServiceAccessors.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // Check if this is a class declaration that might use unsupported service accessors\n      if (ts.isClassDeclaration(node)) {\n        const parseResult = yield* pipe(\n          writeTagClassAccessors.parse(node),\n          Nano.orElse(() => Nano.succeed(null))\n        )\n\n        if (parseResult && parseResult.involvedMembers.length > 0) {\n          // Get existing static members in the class\n          const existingStaticMembers = new Set<string>()\n          node.members?.forEach((member) => {\n            if (\n              ts.isPropertyDeclaration(member) &&\n              member.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.StaticKeyword)\n            ) {\n              if (member.name && ts.isIdentifier(member.name)) {\n                existingStaticMembers.add(ts.idText(member.name))\n              }\n            }\n          })\n\n          // Filter out members that already have static implementations\n          const missingMembers = parseResult.involvedMembers.filter(({ property }) =>\n            !existingStaticMembers.has(ts.symbolName(property))\n          )\n\n          if (missingMembers.length > 0) {\n            const memberNames = missingMembers.map(({ property }) => `'${ts.symbolName(property)}'`).join(\", \")\n\n            report({\n              location: parseResult.className,\n              messageText:\n                `Even if accessors are enabled, accessors for ${memberNames} won't be available because the signature have generic type parameters or multiple call signatures.`,\n              fixes: [{\n                fixName: \"unsupportedServiceAccessors_enableCodegen\",\n                description: \"Enable accessors codegen\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  // Add @effect-codegens comment before the class\n                  const comment = \"// @effect-codegens accessors\\n\"\n                  changeTracker.insertText(sourceFile, ts.getTokenPosOfNode(node, sourceFile), comment)\n                })\n              }]\n            })\n          }\n        }\n      }\n    }\n  })\n})\n","import { catchUnfailableEffect } from \"./diagnostics/catchUnfailableEffect.js\"\nimport { classSelfMismatch } from \"./diagnostics/classSelfMismatch.js\"\nimport { deterministicKeys } from \"./diagnostics/deterministicKeys.js\"\nimport { duplicatePackage } from \"./diagnostics/duplicatePackage.js\"\nimport { effectGenUsesAdapter } from \"./diagnostics/effectGenUsesAdapter.js\"\nimport { effectInVoidSuccess } from \"./diagnostics/effectInVoidSuccess.js\"\nimport { floatingEffect } from \"./diagnostics/floatingEffect.js\"\nimport { genericEffectServices } from \"./diagnostics/genericEffectServices.js\"\nimport { importFromBarrel } from \"./diagnostics/importFromBarrel.js\"\nimport { leakingRequirements } from \"./diagnostics/leakingRequirements.js\"\nimport { missedPipeableOpportunity } from \"./diagnostics/missedPipeableOpportunity.js\"\nimport { missingEffectContext } from \"./diagnostics/missingEffectContext.js\"\nimport { missingEffectError } from \"./diagnostics/missingEffectError.js\"\nimport { missingEffectServiceDependency } from \"./diagnostics/missingEffectServiceDependency.js\"\nimport { missingReturnYieldStar } from \"./diagnostics/missingReturnYieldStar.js\"\nimport { missingStarInYieldEffectGen } from \"./diagnostics/missingStarInYieldEffectGen.js\"\nimport { multipleEffectProvide } from \"./diagnostics/multipleEffectProvide.js\"\nimport { nonObjectEffectServiceType } from \"./diagnostics/nonObjectEffectServiceType.js\"\nimport { outdatedEffectCodegen } from \"./diagnostics/outdatedEffectCodegen.js\"\nimport { overriddenSchemaConstructor } from \"./diagnostics/overriddenSchemaConstructor.js\"\nimport { returnEffectInGen } from \"./diagnostics/returnEffectInGen.js\"\nimport { scopeInLayerEffect } from \"./diagnostics/scopeInLayerEffect.js\"\nimport { strictBooleanExpressions } from \"./diagnostics/strictBooleanExpressions.js\"\nimport { strictEffectProvide } from \"./diagnostics/strictEffectProvide.js\"\nimport { tryCatchInEffectGen } from \"./diagnostics/tryCatchInEffectGen.js\"\nimport { unnecessaryEffectGen } from \"./diagnostics/unnecessaryEffectGen.js\"\nimport { unnecessaryPipe } from \"./diagnostics/unnecessaryPipe.js\"\nimport { unnecessaryPipeChain } from \"./diagnostics/unnecessaryPipeChain.js\"\nimport { unsupportedServiceAccessors } from \"./diagnostics/unsupportedServiceAccessors.js\"\n\nexport const diagnostics = [\n  catchUnfailableEffect,\n  classSelfMismatch,\n  duplicatePackage,\n  effectGenUsesAdapter,\n  missingEffectContext,\n  missingEffectError,\n  missingEffectServiceDependency,\n  floatingEffect,\n  missingStarInYieldEffectGen,\n  unnecessaryEffectGen,\n  missingReturnYieldStar,\n  leakingRequirements,\n  unnecessaryPipe,\n  genericEffectServices,\n  returnEffectInGen,\n  tryCatchInEffectGen,\n  importFromBarrel,\n  scopeInLayerEffect,\n  effectInVoidSuccess,\n  unnecessaryPipeChain,\n  strictBooleanExpressions,\n  multipleEffectProvide,\n  outdatedEffectCodegen,\n  overriddenSchemaConstructor,\n  unsupportedServiceAccessors,\n  nonObjectEffectServiceType,\n  deterministicKeys,\n  missedPipeableOpportunity,\n  strictEffectProvide\n]\n","import * as Array from \"effect/Array\"\nimport * as Order from \"effect/Order\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport { diagnostics } from \"../diagnostics\"\n\nexport const effectDiagnosticsComment = LSP.createCompletion({\n  name: \"effectDiagnosticsComment\",\n  apply: Nano.fn(\"effectDiagnosticsComment\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n    // get the source text\n    const sourceText = sourceFile.text\n\n    // autocomplete the comment to disable the diagnostics\n    const match = (/(\\/\\/|\\/\\*(?:\\*?))\\s*(@)\\s*$/id).exec(sourceText.substring(0, position))\n    if (match && match.indices) {\n      const lastIndex = match.indices[2][0]\n      const replacementSpan: ts.TextSpan = {\n        start: lastIndex,\n        length: Math.max(0, position - lastIndex)\n      }\n\n      const allDiagnostics = Array.sort(Object.values(diagnostics).map((diagnostic) => diagnostic.name), Order.string)\n        .join(\",\")\n      const disableSnippet = \"${1|\" + allDiagnostics + \"|}:${2|off,warning,error,message,suggestion|}$0\"\n\n      return [{\n        name: `@effect-diagnostics`,\n        kind: ts.ScriptElementKind.string,\n        insertText: \"@effect-diagnostics \" + disableSnippet,\n        isSnippet: true,\n        replacementSpan\n      }, {\n        name: `@effect-diagnostics-next-line`,\n        kind: ts.ScriptElementKind.string,\n        insertText: \"@effect-diagnostics-next-line \" + disableSnippet,\n        isSnippet: true,\n        replacementSpan\n      }]\n    }\n\n    return []\n  })\n})\n","import type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\n\nexport const effectJsdocComment = LSP.createCompletion({\n  name: \"effectJsdocComment\",\n  apply: Nano.fn(\"effectJsdocComment\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n    // get the source text\n    const sourceText = sourceFile.text\n\n    // autocomplete the comment to disable the diagnostics\n    const match = (/(\\/\\/|\\/\\*(?:\\*?))\\s*(@)\\s*$/id).exec(sourceText.substring(0, position))\n    if (match && match.indices) {\n      const lastIndex = match.indices[2][0]\n      const replacementSpan: ts.TextSpan = {\n        start: lastIndex,\n        length: Math.max(0, position - lastIndex)\n      }\n\n      return [{\n        name: `@effect-identifier`,\n        kind: ts.ScriptElementKind.string,\n        insertText: \"@effect-identifier\",\n        isSnippet: true,\n        replacementSpan\n      }]\n    }\n\n    return []\n  })\n})\n","import * as KeyBuilder from \"../core/KeyBuilder.js\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const effectSchemaSelfInClasses = LSP.createCompletion({\n  name: \"effectSchemaSelfInClasses\",\n  apply: Nano.fn(\"effectSchemaSelfInClasses\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position)\n    if (!maybeInfos) return []\n    const { accessedObject, className, replacementSpan } = maybeInfos\n\n    // first, given the position, we go back\n    const schemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Schema\"\n    ) || \"Schema\"\n\n    // ensure accessed is an identifier\n    if (schemaIdentifier !== ts.idText(accessedObject)) return []\n    const name = ts.idText(className)\n\n    // create the expected identifier\n    const errorTagKey = (yield* KeyBuilder.createString(sourceFile, name, \"error\")) || name\n\n    return [{\n      name: `Class<${name}>`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${schemaIdentifier}.Class<${name}>(\"${name}\")({${\"${0}\"}}){}`,\n      replacementSpan,\n      isSnippet: true\n    }, {\n      name: `TaggedError<${name}>`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${schemaIdentifier}.TaggedError<${name}>(\"${errorTagKey}\")(\"${errorTagKey}\", {${\"${0}\"}}){}`,\n      replacementSpan,\n      isSnippet: true\n    }, {\n      name: `TaggedClass<${name}>`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${schemaIdentifier}.TaggedClass<${name}>(\"${name}\")(\"${name}\", {${\"${0}\"}}){}`,\n      replacementSpan,\n      isSnippet: true\n    }, {\n      name: `TaggedRequest<${name}>`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${schemaIdentifier}.TaggedRequest<${name}>(\"${name}\")(\"${name}\", {${\"${0}\"}}){}`,\n      replacementSpan,\n      isSnippet: true\n    }] satisfies Array<LSP.CompletionEntryDefinition>\n  })\n})\n","import * as KeyBuilder from \"../core/KeyBuilder.js\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const effectSelfInClasses = LSP.createCompletion({\n  name: \"effectSelfInClasses\",\n  apply: Nano.fn(\"effectSelfInClasses\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position)\n    if (!maybeInfos) return []\n    const { accessedObject, className, replacementSpan } = maybeInfos\n\n    // first, given the position, we go back\n    const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Effect\"\n    ) || \"Effect\"\n\n    // ensure accessed is an identifier\n    if (effectIdentifier !== ts.idText(accessedObject)) return []\n    const name = ts.idText(className)\n\n    // create the expected identifier\n    const tagKey = (yield* KeyBuilder.createString(sourceFile, name, \"service\")) || name\n\n    return [{\n      name: `Service<${name}>`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${effectIdentifier}.Service<${name}>()(\"${tagKey}\", {${\"${0}\"}}){}`,\n      replacementSpan,\n      isSnippet: true\n    }, {\n      name: `Tag(\"${name}\")`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${effectIdentifier}.Tag(\"${tagKey}\")<${name}, {${\"${0}\"}}>(){}`,\n      replacementSpan,\n      isSnippet: true\n    }] satisfies Array<LSP.CompletionEntryDefinition>\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeParser from \"../core/TypeParser\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const fnFunctionStar = LSP.createCompletion({\n  name: \"fnFunctionStar\",\n  apply: Nano.fn(\"fnFunctionStar\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position)\n    if (!maybeInfos) return []\n    const { accessedObject } = maybeInfos\n\n    // we check if it is an effect\n    const isEffectModule = yield* Nano.option(typeParser.importedEffectModule(accessedObject))\n    if (Option.isNone(isEffectModule)) return []\n\n    const span = ts.createTextSpan(\n      accessedObject.end + 1,\n      Math.max(0, position - accessedObject.end - 1)\n    )\n\n    const maybeFnName: Array<LSP.CompletionEntryDefinition> = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, tsUtils.toTextRange(accessedObject.pos)),\n      Array.filter(ts.isVariableDeclaration),\n      Array.map((_) => _.name && ts.isIdentifier(_.name) ? ts.idText(_.name) : \"\"),\n      Array.filter((_) => _.length > 0),\n      Array.head,\n      Option.map((name) => [\n        {\n          name: `fn(\"${name}\")`,\n          kind: ts.ScriptElementKind.constElement,\n          insertText: `fn(\"${name}\")(function*(${\"${1}\"}){${\"${0}\"}})`,\n          replacementSpan: span,\n          isSnippet: true as const\n        }\n      ]),\n      Option.getOrElse(() => [] as Array<LSP.CompletionEntryDefinition>)\n    )\n\n    return maybeFnName.concat([{\n      name: `fn(function*(){})`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `fn(function*(${\"${1}\"}){${\"${0}\"}})`,\n      replacementSpan: span,\n      isSnippet: true\n    }, {\n      name: `fnUntraced(function*(){})`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `fnUntraced(function*(${\"${1}\"}){${\"${0}\"}})`,\n      replacementSpan: span,\n      isSnippet: true\n    }]) satisfies Array<LSP.CompletionEntryDefinition>\n  })\n})\n","import * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const genFunctionStar = LSP.createCompletion({\n  name: \"genFunctionStar\",\n  apply: Nano.fn(\"genFunctionStar\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position)\n    if (!maybeInfos) return []\n    const { accessedObject } = maybeInfos\n\n    const type = typeChecker.getTypeAtLocation(accessedObject)\n    const genMemberSymbol = type.getProperty(\"gen\")\n    if (!genMemberSymbol) return []\n    const genType = typeChecker.getTypeOfSymbolAtLocation(genMemberSymbol, accessedObject)\n    if (typeChecker.getSignaturesOfType(genType, ts.SignatureKind.Call).length === 0) return []\n\n    const span = ts.createTextSpan(\n      accessedObject.end + 1,\n      Math.max(0, position - accessedObject.end - 1)\n    )\n\n    return [{\n      name: `gen(function*(){})`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `gen(function*(){${\"${0}\"}})`,\n      replacementSpan: span,\n      isSnippet: true\n    }] satisfies Array<LSP.CompletionEntryDefinition>\n  })\n})\n","import * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const rpcMakeClasses = LSP.createCompletion({\n  name: \"rpcMakeClasses\",\n  apply: Nano.fn(\"rpcMakeClasses\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position)\n    if (!maybeInfos) return []\n    const { accessedObject, className, replacementSpan } = maybeInfos\n\n    // first, given the position, we go back\n    const rpcIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"@effect/rpc\",\n      \"Rpc\"\n    ) || \"Rpc\"\n\n    // ensure accessed is an identifier\n    if (rpcIdentifier !== ts.idText(accessedObject)) return []\n    const name = ts.idText(className)\n\n    return [{\n      name: `make(\"${name}\")`,\n      kind: ts.ScriptElementKind.constElement,\n      insertText: `${rpcIdentifier}.make(\"${name}\", {${\"${0}\"}}) {}`,\n      replacementSpan,\n      isSnippet: true\n    }] satisfies Array<LSP.CompletionEntryDefinition>\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const schemaBrand = LSP.createCompletion({\n  name: \"schemaBrand\",\n  apply: Nano.fn(\"schemaBrand\")(function*(sourceFile, position) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position)\n    if (!maybeInfos) return []\n    const { accessedObject } = maybeInfos\n\n    if (!ts.isIdentifier(accessedObject)) return []\n\n    const schemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Schema\"\n    ) || \"Schema\"\n\n    if (schemaName !== ts.idText(accessedObject)) return []\n\n    const span = ts.createTextSpan(\n      accessedObject.end + 1,\n      Math.max(0, position - accessedObject.end - 1)\n    )\n\n    return pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, tsUtils.toTextRange(accessedObject.pos)),\n      Array.filter(ts.isVariableDeclaration),\n      Array.map((_) => _.name && ts.isIdentifier(_.name) ? ts.idText(_.name) : \"\"),\n      Array.filter((_) => _.length > 0),\n      Array.head,\n      Option.map((name) => [\n        {\n          name: `brand(\"${name}\")`,\n          kind: ts.ScriptElementKind.constElement,\n          insertText: `brand(\"${name}\")`,\n          replacementSpan: span,\n          isSnippet: true as const\n        }\n      ]),\n      Option.getOrElse(() => [])\n    )\n  })\n})\n","import { contextSelfInClasses } from \"./completions/contextSelfInClasses.js\"\nimport { durationInput } from \"./completions/durationInput.js\"\nimport { effectCodegensComment } from \"./completions/effectCodegensComment.js\"\nimport { effectDataClasses } from \"./completions/effectDataClasses.js\"\nimport { effectDiagnosticsComment } from \"./completions/effectDiagnosticsComment.js\"\nimport { effectJsdocComment } from \"./completions/effectJsdocComment.js\"\nimport { effectSchemaSelfInClasses } from \"./completions/effectSchemaSelfInClasses.js\"\nimport { effectSelfInClasses } from \"./completions/effectSelfInClasses.js\"\nimport { fnFunctionStar } from \"./completions/fnFunctionStar.js\"\nimport { genFunctionStar } from \"./completions/genFunctionStar.js\"\nimport { rpcMakeClasses } from \"./completions/rpcMakeClasses.js\"\nimport { schemaBrand } from \"./completions/schemaBrand.js\"\n\nexport const completions = [\n  effectSchemaSelfInClasses,\n  effectSelfInClasses,\n  contextSelfInClasses,\n  rpcMakeClasses,\n  genFunctionStar,\n  fnFunctionStar,\n  effectDataClasses,\n  effectDiagnosticsComment,\n  effectCodegensComment,\n  effectJsdocComment,\n  durationInput,\n  schemaBrand\n]\n","import * as Array from \"effect/Array\"\nimport * as Predicate from \"effect/Predicate\"\nimport type * as ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"./LanguageServicePluginOptions\"\nimport * as Nano from \"./Nano\"\nimport * as TypeScriptApi from \"./TypeScriptApi\"\nimport * as TypeScriptUtils from \"./TypeScriptUtils\"\n\ninterface ImportKindNamed {\n  _tag: \"NamedImport\"\n  moduleName: string | undefined\n  fileName: string\n  name: string\n  aliasName: string | undefined\n  introducedPrefix: string | undefined\n}\n\ninterface ImportKindNamespace {\n  _tag: \"NamespaceImport\"\n  moduleName: string | undefined\n  fileName: string\n  name: string\n  aliasName: string | undefined\n  introducedPrefix: string | undefined\n}\n\nexport type ImportKind = ImportKindNamed | ImportKindNamespace\n\nexport interface AutoImportProvider {\n  resolve(exportFileName: string, exportName: string): ImportKind | undefined\n  sortText(exportFileName: string, exportName: string): string | undefined\n}\n\nexport interface ParsedImportFromTextChange {\n  moduleName: string\n  exportName: string | undefined\n}\n\nexport const makeAutoImportProvider: (\n  fromSourceFile: ts.SourceFile\n) => Nano.Nano<\n  AutoImportProvider,\n  never,\n  | TypeScriptApi.TypeScriptApi\n  | TypeScriptUtils.TypeScriptUtils\n  | TypeScriptApi.TypeScriptProgram\n  | LanguageServicePluginOptions.LanguageServicePluginOptions\n> = Nano.fn(\"TypeScriptApi\")(function*(\n  fromSourceFile: ts.SourceFile\n) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n  const languageServicePluginOptions = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n  const host = program as any as ts.ProgramHost<ts.BuilderProgram>\n  const getModuleSpecifier = TypeScriptApi.makeGetModuleSpecifier(ts)\n  const resolvePackageNameToPackageJson = TypeScriptApi.makeResolvePackageNameToPackageJson(ts)\n  const getEntrypointsFromPackageJsonInfo = TypeScriptApi.makeGetEntrypointsFromPackageJsonInfo(ts)\n\n  function collectSourceFileReexports(\n    sourceFile: ts.SourceFile\n  ) {\n    const namespaceExports: Array<\n      { exportClause: ts.NamespaceExport; moduleSpecifier: ts.StringLiteral; name: string }\n    > = []\n    const namedExports: Array<\n      { exportClause: ts.NamedExports; moduleSpecifier: ts.StringLiteral; name: string; aliasName: string }\n    > = []\n\n    for (const statement of sourceFile.statements) {\n      if (!ts.isExportDeclaration(statement)) continue\n      if (!statement.exportClause) continue\n      const moduleSpecifier = statement.moduleSpecifier\n      if (!moduleSpecifier) continue\n      if (!ts.isStringLiteral(moduleSpecifier)) continue\n      const exportClause = statement.exportClause\n      if (ts.isNamespaceExport(exportClause)) {\n        if (!exportClause.name) continue\n        if (!ts.isIdentifier(exportClause.name)) continue\n        namespaceExports.push({\n          moduleSpecifier,\n          exportClause,\n          name: ts.idText(exportClause.name)\n        })\n      }\n      if (ts.isNamedExports(exportClause)) {\n        for (const exportSpecifier of exportClause.elements) {\n          const exportName = exportSpecifier.propertyName || exportSpecifier.name\n          if (!ts.isIdentifier(exportName)) continue\n          if (!ts.isIdentifier(exportSpecifier.name)) continue\n          namedExports.push({\n            moduleSpecifier,\n            exportClause,\n            name: ts.idText(exportName),\n            aliasName: ts.idText(exportSpecifier.name)\n          })\n        }\n      }\n    }\n\n    return { namespaceExports, namedExports }\n  }\n\n  function getPackageInfo(\n    fromFileName: string,\n    packageName: string\n  ): { entrypoints: Array<string>; exportedKeys: Array<string> } | undefined {\n    try {\n      // we use undocumented API here\n      if (!resolvePackageNameToPackageJson || !getEntrypointsFromPackageJsonInfo) return\n\n      // then we resolve the package info\n      const packageJsonInfo = resolvePackageNameToPackageJson(\n        packageName,\n        fromFileName,\n        program.getCompilerOptions(),\n        host\n      )\n      if (!packageJsonInfo) return\n      // resolve the list of entrypoints\n      const _entrypoints = getEntrypointsFromPackageJsonInfo(\n        packageJsonInfo,\n        program.getCompilerOptions(),\n        host\n      )\n      // we expect string[] of fileNames\n      if (!_entrypoints) return\n      if (!Array.isArray(_entrypoints)) return\n      if (!Array.every(Predicate.isString)) return\n      const entrypoints = _entrypoints.map((_) => String(_))\n      const info = tsUtils.parsePackageContentNameAndVersionFromScope({ packageJsonScope: packageJsonInfo })\n      if (!info) return { entrypoints, exportedKeys: [] }\n      return { entrypoints, exportedKeys: info.exportsKeys }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (_) {\n      return undefined\n    }\n  }\n\n  const mapFromBarrelToNamespace = new Map<string, Record<string, string>>() // barrelFile => Record<exportName, reexportedFile>\n  const mapFromBarrelToBarrel = new Map<string, Record<string, { fileName: string; exportName: string }>>() // barrelFile => Record<exportName, { fileName: reexportedFile, exportName: exportName }>\n  const mapFromNamespaceToBarrel = new Map<string, { fileName: string; alias: string }>() // namespaceFile => { fileName: barrelFile, alias: exportName }\n  const mapFilenameToModuleAlias = new Map<string, string>() // fileName => moduleAlias\n  const mapFilenameToExportExcludes = new Map<string, Array<string>>() // fileName => Array<exportName>\n  const mapFilenameToModuleName = new Map<string, string>() // fileName => moduleName\n\n  const collectModuleNames = (packageName: string, exportedKey: string) => {\n    const appendPart = exportedKey === \".\" ? \"\" : (exportedKey.startsWith(\"./\") ? exportedKey.slice(1) : exportedKey)\n    const absoluteName = packageName + appendPart\n    const absoluteFileName = ts.resolveModuleName(\n      absoluteName,\n      fromSourceFile.fileName,\n      program.getCompilerOptions(),\n      host\n    )\n    if (!absoluteFileName) return\n    if (!absoluteFileName.resolvedModule) return\n    const realPath = host.realpath\n      ? host.realpath(absoluteFileName.resolvedModule.resolvedFileName)\n      : absoluteFileName.resolvedModule.resolvedFileName\n    if (mapFilenameToModuleName.has(realPath)) return\n    mapFilenameToModuleName.set(realPath, absoluteName)\n  }\n\n  const collectImportCache = Nano.fn(\"TypeScriptApi\")(\n    function*(\n      packagePatterns: Array<string>,\n      kind: \"namespace\" | \"barrel\",\n      topLevelNamedReexports: \"ignore\" | \"follow\"\n    ) {\n      for (const packagePattern of packagePatterns) {\n        const packageNames = tsUtils.resolveModulePattern(program, fromSourceFile, packagePattern)\n        for (const packageName of packageNames) {\n          const packageInfo = getPackageInfo(fromSourceFile.fileName, packageName)\n          if (!packageInfo) continue\n          for (const exportedKey of packageInfo.exportedKeys) {\n            collectModuleNames(packageName, exportedKey)\n          }\n          for (const _fileName of packageInfo.entrypoints) {\n            const realFileName = host.realpath ? host.realpath(_fileName) : _fileName\n            const isPackageRoot = mapFilenameToModuleName.get(realFileName) === packageName\n            const barrelSourceFile = program.getSourceFile(realFileName) ||\n              ts.createSourceFile(realFileName, host.readFile(realFileName) || \"\", fromSourceFile.languageVersion, true)\n            const reExports = collectSourceFileReexports(barrelSourceFile)\n            if (!reExports) continue\n            // heuristic: we want at least one namespace export for the file to be considered a barrel\n            if (reExports.namespaceExports.length === 0) continue\n            for (const namespaceReexport of reExports.namespaceExports) {\n              const reexportedFile = ts.resolveModuleName(\n                namespaceReexport.moduleSpecifier.text,\n                barrelSourceFile.fileName,\n                program.getCompilerOptions(),\n                host\n              )\n              if (!reexportedFile) continue\n              if (!reexportedFile.resolvedModule) continue\n              switch (kind) {\n                case \"namespace\": {\n                  mapFromBarrelToNamespace.set(\n                    barrelSourceFile.fileName,\n                    {\n                      ...(mapFromBarrelToNamespace.get(barrelSourceFile.fileName) || {}),\n                      [namespaceReexport.name]: reexportedFile.resolvedModule.resolvedFileName\n                    }\n                  )\n                  mapFilenameToModuleAlias.set(\n                    reexportedFile.resolvedModule.resolvedFileName,\n                    namespaceReexport.name\n                  )\n                  continue\n                }\n                case \"barrel\": {\n                  mapFromNamespaceToBarrel.set(reexportedFile.resolvedModule.resolvedFileName, {\n                    fileName: barrelSourceFile.fileName,\n                    alias: namespaceReexport.name\n                  })\n                }\n              }\n            }\n            if (isPackageRoot) {\n              for (const namedExport of reExports.namedExports) {\n                if (topLevelNamedReexports === \"ignore\") {\n                  mapFilenameToExportExcludes.set(barrelSourceFile.fileName, [\n                    ...(mapFilenameToExportExcludes.get(barrelSourceFile.fileName) || []),\n                    namedExport.name\n                  ])\n                } else if (topLevelNamedReexports === \"follow\") {\n                  const reexportedFile = ts.resolveModuleName(\n                    namedExport.moduleSpecifier.text,\n                    barrelSourceFile.fileName,\n                    program.getCompilerOptions(),\n                    host\n                  )\n                  if (!reexportedFile) continue\n                  if (!reexportedFile.resolvedModule) continue\n                  mapFromBarrelToBarrel.set(barrelSourceFile.fileName, {\n                    ...(mapFromBarrelToBarrel.get(barrelSourceFile.fileName) || {}),\n                    [namedExport.name]: {\n                      fileName: reexportedFile.resolvedModule.resolvedFileName,\n                      exportName: namedExport.name\n                    }\n                  })\n                  mapFromBarrelToBarrel.set(reexportedFile.resolvedModule.resolvedFileName, {\n                    ...(mapFromBarrelToBarrel.get(reexportedFile.resolvedModule.resolvedFileName) || {}),\n                    [namedExport.name]: {\n                      fileName: reexportedFile.resolvedModule.resolvedFileName,\n                      exportName: namedExport.name\n                    }\n                  })\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  )\n\n  yield* collectImportCache(\n    languageServicePluginOptions.namespaceImportPackages,\n    \"namespace\",\n    languageServicePluginOptions.topLevelNamedReexports\n  )\n  yield* collectImportCache(languageServicePluginOptions.barrelImportPackages, \"barrel\", \"ignore\")\n\n  const resolveModuleName = (fileName: string) => {\n    const fixedModuleName = mapFilenameToModuleName.get(fileName)\n    if (fixedModuleName) return fixedModuleName\n    if (!getModuleSpecifier) return fileName\n    const moduleSpecifier = getModuleSpecifier(\n      program.getCompilerOptions(),\n      fromSourceFile,\n      fromSourceFile.fileName,\n      fileName,\n      host\n    )\n    if (!moduleSpecifier) return fileName\n    return moduleSpecifier\n  }\n\n  const resolveAliasName = (chosenName: string) => {\n    const aliasName = languageServicePluginOptions.importAliases[chosenName]\n    if (aliasName) return aliasName\n    return undefined\n  }\n\n  const resolve = (exportFileName: string, exportName: string): ImportKindNamed | ImportKindNamespace | undefined => {\n    // case 0) excluded\n    const excludedExports = mapFilenameToExportExcludes.get(exportFileName)\n    if (excludedExports && excludedExports.includes(exportName)) return\n    // case 1) need to rewrite the import as a barrel import from another module\n    const mapToBarrelRewritten = mapFromBarrelToBarrel.get(exportFileName)\n    if (mapToBarrelRewritten && exportName in mapToBarrelRewritten) {\n      const reexportedFile = mapToBarrelRewritten[exportName]\n      if (reexportedFile) {\n        return ({\n          _tag: \"NamedImport\",\n          fileName: reexportedFile.fileName,\n          moduleName: resolveModuleName(reexportedFile.fileName),\n          name: exportName,\n          aliasName: resolveAliasName(exportName),\n          introducedPrefix: undefined\n        })\n      }\n    }\n    // case 2) namespace import { Effect } from \"effect\" we need to change both file and introduce alias name\n    const mapToNamespace = mapFromBarrelToNamespace.get(exportFileName)\n    if (mapToNamespace && exportName in mapToNamespace) {\n      const namespacedFileName = mapToNamespace[exportName]!\n      if (namespacedFileName) {\n        const introducedAlias = mapFilenameToModuleAlias.get(namespacedFileName)\n        if (introducedAlias) {\n          return ({\n            _tag: \"NamespaceImport\",\n            fileName: namespacedFileName,\n            moduleName: resolveModuleName(namespacedFileName),\n            name: introducedAlias,\n            aliasName: resolveAliasName(introducedAlias),\n            introducedPrefix: undefined\n          })\n        }\n      }\n    }\n    // case 3) namespace import { intoDeferred } from \"effect/Effect\" filename is already ok, need to add \"Effect.\"\n    const introducedAlias = mapFilenameToModuleAlias.get(exportFileName)\n    if (introducedAlias) {\n      return ({\n        _tag: \"NamespaceImport\",\n        fileName: exportFileName,\n        moduleName: resolveModuleName(exportFileName),\n        name: introducedAlias,\n        aliasName: resolveAliasName(introducedAlias),\n        introducedPrefix: resolveAliasName(introducedAlias) || introducedAlias\n      })\n    }\n    // case 4) barrel import { succeed } from \"effect/Effect\"\n    const mapToBarrel = mapFromNamespaceToBarrel.get(exportFileName)\n    if (mapToBarrel) {\n      return ({\n        _tag: \"NamedImport\",\n        fileName: mapToBarrel.fileName,\n        moduleName: resolveModuleName(mapToBarrel.fileName),\n        name: mapToBarrel.alias,\n        aliasName: resolveAliasName(mapToBarrel.alias),\n        introducedPrefix: resolveAliasName(mapToBarrel.alias) || mapToBarrel.alias\n      })\n    }\n  }\n\n  const sortText = (exportFileName: string, exportName: string) => {\n    // case 0) excluded\n    const excludedExports = mapFilenameToExportExcludes.get(exportFileName)\n    if (excludedExports && excludedExports.includes(exportName)) return\n    // case 1) namespace import { Effect } from \"effect\" we need to move it to the bottom\n    const mapToNamespace = mapFromBarrelToNamespace.get(exportFileName)\n    if (mapToNamespace && exportName in mapToNamespace) return \"99\"\n  }\n\n  return { resolve, sortText }\n})\n\nconst importProvidersCache = new Map<string, AutoImportProvider>()\n\nexport const getOrMakeAutoImportProvider = Nano.fn(\"getOrMakeAutoImportProvider\")(function*(\n  sourceFile: ts.SourceFile\n) {\n  // NOTE: evict the oldest entry when the cache is full to avoid unbounded memory growth\n  while (importProvidersCache.size > 5) {\n    const oldest = importProvidersCache.keys().next().value\n    if (oldest) importProvidersCache.delete(oldest)\n  }\n  const autoImportProvider = importProvidersCache.get(sourceFile.fileName) ||\n    (yield* makeAutoImportProvider(sourceFile))\n  importProvidersCache.set(sourceFile.fileName, autoImportProvider)\n  return autoImportProvider\n})\n\nexport const parseImportOnlyChanges = Nano.fn(\"parseImportOnlyChanges\")(function*(\n  sourceFile: ts.SourceFile,\n  changes: ReadonlyArray<ts.TextChange>\n) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const deletions: Array<ts.TextChange> = []\n  const imports: Array<ParsedImportFromTextChange> = []\n\n  for (const change of changes) {\n    // deletions are fine\n    if (change.newText.length === 0) {\n      deletions.push(change)\n      continue\n    }\n    // is this an import? We try to parse it\n    if (change.newText.trim().startsWith(\"import\") && change.newText.trim().includes(\"from\")) {\n      try {\n        const parsedImport = ts.createSourceFile(\"test.ts\", change.newText, sourceFile.languageVersion, false)\n        for (const statement of parsedImport.statements) {\n          if (!ts.isImportDeclaration(statement)) return\n          const moduleSpecifier = statement.moduleSpecifier\n          if (!ts.isStringLiteral(moduleSpecifier)) return\n          const moduleName = moduleSpecifier.text\n          const importClause = statement.importClause\n          if (!importClause) return\n          const namedBindings = importClause.namedBindings\n          if (!namedBindings) return\n          if (ts.isNamedImports(namedBindings)) {\n            for (const importSpecifier of namedBindings.elements) {\n              if (!ts.isIdentifier(importSpecifier.name)) return\n              const exportName = ts.idText(importSpecifier.name)\n              imports.push({ moduleName, exportName })\n              continue\n            }\n          } else if (ts.isNamespaceImport(namedBindings)) {\n            imports.push({ moduleName, exportName: undefined })\n            continue\n          }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (_) {\n        return\n      }\n    } else {\n      // this may be an addition to an existing import\n      const ancestorNodes = tsUtils.getAncestorNodesInRange(sourceFile, {\n        pos: change.span.start,\n        end: change.span.start\n      })\n      const importNodes = ancestorNodes.filter((node) => ts.isImportDeclaration(node))\n      const importNode = importNodes[0]\n      if (!importNode) return\n      const moduleSpecifier = importNode.moduleSpecifier\n      if (!ts.isStringLiteral(moduleSpecifier)) return\n      const moduleName = moduleSpecifier.text\n      const exportName = change.newText.replace(/,/ig, \"\").trim()\n      if (exportName.length === 0) return\n      imports.push({ moduleName, exportName })\n    }\n  }\n\n  return { deletions, imports }\n})\n\nexport const addImport = (\n  ts: TypeScriptApi.TypeScriptApi,\n  sourceFile: ts.SourceFile,\n  changeTracker: ts.textChanges.ChangeTracker,\n  preferences: ts.UserPreferences | undefined,\n  effectAutoImport: ImportKind\n) => {\n  let description = \"\"\n\n  // add the import based on the style\n  switch (effectAutoImport._tag) {\n    case \"NamespaceImport\": {\n      const aliasName = effectAutoImport.aliasName || effectAutoImport.name\n      const importModule = effectAutoImport.moduleName || effectAutoImport.fileName\n      description = `Import * as ${aliasName} from \"${importModule}\"`\n      ts.insertImports(\n        changeTracker,\n        sourceFile,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(\n            false,\n            undefined,\n            ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasName))\n          ),\n          ts.factory.createStringLiteral(importModule)\n        ),\n        true,\n        preferences || {}\n      )\n      break\n    }\n    case \"NamedImport\": {\n      const importModule = effectAutoImport.moduleName || effectAutoImport.fileName\n      if (effectAutoImport.aliasName) {\n        description = `Import { ${effectAutoImport.name} as ${effectAutoImport.aliasName} } from \"${importModule}\"`\n      } else {\n        description = `Import { ${effectAutoImport.name} } from \"${importModule}\"`\n      }\n      // loop through the import declarations of the source file\n      // and see if we can find the import declaration that is importing the barrel file\n      let foundImportDeclaration = false\n      for (const statement of sourceFile.statements) {\n        if (ts.isImportDeclaration(statement)) {\n          const moduleSpecifier = statement.moduleSpecifier\n          if (\n            moduleSpecifier && ts.isStringLiteral(moduleSpecifier) && moduleSpecifier.text === importModule\n          ) {\n            // we have found the import declaration that is importing the barrel file\n            const importClause = statement.importClause\n            if (importClause && importClause.namedBindings && ts.isNamedImports(importClause.namedBindings)) {\n              const namedImports = importClause.namedBindings\n              const existingImportSpecifier = namedImports.elements.find((element) => {\n                if (effectAutoImport.aliasName) {\n                  return ts.idText(element.name) === effectAutoImport.name && element.propertyName &&\n                    ts.isIdentifier(element.propertyName) &&\n                    ts.idText(element.propertyName) === effectAutoImport.aliasName\n                }\n                return ts.idText(element.name) === effectAutoImport.name\n              })\n              // the import already exists, we can exit\n              if (existingImportSpecifier) {\n                foundImportDeclaration = true\n                break\n              }\n              // we have found the import declaration that is importing the barrel file\n              changeTracker.replaceNode(\n                sourceFile,\n                namedImports,\n                ts.factory.createNamedImports(\n                  namedImports.elements.concat([\n                    ts.factory.createImportSpecifier(\n                      false,\n                      effectAutoImport.aliasName ? ts.factory.createIdentifier(effectAutoImport.name) : undefined,\n                      ts.factory.createIdentifier(effectAutoImport.aliasName || effectAutoImport.name)\n                    )\n                  ])\n                )\n              )\n              foundImportDeclaration = true\n              break\n            }\n          }\n        }\n      }\n      if (!foundImportDeclaration) {\n        ts.insertImports(\n          changeTracker,\n          sourceFile,\n          ts.factory.createImportDeclaration(\n            undefined,\n            ts.factory.createImportClause(\n              false,\n              undefined,\n              ts.factory.createNamedImports(\n                [\n                  ts.factory.createImportSpecifier(\n                    false,\n                    effectAutoImport.aliasName ? ts.factory.createIdentifier(effectAutoImport.name) : undefined,\n                    ts.factory.createIdentifier(effectAutoImport.aliasName || effectAutoImport.name)\n                  )\n                ]\n              )\n            ),\n            ts.factory.createStringLiteral(importModule)\n          ),\n          true,\n          preferences || {}\n        )\n      }\n      break\n    }\n  }\n\n  return { description }\n}\n","import type ts from \"typescript\"\nimport * as AutoImport from \"../core/AutoImport\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\n\nexport const appendEffectCompletionEntryData = Nano.fn(\"appendEffectCompletionEntryData\")(\n  function*(_sourceFile: ts.SourceFile, applicableCompletions: ts.WithMetadata<ts.CompletionInfo> | undefined) {\n    // exit if not enabled\n    const languageServicePluginOptions = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n    if (\n      languageServicePluginOptions.namespaceImportPackages.length === 0 &&\n      languageServicePluginOptions.barrelImportPackages.length === 0\n    ) return applicableCompletions\n\n    // we basically just add the effectReplaceSpan to the data that will be used in the postprocessCompletionEntryDetails\n    if (applicableCompletions) {\n      return {\n        ...applicableCompletions,\n        entries: applicableCompletions.entries.map((entry) =>\n          entry.data ?\n            ({\n              ...entry,\n              data: {\n                ...entry.data,\n                effectReplaceSpan: entry.replacementSpan || applicableCompletions.optionalReplacementSpan\n              }\n            }) :\n            entry\n        )\n      }\n    }\n\n    return applicableCompletions\n  }\n)\n\nconst isAutoImportOnlyCodeActions = Nano.fn(\"isAutoImportOnlyCodeActions\")(\n  function*(sourceFile: ts.SourceFile, codeActions: Array<ts.CodeAction> | undefined, exportName: string) {\n    // we should have existing code actions\n    if (!codeActions) return\n    // we expect a single entry, either add the entire import, or a single name\n    if (codeActions.length !== 1) return\n    const action = codeActions[0]\n    const changes = action.changes\n    if (changes.length !== 1) return\n    const fileTextChanges = action.changes[0]\n    if (fileTextChanges.fileName !== sourceFile.fileName) return\n    const textChanges = fileTextChanges.textChanges\n    const parsedImportChanges = yield* AutoImport.parseImportOnlyChanges(sourceFile, textChanges)\n    if (!parsedImportChanges) return\n    if (parsedImportChanges.deletions.length !== 0) return\n    if (parsedImportChanges.imports.length !== 1) return\n    if (parsedImportChanges.imports[0].exportName !== exportName) return\n    return parsedImportChanges.imports[0]\n  }\n)\n\nconst addImportCodeAction = Nano.fn(\"getImportFromNamespaceCodeActions\")(function*(\n  formatOptions: ts.FormatCodeSettings | ts.FormatCodeOptions | undefined,\n  preferences: ts.UserPreferences | undefined,\n  languageServiceHost: ts.LanguageServiceHost,\n  sourceFile: ts.SourceFile,\n  effectReplaceSpan: ts.TextSpan,\n  effectAutoImport: AutoImport.ImportKind\n) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  let description = \"auto-import\"\n\n  // ok we have proven that the code actions are auto-import actions.\n  const formatContext = ts.formatting.getFormatContext(\n    formatOptions || {},\n    languageServiceHost\n  )\n\n  const changes = ts.textChanges.ChangeTracker.with(\n    {\n      formatContext,\n      host: languageServiceHost,\n      preferences: preferences || {}\n    },\n    (changeTracker) => {\n      // add the introduced prefix if necessary\n      if (effectAutoImport.introducedPrefix) {\n        changeTracker.insertText(\n          sourceFile,\n          effectReplaceSpan.start,\n          effectAutoImport.introducedPrefix + \".\"\n        )\n      }\n\n      // add the import statement\n      description = AutoImport.addImport(\n        ts,\n        sourceFile,\n        changeTracker,\n        preferences,\n        effectAutoImport\n      ).description\n    }\n  )\n\n  return [\n    {\n      description,\n      changes\n    }\n  ] satisfies Array<ts.CodeAction>\n})\n\nexport const postprocessCompletionEntryDetails = Nano.fn(\"postprocessCompletionEntryDetails\")(\n  function*(\n    sourceFile: ts.SourceFile,\n    data: undefined | ts.CompletionEntryData,\n    applicableCompletionEntryDetails: ts.CompletionEntryDetails | undefined,\n    formatOptions: ts.FormatCodeSettings | ts.FormatCodeOptions | undefined,\n    preferences: ts.UserPreferences | undefined,\n    languageServiceHost: ts.LanguageServiceHost\n  ) {\n    // exit if not enabled\n    const languageServicePluginOptions = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n    if (\n      languageServicePluginOptions.namespaceImportPackages.length === 0 &&\n      languageServicePluginOptions.barrelImportPackages.length === 0\n    ) return applicableCompletionEntryDetails\n\n    // if we have no applicable completion entry details, we return early\n    if (!applicableCompletionEntryDetails) return applicableCompletionEntryDetails\n    // if we have no data, we return early\n    if (!data) return applicableCompletionEntryDetails\n    // we need fileName and exportName and moduleSpecifier\n    const { exportName, fileName, moduleSpecifier } = data\n    if (!fileName) return applicableCompletionEntryDetails\n    if (!exportName) return applicableCompletionEntryDetails\n    if (!moduleSpecifier) return applicableCompletionEntryDetails\n    // if we have no effect replace span, we return early\n    if (!(\"effectReplaceSpan\" in data)) return applicableCompletionEntryDetails\n    const effectReplaceSpan = data.effectReplaceSpan as ts.TextSpan\n    // we only intervene if we have auto-import only code actions\n    const result = yield* isAutoImportOnlyCodeActions(\n      sourceFile,\n      applicableCompletionEntryDetails.codeActions,\n      exportName\n    )\n    if (!result) return applicableCompletionEntryDetails\n\n    // get or create the namespace cache info\n    const autoImportProvider = yield* AutoImport.getOrMakeAutoImportProvider(sourceFile)\n\n    // get the expected auto-import\n    const effectAutoImport = autoImportProvider.resolve(fileName, exportName)\n    if (!effectAutoImport) return applicableCompletionEntryDetails\n\n    // create the code action\n    const codeActions = yield* addImportCodeAction(\n      formatOptions,\n      preferences,\n      languageServiceHost,\n      sourceFile,\n      effectReplaceSpan,\n      effectAutoImport\n    )\n\n    return {\n      ...applicableCompletionEntryDetails,\n      codeActions\n    }\n  }\n)\n","import { pipe } from \"effect/Function\"\nimport type * as ts from \"typescript\"\nimport * as AutoImport from \"../core/AutoImport\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\n\nexport const middlewareAutoImportQuickfixes = Nano.fn(\"middlewareAutoImportQuickfixes\")(function*(\n  sourceFile: ts.SourceFile,\n  languageServiceHost: ts.LanguageServiceHost,\n  formatOptions: ts.FormatCodeSettings,\n  preferences: ts.UserPreferences | undefined,\n  codeFixes: ReadonlyArray<ts.CodeFixAction>\n) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n  const autoImportProvider = yield* AutoImport.getOrMakeAutoImportProvider(sourceFile)\n  const changedCodeFixes: Array<ts.CodeFixAction> = []\n\n  const createImportAllChanges = (imports: Array<AutoImport.ParsedImportFromTextChange>) =>\n    Nano.gen(function*() {\n      const newImports: Array<AutoImport.ImportKind> = []\n      for (const importToAdd of imports) {\n        // we should have what to import\n        if (!importToAdd.exportName) return\n        // from the module name, get the file name\n        const fileName = ts.resolveModuleName(\n          importToAdd.moduleName,\n          sourceFile.fileName,\n          program.getCompilerOptions(),\n          program as any\n        )\n        if (!fileName.resolvedModule) return\n        // resolve the import kind\n        const importKind = autoImportProvider.resolve(fileName.resolvedModule.resolvedFileName, importToAdd.exportName)\n        if (!importKind) return\n        // we cannot retroactively change the whole source code\n        if (importKind.introducedPrefix) return\n        newImports.push(importKind)\n      }\n      // then we need to produce the actual changes\n      const formatContext = ts.formatting.getFormatContext(\n        formatOptions,\n        languageServiceHost\n      )\n\n      const edits = ts.textChanges.ChangeTracker.with(\n        {\n          formatContext,\n          host: languageServiceHost,\n          preferences: preferences || {}\n        },\n        (changeTracker) =>\n          newImports.forEach((_) => AutoImport.addImport(ts, sourceFile, changeTracker, preferences, _))\n      )\n      return edits\n    })\n\n  for (const codeFix of codeFixes) {\n    const textFileChanges = codeFix.changes\n    // only one change\n    if (textFileChanges.length !== 1) {\n      changedCodeFixes.push(codeFix)\n      continue\n    }\n    // on the current file\n    if (textFileChanges[0].fileName !== sourceFile.fileName) {\n      changedCodeFixes.push(codeFix)\n      continue\n    }\n    // should be import only changes\n    const parsedChanges = yield* AutoImport.parseImportOnlyChanges(sourceFile, textFileChanges[0].textChanges)\n    if (!parsedChanges) {\n      changedCodeFixes.push(codeFix)\n      continue\n    }\n    // no deletions!\n    if (parsedChanges.deletions.length !== 0) {\n      changedCodeFixes.push(codeFix)\n      continue\n    }\n    // ok process them\n    const changes = yield* pipe(\n      createImportAllChanges(parsedChanges.imports),\n      Nano.orElse(() => Nano.succeed(codeFix.changes))\n    )\n    if (changes) {\n      changedCodeFixes.push({ ...codeFix, changes })\n    } else {\n      changedCodeFixes.push(codeFix)\n    }\n  }\n\n  return changedCodeFixes\n})\n","import type * as ts from \"typescript\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport function effectRpcDefinition(\n  applicableGotoDefinition: ts.DefinitionInfoAndBoundSpan | undefined,\n  sourceFile: ts.SourceFile,\n  position: number\n): Nano.Nano<\n  ts.DefinitionInfoAndBoundSpan | undefined,\n  never,\n  | TypeScriptApi.TypeScriptApi\n  | TypeScriptUtils.TypeScriptUtils\n  | TypeScriptApi.TypeScriptProgram\n  | TypeCheckerApi.TypeCheckerApi\n> {\n  return Nano.gen(function*() {\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const textRange = tsUtils.toTextRange(position)\n\n    function isSymbolFromEffectRpcModule(symbol: ts.Symbol) {\n      if (symbol.valueDeclaration) {\n        const sourceFile = tsUtils.getSourceFileOfNode(symbol.valueDeclaration)\n        if (sourceFile) {\n          const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(sourceFile)\n          if (packageInfo && packageInfo.name === \"@effect/rpc\") {\n            const fileSymbol = typeChecker.getSymbolAtLocation(sourceFile)\n            return fileSymbol && fileSymbol.exports && fileSymbol.exports.has(\"isRpc\" as any) &&\n              fileSymbol.exports.has(\"make\" as any) &&\n              fileSymbol.exports.has(\"fromTaggedRequest\" as any)\n          }\n        }\n      }\n      return false\n    }\n\n    function isSymbolFromEffectRpcClientModule(symbol: ts.Symbol) {\n      if (symbol.valueDeclaration) {\n        const sourceFile = tsUtils.getSourceFileOfNode(symbol.valueDeclaration)\n        if (sourceFile) {\n          const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(sourceFile)\n          if (packageInfo && packageInfo.name === \"@effect/rpc\") {\n            const fileSymbol = typeChecker.getSymbolAtLocation(sourceFile)\n            return fileSymbol && fileSymbol.exports && fileSymbol.exports.has(\"RpcClient\" as any) &&\n              fileSymbol.exports.has(\"make\" as any)\n          }\n        }\n      }\n      return false\n    }\n\n    // first find the rpc client method and object (if any)\n    let rpcName: string | null = null\n    let callNode: ts.Node | null = null\n    for (const node of tsUtils.getAncestorNodesInRange(sourceFile, textRange)) {\n      if (\n        ts.isPropertyAccessExpression(node) &&\n        ts.isIdentifier(node.name) &&\n        tsUtils.isNodeInRange(textRange)(node.name)\n      ) {\n        const type = typeChecker.getTypeAtLocation(node)\n        for (const callSig of typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)) {\n          // we detect if it is an RPC api based on where the options simbol is declared from\n          if (callSig.parameters.length >= 2 && isSymbolFromEffectRpcClientModule(callSig.parameters[1])) {\n            rpcName = ts.idText(node.name)\n            callNode = node.name\n          }\n        }\n      }\n    }\n\n    // no rpc found\n    if (rpcName === null || callNode === null) return applicableGotoDefinition\n\n    // collect involved nodes\n    const result: Array<[ts.Node, ts.Symbol]> = []\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    // loop through source files and keep only the ones referencing Rpc api\n    const filesToTest: Array<ts.SourceFile> = []\n    for (const programFile of program.getSourceFiles()) {\n      if (programFile.isDeclarationFile) continue\n      if (programFile.text.indexOf(\"make\") === -1 && programFile.text.indexOf(\"fromTaggedRequest\") === -1) continue\n      // put first files that contains the name we are searching for (heuristic)\n      if (programFile.text.indexOf(rpcName) > -1) {\n        filesToTest.unshift(programFile)\n      } else {\n        filesToTest.push(programFile)\n      }\n    }\n\n    for (const fileToTest of filesToTest) {\n      // exit as soon we find a hit\n      if (result.length > 0) break\n\n      // start processing the file\n      ts.forEachChild(fileToTest, appendNodeToVisit)\n\n      while (result.length === 0 && nodeToVisit.length > 0) {\n        const node = nodeToVisit.shift()!\n        if (\n          ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) &&\n          ts.isIdentifier(node.expression.name) &&\n          (ts.idText(node.expression.name) === \"make\" || ts.idText(node.expression.name) === \"fromTaggedRequest\")\n        ) {\n          const symbol = typeChecker.getSymbolAtLocation(node.expression.name)\n          if (symbol && isSymbolFromEffectRpcModule(symbol)) {\n            const type = typeChecker.getTypeAtLocation(node)\n            const _tag = type.getProperty(\"_tag\")\n            if (_tag) {\n              const tagValue = typeChecker.getTypeOfSymbolAtLocation(_tag, node)\n              if (\"value\" in tagValue && tagValue.value === rpcName) result.push([node, symbol])\n            }\n          }\n        }\n\n        ts.forEachChild(node, appendNodeToVisit)\n      }\n    }\n\n    // nothing done\n    if (result.length === 0) return applicableGotoDefinition\n\n    // create the result entry for the definitions\n    const effectRpcResult = result.map(([node]) => ({\n      fileName: node.getSourceFile().fileName,\n      textSpan: ts.createTextSpan(node.getStart(), node.end - node.getStart()),\n      kind: ts.ScriptElementKind.constElement,\n      name: rpcName,\n      containerKind: ts.ScriptElementKind.constElement,\n      containerName: rpcName\n    }))\n\n    if (applicableGotoDefinition) {\n      return {\n        ...applicableGotoDefinition,\n        definitions: (applicableGotoDefinition.definitions || []).concat(effectRpcResult)\n      } satisfies ts.DefinitionInfoAndBoundSpan\n    }\n\n    return ({\n      textSpan: ts.createTextSpan(callNode.getStart(), callNode.end - callNode.getStart()),\n      definitions: effectRpcResult\n    })\n  })\n}\n","import type * as ts from \"typescript\"\nimport type * as Nano from \"./core/Nano\"\nimport type * as TypeCheckerApi from \"./core/TypeCheckerApi\"\nimport type * as TypeCheckerUtils from \"./core/TypeCheckerUtils\"\nimport type * as TypeScriptApi from \"./core/TypeScriptApi\"\nimport type * as TypeScriptUtils from \"./core/TypeScriptUtils\"\nimport { effectRpcDefinition } from \"./goto/effectRpcDefinition\"\n\nexport function goto(\n  applicableGotoDefinition: ts.DefinitionInfoAndBoundSpan | undefined,\n  sourceFile: ts.SourceFile,\n  position: number\n): Nano.Nano<\n  ts.DefinitionInfoAndBoundSpan | undefined,\n  never,\n  | TypeScriptApi.TypeScriptApi\n  | TypeScriptUtils.TypeScriptUtils\n  | TypeScriptApi.TypeScriptProgram\n  | TypeCheckerApi.TypeCheckerApi\n  | TypeCheckerUtils.TypeCheckerUtils\n> {\n  return effectRpcDefinition(applicableGotoDefinition, sourceFile, position)\n}\n","import { pipe } from \"effect/Function\"\nimport type * as ts from \"typescript\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const middlewareGenLike = Nano.fn(\"middlewareGenLike\")(function*(\n  sourceFile: ts.SourceFile,\n  _span: ts.TextSpan,\n  preferences: ts.UserPreferences | undefined,\n  inlayHints: Array<ts.InlayHint>\n) {\n  // only if the user has enabled the inlay hints for function like return types\n  if (!preferences) return inlayHints\n  if (preferences.includeInlayFunctionLikeReturnTypeHints !== true) return inlayHints\n  if (!inlayHints) return inlayHints\n\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const typeParser = yield* Nano.service(TypeParser.TypeParser)\n  const result: Array<ts.InlayHint> = []\n\n  // given a node, parses the type and eventual gen-like\n  const parseType = (node: ts.Node) => {\n    return pipe(\n      typeParser.effectGen(node),\n      Nano.orElse(() => pipe(typeParser.effectFnGen(node), Nano.orElse(() => typeParser.effectFnUntracedGen(node))))\n    )\n  }\n\n  // now we loop throgh them, and find the ones that refer to an Effect.gen like function\n  for (const inlayHint of inlayHints) {\n    let shouldOmit = false\n    if (inlayHint.kind === ts.InlayHintKind.Type) {\n      const node = tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, inlayHint.position - 1)\n      if (node && node.parent) {\n        const possiblyGen = node.parent\n        yield* pipe(\n          parseType(possiblyGen),\n          Nano.map((_) => {\n            const argsCloseParen = ts.findChildOfKind(_.generatorFunction, ts.SyntaxKind.CloseParenToken, sourceFile)\n            if (\n              argsCloseParen && _.body && inlayHint.position >= argsCloseParen.end &&\n              inlayHint.position <= _.body.getStart(sourceFile)\n            ) {\n              shouldOmit = true\n            }\n          }),\n          Nano.ignore\n        )\n      }\n    }\n    if (!shouldOmit) result.push(inlayHint)\n  }\n\n  return result\n})\n","import * as Array from \"effect/Array\"\nimport * as Eq from \"effect/Equivalence\"\nimport type ts from \"typescript\"\nimport * as Nano from \"../core/Nano\"\n\nconst SymbolDisplayPartEq = Eq.make<ts.SymbolDisplayPart>((fa, fb) => fa.kind === fb.kind && fa.text === fb.text)\n\nconst JSDocTagInfoEq = Eq.make<ts.JSDocTagInfo>((fa, fb) =>\n  fa.name === fb.name && typeof fa.text === typeof fb.text &&\n  (typeof fa.text !== \"undefined\" ? Eq.array(SymbolDisplayPartEq)(fa.text!, fb.text!) : true)\n)\n\nexport function dedupeJsDocs(quickInfo: ts.QuickInfo | undefined): Nano.Nano<ts.QuickInfo | undefined> {\n  if (!quickInfo) return Nano.succeed(quickInfo)\n  if (quickInfo.tags) {\n    return Nano.succeed({\n      ...quickInfo,\n      tags: Array.dedupeWith(quickInfo.tags, JSDocTagInfoEq)\n    })\n  }\n  return Nano.succeed(quickInfo)\n}\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport function effectTypeArgs(\n  sourceFile: ts.SourceFile,\n  position: number,\n  quickInfo: ts.QuickInfo | undefined\n) {\n  return pipe(\n    Nano.gen(function*() {\n      const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n      const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n      const typeParser = yield* Nano.service(TypeParser.TypeParser)\n      const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n      // early exit\n      if (options.quickinfoEffectParameters === \"never\") return quickInfo\n\n      function formatTypeForQuickInfo(channelType: ts.Type, channelName: string) {\n        let stringRepresentation = \"\"\n        if (options.quickinfoMaximumLength > 0) {\n          const typeNode = typeChecker.typeToTypeNode(\n            channelType,\n            undefined,\n            ts.NodeBuilderFlags.None,\n            // @ts-expect-error\n            undefined,\n            undefined,\n            options.quickinfoMaximumLength\n          )\n          const printer = ts.createPrinter({})\n          stringRepresentation = typeNode ? printer.printNode(ts.EmitHint.Unspecified, typeNode, sourceFile) : \"\"\n        } else {\n          stringRepresentation = typeChecker.typeToString(channelType, undefined, ts.TypeFormatFlags.NoTruncation)\n        }\n        return `type ${channelName} = ${stringRepresentation}`\n      }\n\n      function makeSymbolDisplayParts(title: string, A: ts.Type, E: ts.Type, R: ts.Type): Array<ts.SymbolDisplayPart> {\n        return [{\n          kind: \"text\",\n          text: (\n            \"```ts\\n\" +\n            \"/* \" + title + \" */\\n\" +\n            (formatTypeForQuickInfo(A, \"Success\")) +\n            \"\\n\" +\n            (formatTypeForQuickInfo(E, \"Failure\")) +\n            \"\\n\" +\n            (formatTypeForQuickInfo(R, \"Requirements\")) +\n            \"\\n```\\n\"\n          )\n        }]\n      }\n\n      function getNodeForQuickInfo(node: ts.Node): ts.Node {\n        if (ts.isNewExpression(node.parent) && node.pos === node.parent.pos) {\n          return node.parent.expression\n        }\n        if (ts.isNamedTupleMember(node.parent) && node.pos === node.parent.pos) {\n          return node.parent\n        }\n        if (ts.isJsxNamespacedName(node.parent)) {\n          return node.parent\n        }\n        return node\n      }\n\n      function getDataForQuickInfo() {\n        // NOTE: non-exposed API\n        if (!(\"getTouchingPropertyName\" in ts && typeof ts.getTouchingPropertyName === \"function\")) return\n\n        const touchingNode = ts.getTouchingPropertyName(sourceFile, position) as ts.Node\n        // if we are hovering the whole file, we don't do anything\n        if (touchingNode === sourceFile) return\n        const adjustedNode = getNodeForQuickInfo(touchingNode)\n        // hover over a yield keyword\n        if (ts.isToken(adjustedNode) && adjustedNode.kind === ts.SyntaxKind.YieldKeyword) {\n          if (\n            ts.isYieldExpression(adjustedNode.parent) && adjustedNode.parent.asteriskToken &&\n            adjustedNode.parent.expression\n          ) {\n            // if we are hovering a yield keyword, we need to get the expression\n            return {\n              type: typeChecker.getTypeAtLocation(adjustedNode.parent.expression),\n              atLocation: adjustedNode.parent.expression,\n              node: adjustedNode.parent,\n              shouldTry: true\n            }\n          }\n        }\n        // standard case\n        return {\n          type: typeChecker.getTypeAtLocation(adjustedNode),\n          atLocation: adjustedNode,\n          node: adjustedNode,\n          shouldTry: options.quickinfoEffectParameters === \"always\" && quickInfo ? true : quickInfo &&\n            ts.displayPartsToString(quickInfo.displayParts).indexOf(\"...\") > -1\n        }\n      }\n\n      // check if we should try to get the effect type\n      const data = getDataForQuickInfo()\n      if (!(data && data.shouldTry)) return quickInfo\n      const { atLocation, node, type } = data\n\n      // first try to get the effect type\n      const effectTypeArgsDocumentation = yield* pipe(\n        typeParser.effectType(\n          type,\n          atLocation\n        ),\n        Nano.map((_) => makeSymbolDisplayParts(\"Effect Type Parameters\", _.A, _.E, _.R)),\n        Nano.orElse(() => {\n          // if we have a call signature, we can get the effect type from the return type\n          const callSignatues = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n          if (callSignatues.length !== 1) return Nano.succeed([])\n          const returnType = typeChecker.getReturnTypeOfSignature(callSignatues[0])\n          return pipe(\n            typeParser.effectType(\n              returnType,\n              atLocation\n            ),\n            Nano.map((_) => makeSymbolDisplayParts(\"Returned Effect Type Parameters\", _.A, _.E, _.R))\n          )\n        })\n      )\n\n      // there are cases where we create it from scratch\n      if (!quickInfo) {\n        const start = ts.getTokenPosOfNode(node, sourceFile)\n        const end = node.end\n        return {\n          kind: ts.ScriptElementKind.callSignatureElement,\n          kindModifiers: \"\",\n          textSpan: { start, length: end - start },\n          documentation: effectTypeArgsDocumentation\n        } satisfies ts.QuickInfo\n      }\n\n      if (quickInfo.documentation) {\n        return {\n          ...quickInfo,\n          documentation: effectTypeArgsDocumentation.concat(quickInfo.documentation)\n        }\n      }\n\n      return {\n        ...quickInfo,\n        documentation: effectTypeArgsDocumentation\n      }\n    }),\n    Nano.orElse(() => Nano.succeed(quickInfo))\n  )\n}\n","\n/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED$1               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN$1             = 2;\n\n/*============================================================================*/\n\n\nfunction zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH$1    = 3;\nconst MAX_MATCH$1    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES$1  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS$1      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES$1       = 30;\n/* number of distance codes */\n\nconst BL_CODES$1      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n/* maximum heap size */\n\nconst MAX_BITS$1      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES$1 + 2) * 2);\nzero$1(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES$1 * 2);\nzero$1(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero$1(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\nzero$1(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES$1);\nzero$1(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES$1);\nzero$1(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Tracev((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) => {\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n\n  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n    code = (code + bl_count[bits - 1]) << 1;\n    next_code[bits] = code;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS$1 + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES$1; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES$1; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.sym_next = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) => {\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) => {\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let sx = 0;         /* running index in sym_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.sym_next !== 0) {\n    do {\n      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;\n      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;\n      lc = s.pending_buf[s.sym_buf + sx++];\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and sym_buf is ok: */\n      //Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n\n    } while (sx < s.sym_next);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE$1;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) => {\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"block list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* block_mask is the bit mask of block-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let block_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"block-listed\") bytes. */\n  for (n = 0; n <= 31; n++, block_mask >>>= 1) {\n    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"allow-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS$1; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"block-listed\" or \"allow-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init$1 = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  bi_windup(s);        /* align on byte boundary */\n  put_short(s, stored_len);\n  put_short(s, ~stored_len);\n  if (stored_len) {\n    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);\n  }\n  s.pending += stored_len;\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align$1 = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n */\nconst _tr_flush_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN$1) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->sym_next / 3));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block$1(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally$1 = (s, dist, lc) => {\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist;\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;\n  s.pending_buf[s.sym_buf + s.sym_next++] = lc;\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n  return (s.sym_next === s.sym_end);\n};\n\nvar _tr_init_1  = _tr_init$1;\nvar _tr_stored_block_1 = _tr_stored_block$1;\nvar _tr_flush_block_1  = _tr_flush_block$1;\nvar _tr_tally_1 = _tr_tally$1;\nvar _tr_align_1 = _tr_align$1;\n\nvar trees = {\n\t_tr_init: _tr_init_1,\n\t_tr_stored_block: _tr_stored_block_1,\n\t_tr_flush_block: _tr_flush_block_1,\n\t_tr_tally: _tr_tally_1,\n\t_tr_align: _tr_align_1\n};\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32 = (adler, buf, len, pos) => {\n  let s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n};\n\n\nvar adler32_1 = adler32;\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nconst makeTable = () => {\n  let c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n};\n\n// Create table on load. Just 255 signed longs. Not a problem.\nconst crcTable = new Uint32Array(makeTable());\n\n\nconst crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n\n  crc ^= -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n};\n\n\nvar crc32_1 = crc32;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar messages = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar constants$2 = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  Z_MEM_ERROR:       -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,\n  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,\n  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n  Z_UNKNOWN,\n  Z_DEFLATED: Z_DEFLATED$2\n} = constants$2;\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS$1 = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */\n//#ifdef GZIP\nconst GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n//#endif\nconst EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */\nconst NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */\nconst COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */\nconst HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */\nconst BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */\nconst FINISH_STATE  = 666;    /* stream complete */\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = messages[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) * 2) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */\nconst slide_hash = (s) => {\n  let n, m;\n  let p;\n  let wsize = s.w_size;\n\n  n = s.hash_size;\n  p = n;\n  do {\n    m = s.head[--p];\n    s.head[p] = (m >= wsize ? m - wsize : 0);\n  } while (--n);\n  n = wsize;\n//#ifndef FASTEST\n  p = n;\n  do {\n    m = s.prev[--p];\n    s.prev[p] = (m >= wsize ? m - wsize : 0);\n    /* If n is not on any hash chain, prev[n] is garbage but\n     * its value will never be used.\n     */\n  } while (--n);\n//#endif\n};\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out  += len;\n  s.pending_out  += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending      -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let n, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n      if (s.insert > s.strstart) {\n        s.insert = s.strstart;\n      }\n      slide_hash(s);\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunites to have a single copy from next_in to next_out.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Smallest worthy block size when not flushing or finishing. By default\n   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n   * large input and output buffers, the stored block size will be larger.\n   */\n  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;\n\n  /* Copy as many min_block or larger stored blocks directly to next_out as\n   * possible. If flushing, copy the remaining available input to next_out as\n   * stored blocks, if there is enough space.\n   */\n  let len, left, have, last = 0;\n  let used = s.strm.avail_in;\n  do {\n    /* Set len to the maximum size block that we can copy directly with the\n     * available input data and output space. Set left to how much of that\n     * would be copied from what's left in the window.\n     */\n    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */\n    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    if (s.strm.avail_out < have) {         /* need room for header */\n      break;\n    }\n      /* maximum stored block length that will fit in avail_out: */\n    have = s.strm.avail_out - have;\n    left = s.strstart - s.block_start;  /* bytes left in window */\n    if (len > left + s.strm.avail_in) {\n      len = left + s.strm.avail_in;   /* limit len to the input */\n    }\n    if (len > have) {\n      len = have;             /* limit len to the output */\n    }\n\n    /* If the stored block would be less than min_block in length, or if\n     * unable to copy all of the available input when flushing, then try\n     * copying to the window and the pending buffer instead. Also don't\n     * write an empty block when flushing -- deflate() does that.\n     */\n    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||\n                        flush === Z_NO_FLUSH$2 ||\n                        len !== left + s.strm.avail_in)) {\n      break;\n    }\n\n    /* Make a dummy stored block in pending to get the header bytes,\n     * including any pending bits. This also updates the debugging counts.\n     */\n    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;\n    _tr_stored_block(s, 0, 0, last);\n\n    /* Replace the lengths in the dummy stored block with len. */\n    s.pending_buf[s.pending - 4] = len;\n    s.pending_buf[s.pending - 3] = len >> 8;\n    s.pending_buf[s.pending - 2] = ~len;\n    s.pending_buf[s.pending - 1] = ~len >> 8;\n\n    /* Write the stored block header bytes. */\n    flush_pending(s.strm);\n\n//#ifdef ZLIB_DEBUG\n//    /* Update debugging counts for the data about to be copied. */\n//    s->compressed_len += len << 3;\n//    s->bits_sent += len << 3;\n//#endif\n\n    /* Copy uncompressed bytes from the window to next_out. */\n    if (left) {\n      if (left > len) {\n        left = len;\n      }\n      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);\n      s.strm.next_out += left;\n      s.strm.avail_out -= left;\n      s.strm.total_out += left;\n      s.block_start += left;\n      len -= left;\n    }\n\n    /* Copy uncompressed bytes directly from next_in to next_out, updating\n     * the check value.\n     */\n    if (len) {\n      read_buf(s.strm, s.strm.output, s.strm.next_out, len);\n      s.strm.next_out += len;\n      s.strm.avail_out -= len;\n      s.strm.total_out += len;\n    }\n  } while (last === 0);\n\n  /* Update the sliding window with the last s->w_size bytes of the copied\n   * data, or append all of the copied data to the existing window if less\n   * than s->w_size bytes were copied. Also update the number of bytes to\n   * insert in the hash tables, in the event that deflateParams() switches to\n   * a non-zero compression level.\n   */\n  used -= s.strm.avail_in;    /* number of input bytes directly copied */\n  if (used) {\n    /* If any input was used, then no unused input remains in the window,\n     * therefore s->block_start == s->strstart.\n     */\n    if (used >= s.w_size) {  /* supplant the previous history */\n      s.matches = 2;     /* clear hash */\n      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);\n      s.strstart = s.w_size;\n      s.insert = s.strstart;\n    }\n    else {\n      if (s.window_size - s.strstart <= used) {\n        /* Slide the window down. */\n        s.strstart -= s.w_size;\n        //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n        if (s.matches < 2) {\n          s.matches++;   /* add a pending slide_hash() */\n        }\n        if (s.insert > s.strstart) {\n          s.insert = s.strstart;\n        }\n      }\n      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);\n      s.strstart += used;\n      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;\n    }\n    s.block_start = s.strstart;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* If the last block was written to next_out, then done. */\n  if (last) {\n    return BS_FINISH_DONE;\n  }\n\n  /* If flushing and all input has been consumed, then done. */\n  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&\n    s.strm.avail_in === 0 && s.strstart === s.block_start) {\n    return BS_BLOCK_DONE;\n  }\n\n  /* Fill the window with any remaining input. */\n  have = s.window_size - s.strstart;\n  if (s.strm.avail_in > have && s.block_start >= s.w_size) {\n    /* Slide the window down. */\n    s.block_start -= s.w_size;\n    s.strstart -= s.w_size;\n    //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n    if (s.matches < 2) {\n      s.matches++;       /* add a pending slide_hash() */\n    }\n    have += s.w_size;      /* more space now */\n    if (s.insert > s.strstart) {\n      s.insert = s.strstart;\n    }\n  }\n  if (have > s.strm.avail_in) {\n    have = s.strm.avail_in;\n  }\n  if (have) {\n    read_buf(s.strm, s.window, s.strstart, have);\n    s.strstart += have;\n    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* There was not enough avail_out to write a complete worthy or flushed\n   * stored block to next_out. Write a stored block to pending instead, if we\n   * have enough input for a worthy block, or if flushing and there is enough\n   * room for the remaining input as a stored block in the pending buffer.\n   */\n  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    /* maximum stored block length that will fit in pending: */\n  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;\n  min_block = have > s.w_size ? s.w_size : have;\n  left = s.strstart - s.block_start;\n  if (left >= min_block ||\n     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&\n     s.strm.avail_in === 0 && left <= have)) {\n    len = left > have ? have : left;\n    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&\n         len === left ? 1 : 0;\n    _tr_stored_block(s, s.block_start, len, last);\n    s.block_start += len;\n    flush_pending(s.strm);\n  }\n\n  /* We've done all we can with the available input and output. */\n  return last ? BS_FINISH_STARTED : BS_NEED_MORE;\n};\n\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH$2) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.sym_buf = 0;        /* buffer for distances and literals/lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.sym_next = 0;      /* running index in sym_buf */\n  this.sym_end = 0;       /* symbol table full when sym_next reaches this */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nconst deflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const s = strm.state;\n  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&\n//#ifdef GZIP\n                                s.status !== GZIP_STATE &&\n//#endif\n                                s.status !== EXTRA_STATE &&\n                                s.status !== NAME_STATE &&\n                                s.status !== COMMENT_STATE &&\n                                s.status !== HCRC_STATE &&\n                                s.status !== BUSY_STATE &&\n                                s.status !== FINISH_STATE)) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status =\n//#ifdef GZIP\n    s.wrap === 2 ? GZIP_STATE :\n//#endif\n    s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = -2;\n  _tr_init(s);\n  return Z_OK$3;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK$3) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR$2;\n  }\n  strm.state.gzhead = head;\n  return Z_OK$3;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR$2;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION$1) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n  s.status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  /* We overlay pending_buf and sym_buf. This works since the average size\n   * for length/distance pairs over any compressed block is assured to be 31\n   * bits or less.\n   *\n   * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n   * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n   * possible fixed-codes length/distance pair is then 31 bits total.\n   *\n   * sym_buf starts one-fourth of the way into pending_buf. So there are\n   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n   * in sym_buf is three bytes -- two for the distance and one for the\n   * literal/length. As each symbol is consumed, the pointer to the next\n   * sym_buf value to read moves forward three bytes. From that symbol, up to\n   * 31 bits are written to pending_buf. The closest the written pending_buf\n   * bits gets to the next sym_buf symbol to read is just before the last\n   * code is written. At that time, 31*(n-2) bits have been written, just\n   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n   * symbols are written.) The closest the writing gets to what is unread is\n   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n   * can range from 128 to 32768.\n   *\n   * Therefore, at a minimum, there are 142 bits of space between what is\n   * written and what is read in the overlain buffers, so the symbols cannot\n   * be overwritten by the compressed data. That space is actually 139 bits,\n   * due to the three-bit fixed-code block header.\n   *\n   * That covers the case where either Z_FIXED is specified, forcing fixed\n   * codes, or when the use of fixed codes is chosen, because that choice\n   * results in a smaller compressed block than dynamic codes. That latter\n   * condition then assures that the above analysis also covers all dynamic\n   * blocks. A dynamic-code block will only be chosen to be emitted if it has\n   * fewer bits than a fixed-code block would for the same set of symbols.\n   * Therefore its average symbol length is assured to be less than 31. So\n   * the compressed data for a dynamic block also cannot overwrite the\n   * symbols from which it is being constructed.\n   */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->sym_buf = s->pending_buf + s->lit_bufsize;\n  s.sym_buf = s.lit_bufsize;\n\n  //s->sym_end = (s->lit_bufsize - 1) * 3;\n  s.sym_end = (s.lit_bufsize - 1) * 3;\n  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n};\n\n\n/* ========================================================================= */\nconst deflate$2 = (strm, flush) => {\n\n  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (strm.avail_in !== 0 && !strm.input) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n  }\n\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH$3) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* Write the header */\n  if (s.status === INIT_STATE && s.wrap === 0) {\n    s.status = BUSY_STATE;\n  }\n  if (s.status === INIT_STATE) {\n    /* zlib header */\n    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n    let level_flags = -1;\n\n    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n      level_flags = 0;\n    } else if (s.level < 6) {\n      level_flags = 1;\n    } else if (s.level === 6) {\n      level_flags = 2;\n    } else {\n      level_flags = 3;\n    }\n    header |= (level_flags << 6);\n    if (s.strstart !== 0) { header |= PRESET_DICT; }\n    header += 31 - (header % 31);\n\n    putShortMSB(s, header);\n\n    /* Save the adler32 of the preset dictionary: */\n    if (s.strstart !== 0) {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n    strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#ifdef GZIP\n  if (s.status === GZIP_STATE) {\n    /* gzip header */\n    strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n    put_byte(s, 31);\n    put_byte(s, 139);\n    put_byte(s, 8);\n    if (!s.gzhead) { // s->gzhead == Z_NULL\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, OS_CODE);\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK$3;\n      }\n    }\n    else {\n      put_byte(s, (s.gzhead.text ? 1 : 0) +\n                  (s.gzhead.hcrc ? 2 : 0) +\n                  (!s.gzhead.extra ? 0 : 4) +\n                  (!s.gzhead.name ? 0 : 8) +\n                  (!s.gzhead.comment ? 0 : 16)\n      );\n      put_byte(s, s.gzhead.time & 0xff);\n      put_byte(s, (s.gzhead.time >> 8) & 0xff);\n      put_byte(s, (s.gzhead.time >> 16) & 0xff);\n      put_byte(s, (s.gzhead.time >> 24) & 0xff);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, s.gzhead.os & 0xff);\n      if (s.gzhead.extra && s.gzhead.extra.length) {\n        put_byte(s, s.gzhead.extra.length & 0xff);\n        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n      }\n      if (s.gzhead.hcrc) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n      }\n      s.gzindex = 0;\n      s.status = EXTRA_STATE;\n    }\n  }\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;\n      while (s.pending + left > s.pending_buf_size) {\n        let copy = s.pending_buf_size - s.pending;\n        // zmemcpy(s.pending_buf + s.pending,\n        //    s.gzhead.extra + s.gzindex, copy);\n        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);\n        s.pending = s.pending_buf_size;\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex += copy;\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n        beg = 0;\n        left -= copy;\n      }\n      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility\n      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11\n      let gzhead_extra = new Uint8Array(s.gzhead.extra);\n      // zmemcpy(s->pending_buf + s->pending,\n      //     s->gzhead->extra + s->gzindex, left);\n      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);\n      s.pending += left;\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = NAME_STATE;\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = COMMENT_STATE;\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n    }\n    s.status = HCRC_STATE;\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n      }\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n    }\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#endif\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {\n    let bstate = s.level === 0 ? deflate_stored(s, flush) :\n                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s.strategy === Z_RLE ? deflate_rle(s, flush) :\n                 configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK$3;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH$1) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK$3;\n      }\n    }\n  }\n\n  if (flush !== Z_FINISH$3) { return Z_OK$3; }\n  if (s.wrap <= 0) { return Z_STREAM_END$3; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const status = strm.state.status;\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK$3;\n};\n\n\nvar deflateInit_1 = deflateInit;\nvar deflateInit2_1 = deflateInit2;\nvar deflateReset_1 = deflateReset;\nvar deflateResetKeep_1 = deflateResetKeep;\nvar deflateSetHeader_1 = deflateSetHeader;\nvar deflate_2$1 = deflate$2;\nvar deflateEnd_1 = deflateEnd;\nvar deflateSetDictionary_1 = deflateSetDictionary;\nvar deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateGetDictionary = deflateGetDictionary;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n\nvar deflate_1$2 = {\n\tdeflateInit: deflateInit_1,\n\tdeflateInit2: deflateInit2_1,\n\tdeflateReset: deflateReset_1,\n\tdeflateResetKeep: deflateResetKeep_1,\n\tdeflateSetHeader: deflateSetHeader_1,\n\tdeflate: deflate_2$1,\n\tdeflateEnd: deflateEnd_1,\n\tdeflateSetDictionary: deflateSetDictionary_1,\n\tdeflateInfo: deflateInfo\n};\n\nconst _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar assign = function (obj /*from1, from2, from3, ...*/) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// Join array of chunks to single array.\nvar flattenChunks = (chunks) => {\n  // calculate data length\n  let len = 0;\n\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n\n  // join chunks\n  const result = new Uint8Array(len);\n\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n\n  return result;\n};\n\nvar common = {\n\tassign: assign,\n\tflattenChunks: flattenChunks\n};\n\n// String encode/decode helpers\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nlet STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nconst _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nvar string2buf = (str) => {\n  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str);\n  }\n\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper\nconst buf2binstring = (buf, len) => {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\n\n\n// convert array to string\nvar buf2string = (buf, max) => {\n  const len = max || buf.length;\n\n  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n    return new TextDecoder().decode(buf.subarray(0, max));\n  }\n\n  let i, out;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  const utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    let c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    let c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = (buf, max) => {\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\nvar strings = {\n\tstring2buf: string2buf,\n\tbuf2string: buf2string,\n\tutf8border: utf8border\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nvar zstream = ZStream;\n\nconst toString$1 = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,\n  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED: Z_DEFLATED$1\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate$1(options) {\n  this.options = common.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY\n  }, options || {});\n\n  let opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n\n  let status = deflate_1$2.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK$2) {\n    throw new Error(messages[status]);\n  }\n\n  if (opt.header) {\n    deflate_1$2.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    let dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = deflate_1$2.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK$2) {\n      throw new Error(messages[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n\n  if (this.ended) { return false; }\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString$1.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    // Make sure avail_out > 6 to avoid repeating markers\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    status = deflate_1$2.deflate(strm, _flush_mode);\n\n    // Ended => flush and finish\n    if (status === Z_STREAM_END$2) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = deflate_1$2.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK$2;\n    }\n\n    // Flush if out buffer full\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n\n    // Flush if requested and has data\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$2) {\n    this.result = common.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate$1(input, options) {\n  const deflator = new Deflate$1(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate$1(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip$1(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate$1(input, options);\n}\n\n\nvar Deflate_1$1 = Deflate$1;\nvar deflate_2 = deflate$1;\nvar deflateRaw_1$1 = deflateRaw$1;\nvar gzip_1$1 = gzip$1;\nvar constants$1 = constants$2;\n\nvar deflate_1$1 = {\n\tDeflate: Deflate_1$1,\n\tdeflate: deflate_2,\n\tdeflateRaw: deflateRaw_1$1,\n\tgzip: gzip_1$1,\n\tconstants: constants$1\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nconst BAD$1 = 16209;       /* got a data error -- remain here until reset */\nconst TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvar inffast = function inflate_fast(strm, start) {\n  let _in;                    /* local strm.input */\n  let last;                   /* have enough input while in < last */\n  let _out;                   /* local strm.output */\n  let beg;                    /* inflate()'s initial strm.output */\n  let end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  let dmax;                   /* maximum distance from zlib header */\n//#endif\n  let wsize;                  /* window size or zero if not using window */\n  let whave;                  /* valid bytes in the window */\n  let wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  let s_window;               /* allocated sliding window, if wsize != 0 */\n  let hold;                   /* local strm.hold */\n  let bits;                   /* local strm.bits */\n  let lcode;                  /* local strm.lencode */\n  let dcode;                  /* local strm.distcode */\n  let lmask;                  /* mask for first level of length codes */\n  let dmask;                  /* mask for first level of distance codes */\n  let here;                   /* retrieved table entry */\n  let op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  let len;                    /* match length, unused bytes */\n  let dist;                   /* match distance */\n  let from;                   /* where to copy match from */\n  let from_source;\n\n\n  let input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  const state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD$1;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD$1;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD$1;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE$1;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD$1;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst MAXBITS = 15;\nconst ENOUGH_LENS$1 = 852;\nconst ENOUGH_DISTS$1 = 592;\n//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst CODES$1 = 0;\nconst LENS$1 = 1;\nconst DISTS$1 = 2;\n\nconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n]);\n\nconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n]);\n\nconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n]);\n\nconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n]);\n\nconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n{\n  const bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  let len = 0;               /* a code's length in bits */\n  let sym = 0;               /* index of code symbols */\n  let min = 0, max = 0;          /* minimum and maximum code lengths */\n  let root = 0;              /* number of index bits for root table */\n  let curr = 0;              /* number of index bits for current table */\n  let drop = 0;              /* code bits to drop for sub-table */\n  let left = 0;                   /* number of prefix codes available */\n  let used = 0;              /* code entries in table used */\n  let huff = 0;              /* Huffman code */\n  let incr;              /* for incrementing code, index */\n  let fill;              /* index for replicating entries */\n  let low;               /* low bits for current root entry */\n  let mask;              /* mask for low root bits */\n  let next;             /* next available space in table */\n  let base = null;     /* base value table to use */\n//  let shoextra;    /* extra bits table to use */\n  let match;                  /* use base and extra for symbol >= match */\n  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  let extra = null;\n\n  let here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES$1 || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES$1) {\n    base = extra = work;    /* dummy value--not used */\n    match = 20;\n\n  } else if (type === LENS$1) {\n    base = lbase;\n    extra = lext;\n    match = 257;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    match = 0;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] + 1 < match) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] >= match) {\n      here_op = extra[work[sym] - match];\n      here_val = base[work[sym] - match];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\nvar inftrees = inflate_table;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n\n\n\n\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,\n  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,\n  Z_DEFLATED\n} = constants$2;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nconst    HEAD = 16180;       /* i: waiting for magic header */\nconst    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */\nconst    TIME = 16182;       /* i: waiting for modification time (gzip) */\nconst    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */\nconst    EXLEN = 16184;      /* i: waiting for extra length (gzip) */\nconst    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */\nconst    NAME = 16186;       /* i: waiting for end of file name (gzip) */\nconst    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */\nconst    HCRC = 16188;       /* i: waiting for header crc (gzip) */\nconst    DICTID = 16189;    /* i: waiting for dictionary check value */\nconst    DICT = 16190;      /* waiting for inflateSetDictionary() call */\nconst        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */\nconst        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */\nconst        STORED = 16193;    /* i: waiting for stored size (length and complement) */\nconst        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */\nconst        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */\nconst        TABLE = 16196;     /* i: waiting for dynamic block table lengths */\nconst        LENLENS = 16197;   /* i: waiting for code length code lengths */\nconst        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */\nconst            LEN_ = 16199;      /* i: same as LEN below, but only first time in */\nconst            LEN = 16200;       /* i: waiting for length/lit/eob code */\nconst            LENEXT = 16201;    /* i: waiting for length extra bits */\nconst            DIST = 16202;      /* i: waiting for distance code */\nconst            DISTEXT = 16203;   /* i: waiting for distance extra bits */\nconst            MATCH = 16204;     /* o: waiting for output space to copy string */\nconst            LIT = 16205;       /* o: waiting for output space to write literal */\nconst    CHECK = 16206;     /* i: waiting for 32-bit check value */\nconst    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */\nconst    DONE = 16208;      /* finished check, done -- remain here until reset */\nconst    BAD = 16209;       /* got a data error -- remain here until reset */\nconst    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */\nconst    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_WBITS = MAX_WBITS;\n\n\nconst zswap32 = (q) => {\n\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n};\n\n\nfunction InflateState() {\n  this.strm = null;           /* pointer back to this zlib stream */\n  this.mode = 0;              /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,\n                                 bit 2 true to validate check value */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib), or\n                                 -1 if raw or no header yet */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n  this.work = new Uint16Array(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\n\nconst inflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const state = strm.state;\n  if (!state || state.strm !== strm ||\n    state.mode < HEAD || state.mode > SYNC) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst inflateResetKeep = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.flags = -1;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK$1;\n};\n\n\nconst inflateReset = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n};\n\n\nconst inflateReset2 = (strm, windowBits) => {\n  let wrap;\n\n  /* get the state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 5;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\n\n\nconst inflateInit2 = (strm, windowBits) => {\n\n  if (!strm) { return Z_STREAM_ERROR$1; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  const state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.strm = strm;\n  state.window = null/*Z_NULL*/;\n  state.mode = HEAD;     /* to pass state test in inflateReset2() */\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$1) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n};\n\n\nconst inflateInit = (strm) => {\n\n  return inflateInit2(strm, DEF_WBITS);\n};\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nlet virgin = true;\n\nlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\n\nconst fixedtables = (state) => {\n\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n\n    /* literal/length table */\n    let sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nconst updatewindow = (strm, src, end, copy) => {\n\n  let dist;\n  const state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Uint8Array(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n};\n\n\nconst inflate$2 = (strm, flush) => {\n\n  let state;\n  let input, output;          // input/output buffers\n  let next;                   /* next input INDEX */\n  let put;                    /* next output INDEX */\n  let have, left;             /* available input and output */\n  let hold;                   /* bit buffer */\n  let bits;                   /* bits in bit buffer */\n  let _in, _out;              /* save starting available input and output */\n  let copy;                   /* number of stored or match bytes to copy */\n  let from;                   /* where to copy match bytes from */\n  let from_source;\n  let here = 0;               /* current decoding table entry */\n  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //let last;                   /* parent table entry */\n  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  let len;                    /* length to copy for repeats, bits to drop */\n  let ret;                    /* return code */\n  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n  let opts;\n\n  let n; // temporary variable for NEED_BITS\n\n  const order = /* permutation of code lengths */\n    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n\n\n  if (inflateStateCheck(strm) || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK$1;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          if (state.wbits === 0) {\n            state.wbits = 15;\n          }\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        if (len > 15 || len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n\n        // !!! pako patch. Force use `options.windowBits` if passed.\n        // Required to always use max window size by default.\n        state.dmax = 1 << state.wbits;\n        //state.dmax = 1 << len;\n\n        state.flags = 0;               /* indicate zlib header */\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Uint8Array(state.head.extra_len);\n              }\n              state.head.extra.set(\n                input.subarray(\n                  next,\n                  // extra field is limited to 65536 bytes\n                  // - no need for additional size check\n                  next + copy\n                ),\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if ((state.flags & 0x0200) && (state.wrap & 4)) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT$1;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          output.set(input.subarray(next, next + copy), put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inffast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if ((state.wrap & 4) && _out) {\n            strm.adler = state.check =\n                /*UPDATE_CHECK(state.check, put - _out, _out);*/\n                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END$1;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR$1;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR$1;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR$1;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH$1))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if ((state.wrap & 4) && _out) {\n    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n};\n\n\nconst inflateEnd = (strm) => {\n\n  if (inflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$1;\n};\n\n\nconst inflateGetHeader = (strm, head) => {\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK$1;\n};\n\n\nconst inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n\n  let state;\n  let dictid;\n  let ret;\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32_1(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR$1;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR$1;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK$1;\n};\n\n\nvar inflateReset_1 = inflateReset;\nvar inflateReset2_1 = inflateReset2;\nvar inflateResetKeep_1 = inflateResetKeep;\nvar inflateInit_1 = inflateInit;\nvar inflateInit2_1 = inflateInit2;\nvar inflate_2$1 = inflate$2;\nvar inflateEnd_1 = inflateEnd;\nvar inflateGetHeader_1 = inflateGetHeader;\nvar inflateSetDictionary_1 = inflateSetDictionary;\nvar inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.inflateCodesUsed = inflateCodesUsed;\nmodule.exports.inflateCopy = inflateCopy;\nmodule.exports.inflateGetDictionary = inflateGetDictionary;\nmodule.exports.inflateMark = inflateMark;\nmodule.exports.inflatePrime = inflatePrime;\nmodule.exports.inflateSync = inflateSync;\nmodule.exports.inflateSyncPoint = inflateSyncPoint;\nmodule.exports.inflateUndermine = inflateUndermine;\nmodule.exports.inflateValidate = inflateValidate;\n*/\n\nvar inflate_1$2 = {\n\tinflateReset: inflateReset_1,\n\tinflateReset2: inflateReset2_1,\n\tinflateResetKeep: inflateResetKeep_1,\n\tinflateInit: inflateInit_1,\n\tinflateInit2: inflateInit2_1,\n\tinflate: inflate_2$1,\n\tinflateEnd: inflateEnd_1,\n\tinflateGetHeader: inflateGetHeader_1,\n\tinflateSetDictionary: inflateSetDictionary_1,\n\tinflateInfo: inflateInfo\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nvar gzheader = GZheader;\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_FINISH,\n  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate$1(options) {\n  this.options = common.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: ''\n  }, options || {});\n\n  const opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new zstream();\n  this.strm.avail_out = 0;\n\n  let status  = inflate_1$2.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(messages[status]);\n  }\n\n  this.header = new gzheader();\n\n  inflate_1$2.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer): input data\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n *   `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. If end of stream detected,\n * [[Inflate#onEnd]] will be called.\n *\n * `flush_mode` is not needed for normal operation, because end of stream\n * detected automatically. You may try to use it for advanced things, but\n * this functionality was not tested.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n\n  if (this.ended) return false;\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n  // Convert data if needed\n  if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = inflate_1$2.inflate(strm, _flush_mode);\n\n    if (status === Z_NEED_DICT && dictionary) {\n      status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n\n      if (status === Z_OK) {\n        status = inflate_1$2.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR) {\n        // Replace code with more verbose\n        status = Z_NEED_DICT;\n      }\n    }\n\n    // Skip snyc markers if more data follows and not raw mode\n    while (strm.avail_in > 0 &&\n           status === Z_STREAM_END &&\n           strm.state.wrap > 0 &&\n           data[strm.next_in] !== 0)\n    {\n      inflate_1$2.inflateReset(strm);\n      status = inflate_1$2.inflate(strm, _flush_mode);\n    }\n\n    switch (status) {\n      case Z_STREAM_ERROR:\n      case Z_DATA_ERROR:\n      case Z_NEED_DICT:\n      case Z_MEM_ERROR:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n\n    // Remember real `avail_out` value, because we may patch out buffer content\n    // to align utf8 strings boundaries.\n    last_avail_out = strm.avail_out;\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END) {\n\n        if (this.options.to === 'string') {\n\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail & realign counters\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n\n    // Must repeat iteration if out buffer is full\n    if (status === Z_OK && last_avail_out === 0) continue;\n\n    // Finalize if end of stream reached.\n    if (status === Z_STREAM_END) {\n      status = inflate_1$2.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|String): output data. When string output requested,\n *   each chunk will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = common.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako');\n * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n * let output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err) {\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate$1(input, options) {\n  const inflator = new Inflate$1(options);\n\n  inflator.push(input);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) throw inflator.msg || messages[inflator.err];\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate$1(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nvar Inflate_1$1 = Inflate$1;\nvar inflate_2 = inflate$1;\nvar inflateRaw_1$1 = inflateRaw$1;\nvar ungzip$1 = inflate$1;\nvar constants = constants$2;\n\nvar inflate_1$1 = {\n\tInflate: Inflate_1$1,\n\tinflate: inflate_2,\n\tinflateRaw: inflateRaw_1$1,\n\tungzip: ungzip$1,\n\tconstants: constants\n};\n\nconst { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;\n\nconst { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\n\n\n\nvar Deflate_1 = Deflate;\nvar deflate_1 = deflate;\nvar deflateRaw_1 = deflateRaw;\nvar gzip_1 = gzip;\nvar Inflate_1 = Inflate;\nvar inflate_1 = inflate;\nvar inflateRaw_1 = inflateRaw;\nvar ungzip_1 = ungzip;\nvar constants_1 = constants$2;\n\nvar pako = {\n\tDeflate: Deflate_1,\n\tdeflate: deflate_1,\n\tdeflateRaw: deflateRaw_1,\n\tgzip: gzip_1,\n\tInflate: Inflate_1,\n\tinflate: inflate_1,\n\tinflateRaw: inflateRaw_1,\n\tungzip: ungzip_1,\n\tconstants: constants_1\n};\n\nexport { Deflate_1 as Deflate, Inflate_1 as Inflate, constants_1 as constants, pako as default, deflate_1 as deflate, deflateRaw_1 as deflateRaw, gzip_1 as gzip, inflate_1 as inflate, inflateRaw_1 as inflateRaw, ungzip_1 as ungzip };\n","import { pipe } from \"effect\"\nimport * as Array from \"effect/Array\"\nimport * as Graph from \"effect/Graph\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport type * as ts from \"typescript\"\nimport * as Nano from \"./Nano.js\"\nimport * as TypeCheckerApi from \"./TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"./TypeCheckerUtils.js\"\nimport * as TypeParser from \"./TypeParser.js\"\nimport * as TypeScriptApi from \"./TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"./TypeScriptUtils.js\"\n\nexport class UnableToProduceLayerGraphError {\n  readonly _tag = \"@effect/language-service/UnableToProduceLayerGraphError\"\n  constructor(\n    readonly message: string,\n    readonly node?: ts.Node | undefined\n  ) {}\n}\n\nexport interface LayerGraphNodeInfo {\n  node: ts.Node\n  layerType: ts.Type | undefined\n  provides: Array<ts.Type>\n  requires: Array<ts.Type>\n  layerTypes: undefined | {\n    ROut: ts.Type\n    E: ts.Type\n    RIn: ts.Type\n  }\n}\n\nexport type LayerGraphEdgeInfo =\n  | {\n    relationship: \"call\"\n    argumentIndex: number\n  }\n  | {\n    relationship: \"pipe\"\n  }\n  | {\n    relationship: \"arrayLiteral\"\n    index: number\n  }\n\nexport type LayerGraph = Graph.Graph<LayerGraphNodeInfo, LayerGraphEdgeInfo, \"directed\">\n\nexport const extractLayerGraph = Nano.fn(\"extractLayerGraph\")(function*(node: ts.Node, opts: {\n  arrayLiteralAsMerge: boolean\n  explodeOnlyLayerCalls: boolean\n}) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n  const typeParser = yield* Nano.service(TypeParser.TypeParser)\n  const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n  const sourceFile = tsUtils.getSourceFileOfNode(node)!\n  const layerModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, \"effect\", \"Layer\") ||\n    \"Layer\"\n\n  // keep track of the nodes we've visited\n  const visitedNodes = new WeakSet<ts.Node>()\n  const nodeInPipeContext = new WeakSet<ts.Node>()\n  const nodeToGraph = new WeakMap<ts.Node, Graph.NodeIndex>()\n\n  // do a DFS search to find all the layer nodes and wire them up properly\n  const nodeToVisit: Array<ts.Node> = [node]\n  const appendNodeToVisit = (node: ts.Node) => {\n    nodeToVisit.push(node)\n    return undefined\n  }\n\n  const mutableGraph = Graph.beginMutation(Graph.directed<LayerGraphNodeInfo, LayerGraphEdgeInfo>())\n\n  const extractNodeInfo = Nano.fn(\"extractNodeInfo\")(function*(node: ts.Node) {\n    let provides: Array<ts.Type> = []\n    let requires: Array<ts.Type> = []\n    let layerType: ts.Type | undefined = undefined\n    let layerTypes: LayerGraphNodeInfo[\"layerTypes\"] | undefined = undefined\n    if (nodeInPipeContext.has(node)) {\n      if (ts.isExpression(node)) {\n        const contextualType = typeChecker.getContextualType(node)\n        if (contextualType) {\n          const callSignatures = typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call)\n          if (callSignatures.length === 1) {\n            layerType = typeChecker.getReturnTypeOfSignature(callSignatures[0])\n          }\n        }\n      }\n    } else {\n      layerType = typeChecker.getTypeAtLocation(node)\n    }\n    if (layerType) {\n      layerTypes = yield* pipe(typeParser.layerType(layerType, node), Nano.orElse(() => Nano.void_))\n    }\n    if (!layerTypes) layerType = undefined\n\n    if (layerTypes) {\n      // just omit never, not useful at all.\n      provides = typeCheckerUtils.unrollUnionMembers(layerTypes.ROut).filter((_) => !(_.flags & ts.TypeFlags.Never))\n      requires = typeCheckerUtils.unrollUnionMembers(layerTypes.RIn).filter((_) => !(_.flags & ts.TypeFlags.Never))\n    }\n\n    return { node, layerType, layerTypes, provides, requires }\n  })\n\n  const addNode = Nano.fn(\"addNode\")(function*(node: ts.Node, nodeInfo?: LayerGraphNodeInfo) {\n    const graphNode = Graph.addNode(mutableGraph, nodeInfo ? nodeInfo : yield* extractNodeInfo(node))\n    nodeToGraph.set(node, graphNode)\n    return graphNode\n  })\n\n  while (nodeToVisit.length > 0) {\n    const node = nodeToVisit.pop()!\n\n    // iterate pipe members\n    const pipeArgs = yield* pipe(typeParser.pipeCall(node), Nano.orElse(() => Nano.void_))\n    if (pipeArgs) {\n      if (!visitedNodes.has(node)) {\n        // visit the pipe members, from last to first, then come back to the node\n        appendNodeToVisit(node)\n        appendNodeToVisit(pipeArgs.subject)\n        pipeArgs.args.forEach(appendNodeToVisit)\n        pipeArgs.args.forEach((_) => nodeInPipeContext.add(_))\n        visitedNodes.add(node)\n      } else {\n        // already visited\n        const childNodes = [pipeArgs.subject, ...pipeArgs.args].map((_) => nodeToGraph.get(_)).filter(\n          Predicate.isNumber\n        ).filter(\n          (_) => Graph.hasNode(mutableGraph, _)\n        )\n        if (childNodes.length === pipeArgs.args.length + 1) {\n          // all members are graph nodes, link them up in reverse order\n          let lastNode: number | null = null\n          for (const childNode of childNodes) {\n            if (lastNode !== null) Graph.addEdge(mutableGraph, childNode, lastNode, { relationship: \"pipe\" })\n            lastNode = childNode\n          }\n          if (lastNode !== null) {\n            // and finally a node for the pipe call which links to the last one\n            const graphNode = yield* addNode(node)\n            Graph.addEdge(mutableGraph, graphNode, lastNode, { relationship: \"pipe\" })\n          }\n        } else {\n          // not every member is a graph node, remove the nodes\n          childNodes.forEach((_) => Graph.removeNode(mutableGraph, _))\n          // and if I return a layer, add a node for it\n          const nodeInfo = yield* extractNodeInfo(node)\n          if (nodeInfo.layerTypes) yield* addNode(node, nodeInfo)\n        }\n      }\n      continue\n    }\n\n    // a call expression must evaluate the args first\n    if (ts.isCallExpression(node)) {\n      // if we are exploding only layer api calls, we need to check if this is a layer api call\n      let shouldExplode = !opts.explodeOnlyLayerCalls\n      if (opts.explodeOnlyLayerCalls) {\n        const isLayerCall = ts.isPropertyAccessExpression(node.expression) &&\n          ts.isIdentifier(node.expression.expression) &&\n          ts.idText(node.expression.expression) === layerModuleName\n        if (isLayerCall) shouldExplode = true\n      }\n      // if we should explode\n      if (shouldExplode) {\n        if (!visitedNodes.has(node)) {\n          // visit the args first then come back\n          appendNodeToVisit(node)\n          node.arguments.forEach(appendNodeToVisit)\n          visitedNodes.add(node)\n        } else {\n          const childNodes = node.arguments.map((_) => nodeToGraph.get(_)).filter(Predicate.isNumber).filter((_) =>\n            Graph.hasNode(mutableGraph, _)\n          )\n\n          if (childNodes.length === node.arguments.length) {\n            // all members are graph nodes to link\n            const graphNode = yield* addNode(node)\n            childNodes.forEach((_, argumentIndex) =>\n              Graph.addEdge(mutableGraph, graphNode, _, { relationship: \"call\", argumentIndex })\n            )\n          } else {\n            // not every member is a graph node, remove the nodes and keep only me\n            childNodes.forEach((_) => Graph.removeNode(mutableGraph, _))\n            const nodeInfo = yield* extractNodeInfo(node)\n            if (nodeInfo.layerTypes) yield* addNode(node, nodeInfo)\n          }\n        }\n        continue\n      }\n    }\n\n    // array literal as merge, if enabled.\n    if (opts.arrayLiteralAsMerge && ts.isArrayLiteralExpression(node)) {\n      if (!visitedNodes.has(node)) {\n        appendNodeToVisit(node)\n        node.elements.forEach(appendNodeToVisit)\n        visitedNodes.add(node)\n      } else {\n        const childNodes = node.elements.map((_) => nodeToGraph.get(_)).filter(Predicate.isNumber).filter((_) =>\n          Graph.hasNode(mutableGraph, _)\n        )\n        if (childNodes.length > 0) {\n          const graphNode = yield* addNode(node)\n          childNodes.forEach((_, index) =>\n            Graph.addEdge(mutableGraph, graphNode, _, { relationship: \"arrayLiteral\", index })\n          )\n        }\n      }\n      continue\n    }\n\n    // just a plain expression, so probably the most basic building block\n    if (ts.isExpression(node)) {\n      const nodeInfo = yield* extractNodeInfo(node)\n      if (nodeInfo.layerTypes) {\n        yield* addNode(node, nodeInfo)\n        continue\n      }\n    }\n\n    // PANIC! We got something we don't understand.\n    return yield* Nano.fail(new UnableToProduceLayerGraphError(\"Unable to produce layer graph for node\", node))\n  }\n\n  return Graph.endMutation(mutableGraph)\n})\n\nexport const formatLayerGraph = Nano.fn(\"formatLayerGraph\")(function*(layerGraph: LayerGraph) {\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n  return Graph.toMermaid(layerGraph, {\n    edgeLabel: (edge) => JSON.stringify(edge),\n    nodeLabel: (graphNode) => {\n      const sourceFile = tsUtils.getSourceFileOfNode(graphNode.node)!\n      let text = sourceFile.text.substring(graphNode.node.pos, graphNode.node.end).trim()\n      text += \"\\nprovides: \" +\n        (graphNode.provides.map((_) => typeChecker.typeToString(_, undefined, ts.TypeFormatFlags.NoTruncation)).join(\n          \", \"\n        ))\n      text += \"\\nrequires: \" +\n        graphNode.requires.map((_) => typeChecker.typeToString(_, undefined, ts.TypeFormatFlags.NoTruncation)).join(\n          \", \"\n        )\n      return text\n    }\n  })\n})\n\nexport const formatNestedLayerGraph = Nano.fn(\"formatNestedLayerGraph\")(function*(layerGraph: LayerGraph) {\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n  const mermaidSafe = (value: string) =>\n    value.replace(/\\n/g, \" \").replace(\n      /\\s+/g,\n      \" \"\n    ).substring(0, 50).replace(/\"/g, \"#quot;\").replace(/</mg, \"#lt;\").replace(/>/mg, \"#gt;\").trim()\n\n  const typeNameCache = new Map<ts.Type, string>()\n  const typeName = (type: ts.Type) => {\n    if (typeNameCache.has(type)) return typeNameCache.get(type)!\n    const name = typeChecker.typeToString(type, undefined, ts.TypeFormatFlags.NoTruncation)\n    typeNameCache.set(type, name)\n    return name\n  }\n\n  let result: Array<string> = []\n\n  // create the boxes first\n  for (const [graphNodeIndex, graphNode] of Graph.entries(Graph.nodes(layerGraph))) {\n    let subgraphDefs: Array<string> = []\n    for (const kind of [\"requires\", \"provides\"] as const) {\n      const typesMermaidNodes: Array<string> = []\n      for (let i = 0; i < graphNode[kind].length; i++) {\n        typesMermaidNodes.push(`${graphNodeIndex}_${kind}_${i}[\"${mermaidSafe(typeName(graphNode[kind][i]))}\"]`)\n      }\n      if (typesMermaidNodes.length > 0) {\n        subgraphDefs = [\n          ...subgraphDefs,\n          `subgraph ${graphNodeIndex}_${kind} [${kind === \"provides\" ? \"Provides\" : \"Requires\"}]`,\n          ...typesMermaidNodes.map((_) => `  ${_}`),\n          `end`,\n          `style ${graphNodeIndex}_${kind} stroke:none`\n        ]\n      }\n    }\n    subgraphDefs = [\n      `subgraph ${graphNodeIndex}_wrap[\" \"]`,\n      ...subgraphDefs.map((_) => `  ${_}`),\n      `end`,\n      `style ${graphNodeIndex}_wrap fill:transparent`,\n      `style ${graphNodeIndex}_wrap stroke:none`\n    ]\n    const sourceFile = tsUtils.getSourceFileOfNode(graphNode.node)!\n    const nodePosition = graphNode.node.getStart(sourceFile, false)\n    const { character, line } = ts.getLineAndCharacterOfPosition(sourceFile, nodePosition)\n    const nodeText = sourceFile.text.substring(graphNode.node.pos, graphNode.node.end).trim()\n    result = [\n      ...result,\n      `subgraph ${graphNodeIndex} [\"\\`${mermaidSafe(nodeText)}<br/>_at ln ${line + 1} col ${character}_\\`\"]`,\n      ...subgraphDefs.map((_) => `  ${_}`),\n      `end`,\n      `style ${graphNodeIndex} fill:transparent`\n    ]\n  }\n\n  // and then the edges\n  for (const edgeInfo of Graph.values(Graph.edges(layerGraph))) {\n    const sourceData = layerGraph.nodes.get(edgeInfo.source)!\n    const targetData = layerGraph.nodes.get(edgeInfo.target)!\n    let connected: boolean = false\n    for (const kind of [\"requires\", \"provides\"] as const) {\n      for (let i = 0; i < sourceData[kind].length; i++) {\n        const targetIdx = targetData[kind].indexOf(sourceData[kind][i])\n        if (targetIdx > -1) {\n          result.push(`${edgeInfo.source}_${kind}_${i} -.-> ${edgeInfo.target}_${kind}_${targetIdx}`)\n          connected = true\n        }\n      }\n    }\n    if (!connected) {\n      result.push(`${edgeInfo.source} -.-x ${edgeInfo.target}`)\n    }\n  }\n\n  return [\n    `flowchart TB`,\n    ...result.map((_) => `  ${_}`)\n  ].join(\"\\n\")\n})\n\nexport interface LayerOutlineGraphNodeInfo {\n  node: ts.Node\n  requires: Array<ts.Type>\n  provides: Array<ts.Type>\n}\n\nexport type LayerOutlineGraph = Graph.Graph<LayerOutlineGraphNodeInfo, {}, \"directed\">\n\n// traverse the layer graph and create the outline graph\nexport const extractOutlineGraph = Nano.fn(\"extractOutlineGraph\")(function*(layerGraph: LayerGraph) {\n  const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n  const mutableGraph = Graph.beginMutation(Graph.directed<LayerOutlineGraphNodeInfo, {}>())\n\n  const providers = new Map<ts.Type, Array<Graph.NodeIndex>>()\n  const knownSymbols = new WeakSet<ts.Symbol>()\n\n  const leafNodes = Graph.values(Graph.externals(layerGraph, { direction: \"outgoing\" }))\n  const dedupedLeafNodes: Array<LayerGraphNodeInfo> = []\n\n  for (const leafNode of leafNodes) {\n    const symbol = typeChecker.getSymbolAtLocation(leafNode.node)\n    if (!symbol) {\n      dedupedLeafNodes.push(leafNode)\n    } else if (symbol && !knownSymbols.has(symbol)) {\n      dedupedLeafNodes.push(leafNode)\n      knownSymbols.add(symbol)\n    }\n  }\n\n  // dedupe leafNodes by using the type\n  for (const leafNode of dedupedLeafNodes) {\n    const nodeIndex = Graph.addNode(mutableGraph, {\n      node: leafNode.node,\n      requires: leafNode.requires,\n      provides: leafNode.provides\n    })\n    for (const providedType of leafNode.provides) {\n      // ignore provided and self-required\n      if (leafNode.requires.indexOf(providedType) > -1) continue\n      // add this node to providers\n      const previousProviders = providers.get(providedType) || []\n      providers.set(providedType, [...previousProviders, nodeIndex])\n    }\n  }\n\n  // connect requires to providers\n  for (const [nodeIndex, nodeInfo] of Graph.entries(Graph.nodes(mutableGraph))) {\n    for (const requiredType of nodeInfo.requires) {\n      for (const [providedType, providerNodeIndexes] of providers.entries()) {\n        if (requiredType === providedType || typeChecker.isTypeAssignableTo(requiredType, providedType)) {\n          for (const providerNodeIndex of providerNodeIndexes) {\n            Graph.addEdge(mutableGraph, nodeIndex, providerNodeIndex, {})\n          }\n        }\n      }\n    }\n  }\n\n  return Graph.endMutation(mutableGraph)\n})\n\nexport const formatLayerOutlineGraph = Nano.fn(\"formatLayerOutlineGraph\")(\n  function*(layerOutlineGraph: LayerOutlineGraph) {\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    return Graph.toMermaid(layerOutlineGraph, {\n      edgeLabel: () => \"\",\n      nodeLabel: (graphNode) => {\n        const sourceFile = tsUtils.getSourceFileOfNode(graphNode.node)!\n        return sourceFile.text.substring(graphNode.node.pos, graphNode.node.end).trim()\n      }\n    })\n  }\n)\n\nexport interface LayerMagicNode {\n  merges: boolean\n  provides: boolean\n  layerExpression: ts.Expression\n}\n\nexport interface LayerMagicResult {\n  layerMagicNodes: Array<LayerMagicNode>\n  missingOutputTypes: Set<ts.Type>\n}\n\n// converts an outline graph into a set of provide/provideMerge with target output\nexport const convertOutlineGraphToLayerMagic = Nano.fn(\"convertOutlineGraphToLayerMagic\")(\n  function*(outlineGraph: LayerOutlineGraph, targetOutput: ts.Type) {\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n    const result: Array<LayerMagicNode> = []\n\n    const missingOutputTypes = new Set(typeCheckerUtils.unrollUnionMembers(targetOutput))\n    const currentRequiredTypes = new Set<ts.Type>()\n\n    // no need to filter because the outline graph is already deduplicated and only keeping childs\n    const reversedGraph = Graph.mutate(outlineGraph, Graph.reverse)\n    const rootIndexes = Array.fromIterable(Graph.indices(Graph.externals(reversedGraph, { direction: \"incoming\" })))\n    const allNodes = Array.fromIterable(Graph.values(Graph.dfsPostOrder(reversedGraph, { start: rootIndexes })))\n    for (const nodeInfo of allNodes) {\n      if (!ts.isExpression(nodeInfo.node)) continue\n      const reallyProvidedTypes = nodeInfo.provides.filter((_) => nodeInfo.requires.indexOf(_) === -1)\n      const shouldMerge = reallyProvidedTypes.some((_) => missingOutputTypes.has(_))\n      if (shouldMerge) {\n        reallyProvidedTypes.forEach((_) => missingOutputTypes.delete(_))\n      }\n      nodeInfo.provides.forEach((_) => currentRequiredTypes.delete(_))\n      nodeInfo.requires.forEach((_) => currentRequiredTypes.add(_))\n      result.push({\n        merges: shouldMerge,\n        provides: true,\n        layerExpression: nodeInfo.node\n      })\n    }\n\n    return {\n      layerMagicNodes: result,\n      missingOutputTypes\n    }\n  }\n)\n\n// walk the graph and emit nodes matching the predicate, where no children match the predicate\nexport const walkLeavesMatching = <N, E, T extends Graph.Kind = \"directed\">(\n  graph: Graph.Graph<N, E, T> | Graph.MutableGraph<N, E, T>,\n  predicate: (node: N) => boolean,\n  config: Graph.SearchConfig = {}\n): Graph.NodeWalker<N> => {\n  const start = config.start ?? []\n  const direction = config.direction ?? \"outgoing\"\n\n  return new Graph.Walker((f) => ({\n    [Symbol.iterator]: () => {\n      let queue = [...start]\n      const discovered = new Set<Graph.NodeIndex>()\n\n      const nextMapped = () => {\n        while (queue.length > 0) {\n          const current = queue.shift()!\n\n          if (discovered.has(current)) continue\n          discovered.add(current)\n\n          const neighbors = Graph.neighborsDirected(graph, current, direction)\n          const neighborsMatching: Array<Graph.NodeIndex> = []\n          for (const neighbor of neighbors) {\n            const neighborNode = Graph.getNode(graph, neighbor)\n            if (Option.isSome(neighborNode) && predicate(neighborNode.value)) {\n              neighborsMatching.push(neighbor)\n            }\n          }\n\n          if (neighborsMatching.length > 0) {\n            queue = [...queue, ...neighborsMatching]\n          } else {\n            const nodeData = Graph.getNode(graph, current)\n            if (Option.isSome(nodeData) && predicate(nodeData.value)) {\n              return { done: false, value: f(current, nodeData.value) }\n            }\n          }\n        }\n\n        return { done: true, value: undefined } as const\n      }\n\n      return { next: nextMapped }\n    }\n  }))\n}\n\nexport interface LayerProvidersAndRequirersInfoItem {\n  kind: \"provided\" | \"required\"\n  type: ts.Type\n  nodes: Array<ts.Node>\n}\n\nexport type LayerProvidersAndRequirersInfo = Array<LayerProvidersAndRequirersInfoItem>\n\n// given a layer graph, return the root providers and a list of nodes that introduced them, and same with requires\nexport const extractProvidersAndRequirers = Nano.fn(\"extractProvidersAndRequirers\")(\n  function*(layerGraph: LayerGraph) {\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const rootWalker = Graph.externals(layerGraph, { direction: \"incoming\" })\n    const rootNodes = Array.fromIterable(Graph.values(rootWalker))\n    const rootNodeIndexes = Array.fromIterable(Graph.indices(rootWalker))\n    const result: LayerProvidersAndRequirersInfo = []\n\n    const walkTypes = (rootTypes: Set<ts.Type>, kind: \"provided\" | \"required\") => {\n      const sortedTypes = pipe(Array.fromIterable(rootTypes), Array.sort(typeCheckerUtils.deterministicTypeOrder))\n      for (const layerType of sortedTypes) {\n        const tsNodes: Array<ts.Node> = []\n        for (\n          const layerNode of Graph.values(\n            walkLeavesMatching(\n              layerGraph,\n              (_) =>\n                (kind === \"provided\" ? _.provides : _.requires).some((_) =>\n                  _ === layerType || typeChecker.isTypeAssignableTo(_, layerType)\n                ),\n              { start: rootNodeIndexes }\n            )\n          )\n        ) {\n          tsNodes.push(layerNode.node)\n        }\n        result.push({\n          kind,\n          type: layerType,\n          nodes: tsNodes\n        })\n      }\n    }\n\n    walkTypes(new Set(rootNodes.flatMap((_) => _.provides)), \"provided\")\n    walkTypes(new Set(rootNodes.flatMap((_) => _.requires)), \"required\")\n    return result\n  }\n)\n\nexport const formatLayerProvidersAndRequirersInfo = Nano.fn(\"formatLayerProvidersAndRequirersInfo\")(\n  function*(info: LayerProvidersAndRequirersInfo) {\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    if (info.length === 0) return \"\"\n\n    const textualExplanation: Array<string> = []\n\n    const appendInfo = (infoNode: LayerProvidersAndRequirersInfoItem) => {\n      const typeString = typeChecker.typeToString(\n        infoNode.type,\n        undefined,\n        ts.TypeFormatFlags.NoTruncation\n      )\n\n      const positions = infoNode.nodes.map((_) => {\n        const sourceFile = tsUtils.getSourceFileOfNode(_)!\n        const nodePosition = ts.getTokenPosOfNode(_, sourceFile)\n        const { character, line } = ts.getLineAndCharacterOfPosition(sourceFile, nodePosition)\n        const nodeText = sourceFile.text.substring(_.pos, _.end).trim().replace(/\\n/g, \" \").substr(0, 50)\n        return `ln ${line + 1} col ${character} by \\`${nodeText}\\``\n      })\n\n      textualExplanation.push(`- ${typeString} ${infoNode.kind} at ${positions.join(\", \")}`)\n    }\n\n    const providedItems = info.filter((_) => _.kind === \"provided\")\n    const requiredItems = info.filter((_) => _.kind === \"required\")\n    if (providedItems.length > 0) {\n      for (const item of providedItems) {\n        appendInfo(item)\n      }\n      if (textualExplanation.length > 0 && requiredItems.length > 0) textualExplanation.push(\"\")\n    }\n    if (requiredItems.length > 0) {\n      for (const item of requiredItems) {\n        appendInfo(item)\n      }\n    }\n    return \"/**\\n\" + textualExplanation.map((l) => \" * \" + l).join(\"\\n\") +\n      \"\\n */\"\n  }\n)\n","import * as Array from \"effect/Array\"\nimport * as Encoding from \"effect/Encoding\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as pako from \"pako\"\nimport type * as ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions\"\nimport * as LayerGraph from \"../core/LayerGraph\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi\"\nimport * as TypeParser from \"../core/TypeParser\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nfunction generateMarmaidUri(\n  code: string\n): Nano.Nano<string, never, TypeScriptApi.TypeScriptApi | TypeCheckerApi.TypeCheckerApi> {\n  return Nano.gen(function*() {\n    const state = JSON.stringify({ code })\n    const data = new TextEncoder().encode(state)\n    const compressed = pako.deflate(data, { level: 9 })\n    const pakoString = \"pako:\" + Encoding.encodeBase64Url(compressed)\n    return \"https://www.mermaidchart.com/play#\" + pakoString\n  })\n}\n\nfunction getAdjustedNode(\n  sourceFile: ts.SourceFile,\n  position: number\n) {\n  return Nano.gen(function*() {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    // find the node we are hovering\n    const range = tsUtils.toTextRange(position)\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, range),\n      Array.filter((_) => ts.isVariableDeclaration(_) || ts.isPropertyDeclaration(_)),\n      Array.filter((_) => tsUtils.isNodeInRange(range)(_.name)),\n      Array.head\n    )\n    if (Option.isNone(maybeNode)) return undefined\n    const node = maybeNode.value\n    const layerNode = node.initializer\n      ? node.initializer\n      : node\n\n    const layerType = typeChecker.getTypeAtLocation(layerNode)\n    const maybeLayer = yield* Nano.option(typeParser.layerType(layerType, layerNode))\n\n    if (Option.isNone(maybeLayer)) return undefined\n\n    return { node, layerNode }\n  })\n}\n\nfunction parseLayerGraph(\n  layerNode: ts.Node\n) {\n  return Nano.gen(function*() {\n    const layerGraph = yield* LayerGraph.extractLayerGraph(layerNode, {\n      arrayLiteralAsMerge: false,\n      explodeOnlyLayerCalls: false\n    })\n    const nestedGraphMermaid = yield* LayerGraph.formatNestedLayerGraph(layerGraph)\n\n    const outlineGraph = yield* LayerGraph.extractOutlineGraph(layerGraph)\n    const outlineGraphMermaid = yield* LayerGraph.formatLayerOutlineGraph(outlineGraph)\n    const providersAndRequirers = yield* LayerGraph.extractProvidersAndRequirers(layerGraph)\n    const providersAndRequirersTextualExplanation = yield* LayerGraph.formatLayerProvidersAndRequirersInfo(\n      providersAndRequirers\n    )\n    return { nestedGraphMermaid, outlineGraphMermaid, providersAndRequirersTextualExplanation }\n  })\n}\n\nexport function effectApiGetLayerGraph(\n  sourceFile: ts.SourceFile,\n  line: number,\n  character: number\n) {\n  return Nano.gen(function*() {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const position = ts.getPositionOfLineAndCharacter(sourceFile, line, character)\n    const maybeNodes = yield* getAdjustedNode(sourceFile, position)\n    if (!maybeNodes) return yield* Nano.fail(new LayerGraph.UnableToProduceLayerGraphError(\"No node found\"))\n    const { layerNode, node } = maybeNodes\n    const { nestedGraphMermaid } = yield* parseLayerGraph(layerNode)\n    return { start: node.pos, end: node.end, mermaidCode: nestedGraphMermaid }\n  })\n}\n\nexport function layerInfo(\n  sourceFile: ts.SourceFile,\n  position: number,\n  quickInfo: ts.QuickInfo | undefined\n) {\n  return pipe(\n    Nano.gen(function*() {\n      const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n      const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n      const maybeNodes = yield* getAdjustedNode(sourceFile, position)\n      if (!maybeNodes) return quickInfo\n      const { layerNode, node } = maybeNodes\n\n      const layerInfoDisplayParts = yield* pipe(\n        parseLayerGraph(layerNode),\n        Nano.flatMap(({ nestedGraphMermaid, outlineGraphMermaid, providersAndRequirersTextualExplanation }) =>\n          Nano.gen(function*() {\n            const linkParts: Array<ts.SymbolDisplayPart> = []\n            if (!options.noExternal) {\n              const mermaidUri = yield* generateMarmaidUri(nestedGraphMermaid)\n              const outlineMermaidUri = yield* generateMarmaidUri(outlineGraphMermaid)\n              linkParts.push({ kind: \"space\", text: \"\\n\" })\n              linkParts.push({ kind: \"link\", text: \"{@link \" })\n              linkParts.push({ kind: \"linkText\", text: mermaidUri + \" Show full Layer graph\" })\n              linkParts.push({ kind: \"link\", text: \"}\" })\n              linkParts.push({ kind: \"text\", text: \" - \" })\n              linkParts.push({ kind: \"link\", text: \"{@link \" })\n              linkParts.push({ kind: \"linkText\", text: outlineMermaidUri + \" Show Layer outline\" })\n              linkParts.push({ kind: \"link\", text: \"}\" })\n              linkParts.push({ kind: \"space\", text: \"\\n\" })\n            }\n            if (providersAndRequirersTextualExplanation.length === 0) return linkParts\n            return [\n              {\n                kind: \"text\",\n                text: (\n                  \"```\\n\" +\n                  providersAndRequirersTextualExplanation +\n                  \"\\n```\\n\"\n                )\n              },\n              ...linkParts\n            ]\n          })\n        ),\n        Nano.orElse(() => Nano.succeed([] as Array<ts.SymbolDisplayPart>))\n      )\n\n      // nothing to show\n      if (layerInfoDisplayParts.length === 0) return quickInfo\n\n      // there are cases where we create it from scratch\n      if (!quickInfo) {\n        const start = ts.getTokenPosOfNode(node, sourceFile)\n        const end = node.end\n        return {\n          kind: ts.ScriptElementKind.callSignatureElement,\n          kindModifiers: \"\",\n          textSpan: { start, length: end - start },\n          documentation: layerInfoDisplayParts\n        } satisfies ts.QuickInfo\n      }\n\n      // add to existing documentation\n      if (quickInfo.documentation) {\n        return {\n          ...quickInfo,\n          documentation: quickInfo.documentation.concat([{ kind: \"space\", text: \"\\n\" }]).concat(layerInfoDisplayParts)\n        }\n      }\n\n      return {\n        ...quickInfo,\n        documentation: layerInfoDisplayParts\n      }\n    }),\n    Nano.orElse(() => Nano.succeed(quickInfo))\n  )\n}\n","import type ts from \"typescript\"\nimport type * as LanguageServicePluginOptions from \"./core/LanguageServicePluginOptions.js\"\nimport * as Nano from \"./core/Nano.js\"\nimport type * as TypeCheckerApi from \"./core/TypeCheckerApi.js\"\nimport type * as TypeCheckerUtils from \"./core/TypeCheckerUtils.js\"\nimport type * as TypeParser from \"./core/TypeParser.js\"\nimport type * as TypeScriptApi from \"./core/TypeScriptApi.js\"\nimport type * as TypeScriptUtils from \"./core/TypeScriptUtils.js\"\nimport { dedupeJsDocs } from \"./quickinfo/dedupeJsDocs.js\"\nimport { effectTypeArgs } from \"./quickinfo/effectTypeArgs.js\"\nimport { layerInfo } from \"./quickinfo/layerInfo.js\"\n\nexport function quickInfo(\n  sourceFile: ts.SourceFile,\n  position: number,\n  quickInfo: ts.QuickInfo | undefined\n): Nano.Nano<\n  ts.QuickInfo | undefined,\n  never,\n  | TypeScriptApi.TypeScriptApi\n  | TypeScriptUtils.TypeScriptUtils\n  | TypeCheckerApi.TypeCheckerApi\n  | TypeParser.TypeParser\n  | TypeCheckerUtils.TypeCheckerUtils\n  | LanguageServicePluginOptions.LanguageServicePluginOptions\n> {\n  return Nano.gen(function*() {\n    const deduped = yield* dedupeJsDocs(quickInfo)\n    const withEffectTypeArgs = yield* effectTypeArgs(sourceFile, position, deduped)\n    const withLayerInfo = yield* layerInfo(sourceFile, position, withEffectTypeArgs)\n    return withLayerInfo\n  })\n}\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const asyncAwaitToFn = LSP.createRefactor({\n  name: \"asyncAwaitToFn\",\n  description: \"Convert to Effect.fn\",\n  apply: Nano.fn(\"asyncAwaitToFn.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter((node) =>\n        ts.isFunctionDeclaration(node) || ts.isArrowFunction(node) ||\n        ts.isFunctionExpression(node)\n      ),\n      Array.filter((node) => !!node.body),\n      Array.filter((node) => !!(ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Async)),\n      Array.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.asyncAwaitToFn\",\n      description: \"Rewrite to Effect.fn\",\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n            sourceFile,\n            \"effect\",\n            \"Effect\"\n          ) || \"Effect\"\n\n          const newDeclaration = tsUtils.transformAsyncAwaitToEffectFn(\n            node,\n            effectModuleIdentifierName,\n            (expression) =>\n              ts.factory.createCallExpression(\n                ts.factory.createPropertyAccessExpression(\n                  ts.factory.createIdentifier(effectModuleIdentifierName),\n                  \"promise\"\n                ),\n                undefined,\n                [\n                  ts.factory.createArrowFunction(\n                    undefined,\n                    undefined,\n                    [],\n                    undefined,\n                    undefined,\n                    expression\n                  )\n                ]\n              )\n          )\n\n          changeTracker.replaceNode(sourceFile, node, newDeclaration)\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n        Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker)\n      )\n    })\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const asyncAwaitToFnTryPromise = LSP.createRefactor({\n  name: \"asyncAwaitToFnTryPromise\",\n  description: \"Convert to Effect.fn with failures\",\n  apply: Nano.fn(\"asyncAwaitToFnTryPromise.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter(\n        (node) =>\n          ts.isFunctionDeclaration(node) || ts.isArrowFunction(node) ||\n          ts.isFunctionExpression(node)\n      ),\n      Array.filter((node) => !!node.body),\n      Array.filter((node) => !!(ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Async)),\n      Array.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.asyncAwaitToFnTryPromise\",\n      description: \"Rewrite to Effect.fn with failures\",\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n            sourceFile,\n            \"effect\",\n            \"Effect\"\n          ) || \"Effect\"\n\n          const dataModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n            sourceFile,\n            \"effect\",\n            \"Data\"\n          ) || \"Data\"\n\n          let errorCount = 0\n          const errors: Array<ts.ClassDeclaration> = []\n\n          function createErrorADT() {\n            errorCount++\n            const errorName = \"Error\" + errorCount\n            errors.push(tsUtils.createDataTaggedErrorDeclaration(dataModuleIdentifierName, errorName, [\n              ts.factory.createPropertySignature(\n                undefined,\n                \"cause\",\n                undefined,\n                ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)\n              )\n            ]))\n            return ts.factory.createNewExpression(\n              ts.factory.createIdentifier(errorName),\n              undefined,\n              [ts.factory.createObjectLiteralExpression([\n                ts.factory.createShorthandPropertyAssignment(\"cause\")\n              ])]\n            )\n          }\n\n          const newDeclaration = tsUtils.transformAsyncAwaitToEffectFn(\n            node,\n            effectModuleIdentifierName,\n            (expression) =>\n              ts.factory.createCallExpression(\n                ts.factory.createPropertyAccessExpression(\n                  ts.factory.createIdentifier(effectModuleIdentifierName),\n                  \"tryPromise\"\n                ),\n                undefined,\n                [\n                  ts.factory.createObjectLiteralExpression([\n                    ts.factory.createPropertyAssignment(\n                      ts.factory.createIdentifier(\"try\"),\n                      ts.factory.createArrowFunction(\n                        undefined,\n                        undefined,\n                        [],\n                        undefined,\n                        undefined,\n                        expression\n                      )\n                    ),\n                    ts.factory.createPropertyAssignment(\n                      ts.factory.createIdentifier(\"catch\"),\n                      ts.factory.createArrowFunction(\n                        undefined,\n                        undefined,\n                        [ts.factory.createParameterDeclaration(undefined, undefined, \"cause\")],\n                        undefined,\n                        undefined,\n                        createErrorADT()\n                      )\n                    )\n                  ])\n                ]\n              )\n          )\n\n          let beforeNode: ts.Node = node\n          while (beforeNode.parent && !ts.isSourceFile(beforeNode.parent)) {\n            beforeNode = beforeNode.parent\n          }\n\n          for (const error of errors) {\n            changeTracker.insertNodeBefore(sourceFile, beforeNode, error, true)\n          }\n\n          changeTracker.replaceNode(sourceFile, node, newDeclaration)\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n        Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker)\n      )\n    })\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const asyncAwaitToGen = LSP.createRefactor({\n  name: \"asyncAwaitToGen\",\n  description: \"Convert to Effect.gen\",\n  apply: Nano.fn(\"asyncAwaitToGen.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter((node) =>\n        ts.isFunctionDeclaration(node) || ts.isArrowFunction(node) ||\n        ts.isFunctionExpression(node)\n      ),\n      Array.filter((node) => !!node.body),\n      Array.filter((node) => !!(ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Async)),\n      Array.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.asyncAwaitToGen\",\n      description: \"Rewrite to Effect.gen\",\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n            sourceFile,\n            \"effect\",\n            \"Effect\"\n          ) || \"Effect\"\n\n          const newDeclaration = tsUtils.transformAsyncAwaitToEffectGen(\n            node,\n            effectModuleIdentifierName,\n            (expression) =>\n              ts.factory.createCallExpression(\n                ts.factory.createPropertyAccessExpression(\n                  ts.factory.createIdentifier(effectModuleIdentifierName),\n                  \"promise\"\n                ),\n                undefined,\n                [\n                  ts.factory.createArrowFunction(\n                    undefined,\n                    undefined,\n                    [],\n                    undefined,\n                    undefined,\n                    expression\n                  )\n                ]\n              )\n          )\n\n          changeTracker.replaceNode(sourceFile, node, newDeclaration)\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n        Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker)\n      )\n    })\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const asyncAwaitToGenTryPromise = LSP.createRefactor({\n  name: \"asyncAwaitToGenTryPromise\",\n  description: \"Convert to Effect.gen with failures\",\n  apply: Nano.fn(\"asyncAwaitToGenTryPromise.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter(\n        (node) =>\n          ts.isFunctionDeclaration(node) || ts.isArrowFunction(node) ||\n          ts.isFunctionExpression(node)\n      ),\n      Array.filter((node) => !!node.body),\n      Array.filter((node) => !!(ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Async)),\n      Array.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.asyncAwaitToGenTryPromise\",\n      description: \"Rewrite to Effect.gen with failures\",\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n            sourceFile,\n            \"effect\",\n            \"Effect\"\n          ) || \"Effect\"\n\n          const dataModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n            sourceFile,\n            \"effect\",\n            \"Data\"\n          ) || \"Data\"\n\n          let errorCount = 0\n          const errors: Array<ts.ClassDeclaration> = []\n\n          function createErrorADT() {\n            errorCount++\n            const errorName = \"Error\" + errorCount\n            errors.push(tsUtils.createDataTaggedErrorDeclaration(dataModuleIdentifierName, errorName, [\n              ts.factory.createPropertySignature(\n                undefined,\n                \"cause\",\n                undefined,\n                ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)\n              )\n            ]))\n            return ts.factory.createNewExpression(\n              ts.factory.createIdentifier(errorName),\n              undefined,\n              [ts.factory.createObjectLiteralExpression([\n                ts.factory.createShorthandPropertyAssignment(\"cause\")\n              ])]\n            )\n          }\n\n          const newDeclaration = tsUtils.transformAsyncAwaitToEffectGen(\n            node,\n            effectModuleIdentifierName,\n            (expression) =>\n              ts.factory.createCallExpression(\n                ts.factory.createPropertyAccessExpression(\n                  ts.factory.createIdentifier(effectModuleIdentifierName),\n                  \"tryPromise\"\n                ),\n                undefined,\n                [\n                  ts.factory.createObjectLiteralExpression([\n                    ts.factory.createPropertyAssignment(\n                      ts.factory.createIdentifier(\"try\"),\n                      ts.factory.createArrowFunction(\n                        undefined,\n                        undefined,\n                        [],\n                        undefined,\n                        undefined,\n                        expression\n                      )\n                    ),\n                    ts.factory.createPropertyAssignment(\n                      ts.factory.createIdentifier(\"catch\"),\n                      ts.factory.createArrowFunction(\n                        undefined,\n                        undefined,\n                        [ts.factory.createParameterDeclaration(undefined, undefined, \"cause\")],\n                        undefined,\n                        undefined,\n                        createErrorADT()\n                      )\n                    )\n                  ])\n                ]\n              )\n          )\n\n          let beforeNode: ts.Node = node\n          while (beforeNode.parent && !ts.isSourceFile(beforeNode.parent)) {\n            beforeNode = beforeNode.parent\n          }\n\n          for (const error of errors) {\n            changeTracker.insertNodeBefore(sourceFile, beforeNode, error, true)\n          }\n\n          changeTracker.replaceNode(sourceFile, node, newDeclaration)\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n        Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker)\n      )\n    })\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const effectGenToFn = LSP.createRefactor({\n  name: \"effectGenToFn\",\n  description: \"Convert to Effect.fn\",\n  apply: Nano.fn(\"effectGenToFn.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const skipReturnBlock = (node: ts.Node) =>\n      ts.isBlock(node) && node.statements.length === 1 && ts.isReturnStatement(node.statements[0]) &&\n        node.statements[0].expression\n        ? node.statements[0].expression\n        : node\n\n    const parseFunctionLikeReturnEffectGen = Nano.fn(\"parseFunctionLikeReturnEffect.apply\")(function*(node: ts.Node) {\n      if ((ts.isArrowFunction(node) || ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node)) && node.body) {\n        let subject = skipReturnBlock(node.body)\n        let pipeArgs: Array<ts.Expression> = []\n        while (true) {\n          // there may be some .pipe calls, we need to move them to the new Effect.fn\n          const maybePipe = yield* Nano.option(typeParser.pipeCall(subject))\n          if (Option.isNone(maybePipe)) break\n          subject = maybePipe.value.subject\n          pipeArgs = maybePipe.value.args.concat(pipeArgs)\n        }\n        const fnIdentifier = node.name && ts.isIdentifier(node.name)\n          ? node.name\n          : ts.isVariableDeclaration(node.parent) && node.parent.name && ts.isIdentifier(node.parent.name)\n          ? node.parent.name\n          : undefined\n        const effectGen = yield* typeParser.effectGen(subject)\n        return ({ ...effectGen, nodeToReplace: node, pipeArgs, fnIdentifier })\n      }\n      return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    })\n\n    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange)\n    if (parentNodes.length === 0) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n\n    const nodesFromInitializers: Array<ts.Node> = pipe(\n      parentNodes,\n      Array.filter((_): _ is ts.VariableDeclaration => ts.isVariableDeclaration(_) && _.initializer ? true : false),\n      Array.filter((_) => tsUtils.isNodeInRange(textRange)(_.name)),\n      Array.map((_) => _.initializer!)\n    )\n\n    const maybeNode = yield* pipe(\n      nodesFromInitializers.concat(parentNodes),\n      Array.map(parseFunctionLikeReturnEffectGen),\n      Nano.firstSuccessOf,\n      Nano.option\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const { effectModule, fnIdentifier, generatorFunction, nodeToReplace, pipeArgs } = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.effectGenToFn\",\n      description: fnIdentifier ? `Convert to Effect.fn(\"${ts.idText(fnIdentifier)}\")` : \"Convert to Effect.fn\",\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n          // if we have a name in the function declaration,\n          // we call Effect.fn with the name\n          const effectFn = fnIdentifier ?\n            ts.factory.createCallExpression(\n              ts.factory.createPropertyAccessExpression(\n                effectModule,\n                \"fn\"\n              ),\n              undefined,\n              [ts.factory.createStringLiteral(ts.idText(fnIdentifier))]\n            ) :\n            ts.factory.createPropertyAccessExpression(\n              effectModule,\n              \"fn\"\n            )\n          // append the generator and pipe arguments to the Effect.fn call\n          const effectFnCallWithGenerator = ts.factory.createCallExpression(\n            effectFn,\n            undefined,\n            [ts.factory.createFunctionExpression(\n              undefined,\n              ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n              undefined,\n              nodeToReplace.typeParameters,\n              nodeToReplace.parameters,\n              nodeToReplace.type,\n              generatorFunction.body\n            ) as ts.Expression].concat(pipeArgs)\n          )\n          changeTracker.replaceNode(\n            sourceFile,\n            nodeToReplace,\n            tsUtils.tryPreserveDeclarationSemantics(nodeToReplace, effectFnCallWithGenerator, false)\n          )\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n      )\n    })\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const functionToArrow = LSP.createRefactor({\n  name: \"functionToArrow\",\n  description: \"Convert to arrow\",\n  apply: Nano.fn(\"functionToArrow.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter((_) => ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_)),\n      Array.filter((_) => !!_.body),\n      Array.filter((_) => !!_.name && tsUtils.isNodeInRange(textRange)(_.name)),\n      Array.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.functionToArrow\",\n      description: \"Convert to arrow\",\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n          const body = node.body!\n          let newBody: ts.ConciseBody = ts.factory.createBlock(body.statements)\n          if (body.statements.length === 1) {\n            const statement = body.statements[0]\n            if (statement && ts.isReturnStatement(statement) && statement.expression) {\n              newBody = statement.expression!\n            }\n          }\n\n          let arrowFlags = ts.getCombinedModifierFlags(node)\n          arrowFlags &= ~ts.ModifierFlags.Export\n          arrowFlags &= ~ts.ModifierFlags.Default\n          const arrowModifiers = ts.factory.createModifiersFromModifierFlags(arrowFlags)\n\n          const arrowFunction = ts.factory.createArrowFunction(\n            arrowModifiers,\n            node.typeParameters,\n            node.parameters,\n            undefined,\n            ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n            newBody\n          )\n\n          const newDeclaration: ts.Node = tsUtils.tryPreserveDeclarationSemantics(\n            node,\n            arrowFunction,\n            false\n          )\n          changeTracker.replaceNode(sourceFile, node, newDeclaration, {\n            leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,\n            trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude\n          })\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n      )\n    })\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Graph from \"effect/Graph\"\nimport * as Option from \"effect/Option\"\nimport * as Order from \"effect/Order\"\nimport type ts from \"typescript\"\nimport * as LayerGraph from \"../core/LayerGraph.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const layerMagic = LSP.createRefactor({\n  name: \"layerMagic\",\n  description: \"Layer Magic\",\n  apply: Nano.fn(\"layerMagic.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const layerIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Layer\"\n    ) || \"Layer\"\n\n    const adjustedNode = (node: ts.Node): ts.Node => {\n      if (\n        node.parent &&\n        (ts.isVariableDeclaration(node.parent) || ts.isPropertyDeclaration(node.parent)) &&\n        ts.isIdentifier(node) &&\n        node.parent.initializer &&\n        node.parent.name === node\n      ) {\n        return node.parent.initializer\n      }\n      return node\n    }\n\n    const computeAsAnyAsLayerRefactor = (node: ts.Node) => {\n      const atLocation = adjustedNode(node)\n      return pipe(\n        LayerGraph.extractLayerGraph(atLocation, {\n          arrayLiteralAsMerge: true,\n          explodeOnlyLayerCalls: true\n        }),\n        Nano.flatMap(LayerGraph.extractOutlineGraph),\n        Nano.flatMap((extractedLayer) =>\n          Graph.nodeCount(extractedLayer) <= 1 ? TypeParser.TypeParserIssue.issue : Nano.succeed(extractedLayer)\n        ),\n        Nano.map((extractedLayers) => ({\n          kind: \"refactor.rewrite.effect.layerMagicPrepare\",\n          description: \"Prepare layers for automatic composition\",\n          apply: pipe(\n            Nano.gen(function*() {\n              const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n              const layerOutputTypes = new Set<ts.Type>()\n              for (const layer of Graph.values(Graph.nodes(extractedLayers))) {\n                layer.provides.forEach((_) => layerOutputTypes.add(_))\n              }\n              const layerNodes = pipe(\n                Graph.values(Graph.nodes(extractedLayers)),\n                Array.fromIterable,\n                Array.map((_) => _.node),\n                Array.filter(ts.isExpression),\n                Array.sort(Order.mapInput(\n                  Order.number,\n                  (_: ts.Node) => _.pos\n                ))\n              )\n\n              const previouslyProvided = yield* pipe(\n                typeParser.layerType(typeChecker.getTypeAtLocation(atLocation), atLocation),\n                Nano.map((_) => _.ROut),\n                Nano.option\n              )\n\n              const [existingBefore, newlyIntroduced] = pipe(\n                Array.fromIterable(layerOutputTypes),\n                Array.sort(typeCheckerUtils.deterministicTypeOrder),\n                Array.partition((_) =>\n                  Option.isNone(previouslyProvided) || typeChecker.isTypeAssignableTo(_, previouslyProvided.value)\n                )\n              )\n\n              const typeReferences = pipe(\n                newlyIntroduced,\n                Array.map((_) => typeChecker.typeToTypeNode(_, undefined, ts.NodeBuilderFlags.NoTruncation)),\n                Array.filter((_) => !!_)\n              )\n\n              const providesUnion = typeReferences.length === 0\n                ? ts.factory.createTypeReferenceNode(\"never\")\n                : ts.factory.createUnionTypeNode(typeReferences)\n\n              const typeStrings = pipe(\n                existingBefore,\n                Array.map((_) => typeChecker.typeToString(_, undefined, ts.TypeFormatFlags.NoTruncation)),\n                Array.filter((_) => !!_)\n              )\n\n              const unionWithComment = typeStrings.length === 0\n                ? providesUnion\n                : ts.addSyntheticTrailingComment(\n                  providesUnion,\n                  ts.SyntaxKind.MultiLineCommentTrivia,\n                  \" \" + typeStrings.join(\" | \") + \" \",\n                  false\n                )\n\n              const newDeclaration = ts.factory.createAsExpression(\n                ts.factory.createAsExpression(\n                  ts.factory.createArrayLiteralExpression(layerNodes),\n                  ts.factory.createTypeReferenceNode(\"any\")\n                ),\n                ts.factory.createTypeReferenceNode(\n                  ts.factory.createQualifiedName(ts.factory.createIdentifier(layerIdentifier), \"Layer\"),\n                  [unionWithComment]\n                )\n              )\n\n              changeTracker.replaceNode(sourceFile, atLocation, newDeclaration, {\n                leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,\n                trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude\n              })\n            }),\n            Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n          )\n        }))\n      )\n    }\n\n    const parseAsAnyAsLayer: (\n      node: ts.Node\n    ) => Nano.Nano<\n      { castedStructure: ts.Expression; ROut: ts.Type },\n      TypeParser.TypeParserIssue,\n      never\n    > = (node: ts.Node) => {\n      if (ts.isAsExpression(node) && ts.isTypeReferenceNode(node.type)) {\n        const expression = node.expression\n        if (\n          ts.isAsExpression(expression) && expression.type.kind === ts.SyntaxKind.AnyKeyword\n        ) {\n          const type = typeChecker.getTypeAtLocation(node.type)\n          return pipe(\n            typeParser.layerType(type, node.type),\n            Nano.map((_) => ({ node, ..._, castedStructure: expression.expression }))\n          )\n        }\n      }\n      return TypeParser.TypeParserIssue.issue\n    }\n\n    const computeBuildRefactor = (node: ts.Node) => {\n      const atLocation = adjustedNode(node)\n      return pipe(\n        parseAsAnyAsLayer(atLocation),\n        Nano.flatMap((_targetLayer) =>\n          pipe(\n            LayerGraph.extractLayerGraph(_targetLayer.castedStructure, {\n              arrayLiteralAsMerge: true,\n              explodeOnlyLayerCalls: true\n            }),\n            Nano.flatMap(LayerGraph.extractOutlineGraph),\n            Nano.flatMap((extractedLayer) =>\n              Graph.nodeCount(extractedLayer) <= 1 ? TypeParser.TypeParserIssue.issue : Nano.succeed(extractedLayer)\n            ),\n            Nano.map((extractedLayers) => ({\n              kind: \"refactor.rewrite.effect.layerMagicBuild\",\n              description: \"Compose layers automatically with target output services\",\n              apply: Nano.gen(function*() {\n                const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                const { layerMagicNodes, missingOutputTypes } = yield* pipe(\n                  LayerGraph.convertOutlineGraphToLayerMagic(\n                    extractedLayers,\n                    _targetLayer.ROut\n                  ),\n                  Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker),\n                  Nano.provideService(TypeCheckerUtils.TypeCheckerUtils, typeCheckerUtils),\n                  Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n                )\n\n                // Use sorted nodes for further processing\n                const newDeclaration = ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    layerMagicNodes[0]!.layerExpression,\n                    \"pipe\"\n                  ),\n                  [],\n                  layerMagicNodes.slice(1).map((_) =>\n                    ts.factory.createCallExpression(\n                      ts.factory.createPropertyAccessExpression(\n                        ts.factory.createIdentifier(layerIdentifier),\n                        _.merges && _.provides ? \"provideMerge\" : _.merges ? \"merge\" : \"provide\"\n                      ),\n                      [],\n                      [_.layerExpression]\n                    )\n                  )\n                )\n\n                const newDeclarationWithComment = missingOutputTypes.size > 0\n                  ? ts.addSyntheticTrailingComment(\n                    newDeclaration,\n                    ts.SyntaxKind.MultiLineCommentTrivia,\n                    \" Unable to find \" + Array.fromIterable(missingOutputTypes.values()).map((_) =>\n                      typeChecker.typeToString(_, undefined, ts.TypeFormatFlags.NoTruncation)\n                    ).join(\", \") + \" in the provided layers. \",\n                    false\n                  ) :\n                  newDeclaration\n\n                changeTracker.replaceNode(sourceFile, atLocation, newDeclarationWithComment, {\n                  leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,\n                  trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude\n                })\n              })\n            }))\n          )\n        )\n      )\n    }\n\n    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange)\n    if (parentNodes.length === 0) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n\n    return yield* pipe(\n      Nano.firstSuccessOf(parentNodes.map(computeBuildRefactor)),\n      Nano.orElse(() => Nano.firstSuccessOf(parentNodes.map(computeAsAnyAsLayerRefactor))),\n      Nano.orElse(() => Nano.fail(new LSP.RefactorNotApplicableError()))\n    )\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const _findSchemaVariableDeclaration = Nano.fn(\n  \"makeSchemaOpaque._findSchemaVariableDeclaration\"\n)(\n  function*(sourceFile: ts.SourceFile, textRange: ts.TextRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const findSchema = Nano.fn(\"makeSchemaOpaque.apply.findSchema\")(\n      function*(node: ts.Node) {\n        if (!ts.isVariableDeclaration(node)) {\n          return yield* Nano.fail(\"parent should be variable declaration\")\n        }\n        const identifier = node.name\n        if (!ts.isIdentifier(identifier)) return yield* Nano.fail(\"name should be an identifier\")\n        const initializer = node.initializer\n        if (!initializer) return yield* Nano.fail(\"should have an initializer\")\n\n        const variableDeclarationList = node.parent\n        if (!variableDeclarationList || !ts.isVariableDeclarationList(variableDeclarationList)) {\n          return yield* Nano.fail(\"parent is not a variable declaration list\")\n        }\n\n        const variableStatement = variableDeclarationList.parent\n        if (!variableStatement || !ts.isVariableStatement(variableStatement)) {\n          return yield* Nano.fail(\"parent not variable declaration statement\")\n        }\n\n        const type = typeChecker.getTypeAtLocation(initializer)\n        const types = yield* typeParser.effectSchemaType(type, initializer)\n\n        return { identifier, variableStatement, variableDeclarationList, types }\n      }\n    )\n\n    return yield* pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.map(findSchema),\n      Nano.firstSuccessOf,\n      Nano.option\n    )\n  }\n)\n\nexport const _createOpaqueTypes = Nano.fn(\"_createOpaqueTypes\")(function*(\n  effectSchemaName: string,\n  inferFromName: string,\n  typeA: ts.Type,\n  opaqueTypeName: string,\n  typeE: ts.Type,\n  opaqueEncodedName: string,\n  opaqueContextName: string\n) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  // opaque type\n  const opaqueInferred = ts.factory.createExpressionWithTypeArguments(\n    ts.factory.createPropertyAccessExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(effectSchemaName),\n        ts.factory.createIdentifier(\"Schema\")\n      ),\n      ts.factory.createIdentifier(\"Type\")\n    ),\n    [ts.factory.createTypeQueryNode(\n      ts.factory.createIdentifier(inferFromName)\n    )]\n  )\n  const opaqueType = !(typeA.flags & ts.TypeFlags.Object) ?\n    ts.factory.createTypeAliasDeclaration(\n      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n      opaqueTypeName,\n      [],\n      opaqueInferred\n    ) :\n    ts.factory.createInterfaceDeclaration(\n      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n      opaqueTypeName,\n      undefined,\n      [ts.factory.createHeritageClause(\n        ts.SyntaxKind.ExtendsKeyword,\n        [opaqueInferred]\n      )],\n      []\n    )\n  // encoded type\n  const encodedInferred = ts.factory.createExpressionWithTypeArguments(\n    ts.factory.createPropertyAccessExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(effectSchemaName),\n        ts.factory.createIdentifier(\"Schema\")\n      ),\n      ts.factory.createIdentifier(\"Encoded\")\n    ),\n    [ts.factory.createTypeQueryNode(\n      ts.factory.createIdentifier(inferFromName)\n    )]\n  )\n  const encodedType = !(typeE.flags & ts.TypeFlags.Object) ?\n    ts.factory.createTypeAliasDeclaration(\n      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n      opaqueEncodedName,\n      [],\n      encodedInferred\n    ) :\n    ts.factory.createInterfaceDeclaration(\n      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n      opaqueEncodedName,\n      undefined,\n      [ts.factory.createHeritageClause(\n        ts.SyntaxKind.ExtendsKeyword,\n        [encodedInferred]\n      )],\n      []\n    )\n\n  // context\n  const contextInferred = ts.factory.createExpressionWithTypeArguments(\n    ts.factory.createPropertyAccessExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(effectSchemaName),\n        ts.factory.createIdentifier(\"Schema\")\n      ),\n      ts.factory.createIdentifier(\"Context\")\n    ),\n    [ts.factory.createTypeQueryNode(\n      ts.factory.createIdentifier(inferFromName)\n    )]\n  )\n  const contextType = ts.factory.createTypeAliasDeclaration(\n    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n    opaqueContextName,\n    [],\n    contextInferred\n  )\n\n  return { contextType, encodedType, opaqueType }\n})\n\nexport const makeSchemaOpaque = LSP.createRefactor({\n  name: \"makeSchemaOpaque\",\n  description: \"Make Schema opaque\",\n  apply: Nano.fn(\"makeSchemaOpaque.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeNode = yield* _findSchemaVariableDeclaration(sourceFile, textRange)\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n\n    const { identifier, types, variableDeclarationList, variableStatement } = maybeNode.value\n\n    return {\n      kind: \"refactor.rewrite.effect.makeSchemaOpaque\",\n      description: `Make Schema opaque`,\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n          const effectSchemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n            sourceFile,\n            \"effect\",\n            \"Schema\"\n          ) || \"Schema\"\n\n          const newIdentifier = ts.factory.createIdentifier(ts.idText(identifier) + \"_\")\n          const { contextType, encodedType, opaqueType } = yield* _createOpaqueTypes(\n            effectSchemaName,\n            ts.idText(newIdentifier),\n            types.A,\n            ts.idText(identifier),\n            types.I,\n            ts.idText(identifier) + \"Encoded\",\n            ts.idText(identifier) + \"Context\"\n          )\n\n          changeTracker.replaceNode(\n            sourceFile,\n            identifier,\n            newIdentifier\n          )\n          changeTracker.insertNodeAfter(sourceFile, variableStatement, opaqueType)\n          changeTracker.insertNodeAfter(sourceFile, variableStatement, encodedType)\n          changeTracker.insertNodeAfter(sourceFile, variableStatement, contextType)\n\n          // insert new declaration\n          const newSchemaType = ts.factory.createTypeReferenceNode(\n            ts.factory.createQualifiedName(\n              ts.factory.createIdentifier(effectSchemaName),\n              ts.factory.createIdentifier(\"Schema\")\n            ),\n            [\n              ts.factory.createTypeReferenceNode(opaqueType.name),\n              ts.factory.createTypeReferenceNode(encodedType.name),\n              ts.factory.createTypeReferenceNode(contextType.name)\n            ]\n          )\n          const newConstDeclaration = ts.factory.createVariableStatement(\n            variableStatement.modifiers,\n            ts.factory.createVariableDeclarationList(\n              [ts.factory.createVariableDeclaration(\n                ts.idText(identifier),\n                undefined,\n                newSchemaType,\n                ts.factory.createIdentifier(ts.idText(newIdentifier))\n              )],\n              variableDeclarationList.flags\n            )\n          )\n\n          changeTracker.insertNodeAfter(sourceFile, variableStatement, newConstDeclaration)\n          changeTracker.insertText(sourceFile, variableStatement.end, \"\\n\")\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n      )\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\nimport { _createOpaqueTypes, _findSchemaVariableDeclaration } from \"./makeSchemaOpaque.js\"\n\nexport const makeSchemaOpaqueWithNs = LSP.createRefactor({\n  name: \"makeSchemaOpaqueWithNs\",\n  description: \"Make Schema opaque with namespace\",\n  apply: Nano.fn(\"makeSchemaOpaqueWithNs.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const maybeNode = yield* _findSchemaVariableDeclaration(sourceFile, textRange)\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n\n    const { identifier, types, variableDeclarationList, variableStatement } = maybeNode.value\n\n    return {\n      kind: \"refactor.rewrite.effect.makeSchemaOpaqueWithNs\",\n      description: `Make Schema opaque with namespace`,\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n          const effectSchemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n            sourceFile,\n            \"effect\",\n            \"Schema\"\n          ) || \"Schema\"\n\n          const newIdentifier = ts.factory.createIdentifier(ts.idText(identifier) + \"_\")\n          const { contextType, encodedType, opaqueType } = yield* _createOpaqueTypes(\n            effectSchemaName,\n            ts.idText(newIdentifier),\n            types.A,\n            ts.idText(identifier),\n            types.I,\n            \"Encoded\",\n            \"Context\"\n          )\n\n          const namespace = ts.factory.createModuleDeclaration(\n            [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n            ts.factory.createIdentifier(ts.idText(identifier)),\n            ts.factory.createModuleBlock([\n              encodedType,\n              contextType\n            ]),\n            ts.NodeFlags.Namespace\n          )\n\n          changeTracker.replaceNode(\n            sourceFile,\n            identifier,\n            newIdentifier\n          )\n          changeTracker.insertNodeAfter(sourceFile, variableStatement, opaqueType)\n          changeTracker.insertNodeAfter(sourceFile, variableStatement, namespace)\n\n          const namespaceName = ts.isStringLiteral(namespace.name) ? namespace.name.text : ts.idText(namespace.name)\n\n          // insert new declaration\n          const newSchemaType = ts.factory.createTypeReferenceNode(\n            ts.factory.createQualifiedName(\n              ts.factory.createIdentifier(effectSchemaName),\n              ts.factory.createIdentifier(\"Schema\")\n            ),\n            [\n              ts.factory.createTypeReferenceNode(opaqueType.name),\n              ts.factory.createTypeReferenceNode(\n                ts.factory.createQualifiedName(\n                  ts.factory.createIdentifier(\n                    namespaceName\n                  ),\n                  ts.idText(encodedType.name)\n                )\n              ),\n              ts.factory.createTypeReferenceNode(ts.factory.createQualifiedName(\n                ts.factory.createIdentifier(namespaceName),\n                ts.idText(contextType.name)\n              ))\n            ]\n          )\n          const newConstDeclaration = ts.factory.createVariableStatement(\n            variableStatement.modifiers,\n            ts.factory.createVariableDeclarationList(\n              [ts.factory.createVariableDeclaration(\n                ts.idText(identifier),\n                undefined,\n                newSchemaType,\n                ts.factory.createIdentifier(ts.idText(newIdentifier))\n              )],\n              variableDeclarationList.flags\n            )\n          )\n\n          changeTracker.insertNodeAfter(sourceFile, variableStatement, newConstDeclaration)\n          changeTracker.insertText(sourceFile, variableStatement.end, \"\\n\")\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n      )\n    }\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const pipeableToDatafirst = LSP.createRefactor({\n  name: \"pipeableToDatafirst\",\n  description: \"Rewrite to datafirst\",\n  apply: Nano.fn(\"pipeableToDatafirst.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    function isPipeCall(node: ts.Node): node is ts.CallExpression {\n      if (!ts.isCallExpression(node)) return false\n      const expression = node.expression\n      if (!ts.isIdentifier(expression)) return false\n      if (ts.idText(expression) !== \"pipe\") return false\n      return true\n    }\n\n    function asDataFirstExpression(\n      node: ts.Node,\n      self: ts.Expression\n    ): Option.Option<ts.CallExpression> {\n      if (!ts.isCallExpression(node)) return Option.none()\n      const signature = typeChecker.getResolvedSignature(node)\n      if (!signature) return Option.none()\n      const callSignatures = typeChecker.getSignaturesOfType(\n        typeChecker.getTypeAtLocation(node.expression),\n        ts.SignatureKind.Call\n      )\n      for (let i = 0; i < callSignatures.length; i++) {\n        const callSignature = callSignatures[i]\n        if (callSignature.parameters.length === node.arguments.length + 1) {\n          return Option.some(\n            ts.factory.createCallExpression(\n              node.expression,\n              [],\n              [self].concat(node.arguments)\n            )\n          )\n        }\n      }\n      return Option.none()\n    }\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter(isPipeCall),\n      Array.filter((node) => tsUtils.isNodeInRange(textRange)(node.expression)),\n      Array.filter(\n        (node) => node.arguments.length > 0\n      ),\n      Array.map((node) => {\n        let newNode = node.arguments[0]\n        let didSomething = false\n        for (let i = 1; i < node.arguments.length; i++) {\n          const arg = node.arguments[i]\n          const a = asDataFirstExpression(arg, newNode)\n          if (Option.isSome(a)) {\n            // use found datafirst\n            newNode = a.value\n            didSomething = true\n          } else {\n            if (isPipeCall(newNode)) {\n              // avoid nested pipe(a, pipe(b, c))\n              newNode = ts.factory.createCallExpression(\n                ts.factory.createIdentifier(\"pipe\"),\n                [],\n                newNode.arguments.concat([arg])\n              )\n            } else {\n              // no datafirst, keep pipeable\n              newNode = ts.factory.createCallExpression(ts.factory.createIdentifier(\"pipe\"), [], [\n                newNode,\n                arg\n              ])\n            }\n          }\n        }\n        return didSomething ? Option.some([node, newNode] as const) : Option.none()\n      }),\n      Array.filter(Option.isSome),\n      Array.map((_) => _.value),\n      Array.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const [node, newNode] = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.pipeableToDatafirst\",\n      description: \"Rewrite to datafirst\",\n      apply: Nano.gen(function*() {\n        const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n        changeTracker.replaceNode(sourceFile, node, newNode)\n      })\n    })\n  })\n})\n","import * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\n/**\n * Refactor to remove unnecessary `Effect.gen` calls.\n *\n * This refactor identifies `Effect.gen` calls that are redundant because they only wrap\n * a single `yield*` statement returning an `Effect`. In such cases, the `Effect.gen` wrapper\n * can be removed, and the inner `Effect` can be returned directly.\n *\n * The function works by analyzing the AST within the specified `textRange` to locate\n * `Effect.gen` calls. It checks if the body of the generator function contains only a single\n * `yield*` statement that directly returns an `Effect`. If such a pattern is found, the\n * `Effect.gen` wrapper is replaced with the inner `Effect`.\n *\n * @example\n * Input:\n * ```ts\n * const result = Effect.gen(function* () {\n *   return yield* Effect.succeed(42)\n * })\n * ```\n * Output:\n * ```ts\n * const result = Effect.succeed(42)\n * ```\n *\n * @param ts - The TypeScript API.\n * @param program - The TypeScript program instance, used for type checking.\n * @returns A refactor function that takes a `SourceFile` and a `TextRange`, analyzes the AST,\n *          and applies the refactor if applicable.\n */\nexport const removeUnnecessaryEffectGen = LSP.createRefactor({\n  name: \"removeUnnecessaryEffectGen\",\n  description: \"Remove unnecessary Effect.gen\",\n  apply: Nano.fn(\"removeUnnecessaryEffectGen.apply\")(function*(sourceFile, textRange) {\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    for (\n      const nodeToReplace of tsUtils.getAncestorNodesInRange(sourceFile, textRange)\n    ) {\n      const maybeNode = yield* Nano.option(typeParser.unnecessaryEffectGen(nodeToReplace))\n\n      if (Option.isNone(maybeNode)) continue\n      const replacementNode = maybeNode.value.replacementNode\n\n      return ({\n        kind: \"refactor.rewrite.effect.removeUnnecessaryEffectGen\",\n        description: \"Remove unnecessary Effect.gen\",\n        apply: Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n          changeTracker.replaceNode(sourceFile, nodeToReplace, yield* replacementNode)\n        })\n      })\n    }\n\n    return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const toggleLazyConst = LSP.createRefactor({\n  name: \"toggleLazyConst\",\n  description: \"Toggle lazy const\",\n  apply: Nano.fn(\"toggleLazyConst.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter(ts.isVariableDeclaration),\n      Array.filter((node) => tsUtils.isNodeInRange(textRange)(node.name)),\n      Array.filter((node) =>\n        !!node.initializer &&\n        !(ts.isArrowFunction(node.initializer) && ts.isBlock(node.initializer.body))\n      ),\n      Array.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.toggleLazyConst\",\n      description: \"Toggle lazy const\",\n      apply: Nano.gen(function*() {\n        const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n        const initializer = node.initializer!\n\n        if (ts.isArrowFunction(initializer) && initializer.parameters.length === 0) {\n          // delete eventual closing bracked\n          changeTracker.deleteRange(sourceFile, {\n            pos: initializer.body.end,\n            end: initializer.end\n          })\n          // remove () => {\n          changeTracker.deleteRange(sourceFile, {\n            pos: initializer.pos,\n            end: initializer.body.pos\n          })\n          return\n        }\n\n        // adds () => before\n        changeTracker.insertText(sourceFile, initializer.pos, \" () =>\")\n      })\n    })\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const togglePipeStyle = LSP.createRefactor({\n  name: \"togglePipeStyle\",\n  description: \"Toggle pipe style\",\n  apply: Nano.fn(\"togglePipeStyle.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const togglePipeStyle = (node: ts.Node) =>\n      Nano.gen(function*() {\n        const pipeCall = yield* typeParser.pipeCall(node)\n        switch (pipeCall.kind) {\n          case \"pipe\": {\n            yield* typeParser.pipeableType(typeChecker.getTypeAtLocation(pipeCall.subject), pipeCall.subject)\n            return ({\n              kind: \"refactor.rewrite.effect.togglePipeStyle\",\n              description: \"Rewrite as X.pipe(Y, Z, ...)\",\n              apply: Nano.gen(function*() {\n                const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n                changeTracker.replaceNode(\n                  sourceFile,\n                  node,\n                  ts.factory.createCallExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      pipeCall.subject,\n                      \"pipe\"\n                    ),\n                    undefined,\n                    pipeCall.args\n                  )\n                )\n              })\n            })\n          }\n          case \"pipeable\":\n            return ({\n              kind: \"refactor.rewrite.effect.togglePipeStyle\",\n              description: \"Rewrite as pipe(X, Y, Z, ...)\",\n              apply: Nano.gen(function*() {\n                const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n                changeTracker.replaceNode(\n                  sourceFile,\n                  node,\n                  ts.factory.createCallExpression(\n                    ts.factory.createIdentifier(\"pipe\"),\n                    undefined,\n                    [pipeCall.subject].concat(pipeCall.args)\n                  )\n                )\n              })\n            })\n        }\n      })\n\n    const ancestorNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange)\n\n    return yield* pipe(\n      Nano.firstSuccessOf(ancestorNodes.map(togglePipeStyle)),\n      Nano.orElse(() => Nano.fail(new LSP.RefactorNotApplicableError()))\n    )\n  })\n})\n","import * as ReadonlyArray from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const toggleReturnTypeAnnotation = LSP.createRefactor({\n  name: \"toggleReturnTypeAnnotation\",\n  description: \"Toggle return type annotation\",\n  apply: Nano.fn(\"toggleReturnTypeAnnotation.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    function addReturnTypeAnnotation(\n      sourceFile: ts.SourceFile,\n      changeTracker: ts.textChanges.ChangeTracker,\n      declaration:\n        | ts.FunctionDeclaration\n        | ts.FunctionExpression\n        | ts.ArrowFunction\n        | ts.MethodDeclaration,\n      typeNode: ts.TypeNode\n    ) {\n      const closeParen = ts.findChildOfKind(declaration, ts.SyntaxKind.CloseParenToken, sourceFile)\n      const needParens = ts.isArrowFunction(declaration) && closeParen === undefined\n      const endNode = needParens ? declaration.parameters[0] : closeParen\n      if (endNode) {\n        if (needParens) {\n          changeTracker.insertNodeBefore(\n            sourceFile,\n            endNode,\n            ts.factory.createToken(ts.SyntaxKind.OpenParenToken)\n          )\n          changeTracker.insertNodeAfter(\n            sourceFile,\n            endNode,\n            ts.factory.createToken(ts.SyntaxKind.CloseParenToken)\n          )\n        }\n        changeTracker.insertNodeAt(sourceFile, endNode.end, typeNode, { prefix: \": \" })\n      }\n    }\n\n    function removeReturnTypeAnnotation(\n      sourceFile: ts.SourceFile,\n      changeTracker: ts.textChanges.ChangeTracker,\n      declaration:\n        | ts.FunctionDeclaration\n        | ts.FunctionExpression\n        | ts.ArrowFunction\n        | ts.MethodDeclaration\n    ) {\n      const closeParen = ts.findChildOfKind(declaration, ts.SyntaxKind.CloseParenToken, sourceFile)\n      const needParens = ts.isArrowFunction(declaration) && closeParen === undefined\n      const endNode = needParens ? declaration.parameters[0] : closeParen\n      if (endNode && declaration.type) {\n        changeTracker.deleteRange(sourceFile, { pos: endNode.end, end: declaration.type.end })\n      }\n    }\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      ReadonlyArray.filter((node) =>\n        ts.isFunctionDeclaration(node) || ts.isFunctionExpression(node) ||\n        ts.isArrowFunction(node) || ts.isMethodDeclaration(node)\n      ),\n      ReadonlyArray.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    if (node.type) {\n      return ({\n        kind: \"refactor.rewrite.effect.toggleReturnTypeAnnotation\",\n        description: \"Toggle return type annotation\",\n        apply: pipe(\n          Nano.service(TypeScriptApi.ChangeTracker),\n          Nano.map((changeTracker) => removeReturnTypeAnnotation(sourceFile, changeTracker, node))\n        )\n      })\n    }\n\n    const returnType = typeCheckerUtils.getInferredReturnType(node)\n    if (!returnType) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n\n    const returnTypeNode = typeCheckerUtils.typeToSimplifiedTypeNode(\n      returnType,\n      node,\n      ts.NodeBuilderFlags.NoTruncation\n    )\n\n    if (!returnTypeNode) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n\n    return ({\n      kind: \"refactor.rewrite.effect.toggleReturnTypeAnnotation\",\n      description: \"Toggle return type annotation\",\n      apply: pipe(\n        Nano.service(TypeScriptApi.ChangeTracker),\n        Nano.map((changeTracker) => addReturnTypeAnnotation(sourceFile, changeTracker, node, returnTypeNode))\n      )\n    })\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const toggleTypeAnnotation = LSP.createRefactor({\n  name: \"toggleTypeAnnotation\",\n  description: \"Toggle type annotation\",\n  apply: Nano.fn(\"toggleTypeAnnotation.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const maybeNode = pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter((node) => ts.isVariableDeclaration(node) || ts.isPropertyDeclaration(node)),\n      Array.filter((node) => tsUtils.isNodeInRange(textRange)(node.name)),\n      Array.filter((node) => !!node.initializer),\n      Array.head\n    )\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.toggleTypeAnnotation\",\n      description: \"Toggle type annotation\",\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n          if (node.type) {\n            changeTracker.deleteRange(sourceFile, { pos: node.name.end, end: node.type.end })\n            return\n          }\n\n          const initializer = node.initializer!\n          const initializerType = typeChecker.getTypeAtLocation(initializer)\n          const initializerTypeNode = Option.fromNullable(typeCheckerUtils.typeToSimplifiedTypeNode(\n            initializerType,\n            node,\n            ts.NodeBuilderFlags.NoTruncation\n          )).pipe(\n            Option.orElse(() =>\n              Option.fromNullable(typeCheckerUtils.typeToSimplifiedTypeNode(\n                initializerType,\n                undefined,\n                ts.NodeBuilderFlags.NoTruncation\n              ))\n            ),\n            Option.getOrUndefined\n          )\n          if (initializerTypeNode) {\n            changeTracker.insertNodeAt(\n              sourceFile,\n              node.name.end,\n              initializerTypeNode,\n              {\n                prefix: \": \"\n              }\n            )\n          }\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n      )\n    })\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { identity, pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi\"\nimport type * as TypeCheckerUtils from \"../core/TypeCheckerUtils\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport class TypeParametersNotSupportedError {\n  readonly _tag = \"@effect/language-service/TypeParametersNotSupportedError\"\n  constructor(\n    readonly node: ts.Node\n  ) {\n  }\n\n  toString() {\n    return `Could not process types with type parameters.`\n  }\n}\n\nexport class OnlyLiteralPropertiesSupportedError {\n  readonly _tag = \"@effect/language-service/OnlyLiteralPropertiesSupportedError\"\n  constructor(\n    readonly node: ts.Node\n  ) {\n  }\n\n  toString() {\n    return `Could not process ${this.node.getText()} as only literal properties are supported.`\n  }\n}\n\nexport class RequiredExplicitTypesError {\n  readonly _tag = \"@effect/language-service/RequiredExplicitTypesError\"\n  constructor(\n    readonly node: ts.Node\n  ) {\n  }\n  toString() {\n    return `Could not process ${this.node.getText()} as only explicit types are supported.`\n  }\n}\n\nexport class IndexSignatureWithMoreThanOneParameterError {\n  readonly _tag = \"@effect/language-service/IndexSignatureWithMoreThanOneParameterError\"\n  constructor(\n    readonly node: ts.Node\n  ) {\n  }\n  toString() {\n    return `Could not process ${this.node.getText()} as only index signatures with one parameter are supported.`\n  }\n}\n\ninterface SchemaGenContext {\n  sourceFile: ts.SourceFile\n  ts: TypeScriptApi.TypeScriptApi\n  createApiPropertyAccess(apiName: string): ts.PropertyAccessExpression\n  createApiCall(apiName: string, args: Array<ts.Expression>): ts.CallExpression\n  entityNameToDataTypeName(name: ts.EntityName): Option.Option<string>\n}\nconst SchemaGenContext = Nano.Tag<SchemaGenContext>(\"SchemaGenContext\")\n\nexport const makeSchemaGenContext = Nano.fn(\"SchemaGen.makeSchemaGenContext\")(function*(\n  sourceFile: ts.SourceFile\n) {\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n  const effectSchemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n    sourceFile,\n    \"effect\",\n    \"Schema\"\n  ) || \"Schema\"\n\n  const moduleToImportedName: Record<string, string> = {}\n  for (const moduleName of [\"Option\", \"Either\", \"Chunk\", \"Duration\"]) {\n    const importedName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, \"effect\", moduleName)\n    if (importedName) moduleToImportedName[moduleName] = importedName\n  }\n\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n  return {\n    sourceFile,\n    createApiPropertyAccess: (apiName) =>\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(effectSchemaIdentifier),\n        apiName\n      ),\n    createApiCall: (apiName, args) =>\n      ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          ts.factory.createIdentifier(effectSchemaIdentifier),\n          apiName\n        ),\n        [],\n        args\n      ),\n    entityNameToDataTypeName: (name) => {\n      if (ts.isIdentifier(name)) {\n        switch (ts.idText(name)) {\n          case \"Date\":\n          case \"Pick\":\n          case \"Omit\":\n          case \"Record\":\n            return Option.some(ts.idText(name))\n          case \"ReadonlyArray\":\n          case \"Array\":\n            return Option.some(\"Array\")\n        }\n        return Option.none()\n      }\n      if (!ts.isIdentifier(name.left)) return Option.none()\n      for (const moduleName in moduleToImportedName) {\n        if (ts.idText(name.left) === moduleToImportedName[moduleName] && ts.idText(name.right) === moduleName) {\n          return Option.some(moduleName)\n        }\n      }\n      return Option.none()\n    },\n    ts\n  } satisfies SchemaGenContext\n})\n\nconst typeEntityNameToNode: (\n  entityName: ts.EntityName\n) => Nano.Nano<ts.Identifier | ts.PropertyAccessExpression, never, SchemaGenContext> = Nano.fn(\n  \"SchemaGen.typeEntityNameToNode\"\n)(\n  function*(entityName: ts.EntityName) {\n    const { ts } = yield* Nano.service(SchemaGenContext)\n    if (ts.isIdentifier(entityName)) return ts.factory.createIdentifier(ts.idText(entityName))\n    const left = yield* typeEntityNameToNode(entityName.left)\n    return ts.factory.createPropertyAccessExpression(\n      left,\n      ts.factory.createIdentifier(ts.idText(entityName.right))\n    )\n  }\n)\n\nconst parseAllLiterals: (\n  node: ts.TypeNode\n) => Nano.Nano<\n  Array<ts.StringLiteral | ts.NumericLiteral | ts.NullLiteral | ts.TrueLiteral | ts.FalseLiteral>,\n  ts.TypeNode,\n  SchemaGenContext\n> = Nano\n  .fn(\n    \"SchemaGen.parseAllLiterals\"\n  )(\n    function*(node: ts.TypeNode) {\n      const { ts } = yield* Nano.service(SchemaGenContext)\n      if (ts.isLiteralTypeNode(node)) {\n        switch (node.literal.kind) {\n          case ts.SyntaxKind.StringLiteral:\n            return [ts.factory.createStringLiteral(node.literal.text)]\n          case ts.SyntaxKind.NumericLiteral:\n            return [ts.factory.createNumericLiteral(node.literal.text)]\n          case ts.SyntaxKind.TrueKeyword:\n            return [ts.factory.createTrue()]\n          case ts.SyntaxKind.FalseKeyword:\n            return [ts.factory.createFalse()]\n        }\n      }\n      if (ts.isUnionTypeNode(node)) {\n        return Array.flatten(yield* Nano.all(...node.types.map((_) => parseAllLiterals(_))))\n      }\n      if (ts.isParenthesizedTypeNode(node)) {\n        return yield* parseAllLiterals(node.type)\n      }\n      return yield* Nano.fail(node)\n    }\n  )\n\nconst createUnsupportedNodeComment = (\n  ts: TypeScriptApi.TypeScriptApi,\n  sourceFile: ts.SourceFile,\n  node: ts.Node\n) =>\n  ts.addSyntheticTrailingComment(\n    ts.factory.createIdentifier(\"\"),\n    ts.SyntaxKind.MultiLineCommentTrivia,\n    \" Not supported conversion: \" + node.getText(sourceFile) + \" \"\n  )\n\nexport const processNode = (\n  node: ts.Node,\n  isVirtualTypeNode: boolean\n): Nano.Nano<\n  ts.Expression,\n  | RequiredExplicitTypesError\n  | TypeParametersNotSupportedError\n  | OnlyLiteralPropertiesSupportedError\n  | IndexSignatureWithMoreThanOneParameterError,\n  TypeScriptApi.TypeScriptApi | TypeCheckerApi.TypeCheckerApi | TypeCheckerUtils.TypeCheckerUtils | SchemaGenContext\n> =>\n  Nano.gen(function*() {\n    const { createApiCall, createApiPropertyAccess, entityNameToDataTypeName, sourceFile, ts } = yield* Nano.service(\n      SchemaGenContext\n    )\n    // string | number | boolean | undefined | void | never\n    switch (node.kind) {\n      case ts.SyntaxKind.AnyKeyword:\n        return createApiPropertyAccess(\"Any\")\n      case ts.SyntaxKind.NeverKeyword:\n        return createApiPropertyAccess(\"Never\")\n      case ts.SyntaxKind.UnknownKeyword:\n        return createApiPropertyAccess(\"Unknown\")\n      case ts.SyntaxKind.VoidKeyword:\n        return createApiPropertyAccess(\"Void\")\n      case ts.SyntaxKind.NullKeyword:\n        return createApiPropertyAccess(\"Null\")\n      case ts.SyntaxKind.UndefinedKeyword:\n        return createApiPropertyAccess(\"Undefined\")\n      case ts.SyntaxKind.StringKeyword:\n        return createApiPropertyAccess(\"String\")\n      case ts.SyntaxKind.NumberKeyword:\n        return createApiPropertyAccess(\"Number\")\n      case ts.SyntaxKind.BooleanKeyword:\n        return createApiPropertyAccess(\"Boolean\")\n      case ts.SyntaxKind.BigIntKeyword:\n        return createApiPropertyAccess(\"BigInt\")\n    }\n    // null and other literals\n    if (ts.isLiteralTypeNode(node)) {\n      if (node.literal.kind === ts.SyntaxKind.NullKeyword) return createApiPropertyAccess(\"Null\")\n      const literalMembers = yield* Nano.option(parseAllLiterals(node))\n      if (Option.isSome(literalMembers)) return createApiCall(\"Literal\", literalMembers.value)\n    }\n    // A | B\n    if (ts.isUnionTypeNode(node)) {\n      // \"a\" | \"b\" can be optimized into a single Schema.Literal(\"a\", \"b\")\n      const allLiterals = yield* Nano.option(parseAllLiterals(node))\n      if (Option.isSome(allLiterals)) return createApiCall(\"Literal\", allLiterals.value)\n      // regular union\n      const members = yield* Nano.all(...node.types.map((_) => processNode(_, isVirtualTypeNode)))\n      return createApiCall(\"Union\", members)\n    }\n    // {a: 1} & {b: 2} & {c: 3}\n    if (ts.isIntersectionTypeNode(node)) {\n      const [firstSchema, ...otherSchemas] = yield* Nano.all(\n        ...node.types.map((_) => processNode(_, isVirtualTypeNode))\n      )\n      if (otherSchemas.length === 0) return firstSchema\n      return ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          firstSchema,\n          \"pipe\"\n        ),\n        [],\n        otherSchemas.map((_) => createApiCall(\"extend\", [_]))\n      )\n    }\n    // keyof A\n    if (ts.isTypeOperatorNode(node)) {\n      if (node.operator === ts.SyntaxKind.KeyOfKeyword) {\n        return createApiCall(\"keyof\", [yield* processNode(node.type, isVirtualTypeNode)])\n      } else if (node.operator === ts.SyntaxKind.ReadonlyKeyword) {\n        return yield* processNode(node.type, isVirtualTypeNode)\n      }\n    }\n    // string[]\n    if (ts.isArrayTypeNode(node)) {\n      const typeSchema = yield* processNode(node.elementType, isVirtualTypeNode)\n      return createApiCall(\"Array\", [typeSchema])\n    }\n    // { a: string, b: boolean }\n    if (ts.isTypeLiteralNode(node)) {\n      const { properties, records } = yield* processMembers(node.members, isVirtualTypeNode)\n\n      return createApiCall(\n        \"Struct\",\n        [ts.factory.createObjectLiteralExpression(properties, true)].concat(records)\n      )\n    }\n    // parenthesided (A)\n    if (ts.isParenthesizedTypeNode(node)) {\n      return yield* processNode(node.type, isVirtualTypeNode)\n    }\n    // typeof A\n    if (ts.isTypeQueryNode(node)) {\n      const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n      const type = typeChecker.getTypeAtLocation(node.exprName)\n      const typeNode = typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.NoTruncation)\n      if (typeNode) return yield* processNode(typeNode, true)\n    }\n    // special pattern (typeof A)[keyof typeof A]\n    if (\n      !isVirtualTypeNode &&\n      ts.isIndexedAccessTypeNode(node) && ts.isParenthesizedTypeNode(node.objectType) &&\n      ts.isTypeQueryNode(node.objectType.type) && ts.isTypeOperatorNode(node.indexType) &&\n      node.indexType.operator === ts.SyntaxKind.KeyOfKeyword && ts.isTypeQueryNode(node.indexType.type) &&\n      node.indexType.type.exprName.getText().trim() === node.objectType.type.exprName.getText().trim()\n    ) {\n      const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n      const type = typeChecker.getTypeAtLocation(node)\n      const typeNode = typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.NoTruncation)\n      if (typeNode) return yield* processNode(typeNode, true)\n    }\n    // type reference\n    if (ts.isTypeReferenceNode(node)) {\n      const parsedName = entityNameToDataTypeName(node.typeName)\n      if (Option.isSome(parsedName)) {\n        switch (parsedName.value) {\n          case \"Duration\":\n          case \"Date\":\n            return createApiPropertyAccess(parsedName.value)\n          case \"Option\":\n          case \"Chunk\":\n          case \"Array\": {\n            const elements = yield* Nano.all(\n              ...(node.typeArguments\n                ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode))\n                : [])\n            )\n            return createApiCall(parsedName.value, elements)\n          }\n          case \"Record\": {\n            const elements = yield* Nano.all(\n              ...(node.typeArguments\n                ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode))\n                : [])\n            )\n            if (elements.length >= 2) {\n              return createApiCall(parsedName.value, [\n                ts.factory.createObjectLiteralExpression([\n                  ts.factory.createPropertyAssignment(\"key\", elements[0]),\n                  ts.factory.createPropertyAssignment(\"value\", elements[1])\n                ])\n              ])\n            }\n            return createUnsupportedNodeComment(ts, sourceFile, node)\n          }\n          case \"Either\": {\n            const elements = yield* Nano.all(\n              ...(node.typeArguments\n                ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode))\n                : [])\n            )\n            if (elements.length >= 2) {\n              return createApiCall(parsedName.value, [\n                ts.factory.createObjectLiteralExpression([\n                  ts.factory.createPropertyAssignment(\"right\", elements[0]),\n                  ts.factory.createPropertyAssignment(\"left\", elements[1])\n                ])\n              ])\n            }\n            return createUnsupportedNodeComment(ts, sourceFile, node)\n          }\n          case \"Pick\":\n          case \"Omit\": {\n            const typeArguments = Array.fromIterable(node.typeArguments || [])\n            if (typeArguments.length !== 2) {\n              return createUnsupportedNodeComment(ts, sourceFile, node)\n            }\n            const baseType = yield* processNode(typeArguments[0], isVirtualTypeNode)\n            const stringLiteralArguments = yield* Nano.option(parseAllLiterals(typeArguments[1]))\n\n            if (Option.isNone(stringLiteralArguments)) {\n              return createUnsupportedNodeComment(ts, sourceFile, node)\n            }\n            return ts.factory.createCallExpression(\n              ts.factory.createPropertyAccessExpression(\n                baseType,\n                \"pipe\"\n              ),\n              [],\n              [createApiCall(parsedName.value.toLowerCase(), stringLiteralArguments.value)]\n            )\n          }\n        }\n      }\n    }\n    // type reference\n    if (ts.isTypeReferenceNode(node)) {\n      if (!(node.typeArguments && node.typeArguments.length > 0)) {\n        return yield* typeEntityNameToNode(node.typeName)\n      }\n    }\n\n    // wtf\n    return createUnsupportedNodeComment(ts, sourceFile, node)\n  })\n\nconst processMembers = Nano.fn(\n  \"SchemaGen.processMembers\"\n)(\n  function*(members: ts.NodeArray<ts.TypeElement>, isVirtualTypeNode: boolean) {\n    const { createApiCall, ts } = yield* Nano.service(\n      SchemaGenContext\n    )\n\n    const properties: Array<ts.PropertyAssignment> = []\n    for (const propertySignature of members.filter(ts.isPropertySignature)) {\n      const name = propertySignature.name\n      if (!(ts.isIdentifier(name) || ts.isStringLiteral(name))) {\n        return yield* Nano.fail(new OnlyLiteralPropertiesSupportedError(propertySignature))\n      }\n      if (!propertySignature.type) {\n        return yield* Nano.fail(new RequiredExplicitTypesError(propertySignature))\n      }\n      const propertyAssignment = pipe(\n        yield* processNode(propertySignature.type, isVirtualTypeNode),\n        propertySignature.questionToken ? (_) => createApiCall(\"optional\", [_]) : identity,\n        (_) => ts.factory.createPropertyAssignment(name, _)\n      )\n\n      properties.push(propertyAssignment)\n    }\n\n    const records: Array<ts.ObjectLiteralExpression> = []\n    for (const indexSignature of members.filter(ts.isIndexSignatureDeclaration)) {\n      if (indexSignature.parameters.length !== 1) {\n        return yield* Nano.fail(new IndexSignatureWithMoreThanOneParameterError(indexSignature))\n      }\n      const parameter = indexSignature.parameters[0]\n      if (!parameter.type) return yield* Nano.fail(new RequiredExplicitTypesError(parameter))\n      const parameterType = parameter.type\n      const key = yield* processNode(parameterType, isVirtualTypeNode)\n      const value = yield* processNode(indexSignature.type, isVirtualTypeNode)\n      records.push(\n        ts.factory.createObjectLiteralExpression([\n          ts.factory.createPropertyAssignment(\"key\", key),\n          ts.factory.createPropertyAssignment(\"value\", value)\n        ])\n      )\n    }\n\n    return { properties, records }\n  }\n)\n\nconst processInterfaceDeclaration = Nano.fn(\"SchemaGen.processInterfaceDeclaration\")(\n  function*(node: ts.InterfaceDeclaration, preferClass: boolean) {\n    if (node.typeParameters && node.typeParameters.length > 0) {\n      return yield* Nano.fail(new TypeParametersNotSupportedError(node))\n    }\n    const { createApiCall, ts } = yield* Nano.service(\n      SchemaGenContext\n    )\n\n    const { properties, records } = yield* processMembers(node.members, false)\n\n    if (preferClass && records.length === 0) {\n      return yield* createExportSchemaClassDeclaration(ts.idText(node.name), properties)\n    }\n\n    const schemaStruct = createApiCall(\n      \"Struct\",\n      [ts.factory.createObjectLiteralExpression(properties, true)].concat(records)\n    )\n\n    return yield* createExportVariableDeclaration(ts.idText(node.name), schemaStruct)\n  }\n)\n\nconst processTypeAliasDeclaration = Nano.fn(\"SchemaGen.processInterfaceDeclaration\")(\n  function*(node: ts.TypeAliasDeclaration, preferClass: boolean) {\n    const { ts } = yield* Nano.service(SchemaGenContext)\n\n    if (node.typeParameters && node.typeParameters.length > 0) {\n      return yield* Nano.fail(new TypeParametersNotSupportedError(node))\n    }\n\n    if (preferClass && ts.isTypeLiteralNode(node.type)) {\n      const { properties, records } = yield* processMembers(node.type.members, false)\n      if (records.length === 0) {\n        return yield* createExportSchemaClassDeclaration(ts.idText(node.name), properties)\n      }\n    }\n\n    const effectSchema = yield* processNode(node.type, false)\n\n    return yield* createExportVariableDeclaration(ts.idText(node.name), effectSchema)\n  }\n)\n\nconst createExportVariableDeclaration = Nano.fn(\"SchemaGen.createExportVariableDeclaration\")(\n  function*(\n    name: string,\n    initializer: ts.Expression\n  ) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    return ts.factory.createVariableStatement(\n      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n      ts.factory.createVariableDeclarationList([\n        ts.factory.createVariableDeclaration(\n          ts.factory.createIdentifier(name),\n          undefined,\n          undefined,\n          initializer\n        )\n      ], ts.NodeFlags.Const)\n    )\n  }\n)\n\nconst createExportSchemaClassDeclaration = Nano.fn(\"SchemaGen.createExportSchemaClassDeclaration\")(\n  function*(\n    name: string,\n    members: Array<ts.PropertyAssignment>\n  ) {\n    const { createApiPropertyAccess } = yield* Nano.service(SchemaGenContext)\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    return ts.factory.createClassDeclaration(\n      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n      ts.factory.createIdentifier(name),\n      [],\n      [ts.factory.createHeritageClause(\n        ts.SyntaxKind.ExtendsKeyword,\n        [\n          ts.factory.createExpressionWithTypeArguments(\n            ts.factory.createCallExpression(\n              ts.factory.createCallExpression(\n                createApiPropertyAccess(\"Class\"),\n                [ts.factory.createTypeReferenceNode(\n                  name\n                )],\n                [ts.factory.createStringLiteral(name)]\n              ),\n              [],\n              [ts.factory.createObjectLiteralExpression(\n                members,\n                true\n              )]\n            ),\n            []\n          )\n        ]\n      )],\n      []\n    )\n  }\n)\n\nexport const process = Nano.fn(\"SchemaGen.process\")(\n  function*(\n    sourceFile: ts.SourceFile,\n    node: ts.InterfaceDeclaration | ts.TypeAliasDeclaration,\n    preferClass: boolean\n  ) {\n    const ctx = yield* makeSchemaGenContext(sourceFile)\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n    return yield* pipe(\n      ts.isInterfaceDeclaration(node)\n        ? processInterfaceDeclaration(node, preferClass)\n        : processTypeAliasDeclaration(node, preferClass),\n      Nano.provideService(SchemaGenContext, ctx)\n    )\n  }\n)\n\nexport const findNodeToProcess = Nano.fn(\"SchemaGen.findNodeToProcess\")(\n  function*(sourceFile: ts.SourceFile, textRange: ts.TextRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    return pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      Array.filter((node) => ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)),\n      Array.filter((node) => tsUtils.isNodeInRange(textRange)(node.name)),\n      Array.filter((node) => (node.typeParameters || []).length === 0),\n      Array.head\n    )\n  }\n)\n\nexport const applyAtNode = Nano.fn(\"SchemaGen.applyAtNode\")(\n  function*(\n    sourceFile: ts.SourceFile,\n    node: ts.TypeAliasDeclaration | ts.InterfaceDeclaration,\n    preferClass: boolean\n  ) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n    const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n    const newNode = yield* pipe(\n      process(sourceFile, node, preferClass),\n      Nano.orElse((error) =>\n        Nano.succeed(ts.addSyntheticLeadingComment(\n          ts.factory.createIdentifier(\"\"),\n          ts.SyntaxKind.MultiLineCommentTrivia,\n          \" \" + String(error) + \" \",\n          true\n        ))\n      )\n    )\n    changeTracker.insertNodeBefore(sourceFile, node, newNode, true, {\n      leadingTriviaOption: ts.textChanges.LeadingTriviaOption.StartLine\n    })\n  }\n)\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\nimport * as SchemaGen from \"../utils/SchemaGen.js\"\n\nexport const typeToEffectSchema = LSP.createRefactor({\n  name: \"typeToEffectSchema\",\n  description: \"Refactor to Schema\",\n  apply: Nano.fn(\"typeToEffectSchema.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const maybeNode = yield* SchemaGen.findNodeToProcess(sourceFile, textRange)\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.typeToEffectSchema\",\n      description: \"Refactor to Schema\",\n      apply: pipe(\n        SchemaGen.applyAtNode(sourceFile, node, false),\n        Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker),\n        Nano.provideService(TypeScriptUtils.TypeScriptUtils, tsUtils),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n        Nano.provideService(TypeCheckerUtils.TypeCheckerUtils, typeCheckerUtils)\n      )\n    })\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\nimport * as SchemaGen from \"../utils/SchemaGen.js\"\n\nexport const typeToEffectSchemaClass = LSP.createRefactor({\n  name: \"typeToEffectSchemaClass\",\n  description: \"Refactor to Schema.Class\",\n  apply: Nano.fn(\"typeToEffectSchemaClass.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const maybeNode = yield* SchemaGen.findNodeToProcess(sourceFile, textRange)\n\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    const node = maybeNode.value\n\n    return ({\n      kind: \"refactor.rewrite.effect.typeToEffectSchemaClass\",\n      description: \"Refactor to Schema.Class\",\n      apply: pipe(\n        SchemaGen.applyAtNode(sourceFile, node, true),\n        Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker),\n        Nano.provideService(TypeScriptUtils.TypeScriptUtils, tsUtils),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n        Nano.provideService(TypeCheckerUtils.TypeCheckerUtils, typeCheckerUtils)\n      )\n    })\n  })\n})\n","import * as ReadonlyArray from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const wrapWithEffectGen = LSP.createRefactor({\n  name: \"wrapWithEffectGen\",\n  description: \"Wrap with Effect.gen\",\n  apply: Nano.fn(\"wrapWithEffectGen.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const findEffectToWrap = Nano.fn(\"wrapWithEffectGen.apply.findEffectToWrap\")(\n      function*(node: ts.Node) {\n        if (!ts.isExpression(node)) return yield* Nano.fail(\"is not an expression\")\n        if (node.parent && ts.isHeritageClause(node.parent)) return yield* Nano.fail(\"is in a heritage clause\")\n\n        const parent = node.parent\n        if (\n          parent != null && ts.isVariableDeclaration(parent) && parent.initializer !== node\n        ) return yield* Nano.fail(\"is LHS of variable declaration\")\n\n        const type = typeChecker.getTypeAtLocation(node)\n        yield* typeParser.strictEffectType(type, node)\n\n        return node\n      }\n    )\n\n    const maybeNode = yield* pipe(\n      tsUtils.getAncestorNodesInRange(sourceFile, textRange),\n      ReadonlyArray.map(findEffectToWrap),\n      Nano.firstSuccessOf,\n      Nano.option\n    )\n    if (Option.isNone(maybeNode)) return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n\n    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Effect\"\n    ) || \"Effect\"\n\n    return {\n      kind: \"refactor.rewrite.effect.wrapWithEffectGen\",\n      description: `Wrap with Effect.gen`,\n      apply: pipe(\n        Nano.gen(function*() {\n          const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n          const effectGen = tsUtils.createEffectGenCallExpressionWithBlock(\n            effectModuleIdentifier,\n            tsUtils.createReturnYieldStarStatement(maybeNode.value)\n          )\n\n          changeTracker.replaceNode(sourceFile, maybeNode.value, effectGen)\n        }),\n        Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n        Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker)\n      )\n    }\n  })\n})\n","import * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const wrapWithPipe = LSP.createRefactor({\n  name: \"wrapWithPipe\",\n  description: \"Wrap with pipe\",\n  apply: Nano.fn(\"wrapWithPipe.apply\")(function*(sourceFile, textRange) {\n    if (textRange.end - textRange.pos === 0) {\n      return yield* Nano.fail(new LSP.RefactorNotApplicableError())\n    }\n\n    return ({\n      kind: \"refactor.rewrite.effect.wrapWithPipe\",\n      description: `Wrap with pipe(...)`,\n      apply: Nano.gen(function*() {\n        const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n        changeTracker.insertText(sourceFile, textRange.pos, \"pipe(\")\n        changeTracker.insertText(sourceFile, textRange.end, \")\")\n      })\n    })\n  })\n})\n","import { asyncAwaitToFn } from \"./refactors/asyncAwaitToFn.js\"\nimport { asyncAwaitToFnTryPromise } from \"./refactors/asyncAwaitToFnTryPromise.js\"\nimport { asyncAwaitToGen } from \"./refactors/asyncAwaitToGen.js\"\nimport { asyncAwaitToGenTryPromise } from \"./refactors/asyncAwaitToGenTryPromise.js\"\nimport { effectGenToFn } from \"./refactors/effectGenToFn.js\"\nimport { functionToArrow } from \"./refactors/functionToArrow.js\"\nimport { layerMagic } from \"./refactors/layerMagic.js\"\nimport { makeSchemaOpaque } from \"./refactors/makeSchemaOpaque.js\"\nimport { makeSchemaOpaqueWithNs } from \"./refactors/makeSchemaOpaqueWithNs.js\"\nimport { pipeableToDatafirst } from \"./refactors/pipeableToDatafirst.js\"\nimport { removeUnnecessaryEffectGen } from \"./refactors/removeUnnecessaryEffectGen.js\"\nimport { toggleLazyConst } from \"./refactors/toggleLazyConst.js\"\nimport { togglePipeStyle } from \"./refactors/togglePipeStyle.js\"\nimport { toggleReturnTypeAnnotation } from \"./refactors/toggleReturnTypeAnnotation.js\"\nimport { toggleTypeAnnotation } from \"./refactors/toggleTypeAnnotation.js\"\nimport { typeToEffectSchema } from \"./refactors/typeToEffectSchema.js\"\nimport { typeToEffectSchemaClass } from \"./refactors/typeToEffectSchemaClass.js\"\nimport { wrapWithEffectGen } from \"./refactors/wrapWithEffectGen.js\"\nimport { wrapWithPipe } from \"./refactors/wrapWithPipe.js\"\nimport { writeTagClassAccessors } from \"./refactors/writeTagClassAccessors.js\"\n\nexport const refactors = [\n  layerMagic,\n  asyncAwaitToGen,\n  asyncAwaitToGenTryPromise,\n  asyncAwaitToFn,\n  asyncAwaitToFnTryPromise,\n  functionToArrow,\n  typeToEffectSchema,\n  typeToEffectSchemaClass,\n  makeSchemaOpaque,\n  makeSchemaOpaqueWithNs,\n  pipeableToDatafirst,\n  removeUnnecessaryEffectGen,\n  toggleLazyConst,\n  toggleReturnTypeAnnotation,\n  toggleTypeAnnotation,\n  wrapWithEffectGen,\n  wrapWithPipe,\n  effectGenToFn,\n  togglePipeStyle,\n  writeTagClassAccessors\n]\n","import { pipe } from \"effect\"\nimport * as Option from \"effect/Option\"\nimport type * as ts from \"typescript\"\nimport * as Nano from \"../core/Nano\"\nimport * as TypeParser from \"../core/TypeParser\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils\"\n\nexport const renameKeyStrings = (\n  sourceFile: ts.SourceFile,\n  position: number,\n  _findInStrings: boolean,\n  _findInComments: boolean,\n  _preferences: ts.UserPreferences,\n  renameLocations: ReadonlyArray<ts.RenameLocation> | undefined\n) =>\n  Nano.gen(function*() {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const additionalPositions: Array<ts.RenameLocation> = []\n\n    const node = tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, position)\n    if (node && ts.isIdentifier(node)) {\n      const textToReplace = ts.idText(node)\n      const parentClass = node.parent\n      if (ts.isClassDeclaration(parentClass) && parentClass.name === node) {\n        const baseIdentifier = yield* pipe(\n          Nano.map(typeParser.extendsContextTag(parentClass), (_) => [_.keyStringLiteral]),\n          Nano.orElse(() => Nano.map(typeParser.extendsEffectService(parentClass), (_) => [_.keyStringLiteral])),\n          Nano.orElse(() => Nano.map(typeParser.extendsEffectTag(parentClass), (_) => [_.keyStringLiteral])),\n          Nano.orElse(() =>\n            Nano.map(typeParser.extendsSchemaTaggedClass(parentClass), (_) => [_.keyStringLiteral, _.tagStringLiteral])\n          ),\n          Nano.orElse(() =>\n            Nano.map(typeParser.extendsSchemaTaggedError(parentClass), (_) => [_.keyStringLiteral, _.tagStringLiteral])\n          ),\n          Nano.orElse(() => Nano.map(typeParser.extendsDataTaggedError(parentClass), (_) => [_.keyStringLiteral])),\n          Nano.orElse(() => Nano.map(typeParser.extendsDataTaggedClass(parentClass), (_) => [_.keyStringLiteral])),\n          Nano.orElse(() =>\n            Nano.map(\n              typeParser.extendsSchemaTaggedRequest(parentClass),\n              (_) => [_.keyStringLiteral, _.tagStringLiteral]\n            )\n          ),\n          Nano.option\n        )\n        if (Option.isSome(baseIdentifier)) {\n          for (const keyStringLiteral of baseIdentifier.value) {\n            if (!keyStringLiteral) continue\n            const baseText = sourceFile.text.slice(keyStringLiteral.pos, keyStringLiteral.end)\n            const lastIndex = baseText.lastIndexOf(textToReplace)\n            if (lastIndex !== -1) {\n              additionalPositions.push({\n                fileName: sourceFile.fileName,\n                textSpan: {\n                  start: keyStringLiteral.pos + lastIndex,\n                  length: textToReplace.length\n                }\n              })\n            }\n          }\n        }\n      }\n    }\n    return additionalPositions.length === 0 ? renameLocations : additionalPositions.concat(renameLocations || [])\n  })\n","import * as Either from \"effect/Either\"\nimport { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport { completions } from \"./completions.js\"\nimport {\n  appendEffectCompletionEntryData,\n  postprocessCompletionEntryDetails\n} from \"./completions/middlewareAutoImports.js\"\nimport * as LanguageServicePluginOptions from \"./core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"./core/LSP.js\"\nimport * as Nano from \"./core/Nano.js\"\nimport * as TypeCheckerApi from \"./core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"./core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"./core/TypeParser.js\"\nimport * as TypeScriptApi from \"./core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"./core/TypeScriptUtils.js\"\nimport { diagnostics } from \"./diagnostics.js\"\nimport { middlewareAutoImportQuickfixes } from \"./diagnostics/middlewareAutoImportQuickfixes.js\"\nimport { goto } from \"./goto.js\"\nimport { middlewareGenLike } from \"./inlays/middlewareGenLike.js\"\nimport { quickInfo } from \"./quickinfo.js\"\nimport { effectApiGetLayerGraph } from \"./quickinfo/layerInfo.js\"\nimport { refactors } from \"./refactors.js\"\nimport { renameKeyStrings } from \"./renames/keyStrings.js\"\n\nconst LSP_INJECTED_URI = \"@effect/language-service/injected\"\n\nconst init = (\n  modules: {\n    typescript: typeof ts\n  }\n) => {\n  // this is nothing more than an hack. Seems like vscode and other editors do not\n  // support new error codes in diagnostics. Because they somehow rely on looking into\n  // typescript.codefixes object. SO ONLY OPTION here is to register fake codefix.\n  // by hooking into the codefixes object and registering a fake codefix.\n  const diagnosticsErrorCodes = diagnostics.map((diagnostic) => diagnostic.code)\n  try {\n    ;(modules.typescript as any).codefix.registerCodeFix({\n      errorCodes: diagnosticsErrorCodes,\n      getCodeActions: () => undefined\n    })\n    // eslint-disable-next-line no-empty, @typescript-eslint/no-unused-vars\n  } catch (_) {}\n\n  let languageServicePluginOptions: LanguageServicePluginOptions.LanguageServicePluginOptions =\n    LanguageServicePluginOptions.parse({})\n\n  function onConfigurationChanged(config: any) {\n    languageServicePluginOptions = LanguageServicePluginOptions.parse(config)\n  }\n\n  function create(info: ts.server.PluginCreateInfo) {\n    const languageService = info.languageService\n    languageServicePluginOptions = LanguageServicePluginOptions.parse(info.config)\n\n    // prevent double-injection of the effect language service\n    if ((languageService as any)[LSP_INJECTED_URI]) return languageService\n\n    info.project.log(\"[@effect/language-service] Started!\")\n\n    // create the proxy and mark it as injected (to avoid double-applies)\n    const proxy: ts.LanguageService = Object.create(null)\n    ;(proxy as any)[LSP_INJECTED_URI] = true\n    for (const k of Object.keys(languageService) as Array<keyof ts.LanguageService>) {\n      // @ts-expect-error\n      proxy[k] = (...args: Array<{}>) => languageService[k]!.apply(languageService, args)\n    }\n\n    // this is the Nano runner used by all the endpoints\n    // it will take a nano, provide some LSP services and run it.\n    function runNano(program: ts.Program) {\n      return <A, E>(\n        fa: Nano.Nano<\n          A,\n          E,\n          | TypeCheckerApi.TypeCheckerApi\n          | TypeScriptApi.TypeScriptProgram\n          | TypeScriptApi.TypeScriptApi\n          | TypeScriptUtils.TypeScriptUtils\n          | TypeCheckerUtils.TypeCheckerUtils\n          | TypeParser.TypeParser\n          | LanguageServicePluginOptions.LanguageServicePluginOptions\n        >\n      ) =>\n        pipe(\n          fa,\n          TypeParser.nanoLayer,\n          TypeCheckerUtils.nanoLayer,\n          TypeScriptUtils.nanoLayer,\n          Nano.provideService(TypeCheckerApi.TypeCheckerApi, program.getTypeChecker()),\n          Nano.provideService(TypeScriptApi.TypeScriptProgram, program),\n          Nano.provideService(TypeScriptApi.TypeScriptApi, modules.typescript),\n          Nano.provideService(\n            LanguageServicePluginOptions.LanguageServicePluginOptions,\n            languageServicePluginOptions\n          ),\n          Nano.run\n        )\n    }\n\n    const effectCodeFixesForFile = new Map<\n      string,\n      Array<LSP.ApplicableDiagnosticDefinitionFixWithPositionAndCode>\n    >()\n    const runDiagnosticsAndCacheCodeFixes = (fileName: string) => {\n      const program = languageService.getProgram()\n      while (effectCodeFixesForFile.size > 5) {\n        const oldest = effectCodeFixesForFile.keys().next().value\n        if (oldest) effectCodeFixesForFile.delete(oldest)\n      }\n      if (languageServicePluginOptions.diagnostics && program) {\n        effectCodeFixesForFile.delete(fileName)\n        const sourceFile = program.getSourceFile(fileName)\n\n        if (sourceFile) {\n          return pipe(\n            LSP.getSemanticDiagnosticsWithCodeFixes(diagnostics, sourceFile),\n            runNano(program),\n            Either.map(({ codeFixes, diagnostics }) => {\n              effectCodeFixesForFile.set(fileName, codeFixes)\n              return diagnostics\n            }),\n            Either.getOrElse(() => [])\n          )\n        }\n      }\n      return []\n    }\n\n    proxy.getSemanticDiagnostics = (fileName, ...args) => {\n      const applicableDiagnostics = languageService.getSemanticDiagnostics(fileName, ...args)\n      return LSP.concatDiagnostics(runDiagnosticsAndCacheCodeFixes(fileName), applicableDiagnostics)\n    }\n\n    proxy.getSupportedCodeFixes = (...args) =>\n      languageService.getSupportedCodeFixes(...args).concat(\n        diagnosticsErrorCodes.map((_) => \"\" + _)\n      )\n\n    proxy.getCodeFixesAtPosition = (\n      fileName,\n      start,\n      end,\n      errorCodes,\n      formatOptions,\n      preferences,\n      ...args\n    ) => {\n      const applicableCodeFixes = languageService.getCodeFixesAtPosition(\n        fileName,\n        start,\n        end,\n        errorCodes,\n        formatOptions,\n        preferences,\n        ...args\n      )\n      const program = languageService.getProgram()\n\n      if (languageServicePluginOptions.diagnostics && program) {\n        const sourceFile = program.getSourceFile(fileName)\n\n        if (sourceFile) {\n          return pipe(\n            Nano.sync(() => {\n              const effectCodeFixes: Array<ts.CodeFixAction> = []\n\n              // ensure that diagnostics are run before code fixes\n              if (!effectCodeFixesForFile.has(fileName)) {\n                runDiagnosticsAndCacheCodeFixes(fileName)\n              }\n              const applicableFixes = (effectCodeFixesForFile.get(fileName) || []).filter((_) =>\n                _.start === start && _.end === end && errorCodes.indexOf(_.code) > -1\n              )\n\n              const formatContext = modules.typescript.formatting.getFormatContext(\n                formatOptions,\n                info.languageServiceHost\n              )\n\n              for (const applicableFix of applicableFixes) {\n                const changes = modules.typescript.textChanges.ChangeTracker.with(\n                  {\n                    formatContext,\n                    host: info.languageServiceHost,\n                    preferences: preferences || {}\n                  },\n                  (changeTracker) =>\n                    pipe(\n                      applicableFix.apply,\n                      Nano.provideService(TypeScriptApi.ChangeTracker, changeTracker),\n                      Nano.run\n                    )\n                )\n                effectCodeFixes.push({\n                  fixName: applicableFix.fixName,\n                  description: applicableFix.description,\n                  changes\n                })\n              }\n\n              return effectCodeFixes\n            }),\n            Nano.flatMap((effectCodeFixes) =>\n              pipe(\n                middlewareAutoImportQuickfixes(\n                  sourceFile,\n                  info.languageServiceHost,\n                  formatOptions,\n                  preferences,\n                  applicableCodeFixes\n                ),\n                Nano.map((modifiedCodeFixes) => effectCodeFixes.concat(modifiedCodeFixes))\n              )\n            ),\n            runNano(program),\n            Either.getOrElse(() => applicableCodeFixes)\n          )\n        }\n      }\n\n      return applicableCodeFixes\n    }\n\n    proxy.getApplicableRefactors = (...args) => {\n      const applicableRefactors = languageService.getApplicableRefactors(...args)\n      const [fileName, positionOrRange] = args\n      const program = languageService.getProgram()\n\n      if (program) {\n        const sourceFile = program.getSourceFile(fileName)\n        if (sourceFile) {\n          return pipe(\n            LSP.getApplicableRefactors(refactors, sourceFile, positionOrRange),\n            runNano(program),\n            Either.map((effectRefactors) => applicableRefactors.concat(effectRefactors)),\n            Either.getOrElse(() => applicableRefactors)\n          )\n        }\n      }\n      return applicableRefactors\n    }\n\n    proxy.getEditsForRefactor = (\n      fileName,\n      formatOptions,\n      positionOrRange,\n      refactorName,\n      actionName,\n      preferences,\n      ...args\n    ) => {\n      const program = languageService.getProgram()\n      if (program) {\n        const sourceFile = program.getSourceFile(fileName)\n        if (sourceFile) {\n          const result = pipe(\n            Nano.gen(function*() {\n              const applicableRefactor = yield* LSP.getEditsForRefactor(\n                refactors,\n                sourceFile,\n                positionOrRange,\n                refactorName\n              )\n\n              const formatContext = modules.typescript.formatting.getFormatContext(\n                formatOptions,\n                info.languageServiceHost\n              )\n\n              const edits = modules.typescript.textChanges.ChangeTracker.with(\n                {\n                  formatContext,\n                  host: info.languageServiceHost,\n                  preferences: preferences || {}\n                },\n                (changeTracker) =>\n                  pipe(\n                    applicableRefactor.apply,\n                    Nano.provideService(TypeScriptApi.ChangeTracker, changeTracker),\n                    Nano.run\n                  )\n              )\n\n              return { edits } as ts.RefactorEditInfo\n            }),\n            runNano(program)\n          )\n\n          if (Either.isRight(result)) return result.right\n        }\n      }\n\n      return languageService.getEditsForRefactor(\n        fileName,\n        formatOptions,\n        positionOrRange,\n        refactorName,\n        actionName,\n        preferences,\n        ...args\n      )\n    }\n\n    proxy.getQuickInfoAtPosition = (fileName, position, ...args) => {\n      const applicableQuickInfo = languageService.getQuickInfoAtPosition(fileName, position, ...args)\n\n      if (languageServicePluginOptions.quickinfo) {\n        const program = languageService.getProgram()\n        if (program) {\n          const sourceFile = program.getSourceFile(fileName)\n          if (sourceFile) {\n            return pipe(\n              quickInfo(\n                sourceFile,\n                position,\n                applicableQuickInfo\n              ),\n              runNano(program),\n              Either.getOrElse(() => applicableQuickInfo)\n            )\n          }\n        }\n      }\n\n      return applicableQuickInfo\n    }\n\n    proxy.getCompletionsAtPosition = (fileName, position, options, formattingSettings, ...args) => {\n      const applicableCompletions = languageService.getCompletionsAtPosition(\n        fileName,\n        position,\n        options,\n        formattingSettings,\n        ...args\n      )\n\n      if (languageServicePluginOptions.completions) {\n        const program = languageService.getProgram()\n        if (program) {\n          const sourceFile = program.getSourceFile(fileName)\n          if (sourceFile) {\n            return pipe(\n              appendEffectCompletionEntryData(sourceFile, applicableCompletions),\n              Nano.flatMap((augmentedCompletions) =>\n                pipe(\n                  LSP.getCompletionsAtPosition(\n                    completions,\n                    sourceFile,\n                    position,\n                    options,\n                    formattingSettings\n                  ),\n                  Nano.map((effectCompletions) => (augmentedCompletions\n                    ? {\n                      ...augmentedCompletions,\n                      entries: effectCompletions.concat(augmentedCompletions.entries)\n                    }\n                    : (effectCompletions.length > 0 ?\n                      ({\n                        entries: effectCompletions,\n                        isGlobalCompletion: false,\n                        isMemberCompletion: false,\n                        isNewIdentifierLocation: false\n                      }) satisfies ts.CompletionInfo :\n                      undefined))\n                  )\n                )\n              ),\n              runNano(program),\n              Either.getOrElse(() => applicableCompletions)\n            )\n          }\n        }\n      }\n\n      return applicableCompletions\n    }\n\n    proxy.getCompletionEntryDetails = (\n      fileName,\n      position,\n      entryName,\n      formatOptions,\n      source,\n      preferences,\n      _data,\n      ...args\n    ) => {\n      const applicableCompletionEntryDetails = languageService.getCompletionEntryDetails(\n        fileName,\n        position,\n        entryName,\n        formatOptions,\n        source,\n        preferences,\n        _data,\n        ...args\n      )\n\n      if (languageServicePluginOptions.completions) {\n        const program = languageService.getProgram()\n        if (program) {\n          const sourceFile = program.getSourceFile(fileName)\n          if (sourceFile) {\n            return pipe(\n              postprocessCompletionEntryDetails(\n                sourceFile,\n                _data,\n                applicableCompletionEntryDetails,\n                formatOptions,\n                preferences,\n                info.languageServiceHost\n              ),\n              runNano(program),\n              Either.getOrElse(() => applicableCompletionEntryDetails)\n            )\n          }\n        }\n      }\n\n      return applicableCompletionEntryDetails\n    }\n\n    proxy.getDefinitionAndBoundSpan = (fileName, position, ...args) => {\n      const applicableDefinition = languageService.getDefinitionAndBoundSpan(fileName, position, ...args)\n\n      if (languageServicePluginOptions.goto) {\n        const program = languageService.getProgram()\n        if (program) {\n          const sourceFile = program.getSourceFile(fileName)\n          if (sourceFile) {\n            return pipe(\n              goto(applicableDefinition, sourceFile, position),\n              runNano(program),\n              Either.getOrElse(() => applicableDefinition)\n            )\n          }\n        }\n      }\n\n      return applicableDefinition\n    }\n\n    proxy.provideInlayHints = (fileName, span, preferences, ...args) => {\n      const applicableInlayHints = languageService.provideInlayHints(fileName, span, preferences, ...args)\n\n      if (languageServicePluginOptions.inlays) {\n        const program = languageService.getProgram()\n        if (program) {\n          const sourceFile = program.getSourceFile(fileName)\n          if (sourceFile) {\n            return pipe(\n              middlewareGenLike(sourceFile, span, preferences, applicableInlayHints),\n              runNano(program),\n              Either.getOrElse(() => applicableInlayHints)\n            )\n          }\n        }\n      }\n\n      return applicableInlayHints\n    }\n\n    proxy.findRenameLocations = (fileName, position, findInStrings, findInComments, userPreferences, ...args) => {\n      const applicableRenameInfo = languageService.findRenameLocations(\n        fileName,\n        position,\n        findInStrings,\n        findInComments,\n        userPreferences as ts.UserPreferences,\n        ...args\n      )\n\n      if (languageServicePluginOptions.renames) {\n        const program = languageService.getProgram()\n        if (program) {\n          const sourceFile = program.getSourceFile(fileName)\n          if (sourceFile) {\n            return pipe(\n              renameKeyStrings(\n                sourceFile,\n                position,\n                findInStrings,\n                findInComments,\n                userPreferences as ts.UserPreferences,\n                applicableRenameInfo\n              ),\n              runNano(program),\n              Either.getOrElse(() => applicableRenameInfo)\n            )\n          }\n        }\n      }\n\n      return applicableRenameInfo\n    }\n\n    const additionalProtocolHandlers: Record<\n      string,\n      (request: ts.server.protocol.Request) => ts.server.HandlerResponse\n    > = {\n      \"_effectGetLayerMermaid\": (arg) => {\n        const { character, line, path } = arg.arguments\n        const normalizedPath = modules.typescript.server.toNormalizedPath(path)\n\n        const projectService = info.project.projectService\n        const scriptInfo = projectService.getScriptInfoForNormalizedPath(normalizedPath)\n        if (scriptInfo) {\n          const targetProject = scriptInfo.getDefaultProject()\n          if (targetProject) {\n            const program = targetProject.getLanguageService().getProgram()\n            if (program) {\n              const sourceFile = targetProject.getSourceFile(scriptInfo.path)\n              if (sourceFile) {\n                return pipe(\n                  effectApiGetLayerGraph(sourceFile, line, character),\n                  Nano.map((response) => ({\n                    response: {\n                      success: true,\n                      ...response\n                    }\n                  })),\n                  runNano(program),\n                  Either.getOrElse((e) => ({\n                    response: {\n                      success: false,\n                      error: e.message\n                    }\n                  }))\n                )\n              }\n            }\n          }\n        }\n\n        return {\n          response: {\n            success: false,\n            error: \"No source file found\"\n          }\n        }\n      }\n    }\n\n    if (info.session) {\n      for (const [key, value] of Object.entries(additionalProtocolHandlers)) {\n        try {\n          info.session.addProtocolHandler(key, value)\n        } catch (e) {\n          info.project.log(\"[@effect/language-service] Skipped adding \" + key + \" protocol handler due to error: \" + e)\n        }\n      }\n    }\n\n    return proxy\n  }\n\n  return { create, onConfigurationChanged }\n}\n\nmodule.exports = init\n"],"mappings":";;;AA4BO,IAAMA,aAAcC,WAAsC,OAAOA,UAAU;AAkE3E,IAAMC,OAmIT,SAASC,OAAOC,MAAI;AACtB,MAAI,OAAOD,UAAU,YAAY;AAC/B,WAAO,WAAA;AACL,UAAIA,MAAME,SAAS,GAAG;AAEpB,eAAOD,KAAKE,MAAM,MAAMD,SAAS;MACnC;AACA,aAASE,UAAcH,KAAKG,MAAM,GAAGF,SAAS;IAChD;EACF;AAEA,UAAQF,OAAK;IACX,KAAK;IACL,KAAK;AACH,YAAM,IAAIK,WAAW,iBAAiBL,KAAK,EAAE;IAE/C,KAAK;AACH,aAAO,SAASM,GAAGC,GAAC;AAClB,YAAIL,UAAUM,UAAU,GAAG;AACzB,iBAAOP,KAAKK,GAAGC,CAAC;QAClB;AACA,eAAO,SAASH,MAAS;AACvB,iBAAOH,KAAKG,MAAME,CAAC;QACrB;MACF;IAEF,KAAK;AACH,aAAO,SAASA,GAAGC,GAAGE,GAAC;AACrB,YAAIP,UAAUM,UAAU,GAAG;AACzB,iBAAOP,KAAKK,GAAGC,GAAGE,CAAC;QACrB;AACA,eAAO,SAASL,MAAS;AACvB,iBAAOH,KAAKG,MAAME,GAAGC,CAAC;QACxB;MACF;IAEF,KAAK;AACH,aAAO,SAASD,GAAGC,GAAGE,GAAGC,GAAC;AACxB,YAAIR,UAAUM,UAAU,GAAG;AACzB,iBAAOP,KAAKK,GAAGC,GAAGE,GAAGC,CAAC;QACxB;AACA,eAAO,SAASN,MAAS;AACvB,iBAAOH,KAAKG,MAAME,GAAGC,GAAGE,CAAC;QAC3B;MACF;IAEF,KAAK;AACH,aAAO,SAASH,GAAGC,GAAGE,GAAGC,GAAGC,GAAC;AAC3B,YAAIT,UAAUM,UAAU,GAAG;AACzB,iBAAOP,KAAKK,GAAGC,GAAGE,GAAGC,GAAGC,CAAC;QAC3B;AACA,eAAO,SAASP,MAAS;AACvB,iBAAOH,KAAKG,MAAME,GAAGC,GAAGE,GAAGC,CAAC;QAC9B;MACF;IAEF;AACE,aAAO,WAAA;AACL,YAAIR,UAAUM,UAAUR,OAAO;AAE7B,iBAAOC,KAAKE,MAAM,MAAMD,SAAS;QACnC;AACA,cAAMU,QAAOV;AACb,eAAO,SAASE,MAAS;AACvB,iBAAOH,KAAKG,MAAM,GAAGQ,KAAI;QAC3B;MACF;EACJ;AACF;AA8DO,IAAMC,WAAeC,OAAYA;AA0DjC,IAAMC,WAAeC,WAAyB,MAAMA;AAepD,IAAMC,YAA8BF,yBAAS,IAAI;AAejD,IAAMG,aAA+BH,yBAAS,KAAK;AA8BnD,IAAMI,iBAAqCC,yBAASC,MAAS;AAgpB9D,SAAUC,KACdC,GACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IAAa;AAEb,UAAQC,UAAUC,QAAM;IACtB,KAAK;AACH,aAAOV;IACT,KAAK;AACH,aAAOC,GAAID,CAAC;IACd,KAAK;AACH,aAAOE,GAAID,GAAID,CAAC,CAAC;IACnB,KAAK;AACH,aAAOG,GAAID,GAAID,GAAID,CAAC,CAAC,CAAC;IACxB,KAAK;AACH,aAAOI,GAAID,GAAID,GAAID,GAAID,CAAC,CAAC,CAAC,CAAC;IAC7B,KAAK;AACH,aAAOK,GAAID,GAAID,GAAID,GAAID,GAAID,CAAC,CAAC,CAAC,CAAC,CAAC;IAClC,KAAK;AACH,aAAOM,GAAID,GAAID,GAAID,GAAID,GAAID,GAAID,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACvC,KAAK;AACH,aAAOO,GAAID,GAAID,GAAID,GAAID,GAAID,GAAID,GAAID,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5C,KAAK;AACH,aAAOQ,GAAID,GAAID,GAAID,GAAID,GAAID,GAAID,GAAID,GAAID,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACjD,SAAS;AACP,UAAIW,MAAMF,UAAU,CAAC;AACrB,eAASG,IAAI,GAAGA,IAAIH,UAAUC,QAAQE,KAAK;AACzCD,cAAMF,UAAUG,CAAC,EAAED,GAAG;MACxB;AACA,aAAOA;IACT;EACF;AACF;;;ACjnCO,IAAME,OAAWC,kBAAgE,CAACC,MAASC,SAChGD,SAASC,QAAQF,aAAaC,MAAMC,IAAI;AAgMnC,IAAMC,QAAYC,UACvBC,KAAK,CAACC,MAAMC,SAAQ;AAClB,MAAID,KAAKE,WAAWD,KAAKC,QAAQ;AAC/B,WAAO;EACT;AAEA,WAASC,IAAI,GAAGA,IAAIH,KAAKE,QAAQC,KAAK;AACpC,UAAMC,OAAON,KAAKE,KAAKG,CAAC,GAAGF,KAAKE,CAAC,CAAC;AAClC,QAAI,CAACC,MAAM;AACT,aAAO;IACT;EACF;AAEA,SAAO;AACT,CAAC;;;AC/NH,IAAMC,gBAAgB;AAEtB,IAAIC;AAyBG,IAAMC,cAAcA,CAAIC,IAAaC,YAAuB;AACjE,MAAI,CAACH,aAAa;AAEhBI,eAAWL,aAAa,MAAM,oBAAIM,IAAG;AAErCL,kBAAcI,WAAWL,aAAa;EACxC;AACA,MAAI,CAACC,YAAYM,IAAIJ,EAAE,GAAG;AACxBF,gBAAYO,IAAIL,IAAIC,QAAO,CAAE;EAC/B;AACA,SAAOH,YAAYQ,IAAIN,EAAE;AAC3B;;;ACmbO,IAAMO,WAAYC,WAAoC,OAAOA,UAAU;AAqBvE,IAAMC,WAAYD,WAAoC,OAAOA,UAAU;AAoBvE,IAAME,YAAaF,WAAqC,OAAOA,UAAU;AA+DzE,IAAMG,cAAoDC;AAsH1D,IAAMC,kBAAmBC,WAC9B,OAAOA,UAAU,YAAYA,UAAU;AAuBlC,IAAMC,WAAYD,WAAoCD,gBAAgBC,KAAK,KAAKE,YAAWF,KAAK;AAwBhG,IAAMG,cA+CTC,qBACF,GACA,CAAwBC,MAAeC,aACrCL,SAASI,IAAI,KAAMC,YAAYD,IAAK;AAgCjC,IAAME,WA6DTH,qBACF,GACA,CAAmBC,MAAeG,QAAgCL,YAAYE,MAAM,MAAM,KAAKA,KAAK,MAAM,MAAMG,GAAG;AAqJ9G,IAAMC,WAAYC,WACvBC,gBAAgBD,KAAK,KAAK,CAACE,MAAMC,QAAQH,KAAK;;;ACvhCzC,IAAMI,qBAAsBC,aACjC,QAAQA,OAAO;;;ACqBV,IAAMC,gBAA+BC,uBAAOC,IAAI,oBAAoB;AA4BrE,IAAOC,cAAP,MAAkB;EAKXC;EAJXC,YAIWD,OAA0B;AAA1B,SAAAA,QAAAA;EACR;;;;EAKH,IAAIE,KAAE;AACJ,WAAOC;EACT;;;;EAKA,IAAIC,KAAE;AACJ,WAAQC,OAASA;EACnB;;;;EAKA,IAAIC,KAAE;AACJ,WAAQD,OAAgBA;EAC1B;;;;EAKA,IAAIE,KAAE;AACJ,WAAQF,OAAgBA;EAC1B;;;;EAKS,CAACG,aAAa,IAA0BA;;;;EAKjD,CAACC,OAAOC,QAAQ,IAAC;AACf,WAAO,IAAIC,cAAyC,IAAW;EACjE;;AAOI,IAAOA,gBAAP,MAAOA,eAAa;EAGHC;EAFbC,SAAS;EAEjBZ,YAAqBW,MAAO;AAAP,SAAAA,OAAAA;EAAU;;;;EAK/BE,KAAKC,GAAI;AACP,WAAO,KAAKF,SACT;MACCb,OAAOe;MACPC,MAAM;SAEP,KAAKH,SAAS,MACZ;MACCb,OAAO,KAAKY;MACZI,MAAM;;EAEd;;;;EAKAC,OAAOF,GAAI;AACT,WAAQ;MACNf,OAAOe;MACPC,MAAM;;EAEV;;;;EAKAE,MAAMC,GAAU;AACd,UAAMA;EACR;;;;EAKA,CAACV,OAAOC,QAAQ,IAAC;AACf,WAAO,IAAIC,eAAoB,KAAKC,IAAI;EAC1C;;AAmVF,IAAMQ,SAAS,eAAe;AAC9B,IAAMC,SAAS,eAAe;AAyNvB,IAAMC,kBAAiCC,uBAAOC,IAAI,wBAAwB;AAK3E,IAAOC,YAAP,MAAgB;;;;EAIX;EACTC,YAAYC,OAAQ;AAClB,SAAK,SAASA;EAChB;;;;EAIA,CAACL,eAAe,IAAC;AACf,WAAO,KAAK;EACd;;AAoBK,IAAMM,wBAAwBC,4BACnC,mCACA,OAAwF;EACtFC,SAAS;EACTC,QAAQC;EACR;AAyBJ,IAAMC,WAAW;EACfC,0BAA8BC,UAAiB;AAC7C,WAAOA,KAAI;EACb;;AAGF,IAAMC,SAAS;EACbF,0BAA8BC,UAAiB;AAC7C,QAAI;AACF,aAAOA,KAAI;IACb,UAAC;IACC;EAEJ;;AAGF,IAAME,qBACJJ,yBAASC,yBAAyB,MAAM,IAAII,MAAK,EAAGC,KAAK,GAAGC,SAAS,0BAA0B,MAAM;AAOhG,IAAMC,eAAeJ,qBAAqBJ,SAASC,2BAA2BE,OAAOF;AAE5F,IAAMQ,iBAAkB,aAAS;AAAI,EAAGC;;;ACzxBxC,IAAMC,kBAAkBC,4BACtBC,uBAAOC,IAAI,6BAA6B,GACxC,MAAM,oBAAIC,QAAO,CAAkB;AAO9B,IAAMC,SAAwBH,uBAAOC,IAAI,aAAa;AActD,IAAMG,OAAmCC,UAAW;AACzD,MAAIC,sBAAsBC,YAAY,MAAM;AAC1C,WAAO;EACT;AAEA,UAAQ,OAAOF,MAAI;IACjB,KAAK;AACH,aAAOG,OAAOH,IAAI;IACpB,KAAK;AACH,aAAOI,OAAOJ,KAAKK,SAAS,EAAE,CAAC;IACjC,KAAK;AACH,aAAOD,OAAOE,OAAON,IAAI,CAAC;IAC5B,KAAK;AACH,aAAOI,OAAOE,OAAON,IAAI,CAAC;IAC5B,KAAK;AACH,aAAOI,OAAOJ,IAAI;IACpB,KAAK;AACH,aAAOI,OAAO,WAAW;IAC3B,KAAK;IACL,KAAK,UAAU;AACb,UAAIJ,SAAS,MAAM;AACjB,eAAOI,OAAO,MAAM;MACtB,WAAWJ,gBAAgBO,MAAM;AAC/B,eAAOR,KAAKC,KAAKQ,YAAW,CAAE;MAChC,WAAWR,gBAAgBS,KAAK;AAC9B,eAAOV,KAAKC,KAAKU,IAAI;MACvB,WAAWC,OAAOX,IAAI,GAAG;AACvB,eAAOA,KAAKF,MAAM,EAAC;MACrB,OAAO;AACL,eAAOc,OAAOZ,IAAI;MACpB;IACF;IACA;AACE,YAAM,IAAIa,MACR,yBAAyB,OAAOb,IAAI,yEAAyE;EAEnH;AACF;AAMO,IAAMY,SAAiDZ,UAAQ;AACpE,MAAI,CAACP,gBAAgBqB,IAAId,IAAI,GAAG;AAC9BP,oBAAgBsB,IAAIf,MAAMG,OAAOa,KAAKC,MAAMD,KAAKJ,OAAM,IAAKM,OAAOC,gBAAgB,CAAC,CAAC;EACvF;AACA,SAAO1B,gBAAgB2B,IAAIpB,IAAI;AACjC;AAMO,IAAMqB,UAAoDC,OAAOtB,UAAUA,OAAO,KAAMsB;AAMxF,IAAMC,WAAYC,OAAuBA,IAAI,aAAgBA,MAAM,IAAK;AAMxE,IAAMb,SAAUc,OAA0BC,YAAYD,GAAG3B,MAAM;AAM/D,IAAMK,SAAUqB,OAAa;AAClC,MAAIA,MAAMA,KAAKA,MAAMG,UAAU;AAC7B,WAAO;EACT;AACA,MAAIC,IAAIJ,IAAI;AACZ,MAAII,MAAMJ,GAAG;AACXI,SAAKJ,IAAI;EACX;AACA,SAAOA,IAAI,YAAY;AACrBI,SAAKJ,KAAK;EACZ;AACA,SAAOD,SAASK,CAAC;AACnB;AAMO,IAAMxB,SAAUyB,SAAe;AACpC,MAAID,IAAI,MAAME,IAAID,IAAIE;AACtB,SAAOD,GAAG;AACRF,QAAKA,IAAI,KAAMC,IAAIG,WAAW,EAAEF,CAAC;EACnC;AACA,SAAOP,SAASK,CAAC;AACnB;AAMO,IAAMK,gBAAgBA,CAAmBC,GAAMC,UAAgC;AACpF,MAAIP,IAAI;AACR,WAASE,IAAI,GAAGA,IAAIK,MAAKJ,QAAQD,KAAK;AACpCF,SAAKQ,KAAKhC,OAAO+B,MAAKL,CAAC,CAAY,GAAGT,QAAQtB,KAAMmC,EAAUC,MAAKL,CAAC,CAAE,CAAC,CAAC,CAAC;EAC3E;AACA,SAAOP,SAASK,CAAC;AACnB;AAMO,IAAMS,YAA+BH,OAC1CD,cAAcC,GAAGI,OAAOH,KAAKD,CAAC,CAAsC;AAM/D,IAAMK,SAAYC,SAAyB;AAChD,MAAIZ,IAAI;AACR,WAASE,IAAI,GAAGA,IAAIU,IAAIT,QAAQD,KAAK;AACnCF,QAAIQ,KAAKR,GAAGP,QAAQtB,KAAKyC,IAAIV,CAAC,CAAC,CAAC,CAAC;EACnC;AACA,SAAOP,SAASK,CAAC;AACnB;AAMO,IAAMa,SAWT,WAAA;AACF,MAAIC,UAAUX,WAAW,GAAG;AAC1B,UAAM/B,QAAO0C,UAAU,CAAC;AACxB,WAAO,SAAS3C,OAAY;AAC1BuC,aAAOK,eAAe3C,OAAMF,QAAQ;QAClC8C,QAAK;AACH,iBAAO7C;QACT;QACA8C,YAAY;OACb;AACD,aAAO9C;IACT;EACF;AACA,QAAMC,OAAO0C,UAAU,CAAC;AACxB,QAAM3C,QAAO2C,UAAU,CAAC;AACxBJ,SAAOK,eAAe3C,MAAMF,QAAQ;IAClC8C,QAAK;AACH,aAAO7C;IACT;IACA8C,YAAY;GACb;AAED,SAAO9C;AACT;;;AC3LO,IAAM+C,UAAwBC,uBAAOC,IAAI,cAAc;AAgBxD,SAAUC,SAAM;AACpB,MAAIC,UAAUC,WAAW,GAAG;AAC1B,WAAQC,UAAkBC,YAAYD,MAAMF,UAAU,CAAC,CAAC;EAC1D;AACA,SAAOG,YAAYH,UAAU,CAAC,GAAGA,UAAU,CAAC,CAAC;AAC/C;AAEA,SAASG,YAAYD,MAAeE,MAAa;AAC/C,MAAIF,SAASE,MAAM;AACjB,WAAO;EACT;AACA,QAAMC,WAAW,OAAOH;AACxB,MAAIG,aAAa,OAAOD,MAAM;AAC5B,WAAO;EACT;AACA,MAAIC,aAAa,YAAYA,aAAa,YAAY;AACpD,QAAIH,SAAS,QAAQE,SAAS,MAAM;AAClC,UAAIE,QAAQJ,IAAI,KAAKI,QAAQF,IAAI,GAAG;AAClC,YAASG,KAAKL,IAAI,MAAWK,KAAKH,IAAI,KAAKF,KAAKN,OAAM,EAAEQ,IAAI,GAAG;AAC7D,iBAAO;QACT,OAAO;AACL,iBAAOI,sBAAsBC,WAAWD,sBAAsBE,SAC1DF,sBAAsBE,OAAOR,MAAME,IAAI,IACvC;QACN;MACF,WAAWF,gBAAgBS,QAAQP,gBAAgBO,MAAM;AACvD,eAAOT,KAAKU,YAAW,MAAOR,KAAKQ,YAAW;MAChD,WAAWV,gBAAgBW,OAAOT,gBAAgBS,KAAK;AACrD,eAAOX,KAAKY,SAASV,KAAKU;MAC5B;IACF;AACA,QAAIN,sBAAsBC,SAAS;AACjC,UAAIM,MAAMC,QAAQd,IAAI,KAAKa,MAAMC,QAAQZ,IAAI,GAAG;AAC9C,eAAOF,KAAKD,WAAWG,KAAKH,UAAUC,KAAKe,MAAM,CAACC,GAAGC,MAAMhB,YAAYe,GAAGd,KAAKe,CAAC,CAAC,CAAC;MACpF;AACA,UAAIC,OAAOC,eAAenB,IAAI,MAAMkB,OAAOE,aAAaF,OAAOC,eAAenB,IAAI,MAAMkB,OAAOE,WAAW;AACxG,cAAMC,WAAWH,OAAOI,KAAKtB,IAAW;AACxC,cAAMuB,WAAWL,OAAOI,KAAKpB,IAAW;AACxC,YAAImB,SAAStB,WAAWwB,SAASxB,QAAQ;AACvC,qBAAWyB,OAAOH,UAAU;AAE1B,gBAAI,EAAEG,OAAOtB,QAAQD,YAAYD,KAAKwB,GAAG,GAAGtB,KAAKsB,GAAG,CAAC,IAAI;AACvD,qBAAOlB,sBAAsBE,SAASF,sBAAsBE,OAAOR,MAAME,IAAI,IAAI;YACnF;UACF;AACA,iBAAO;QACT;MACF;AACA,aAAOI,sBAAsBE,SAASF,sBAAsBE,OAAOR,MAAME,IAAI,IAAI;IACnF;EACF;AAEA,SAAOI,sBAAsBC,WAAWD,sBAAsBE,SAC1DF,sBAAsBE,OAAOR,MAAME,IAAI,IACvC;AACN;AAMO,IAAME,UAAWqB,OAA2BC,YAAYD,GAAG/B,OAAM;AAMjE,IAAMiC,cAAuCA,MAAM9B;;;ACpFnD,IAAM+B,oBAAoBC,uBAAOC,IAAI,4BAA4B;AAqBjE,IAAMC,SAAUC,OAAuB;AAC5C,MAAI;AACF,QACEC,YAAYD,GAAG,QAAQ,KAAKE,YAAWF,EAAE,QAAQ,CAAC,KAClDA,EAAE,QAAQ,EAAEG,WAAW,GACvB;AACA,aAAOH,EAAED,OAAM;IACjB,WAAWK,MAAMC,QAAQL,CAAC,GAAG;AAC3B,aAAOA,EAAEM,IAAIP,MAAM;IACrB;EACF,QAAQ;AACN,WAAO,CAAA;EACT;AACA,SAAOQ,OAAOP,CAAC;AACjB;AAKO,IAAMQ,SAAUR,OAAuBS,KAAKC,UAAUV,GAAG,MAAM,CAAC;AAKhE,IAAMW,YAAyB;EACpCZ,SAAM;AACJ,WAAOA,OAAO,IAAI;EACpB;EACA,CAACH,iBAAiB,IAAC;AACjB,WAAO,KAAKG,OAAM;EACpB;EACAa,WAAQ;AACN,WAAOJ,OAAO,KAAKT,OAAM,CAAE;EAC7B;;AAMI,IAAgBc,QAAhB,MAAqB;;;;EAQzB,CAACjB,iBAAiB,IAAC;AACjB,WAAO,KAAKG,OAAM;EACpB;;;;EAIAa,WAAQ;AACN,WAAOJ,OAAO,KAAKT,OAAM,CAAE;EAC7B;;AAoBK,IAAMe,oBAAoBA,CAACC,KAAcC,eAAoD;AAClG,MAAIC,QAAwB,CAAA;AAC5B,QAAMC,SAASC,KAAKC,UAClBL,KACA,CAACM,MAAMC,UACL,OAAOA,UAAU,YAAYA,UAAU,OACnCL,MAAMM,SAASD,KAAK,IAClBE,SACAP,MAAMQ,KAAKH,KAAK,MAAMI,gBAAgBC,cAAcH,UAAaI,aAAaN,KAAK,IACjFA,MAAMO,gBAAgB,EAAEH,gBAAgBC,SAAS,IACjDL,SACJA,OACNN,UAAU;AAEVC,UAAgBO;AAClB,SAAON;AACT;AAcO,IAAMW,mBAAkCC,uBAAOC,IAAI,+BAA+B;AAMlF,IAAMH,eAAgBI,OAC3B,OAAOA,MAAM,YAAYA,MAAM,QAAQH,oBAAoBG;AAE7D,IAAMN,kBAAkBO,4BAAY,sCAAsC,OAAO;EAC/EN,WAAWH;EACX;AAoBK,IAAMU,SAAUC,OAAuB;AAC5C,MAAIC,aAAaD,CAAC,KAAKE,gBAAgBC,cAAcC,QAAW;AAC9D,WAAOJ,EAAEK,gBAAgB,EAAEH,gBAAgBC,SAAS;EACtD;AACA,SAAOH;AACT;;;ACkUO,IAAMM,gBAAgBA,CAAIC,MAASC,UAA6B;AACrE,UAAQA,MAAKC,QAAM;IACjB,KAAK;AACH,aAAOF;IACT,KAAK;AACH,aAAOC,MAAK,CAAC,EAAED,IAAI;IACrB,KAAK;AACH,aAAOC,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAED,IAAI,CAAC;IAC9B,KAAK;AACH,aAAOC,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAED,IAAI,CAAC,CAAC;IACvC,KAAK;AACH,aAAOC,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAED,IAAI,CAAC,CAAC,CAAC;IAChD,KAAK;AACH,aAAOC,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAED,IAAI,CAAC,CAAC,CAAC,CAAC;IACzD,KAAK;AACH,aAAOC,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAED,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAClE,KAAK;AACH,aAAOC,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAED,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3E,KAAK;AACH,aAAOC,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAED,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACpF,KAAK;AACH,aAAOC,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAEA,MAAK,CAAC,EAAED,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7F,SAAS;AACP,UAAIG,MAAMH;AACV,eAASI,IAAI,GAAGC,MAAMJ,MAAKC,QAAQE,IAAIC,KAAKD,KAAK;AAC/CD,cAAMF,MAAKG,CAAC,EAAED,GAAG;MACnB;AACA,aAAOA;IACT;EACF;AACF;;;ACngBO,IAAMG,YAAY;AAMlB,IAAMC,aAAa;AA4DnB,IAAMC,kBAAkB;;;AC5E/B,IAAIC,gBAAgB;AAEb,IAAMC,oBAAoBA,MAAMD;;;ACWhC,IAAME,eAAoCC,uBAAOC,IAAI,eAAe;AAGpE,IAAMC,eAAoCF,uBAAOC,IAAI,eAAe;AAGpE,IAAME,aAA8BH,uBAAOC,IAAI,aAAa;AAG5D,IAAMG,gBAAuCJ,uBAAOC,IAAI,gBAAgB;AAGxE,IAAMI,iBAAiB;;EAE5BC,IAAKC,OAAaA;;EAElBC,IAAKD,OAAaA;;EAElBE,IAAKF,OAAaA;EAElBG,IAAIC,gBAAQC,kBAAiB;;AAG/B,IAAMC,eAAe;;EAEnBJ,IAAKF,OAAaA;;EAElBO,KAAMP,OAAeA;;EAErBQ,IAAKR,OAAaA;;EAElBC,IAAKD,OAAaA;;EAElBD,IAAKC,OAAaA;;AAGpB,IAAMS,kBAAkB;;EAEtBC,MAAOV,OAAaA;;EAEpBW,QAASX,OAAeA;;EAExBY,SAAUZ,OAAeA;;EAEzBa,SAAUb,OAAeA;;EAEzBc,SAAUd,OAAaA;;EAEvBe,UAAWf,OAAaA;;EAExBgB,UAAWhB,OAAaA;;AAInB,IAAMiB,kBAAsD;EACjE,CAACzB,YAAY,GAAGM;EAChB,CAACH,YAAY,GAAGG;EAChB,CAACF,UAAU,GAAGU;EACd,CAACT,aAAa,GAAGY;EACjB,CAAOS,OAAM,EAAEC,MAAS;AACtB,WAAO,SAASA;EAClB;EACA,CAAMD,MAAM,IAAC;AACX,WAAYE,OAAO,MAAWC,OAAO,IAAI,CAAC;EAC5C;EACA,CAAC5B,OAAO6B,QAAQ,IAAC;AACf,WAAO,IAAIC,cAAc,IAAIC,UAAU,IAAI,CAAC;EAC9C;EACAC,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;;AAIK,IAAMC,sBAAmC;EAC9C,CAAMV,MAAM,IAAC;AACX,WAAYE,OAAO,MAAWS,UAAU,IAAI,CAAC;EAC/C;EACA,CAAOX,OAAM,EAAqBC,MAAiB;AACjD,UAAMW,WAAWC,OAAOC,KAAK,IAAI;AACjC,UAAMC,WAAWF,OAAOC,KAAKb,IAAc;AAC3C,QAAIW,SAASI,WAAWD,SAASC,QAAQ;AACvC,aAAO;IACT;AACA,eAAWC,OAAOL,UAAU;AAC1B,UAAI,EAAEK,OAAQhB,QAAyBiB,OAAQ,KAAaD,GAAG,GAAIhB,KAAagB,GAAG,CAAC,IAAI;AACtF,eAAO;MACT;IACF;AACA,WAAO;EACT;;AAIK,IAAME,kBAAwC;EACnD,GAAGpB;EACHqB,KAAaC;;AAIR,IAAMC,4BAAkD;EAC7D,GAAGH;EACH,GAAGT;;;;ACxGL,IAAMa,SAAwBC,uBAAOC,IAAI,eAAe;AAExD,IAAMC,cAAc;EAClB,GAAGC;EACH,CAACJ,MAAM,GAAG;IACRK,IAAKC,OAAaA;;EAEpB,CAACC,iBAAiB,IAAC;AACjB,WAAO,KAAKC,OAAM;EACpB;EACAC,WAAQ;AACN,WAAOC,OAAO,KAAKF,OAAM,CAAE;EAC7B;;AAGF,IAAMG,YAAYC,uBAAOC,OAAOD,uBAAOE,OAAOX,WAAW,GAAG;EAC1DY,MAAM;EACNC,KAAK;EACL,CAAOC,OAAM,EAA2BC,MAAa;AACnD,WAAOC,SAASD,IAAI,KAAKE,OAAOF,IAAI,KAAWG,OAAO,KAAKC,OAAOJ,KAAKI,KAAK;EAC9E;EACA,CAAML,MAAM,IAAC;AACX,WAAYM,OAAO,MAAWC,QAAaC,KAAK,KAAKV,IAAI,CAAC,EAAOU,KAAK,KAAKH,KAAK,CAAC,CAAC;EACpF;EACAd,SAAM;AACJ,WAAO;MACLkB,KAAK;MACLX,MAAM,KAAKA;MACXO,OAAOd,OAAO,KAAKc,KAAK;;EAE5B;CACD;AAED,IAAMK,WAAWC,gBAAKH,KAAK,MAAM;AACjC,IAAMI,YAAYjB,uBAAOC,OAAOD,uBAAOE,OAAOX,WAAW,GAAG;EAC1DY,MAAM;EACNC,KAAK;EACL,CAAOC,OAAM,EAA2BC,MAAa;AACnD,WAAOC,SAASD,IAAI,KAAKY,OAAOZ,IAAI;EACtC;EACA,CAAMD,MAAM,IAAC;AACX,WAAOU;EACT;EACAnB,SAAM;AACJ,WAAO;MACLkB,KAAK;MACLX,MAAM,KAAKA;;EAEf;CACD;AAGM,IAAMI,WAAYY,WAAoDC,YAAYD,OAAO/B,MAAM;AAG/F,IAAM8B,SAAaG,QAA+CA,GAAGlB,SAAS;AAG9E,IAAMK,SAAaa,QAA+CA,GAAGlB,SAAS;AAG9E,IAAMmB,OAA6BtB,uBAAOE,OAAOe,SAAS;AAG1D,IAAMM,OAAWb,WAA8B;AACpD,QAAMc,IAAIxB,OAAOE,OAAOH,SAAS;AACjCyB,IAAEd,QAAQA;AACV,SAAOc;AACT;;;AC9DO,IAAMC,UAAwBC,uBAAOC,IAAI,eAAe;AAE/D,IAAMC,eAAc;EAClB,GAAGC;EACH,CAACJ,OAAM,GAAG;IACRK,IAAKC,OAAaA;;EAEpB,CAACC,iBAAiB,IAAC;AACjB,WAAO,KAAKC,OAAM;EACpB;EACAC,WAAQ;AACN,WAAOC,OAAO,KAAKF,OAAM,CAAE;EAC7B;;AAGF,IAAMG,aAAaC,uBAAOC,OAAOD,uBAAOE,OAAOX,YAAW,GAAG;EAC3DY,MAAM;EACNC,KAAK;EACL,CAAOC,OAAM,EAAkCC,MAAa;AAC1D,WAAOC,SAASD,IAAI,KAAKE,QAAQF,IAAI,KAAWG,OAAO,KAAKC,OAAOJ,KAAKI,KAAK;EAC/E;EACA,CAAML,MAAM,IAAC;AACX,WAAYM,QAAaC,KAAK,KAAKT,IAAI,CAAC,EAAOS,KAAK,KAAKF,KAAK,CAAC;EACjE;EACAd,SAAM;AACJ,WAAO;MACLiB,KAAK;MACLV,MAAM,KAAKA;MACXO,OAAOd,OAAO,KAAKc,KAAK;;EAE5B;CACD;AAED,IAAMI,YAAYd,uBAAOC,OAAOD,uBAAOE,OAAOX,YAAW,GAAG;EAC1DY,MAAM;EACNC,KAAK;EACL,CAAOC,OAAM,EAAiCC,MAAa;AACzD,WAAOC,SAASD,IAAI,KAAKS,OAAOT,IAAI,KAAWG,OAAO,KAAKO,MAAMV,KAAKU,IAAI;EAC5E;EACA,CAAMX,MAAM,IAAC;AACX,WAAYM,QAAaC,KAAK,KAAKT,IAAI,CAAC,EAAOS,KAAK,KAAKI,IAAI,CAAC;EAChE;EACApB,SAAM;AACJ,WAAO;MACLiB,KAAK;MACLV,MAAM,KAAKA;MACXa,MAAMpB,OAAO,KAAKoB,IAAI;;EAE1B;CACD;AAGM,IAAMT,WAAYU,WAA6DC,YAAYD,OAAO7B,OAAM;AAGxG,IAAM2B,SAAgBI,QAAqDA,GAAGhB,SAAS;AAGvF,IAAMK,UAAiBW,QAAsDA,GAAGhB,SAAS;AAGzF,IAAMa,OAAWA,CAAAA,UAAoC;AAC1D,QAAMI,IAAIpB,OAAOE,OAAOY,SAAS;AACjCM,IAAEJ,OAAOA;AACT,SAAOI;AACT;AAGO,IAAMV,QAAYA,CAAAA,WAA8B;AACrD,QAAMU,IAAIpB,OAAOE,OAAOH,UAAU;AAClCqB,IAAEV,QAAQA;AACV,SAAOU;AACT;;;AC8BO,IAAMC,SAAuCA;AAkB7C,IAAMC,QAA6CA;AAgLnD,IAAMC,UAAkEA;AAiBxE,IAAMC,WAAoEA;AAqH1E,IAAMC,MAeTC,qBACF,GACA,CAAWC,MAAoBC,MAC7BC,SAAQF,IAAI,IAAIG,OAAMF,EAAED,KAAKG,KAAK,CAAC,IAAIC,MAAKJ,KAAKI,IAAI,CAAC;AAsanD,IAAMC,YAiCTC,qBACF,GACA,CAAWC,MAAoBC,WAAoCC,QAAOF,IAAI,IAAIC,OAAOD,KAAKG,IAAI,IAAIH,KAAKI,KAAK;;;ACn5B3G,IAAMC,kBAAsBC,UAAqDA,KAAKC,SAAS;;;ACkC/F,IAAMC,QACXC,aAEF,CAACC,MAAMC,SAASD,SAASC,OAAO,IAAIF,QAAQC,MAAMC,IAAI;AAM/C,IAAMC,UAAwBJ,gBAAAA,MAAK,CAACE,MAAMC,SAASD,OAAOC,OAAO,KAAK,CAAC;AAMvE,IAAME,UAAwBL,gBAAAA,MAAK,CAACE,MAAMC,SAASD,OAAOC,OAAO,KAAK,CAAC;AAwFvE,IAAMG,WAWTC,qBACF,GACA,CAAOC,MAAgBC,MAA6BC,MAAK,CAACC,IAAIC,OAAOJ,KAAKC,EAAEE,EAAE,GAAGF,EAAEG,EAAE,CAAC,CAAC,CAAC;;;ACInF,IAAMC,QAAOA,MAAmCA;AAyBhD,IAAMC,QAA0CA;AAkDhD,IAAMC,UAAyDA;AAqB/D,IAAMC,UAAyDA;AAqU/D,IAAMC,aAqETC,qBACF,GACA,CAAOC,MAAiBC,WAA8BC,QAAOF,IAAI,IAAIC,OAAM,IAAKD,KAAKG,KAAK;AAuCrF,IAAMC,SA2ETL,qBACF,GACA,CAAOC,MAAiBK,SAA4CH,QAAOF,IAAI,IAAIK,KAAI,IAAKL,IAAI;AA+O3F,IAAMM,eACXC,mBAC4BA,iBAAiB,OAAOC,MAAI,IAAKC,MAAKF,aAA+B;AAgG5F,IAAMG,iBAAwDC,gBAAAA,WAAUC,cAAc;AAuMtF,IAAMC,OAuETC,qBACF,GACA,CAAOC,MAAiBC,MAA8BC,QAAOF,IAAI,IAAIG,MAAI,IAAKC,MAAKH,EAAED,KAAKK,KAAK,CAAC,CAAC;;;AC7jB5F,IAAMC,OA2CTC,qBACF,GACA,CAAyBC,MAA4BC,MAAiD;AACpG,QAAMC,MAAoB;IAAE,GAAGF;EAAI;AACnC,aAAWG,OAAOC,KAAKJ,IAAI,GAAG;AAC5BE,QAAIC,GAAG,IAAIF,EAAED,KAAKG,GAAG,GAAGA,GAAG;EAC7B;AACA,SAAOD;AACT,CAAC;AA+kBI,IAAMG,OAAsCC,UACjDC,OAAOF,KAAKC,IAAI;;;AChsCX,IAAME,eAAmBC,gBAC9BC,MAAMC,QAAQF,UAAU,IAAIA,aAAaC,MAAME,KAAKH,UAAU;AAiczD,IAAMI,SAiCTC,qBAAK,GAAG,CAAOC,MAAmBC,SAA0B,CAAC,GAAGD,MAAMC,IAAI,CAAC;AASxE,IAAMC,YAiCTH,qBACF,GACA,CAAIC,MAAmBG,SAAgCC,aAAaJ,IAAI,EAAEK,OAAOD,aAAaD,IAAI,CAAC,CAAC;AAoK/F,IAAMG,UAiCTC,MAAMD;AAiBH,IAAME,eAAmBC,UAA+BA,KAAKC,WAAW;AAiBxE,IAAMC,uBAA2EH;AAsCjF,IAAMI,0BACGC;AAUhB,IAAMC,gBAAgBA,CAAIC,GAAWC,OAAkCD,IAAI,KAAKA,KAAKC,GAAGC;AAUjF,IAAMC,MAeTC,qBAAK,GAAG,CAAIC,MAAwBC,UAAmC;AACzE,QAAMC,IAAIC,KAAKC,MAAMH,KAAK;AAC1B,SAAOI,cAAcH,GAAGF,IAAI,IAAWM,MAAI,IAAYC,MAAKP,KAAKE,CAAC,CAAC;AACrE,CAAC;AAQM,IAAMM,YAeTT,qBAAK,GAAG,CAAIC,MAAwBC,UAAoB;AAC1D,QAAMC,IAAIC,KAAKC,MAAMH,KAAK;AAC1B,MAAII,cAAcH,GAAGF,IAAI,GAAG;AAC1B,UAAM,IAAIS,MAAM,SAASP,CAAC,gBAAgB;EAC5C;AACA,SAAOF,KAAKE,CAAC;AACf,CAAC;AA8CM,IAAMQ,OAAwDC,oBAAI,CAAC;AAiBnE,IAAMC,eAAyDC,0BAAU,CAAC;AAsD1E,IAAMC,eAAmBC,UAA6CA,KAAKC,MAAM,CAAC;AA6gDlF,IAAMC,UACXC,UAEAC,MAAMC,KAAKF,IAAI,EAAED,QAAO;AASnB,IAAMI,OAyBTC,qBAAK,GAAG,CAAiBJ,MAAmBK,MAA+B;AAC7E,QAAMC,MAAML,MAAMC,KAAKF,IAAI;AAC3BM,MAAIH,KAAKE,CAAC;AACV,SAAOC;AACT,CAAC;AA+vBM,IAAMC,eAAmBC,kBAI9BC,KAAK,GAAG,CAACC,MAAmBC,MAAiB;AAC3C,aAAWC,KAAKF,MAAM;AACpB,QAAIF,aAAaG,GAAGC,CAAC,GAAG;AACtB,aAAO;IACT;EACF;AACA,SAAO;AACT,CAAC;AAEH,IAAMC,eAAeC,gBAAMC,YAAW;AAukC/B,IAAMC,mBAAuBC,kBAGhC;AACF,QAAMC,OAAMC,aAAaF,YAAY;AACrC,SAAOG,KACL,GACA,CAACC,MAAmBC,SAAgCC,aAAaF,IAAI,EAAEG,OAAQC,OAAMP,KAAII,MAAMG,CAAC,CAAC,CAAC;AAEtG;AAiBO,IAAMC,eAiCTV,iCAAiBW,YAAY;AAoF1B,IAAMC,QAAmCA,MAAM,CAAA;AA8D/C,IAAMC,OAWTC,qBAAK,GAAG,CAAOC,MAAwBC,MAAwCD,KAAKF,IAAIG,CAAC,CAAC;AAQvF,IAAMC,UAyBTH,qBACF,GACA,CAAOC,MAAwBC,MAAsD;AACnF,MAAIE,qBAAqBH,IAAI,GAAG;AAC9B,WAAO,CAAA;EACT;AACA,QAAMI,MAAgB,CAAA;AACtB,WAASC,IAAI,GAAGA,IAAIL,KAAKM,QAAQD,KAAK;AACpC,UAAME,QAAQN,EAAED,KAAKK,CAAC,GAAGA,CAAC;AAC1B,aAASG,IAAI,GAAGA,IAAID,MAAMD,QAAQE,KAAK;AACrCJ,UAAIK,KAAKF,MAAMC,CAAC,CAAC;IACnB;EACF;AACA,SAAOJ;AACT,CAAC;AAoBI,IAAMM,UAA8FR,wBACzGS,QAAQ;AAyUH,IAAMC,SAqBTC,qBACF,GACA,CAAIC,MAAmBC,cAAqD;AAC1E,QAAMC,KAAKC,aAAaH,IAAI;AAC5B,QAAMI,MAAgB,CAAA;AACtB,WAASC,IAAI,GAAGA,IAAIH,GAAGI,QAAQD,KAAK;AAClC,QAAIJ,UAAUC,GAAGG,CAAC,GAAGA,CAAC,GAAG;AACvBD,UAAIG,KAAKL,GAAGG,CAAC,CAAC;IAChB;EACF;AACA,SAAOD;AACT,CAAC;AAkBI,IAAMI,YAmETT,qBACF,GACA,CAAIC,MAAmBC,cAAuF;AAC5G,QAAMQ,QAAiB,CAAA;AACvB,QAAMC,SAAkB,CAAA;AACxB,QAAMR,KAAKC,aAAaH,IAAI;AAC5B,WAASK,IAAI,GAAGA,IAAIH,GAAGI,QAAQD,KAAK;AAClC,QAAIJ,UAAUC,GAAGG,CAAC,GAAGA,CAAC,GAAG;AACvBK,MAAAA,OAAMH,KAAKL,GAAGG,CAAC,CAAC;IAClB,OAAO;AACLI,MAAAA,MAAKF,KAAKL,GAAGG,CAAC,CAAC;IACjB;EACF;AACA,SAAO,CAACI,OAAMC,MAAK;AACrB,CAAC;AA6BI,IAAMC,SAiCTC,qBACF,GACA,CAAOC,MAAmBC,GAAMC,MAC9BC,aAAaH,IAAI,EAAEF,OAAO,CAACG,IAAGG,GAAGC,MAAMH,EAAED,IAAGG,GAAGC,CAAC,GAAGJ,CAAC,CAAC;AAyOlD,IAAMK,QA6BTC,qBACF,GACA,CAAiBC,MAAwBC,eACvCD,KAAKF,MAAMG,UAAU,CAAC;AAySnB,IAAMC,aAsDTC,qBACF,GACA,CAAIC,MAAmBC,iBAAyD;AAC9E,QAAMC,QAAQC,aAAaH,IAAI;AAC/B,MAAII,wBAAwBF,KAAK,GAAG;AAClC,UAAMG,MAAwB,CAACC,aAAaJ,KAAK,CAAC;AAClD,UAAMK,OAAOC,aAAaN,KAAK;AAC/B,eAAWO,KAAKF,MAAM;AACpB,UAAIF,IAAIK,MAAOC,OAAM,CAACV,aAAaQ,GAAGE,CAAC,CAAC,GAAG;AACzCN,YAAIO,KAAKH,CAAC;MACZ;IACF;AACA,WAAOJ;EACT;AACA,SAAO,CAAA;AACT,CAAC;AASI,IAAMQ,SACXb,UAEAF,WAAWE,MAAYc,YAAW,CAAE;;;AC7+L/B,IAAM,UAAN,MAAiB;AAAA,EAEtB,YACW,KACT;AADS;AAAA,EACR;AACL;AAEO,IAAM,MAAM,CAAY,eAAuB,IAAI,QAAW,UAAU;AAExE,IAAMC,iBAAN,MAAM,eAAsD;AAAA,EACzD,SAAS;AAAA,EACR;AAAA,EAET,YAAY,MAAS;AACnB,SAAK,OAAO;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,GAA4B;AAC/B,WAAO,KAAK,SACT;AAAA,MACC,OAAO;AAAA,MACP,MAAM;AAAA,IACR,KACC,KAAK,SAAS,MACZ;AAAA,MACC,OAAO,KAAK;AAAA,MACZ,MAAM;AAAA,IACR;AAAA,EACN;AAAA;AAAA;AAAA;AAAA,EAKA,CAAC,OAAO,QAAQ,IAA4B;AAC1C,WAAO,IAAI,eAAoB,KAAK,IAAI;AAAA,EAC1C;AACF;AAUA,IAAM,WAAW,OAAO,IAAI,eAAe;AAC3C,IAAM,QAAQ,OAAO,IAAI,YAAY;AAErC,IAAM,QAAQ,OAAO,IAAI,YAAY;AAErC,IAAM,UAAU,OAAO,IAAI,cAAc;AAEzC,IAAM,YAAY,OAAO,IAAI,YAAY;AAEzC,IAAM,OAAO,OAAO,IAAI,WAAW;AAG5B,IAAM,sBAAN,MAA0B;AAAA,EAE/B,YACW,SACT;AADS;AAAA,EACR;AAAA,EAHM,OAAO;AAIlB;AAsCA,IAAM,iBAA8D;AAAA,EAClE,CAAC,OAAO,QAAQ,IAAI;AAClB,WAAO,IAAIA,eAAc,IAAW;AAAA,EACtC;AACF;AAEA,IAAM,eAAyC;AAAA,EAC7C,GAAG;AAAA,EACH,MAAM;AAAA,EACN,IAAI,QAAQ;AACV,WAAO,KAAK,IAAI;AAAA,EAClB;AAAA,EACA,CAAC,QAAQ,EAAE,OAAkB;AAC3B,UAAM,OAAO,MAAM,QAAQ,KAAK;AAChC,WAAO,OAAO,KAAK,KAAK,EAAE,KAAK,IAAI,GAAG,KAAK,IAAI,MAAM,UAAU,IAAI;AAAA,EACrE;AACF;AACO,IAAM,UAAkD,CAAI,UAAa;AAC9E,QAAM,OAAO,OAAO,OAAO,YAAY;AACvC,OAAK,IAAI,IAAI;AACb,SAAO;AACT;AAEA,IAAM,eAAyC;AAAA,EAC7C,GAAG;AAAA,EACH,MAAM;AAAA,EACN,IAAI,QAAQ;AACV,WAAO,KAAK,IAAI;AAAA,EAClB;AAAA,EACA,CAAC,QAAQ,EAAE,OAAkB;AAC3B,UAAM,OAAO,MAAM,QAAQ,KAAK;AAChC,WAAO,OAAO,KAAK,KAAK,EAAE,KAAK,IAAI,GAAG,KAAK,IAAI,MAAM,UAAU,IAAI;AAAA,EACrE;AACF;AACO,IAAM,OAA+C,CAAI,UAAa;AAC3E,QAAM,OAAO,OAAO,OAAO,YAAY;AACvC,OAAK,IAAI,IAAI;AACb,SAAO;AACT;AAEA,IAAM,eAA8B;AAAA,EAClC,GAAG;AAAA,EACH,CAAC,QAAQ,IAAI;AACX,WAAO,KAAK,IAAI,EAAE;AAAA,EACpB;AACF;AACO,IAAM,UAA+D,CAAUC,QAA4B;AAChH,QAAM,OAAO,OAAO,OAAO,YAAY;AACvC,OAAK,IAAI,IAAIA;AACb,SAAO;AACT;AAEA,IAAM,YAAN,MAAgB;AAAA,EACL,SAA+B,CAAC;AAAA,EACzC,WAAiC;AAAA,EACjC,YAAiC,CAAC;AAAA,EAClC,SAA4C,CAAC;AAAA,EAC7C,QAAiB;AAAA,EAEjB,QAAQ,MAA2B;AACjC,QAAI,UAAqC;AACzC,WAAO,MAAM;AACX,gBAAW,QAAgB,QAAQ,EAAE,IAAI;AACzC,UAAI,YAAY,WAAW;AACzB,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAAA,EAEA,QAAkDC,SAGlD;AACE,WAAO,MAAM;AACX,YAAM,KAAK,KAAK,OAAO,IAAI;AAC3B,UAAI,CAAC,GAAI,QAAO;AAChB,YAAM,OAAO,GAAG,OAAO,KAAK,GAAG,OAAO,EAAE,IAAI;AAC5C,UAAI,KAAM,QAAO,EAAE,CAACA,OAAM,GAAG,KAAK;AAClC,UAAI,GAAGA,OAAM,EAAG,QAAO;AAAA,IACzB;AAAA,EACF;AAAA,EAEA,UAA2B,OAA4B;AACrD,SAAK,WAAW;AAChB,WAAO;AAAA,EACT;AACF;AAEA,IAAM,UAAkC,CAAC;AACzC,IAAM,eAAuC,CAAC;AAC9C,IAAM,gBAA+B;AAAA,EACnC,GAAG;AAAA,EACH,CAAC,QAAQ,EAAE,OAAO;AAChB,UAAM,CAAC,IAAI,IAAI,IAAmC,KAAK,IAAI;AAC3D,QAAI,CAAC,MAAM,MAAO,QAAO;AACzB,UAAM,QAAQ,YAAY,IAAI;AAC9B,iBAAa,IAAI,KAAK,aAAa,IAAI,KAAK,KAAK;AACjD,WAAO,MAAM,IAAI;AAAA,MACf,WAAW,CAAC,MAAM;AAChB,cAAM,MAAM,YAAY,IAAI;AAC5B,gBAAQ,IAAI,KAAK,QAAQ,IAAI,KAAK,MAAM,MAAM;AAC9C,eAAO,QAAQ,CAAC;AAAA,MAClB;AAAA,MACA,WAAW,CAAC,MAAM;AAChB,cAAM,MAAM,YAAY,IAAI;AAC5B,gBAAQ,IAAI,KAAK,QAAQ,IAAI,KAAK,MAAM,MAAM;AAC9C,eAAO,KAAK,CAAC;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,IAAM,WAAW,CACtB,SAEF,CAAU,OAAqC;AAC7C,QAAM,OAAO,OAAO,OAAO,aAAa;AACxC,OAAK,IAAI,IAAI,CAAC,IAAI,IAAI;AACtB,SAAO;AACT;AAEO,IAAM,YAAY,CAAO,SAAuE;AACrG,QAAM,QAAQ,IAAI,UAAU;AAC5B,QAAM,SAAS,MAAM,QAAQ,IAAI;AACjC,MAAI,OAAO,SAAS,WAAW;AAC7B,WAAcC,OAAM,OAAO,KAAK;AAAA,EAClC;AACA,SAAcC,MAAK,OAAO,KAAK;AACjC;AAEO,IAAM,MAAM,CAAO,SAAuE;AAC/F,MAAI;AACF,WAAO,UAAU,IAAI;AAAA,EACvB,SAAS,GAAG;AACV,WAAcA,MAAK,IAAI,oBAAoB,CAAC,CAAC;AAAA,EAC/C;AACF;AAEA,IAAM,iBAAgC;AAAA,EACpC,GAAG;AAAA,EACH,CAAC,QAAQ,EAAE,OAAkB;AAC3B,UAAM,OAAO,KAAK,IAAI;AACtB,WAAO,KAAK,IAAI;AAAA,EAClB;AACF;AAEO,IAAMC,WAGT,KAAK,GAAG,CACV,IACA,MACG;AACH,QAAM,OAAO,OAAO,OAAO,cAAc;AACzC,OAAK,IAAI,IAAI;AACb,OAAK,KAAK,IAAI;AACd,SAAO;AACT,CAAC;AAEM,IAAMC,OAGT,KAAK,GAAG,CACV,IACA,MACGD,SAAQ,IAAI,CAAC,MAAM,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;AAEtC,IAAM,YAA2B;AAAA,EAC/B,GAAG;AAAA,EACH,CAAC,QAAQ,EAAE,OAAO;AAChB,UAAM,QAAQ,KAAK,IAAI,EAAE;AACzB,UAAM,OAAO,MAAM,QAAQ,KAAK;AAChC,WAAO,OACH,KAAK,KAAK,EAAE,OAAO,KAAK,IACxB,MAAM,UAAU,QAAQ,KAAK,CAAQ;AAAA,EAC3C;AACF;AAEO,IAAM,OAAO,CAAI,MAAsC;AAC5D,QAAM,OAAO,OAAO,OAAO,SAAS;AACpC,OAAK,IAAI,IAAI;AACb,SAAO;AACT;AAEO,IAAM,QAAQ,QAAQ,MAAS;AAEtC,IAAM,oBAAmC;AAAA,EACvC,GAAG;AAAA,EACH,CAAC,KAAK,EAAE,OAAO,OAAO;AACpB,UAAM,QAAQ,KAAK,IAAI,EAAE,CAAC,EAAE,KAAK,KAAK;AACtC,QAAI,MAAM,KAAM,QAAO,QAAQ,MAAM,KAAK;AAC1C,UAAM,OAAO,KAAK,IAAI;AACtB,WAAO,MAAM;AAAA,EACf;AAAA,EACA,CAAC,QAAQ,EAAa,OAAkB;AACtC,WAAO,KAAK,KAAK,EAAE,KAAK,IAAI,EAAE,CAAC,GAAG,KAAK;AAAA,EACzC;AACF;AAEA,IAAM,qBAAqB,CACzB,UACA,YACG;AACH,QAAM,OAAO,OAAO,OAAO,iBAAiB;AAC5C,OAAK,IAAI,IAAI,CAAC,UAAU,OAAO;AAC/B,SAAO;AACT;AAEO,IAAM,MAAM,IACdE,UASA,QAAQ,MAAM,mBAAmBA,MAAK,CAAC,EAAE,CAAC,CAAC;AAEzC,IAAM,KAAK,CAAC,MACnB,CACE,SAEF,IAAIA,UAQC,SAAS,CAAC,EAAE,QAAQ,MAAM,mBAAmB,KAAK,GAAGA,KAAI,CAAC,CAAC,CAAC;AAEjE,IAAM,aAA4B;AAAA,EAChC,GAAG;AAAA,EACH,CAAC,QAAQ,EAAE,OAAO;AAChB,UAAM,OAAO,KAAK,IAAI;AACtB,WAAO,KAAK,IAAI;AAAA,EAClB;AACF;AAEA,IAAM,QAAQ,CACZ,IACA,SAIsC;AACtC,QAAM,OAAO,OAAO,OAAO,UAAU;AACrC,OAAK,IAAI,IAAI;AACb,OAAK,KAAK,IAAI,KAAK;AACnB,OAAK,KAAK,IAAI,KAAK;AACnB,SAAO;AACT;AAEO,IAAMC,UAAS,CACpB,MAEF,CAAO,OAA+C;AACpD,QAAM,OAAO,OAAO,OAAO,UAAU;AACrC,OAAK,IAAI,IAAI;AACb,OAAK,KAAK,IAAI,CAAC,MAA+B,aAAa,sBAAsB,KAAK,CAAC,IAAI,EAAE,CAAC;AAC9F,SAAO;AACT;AAEO,IAAM,iBAAiB,CAC5B,QAEA,IAAI,MAAM,CAAC,EAAE,OAAO,CAACC,MAAK,OAAOD,QAAO,MAAM,EAAE,EAAEC,IAAG,GAAG,IAAI,CAAC,CAAC;AAEhE,IAAM,sBAAqC;AAAA,EACzC,GAAG;AAAA,EACH,CAAC,QAAQ,EAAE,OAAO;AAChB,UAAM,eAAe,MAAM;AAC3B,UAAM,CAAC,IAAI,KAAK,KAAK,IAA8C,KAAK,IAAI;AAC5E,UAAM,YAAY;AAAA,MAChB,GAAG,MAAM;AAAA,MACT,CAAC,IAAI,GAAG,GAAG;AAAA,IACb;AACA,WAAO,MAAM,IAAI;AAAA,MACf,WAAW,CAAC,MAAM;AAChB,cAAM,YAAY;AAClB,eAAO,QAAQ,CAAC;AAAA,MAClB;AAAA,MACA,WAAW,CAAC,MAAM;AAChB,cAAM,YAAY;AAClB,eAAO,KAAK,CAAC;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,IAAM,iBAAiB,CAC5B,KACA,UAEF,CAAU,OAAuE;AAC/E,QAAM,OAAO,OAAO,OAAO,mBAAmB;AAC9C,OAAK,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK;AAC5B,SAAO;AACT;AAEA,IAAM,eAA8B;AAAA,EAClC,GAAG;AAAA,EACH,CAAC,QAAQ,EAAE,OAAO;AAChB,UAAM,MAAoB,KAAK,IAAI;AACnC,QAAI,IAAI,OAAO,MAAM,WAAW;AAC9B,YAAM,QAAQ,MAAM,UAAU,IAAI,GAAG;AACrC,YAAMC,QAAO,MAAM,QAAQ,KAAK;AAChC,aAAOA,QAAOA,MAAK,KAAK,EAAE,OAAO,KAAK,IAAI,MAAM,UAAU,QAAQ,KAAK,CAAQ;AAAA,IACjF;AACA,UAAM,OAAO,MAAM,QAAQ,KAAK;AAChC,WAAO,OACH,KAAK,KAAK,EAAE,KAAK,KAAK,IACtB,MAAM,UAAU,KAAK,IAAI,oBAAoB,WAAW,IAAI,GAAG,YAAY,CAAC,CAAQ;AAAA,EAC1F;AACF;AAEO,IAAM,UAAU,CACrB,QACkE;AAClE,QAAM,OAAO,OAAO,OAAO,YAAY;AACvC,OAAK,IAAI,IAAI;AACb,SAAO;AACT;AAEA,IAAM,cAA6B;AAAA,EACjC,GAAG;AAAA,EACH,CAAC,QAAQ,EAAE,OAAO;AAChB,UAAM,CAAC,IAAI,MAAM,GAAG,IAAwC,KAAK,IAAI;AACrE,UAAM,QAAQ,MAAM,OAAO,IAAI,KAAK,oBAAI,QAAkB;AAC1D,UAAM,OAAO,IAAI,IAAI;AACrB,UAAMC,UAAS,MAAM,IAAI,GAAG;AAC5B,QAAIA,QAAQ,QAAOA;AACnB,WAAO,MAAM,IAAI;AAAA,MACf,WAAW,CAAC,MAAM;AAChB,cAAM,IAAI,KAAK,QAAQ,CAAC,CAAC;AACzB,eAAO,QAAQ,CAAC;AAAA,MAClB;AAAA,MACA,WAAW,CAAC,MAAM;AAChB,cAAM,IAAI,KAAK,KAAK,CAAC,CAAC;AACtB,eAAO,KAAK,CAAC;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,SAAS,SACd,IACA,MACA,WACA;AACA,SAAO,IAAI,MAAwB;AACjC,UAAM,OAAO,OAAO,OAAO,WAAW;AACtC,SAAK,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,GAAG,MAAM,UAAU,GAAG,CAAC,CAAC;AAC7C,WAAO;AAAA,EACT;AACF;AAEO,IAAM,SAAS,CAAU,OAAwD;AACtF,QAAM,OAAO,OAAO,OAAO,UAAU;AACrC,OAAK,IAAI,IAAI;AACb,OAAK,KAAK,IAAI,CAAC,MAAS,QAAeC,MAAK,CAAC,CAAC;AAC9C,OAAK,KAAK,IAAI,CAAC,MAA+B,aAAa,sBAAsB,KAAK,CAAC,IAAI,QAAeC,MAAK,CAAC;AAChH,SAAO;AACT;AAEO,IAAM,SAAS,CAAU,OAA4C;AAC1E,QAAM,OAAO,OAAO,OAAO,UAAU;AACrC,OAAK,IAAI,IAAI;AACb,OAAK,KAAK,IAAI,CAAC,MAAS;AACxB,OAAK,KAAK,IAAI,CAAC,MAA+B,aAAa,sBAAsB,KAAK,CAAC,IAAI;AAC3F,SAAO;AACT;AAUO,IAAM,MAE6F,GAAG,KAAK;AAAA,EAChH,cACKC,OACH;AACA,UAAM,UAAU,CAAC;AACjB,eAAW,MAAMA,OAAM;AACrB,YAAM,SAAS,OAAO;AACtB,cAAQ,KAAK,MAAM;AAAA,IACrB;AACA,WAAO;AAAA,EACT;AACF;;;ACjdO,IAAM,+BAAoC,IAAkC,eAAe;AAElG,SAAS,qBAAqB,OAAoD;AAChF,SAAO,UAAU,SAAS,UAAU,WAAW,UAAU,aAAa,UAAU,aAAa,UAAU;AACzG;AAEA,SAAS,wBAAwB,QAAkF;AACjH,MAAI,CAAC,SAAS,MAAM,EAAG,QAAO,CAAC;AAC/B,SAAO,OAAO;AAAA,IACZ;AAAA,MACE,OAAO,QAAQ,MAAM;AAAA,MACf,OAAO,CAAC,CAAC,KAAK,KAAK,MAAM,SAAS,GAAG,KAAK,SAAS,KAAK,CAAC;AAAA,MACzDC,KAAI,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,OAAO,GAAG,EAAE,YAAY,GAAG,OAAO,KAAK,EAAE,YAAY,CAAC,CAAC;AAAA,MAC9E,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,qBAAqB,KAAK,CAAC;AAAA,IAC1D;AAAA,EACF;AACF;AAEO,IAAM,WAAyC;AAAA,EACpD,WAAW;AAAA,EACX,aAAa;AAAA,EACb,oBAAoB,CAAC;AAAA,EACrB,iBAAiB;AAAA,EACjB,2BAA2B;AAAA,EAC3B,WAAW;AAAA,EACX,2BAA2B;AAAA,EAC3B,wBAAwB;AAAA,EACxB,aAAa;AAAA,EACb,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,2BAA2B,CAAC;AAAA,EAC5B,yBAAyB,CAAC;AAAA,EAC1B,wBAAwB;AAAA,EACxB,sBAAsB,CAAC;AAAA,EACvB,eAAe,CAAC;AAAA,EAChB,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,aAAa,CAAC;AAAA,IACZ,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,iBAAiB,CAAC,MAAM;AAAA,EAC1B,GAAG;AAAA,IACD,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,iBAAiB,CAAC,MAAM;AAAA,EAC1B,CAAC;AAAA,EACD,sBAAsB;AAAA,EACtB,qBAAqB;AACvB;AAEA,SAAS,iBAAiB,UAAyE;AACjG,QAAM,SAAwD,CAAC;AAC/D,aAAW,SAAS,UAAU;AAC5B,QAAI,CAAC,SAAS,KAAK,EAAG;AACtB,WAAO,KAAK;AAAA,MACV,QAAQ,YAAY,OAAO,QAAQ,KAAK,SAAS,MAAM,MAAM,KACzD,CAAC,WAAW,SAAS,QAAQ,EAAE,SAAS,MAAM,OAAO,YAAY,CAAC,IAClE,MAAM,OAAO,YAAY,IACzB;AAAA,MACJ,SAAS,YAAY,OAAO,SAAS,KAAK,SAAS,MAAM,OAAO,KAC5D,CAAC,sBAAsB,WAAW,gBAAgB,EAAE,SAAS,MAAM,QAAQ,YAAY,CAAC,IACxF,MAAM,QAAQ,YAAY,IAC1B;AAAA,MACJ,iBACE,YAAY,OAAO,iBAAiB,KAAK,QAAQ,MAAM,eAAe,KAAK,MAAM,gBAAgB,MAAM,QAAQ,IAC3G,MAAM,kBACN,CAAC,MAAM;AAAA,IACf,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAEO,SAAS,MAAM,QAA2C;AAC/D,SAAO;AAAA,IACL,WAAW,SAAS,MAAM,KAAK,YAAY,QAAQ,WAAW,KAAK,UAAU,OAAO,SAAS,IACzF,OAAO,YACP,SAAS;AAAA,IACb,aAAa,SAAS,MAAM,KAAK,YAAY,QAAQ,aAAa,KAAK,UAAU,OAAO,WAAW,IAC/F,OAAO,cACP,SAAS;AAAA,IACb,oBACE,SAAS,MAAM,KAAK,YAAY,QAAQ,oBAAoB,KAAK,SAAS,OAAO,kBAAkB,IAC/F,wBAAwB,OAAO,kBAAkB,IACjD,SAAS;AAAA,IACf,iBAAiB,SAAS,MAAM,KAAK,YAAY,QAAQ,iBAAiB,KAAK,UAAU,OAAO,eAAe,IAC3G,OAAO,kBACP,SAAS;AAAA,IACb,2BAA2B,SAAS,MAAM,KAAK,YAAY,QAAQ,2BAA2B,KAC1F,SAAS,OAAO,yBAAyB,KAAK,qBAAqB,OAAO,yBAAyB,IACnG,OAAO,4BACP,SAAS;AAAA,IACb,WAAW,SAAS,MAAM,KAAK,YAAY,QAAQ,WAAW,KAAK,UAAU,OAAO,SAAS,IACzF,OAAO,YACP,SAAS;AAAA,IACb,2BAA2B,SAAS,MAAM,KAAK,YAAY,QAAQ,2BAA2B,KAC1F,SAAS,OAAO,yBAAyB,KACzC,CAAC,UAAU,SAAS,eAAe,EAAE,SAAS,OAAO,0BAA0B,YAAY,CAAC,IAC5F,OAAO,0BAA0B,YAAY,IAC7C,SAAS;AAAA,IACb,wBACE,SAAS,MAAM,KAAK,YAAY,QAAQ,wBAAwB,KAAK,SAAS,OAAO,sBAAsB,IACvG,OAAO,yBACP,SAAS;AAAA,IACf,aAAa,SAAS,MAAM,KAAK,YAAY,QAAQ,aAAa,KAAK,UAAU,OAAO,WAAW,IAC/F,OAAO,cACP,SAAS;AAAA,IACb,MAAM,SAAS,MAAM,KAAK,YAAY,QAAQ,MAAM,KAAK,UAAU,OAAO,IAAI,IAC1E,OAAO,OACP,SAAS;AAAA,IACb,QAAQ,SAAS,MAAM,KAAK,YAAY,QAAQ,QAAQ,KAAK,UAAU,OAAO,MAAM,IAChF,OAAO,SACP,SAAS;AAAA,IACb,2BAA2B,SAAS,MAAM,KAAK,YAAY,QAAQ,2BAA2B,KAC1F,QAAQ,OAAO,yBAAyB,KAAK,OAAO,0BAA0B,MAAM,QAAQ,IAC5F,OAAO,0BAA0B,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,IAC3D,SAAS;AAAA,IACb,yBAAyB,SAAS,MAAM,KAAK,YAAY,QAAQ,yBAAyB,KACtF,QAAQ,OAAO,uBAAuB,KAAK,OAAO,wBAAwB,MAAM,QAAQ,IACxF,OAAO,wBAAwB,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,IACzD,SAAS;AAAA,IACb,sBAAsB,SAAS,MAAM,KAAK,YAAY,QAAQ,sBAAsB,KAChF,QAAQ,OAAO,oBAAoB,KAAK,OAAO,qBAAqB,MAAM,QAAQ,IAClF,OAAO,qBAAqB,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,IACtD,SAAS;AAAA,IACb,eAAe,SAAS,MAAM,KAAK,YAAY,QAAQ,eAAe,KAAK,SAAS,OAAO,aAAa,IAC7FA,KAAI,OAAO,eAAe,CAAC,UAAU,OAAO,KAAK,CAAC,IACzD,SAAS;AAAA,IACb,wBAAwB,SAAS,MAAM,KAAK,YAAY,QAAQ,wBAAwB,KACpF,SAAS,OAAO,sBAAsB,KACtC,CAAC,UAAU,QAAQ,EAAE,SAAS,OAAO,uBAAuB,YAAY,CAAC,IACzE,OAAO,uBAAuB,YAAY,IAC1C,SAAS;AAAA,IACb,SAAS,SAAS,MAAM,KAAK,YAAY,QAAQ,SAAS,KAAK,UAAU,OAAO,OAAO,IACnF,OAAO,UACP,SAAS;AAAA,IACb,YAAY,SAAS,MAAM,KAAK,YAAY,QAAQ,YAAY,KAAK,UAAU,OAAO,UAAU,IAC5F,OAAO,aACP,SAAS;AAAA,IACb,aAAa,SAAS,MAAM,KAAK,YAAY,QAAQ,aAAa,KAAK,QAAQ,OAAO,WAAW,IAC7F,iBAAiB,OAAO,WAAW,IACnC,SAAS;AAAA,IACb,sBACE,SAAS,MAAM,KAAK,YAAY,QAAQ,sBAAsB,KAAK,UAAU,OAAO,oBAAoB,IACpG,OAAO,uBACP,SAAS;AAAA,IACf,qBACE,SAAS,MAAM,KAAK,YAAY,QAAQ,qBAAqB,KAAK,SAAS,OAAO,mBAAmB,IACjG,OAAO,sBACP,SAAS;AAAA,EACjB;AACF;;;AClCO,IAAM,gBAAqB,IAAmB,eAAe;AAI7D,IAAM,oBAAyB,IAAuB,mBAAmB;AAEzE,IAAM,gBAAqB,IAAkC,eAAe;AAM5E,SAAS,wBAAwB,SAAuD;AAC7F,MAAI;AACF,QAAI,YAAY,SAAS,0BAA0B,KAAKC,YAAW,QAAQ,wBAAwB,GAAG;AACpG,YAAM,wBAAwB,QAAQ,yBAAyB;AAC/D,UACE,YAAY,uBAAuB,yBAAyB,KAC5DA,YAAW,sBAAsB,uBAAuB,GACxD;AACA,eAAO,sBAAsB,wBAAwB;AAAA,MACvD;AAAA,IACF;AAAA,EAEF,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,SAAS,iBAAiB,IAAmB,MAAsB;AACxE,MAAI;AACF,QAAI,YAAY,IAAI,kBAAkB,KAAKA,YAAW,GAAG,gBAAgB,GAAG;AAC1E,aAAO,GAAG,iBAAiB,IAAI;AAAA,IACjC;AACA,WAAO;AAAA,EAET,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACF;AAEO,SAAS,uBAAuB,IAAmB;AACxD,MACE,EAAE,YAAY,IAAI,kBAAkB,KAAK,YAAY,GAAG,kBAAkB,oBAAoB,KAC5FA,YAAW,GAAG,iBAAiB,kBAAkB,GACnD;AACF,QAAM,YAAY,GAAG,iBAAiB;AACtC,SAAO,CACL,iBACA,qBACA,yBACA,YACA,MACA,YACW;AACX,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAMO,SAAS,sCACd,IACA;AACA,MAAI,YAAY,IAAI,mCAAmC,KAAKA,YAAW,GAAG,iCAAiC,GAAG;AAC5G,UAAM,YAAY,GAAG;AACrB,WAAO,CACL,OACA,SACA,oBAC0B,UAAU,OAAO,SAAS,eAAe;AAAA,EACvE;AACA,SAAO;AACT;AAEO,SAAS,2BACd,IACA;AACA,MAAI,YAAY,IAAI,wBAAwB,KAAKA,YAAW,GAAG,sBAAsB,GAAG;AACtF,UAAM,YAAY,GAAG;AACrB,WAAO,CAAC,MAAc,UAAiC,UAAU,MAAM,KAAK;AAAA,EAC9E;AACF;AAEO,SAAS,oCACd,IACA;AACA,MAAI,YAAY,IAAI,iCAAiC,KAAKA,YAAW,GAAG,+BAA+B,GAAG;AACxG,UAAM,YAAY,GAAG;AACrB,WAAO,CAAC,aAAqB,cAAsB,iBAAqC,SACtF,UAAU,aAAa,cAAc,iBAAiB,IAAI;AAAA,EAC9D;AACF;AAEO,SAAS,sCACd,IACA;AACA,MAAI,YAAY,IAAI,mCAAmC,KAAKA,YAAW,GAAG,iCAAiC,GAAG;AAC5G,UAAM,YAAY,GAAG;AACrB,WAAO,CAAC,iBAAsB,iBAAqC,SACjE,UAAU,iBAAiB,iBAAiB,IAAI;AAAA,EACpD;AACF;;;AC1LO,IAAM,kBAAuB,IAAqB,iBAAiB;AAEnE,IAAM,YAAY,CACvB,OAEA;AAAA,EACO,QAAsB,aAAa;AAAA,EACnCC,SAAQ,CAAC,OAAO,KAAK,IAAS,eAAe,iBAAiB,oBAAoB,EAAE,CAAC,CAAC,CAAC;AAC9F;AAEK,SAAS,oBAAoB,IAAkD;AACpF,QAAM,oCAAkD,sCAAsC,EAAE;AAChG,QAAM,yBAAuC,2BAA2B,EAAE;AAK1E,WAAS,2CAA2C,GAA+C;AACjG,QAAI,CAAC,SAAS,CAAC,EAAG;AAClB,QAAI,CAAC,YAAY,GAAG,kBAAkB,EAAG;AACzC,QAAI,CAAC,EAAE,iBAAkB;AACzB,UAAM,mBAAmB,EAAE;AAC3B,QAAI,CAAC,YAAY,kBAAkB,UAAU,EAAG;AAChD,QAAI,CAAC,YAAY,iBAAiB,UAAU,oBAAoB,EAAG;AACnE,UAAM,qBAAqB,iBAAiB,SAAS;AACrD,QAAI,CAAC,YAAY,oBAAoB,MAAM,EAAG;AAC9C,QAAI,CAAC,YAAY,kBAAkB,kBAAkB,EAAG;AACxD,QAAI,CAAC,SAAS,iBAAiB,gBAAgB,EAAG;AAClD,UAAM,EAAE,KAAK,IAAI;AACjB,UAAM,UAAU,YAAY,kBAAkB,SAAS,IAAI,iBAAiB,UAAU;AACtF,QAAI,CAAC,SAAS,IAAI,EAAG;AACrB,QAAI,CAAC,SAAS,OAAO,EAAG;AACxB,UAAM,8BAA8B,YAAY,oBAAoB,kBAAkB,KACpF,SAAS,mBAAmB,gBAAgB,KAC5C,YAAY,mBAAmB,kBAAkB,QAAQ;AAE3D,UAAM,qBAAqB,OAAO,KAAK;AAAA,MACrC,GAAI,YAAY,oBAAoB,cAAc,KAAK,SAAS,mBAAmB,YAAY,IAC3F,mBAAmB,eACnB,CAAC;AAAA,MACL,GAAI,YAAY,oBAAoB,kBAAkB,KAAK,SAAS,mBAAmB,gBAAgB,IACnG,mBAAmB,mBACnB,CAAC;AAAA,MACL,GAAI,YAAY,oBAAoB,iBAAiB,KAAK,SAAS,mBAAmB,eAAe,IACjG,mBAAmB,kBACnB,CAAC;AAAA,IACP,CAAC;AAED,UAAM,cAAc,OAAO;AAAA,MACzB,YAAY,oBAAoB,SAAS,KAAK,SAAS,mBAAmB,OAAO,IAC7E,mBAAmB,UACnB,CAAC;AAAA,IACP;AAEA,WAAO;AAAA,MACL,MAAM,KAAK,YAAY;AAAA,MACvB,SAAS,QAAQ,YAAY;AAAA,MAC7B;AAAA,MACA,UAAU;AAAA,MACV,kBAAkB,iBAAiB;AAAA,MACnC;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,WAAS,2CACP,SACA,YACmC;AACnC,QAAI,mBAAmB,2CAA2C,UAAU;AAC5E,QACE,CAAC,oBAAoB,0BAA0B,mCAC/C;AACA,YAAM,uBAAqC,wBAAwB,OAAO;AAC1E,YAAM,iCAAiC;AAAA,QACrC;AAAA,QACA;AAAA,QACA,QAAQ,mBAAmB;AAAA,MAC7B;AACA,YAAM,gBAA8B,iBAAiB,IAAI,WAAW,QAAQ;AAC5E,yBAAmB,2CAA2C;AAAA,QAC5D,GAAG;AAAA,QACH,kBAAkB,uBAAuB,eAAe,8BAA8B;AAAA,MACxF,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAEA,WAAS,qBAAqB,SAAqB,YAA2B,SAAiB;AAC7F,QAAI,QAAQ,QAAQ,GAAG,MAAM,GAAI,QAAO,CAAC,QAAQ,YAAY,CAAC;AAC9D,UAAM,mBAAmB,2CAA2C,SAAS,UAAU;AACvF,UAAM,qBAAoC,CAAC;AAC3C,eAAW,aAAa,WAAW,YAAY;AAC7C,UAAI,GAAG,oBAAoB,SAAS,KAAK,GAAG,gBAAgB,UAAU,eAAe,GAAG;AACtF,cAAM,kBAAkB,UAAU,gBAAgB,KAAK,YAAY;AACnE,cAAM,cAAc,gBAAgB,WAAW,GAAG,IAC9C,gBAAgB,MAAM,KAAK,CAAC,EAAE,KAAK,GAAG,IACtC,gBAAgB,MAAM,KAAK,CAAC,EAAE,KAAK,GAAG;AAC1C,2BAAmB,KAAK,WAAW;AAAA,MACrC;AAAA,IACF;AACA,WAAO;AAAA,MACL,mBAAmB,OAAO,kBAAkB,sBAAsB,CAAC,CAAC;AAAA,MAC9D;AAAA,MACAC,KAAI,CAAC,gBAAgB,YAAY,YAAY,CAAC;AAAA,MAC9C;AAAA,QAAO,CAAC,gBACZ,QAAQ,SAAS,GAAG,KACpB,YAAY,WAAW,QAAQ,YAAY,EAAE,UAAU,GAAG,QAAQ,SAAS,CAAC,CAAC;AAAA,MAC/E;AAAA,IACF;AAAA,EACF;AAEA,WAAS,qCAAqC,YAA2B,UAAkB;AACzF,UAAM,aAAa,WAAW;AAC9B,QAAI;AAEJ,aAAS,KAAK,MAAe;AAE3B,YAAM,UAAU,GAAG,wBAAwB,YAAY,KAAK,GAAG;AAC/D,UAAI,SAAS;AACX,mBAAW,gBAAgB,SAAS;AAClC,cAAI,aAAa,OAAO,YAAY,WAAW,aAAa,KAAK;AAE/D,qBAAS,EAAE,MAAM,aAAa;AAC9B;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,KAAK,OAAO,YAAY,WAAW,KAAK,KAAK;AAC/C,WAAG,aAAa,MAAM,IAAI;AAAA,MAC5B;AAAA,IACF;AACA,SAAK,UAAU;AACf,WAAO;AAAA,EACT;AAQA,WAAS,mCACP,MACA,WACgB;AAChB,QAAI,SAAe,MAAe;AAClC,QAAI,SAAS;AACb,WAAO,QAAQ;AACb,UAAI,OAAO,OAAO,UAAU,KAAK;AAC/B,iBAAS,KAAK,QAAc,OAAO,MAAM,CAAC;AAAA,MAC5C;AACA,eAAS,OAAO;AAAA,IAClB;AACA,WAAO;AAAA,EACT;AAQA,WAAS,mBACP,YACA,UACA;AACA,aAAS,KAAK,MAAoC;AAChD,UAAI,YAAY,GAAG,kBAAkB,MAAM,UAAU,KAAK,WAAW,KAAK,KAAK;AAE7E,eAAO,GAAG,aAAa,MAAM,IAAI,KAAK;AAAA,MACxC;AACA,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,UAAU;AAAA,EACxB;AAEA,WAAS,kCACP,YACA,UACA;AACA,aAAS,KAAK,MAAoC;AAChD,UAAI,YAAY,KAAK,OAAO,WAAW,KAAK,KAAK;AAE/C,eAAO,GAAG,aAAa,MAAM,IAAI,KAAK;AAAA,MACxC;AACA,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,UAAU;AAAA,EACxB;AAaA,WAAS,wBACP,YACA,WACA;AACA,UAAM,iBAAiB,mBAAmB,YAAY,UAAU,GAAG;AACnE,QAAI,CAAC,eAAgB,QAAa,MAAe;AACjD,WAAO,mCAAmC,gBAAgB,SAAS;AAAA,EACrE;AAEA,WAAS,qBACP,YACA,KACA;AACA,UAAM,QAAQ,kCAAkC,YAAY,GAAG;AAE/D,QACE,UAAU,UAAa,MAAM,SAAS,GAAG,WAAW,WACpD,OAAO,MAAM,OAAO,GAAG,cAAc,MAAM,IAAI,KAAK,IAAI,QACxD;AACA;AAAA,IACF;AACA,UAAM,WAAW,MAAM,QAAQ,KAAK,GAAG,WAAW,WAAW,IAAI,KAAK,IAAI,SAAS,MAAM;AAEzF,UAAM,SAAS,GAAG,4BAA4B,WAAW,MAAM,UAAU,kBAAkB,GAAG,KAC5F,GAAG,2BAA2B,WAAW,MAAM,UAAU,kBAAkB,GAAG;AAEhF,WAAO;AAAA,EACT;AAEA,WAAS,iBACP,KACA,KACA,MACA,KACA,IAC6B;AAC7B,WAAO,MAAM,OAAO,KAAK,MAAM,EAAE,KAAK,KAAK,KAAK,IAAI;AAAA,EACtD;AAKA,WAAS,YAAY,iBAAsD;AACzE,WAAO,OAAO,oBAAoB,WAC9B,EAAE,KAAK,iBAAiB,KAAK,gBAAgB,IAC7C;AAAA,EACN;AAEA,WAAS,cAAc,WAAyB;AAC9C,WAAO,CAAC,SAAkB,KAAK,OAAO,UAAU,OAAO,KAAK,OAAO,UAAU;AAAA,EAC/E;AAEA,WAAS,yCACP,MACA,SACgB;AAChB,aAAS,QAAQ,GAAqB;AACpC,UAAI,GAAG,kBAAkB,CAAC,GAAG;AAC3B,cAAM,aAAa,GAAG,eAAe,EAAE,YAAY,SAAS,GAAG,yBAAyB;AAExF,eAAO,GAAG,QAAQ;AAAA,UAChB,GAAG,QAAQ,YAAY,GAAG,WAAW,aAAa;AAAA,UAClD,QAAQ,UAAU;AAAA,QACpB;AAAA,MACF;AACA,aAAO,GAAG,eAAe,GAAG,SAAS,GAAG,yBAAyB;AAAA,IACnE;AACA,WAAO,QAAQ,IAAI;AAAA,EACrB;AAEA,WAAS,8BACP,MACA,kBACA,SACA;AACA,UAAM,gBAAgB,yCAAyC,KAAK,MAAO,OAAO;AAClF,UAAM,SAAS,KAAK,QAAQ,GAAG,aAAa,KAAK,IAAI,IACjD,KAAK,OACL,GAAG,sBAAsB,KAAK,MAAM,KAAK,GAAG,aAAa,KAAK,OAAO,IAAI,KAAK,KAAK,OAAO,gBAAgB,OAC1G,KAAK,OAAO,OACZ;AAEJ,QAAI,SAAwB,GAAG,QAAQ;AAAA,MACrC,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,MAC5C;AAAA,IACF;AACA,QAAI,QAAQ;AACV,eAAS,GAAG,QAAQ;AAAA,QAClB;AAAA,QACA;AAAA,QACA,CAAC,GAAG,QAAQ,oBAAoB,GAAG,OAAO,MAAM,CAAC,CAAC;AAAA,MACpD;AAAA,IACF;AACA,WAAO;AAAA,MACL;AAAA,MACA,GAAG,QAAQ;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,UACE,GAAG,QAAQ;AAAA,YACT;AAAA,YACA,GAAG,QAAQ,YAAY,GAAG,WAAW,aAAa;AAAA,YAClD;AAAA,YACA,KAAK;AAAA,YACL,KAAK;AAAA,YACL;AAAA,YACA,GAAG,QAAQ,aAAa,IACpB,gBACA,GAAG,QAAQ,YAAY,CAAC,GAAG,QAAQ,sBAAsB,aAAa,CAAC,CAAC;AAAA,UAC9E;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,WAAS,+BACP,MACA,kBACA,SACA;AACA,UAAM,gBAAgB,yCAAyC,KAAK,MAAO,OAAO;AAElF,UAAM,mBAAmB,8BAA8B,kBAAkB,aAAa;AAEtF,QAAI,eAAe,GAAG,yBAAyB,IAAI;AACnD,oBAAgB,CAAC,GAAG,cAAc;AAClC,UAAM,eAAe,GAAG,QAAQ,iCAAiC,YAAY;AAE7E,QAAI,GAAG,gBAAgB,IAAI,GAAG;AAC5B,aAAO,GAAG,QAAQ;AAAA,QAChB;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MACF;AAAA,IACF;AAEA,UAAM,UAAU,GAAG,QAAQ,YAAY;AAAA,MACrC,GAAG,QAAQ,sBAAsB,gBAAgB;AAAA,IACnD,CAAC;AAED,QAAI,GAAG,sBAAsB,IAAI,GAAG;AAClC,aAAO,GAAG,QAAQ;AAAA,QAChB;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO,GAAG,QAAQ;AAAA,MAChB;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,WAAS,6BACP,YACA,MAKA;AACA,eAAW,aAAa,WAAW,YAAY;AAC7C,UAAI,CAAC,GAAG,oBAAoB,SAAS,EAAG;AACxC,YAAM,eAAe,UAAU;AAC/B,UAAI,CAAC,aAAc;AACnB,YAAM,gBAAgB,aAAa;AACnC,UAAI,CAAC,cAAe;AACpB,UAAI,GAAG,kBAAkB,aAAa,GAAG;AACvC,YAAI,KAAK,cAAc,MAAM,UAAU,iBAAwBC,MAAK,CAAC,GAAG;AACtE,iBAAO,GAAG,OAAO,cAAc,IAAI;AAAA,QACrC;AAAA,MACF,WAAW,GAAG,eAAe,aAAa,GAAG;AAC3C,mBAAW,mBAAmB,cAAc,UAAU;AACpD,gBAAM,iBAAwB,aAAa,gBAAgB,YAAY,EAAE;AAAA,YAChE,OAAO,MAAaC,MAAK,gBAAgB,IAAI,CAAC;AAAA,UACvD;AACA,cAAI,KAAK,gBAAgB,MAAM,UAAU,iBAAiB,cAAc,GAAG;AACzE,mBAAO,GAAG,OAAO,gBAAgB,IAAI;AAAA,UACvC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,qDACP,YACA,aACA,YACA;AACA,WAAO;AAAA,MACL;AAAA,MACA,CAAC,GAAG,YAAY,mBAAmB;AAEjC,YACSC,QAAO,cAAc,KAAK,GAAG,gBAAgB,UAAU,KAC9D,WAAW,SAAS,cAAc,MAAM,YACxC;AACA,iBAAO;AAAA,QACT;AAIA,YACSC,QAAO,cAAc,KAAK,GAAG,aAAa,eAAe,KAAK,KACrE,GAAG,OAAO,eAAe,KAAK,MAAM,cAAc,GAAG,gBAAgB,UAAU,KAC/E,WAAW,SAAS,aACpB;AACA,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,WAAS,iBAAiB,UAAuB;AAC/C,aAAS,gBACPC,WACmD;AAEnD,UAAI,GAAG,wBAAwBA,SAAQ,EAAG,QAAO,gBAAgBA,UAAS,IAAI;AAE9E,UAAI,GAAG,mBAAmBA,SAAQ,GAAG;AACnC,eAAcH,MAAK;AAAA,UACjB,GAAG,QAAQ,oBAAoBG,UAAS,gBAAgBA,UAAS,YAAYA,UAAS,IAAI;AAAA,QAC5F,CAAC;AAAA,MACH;AAEA,UAAI,GAAG,kBAAkBA,SAAQ,GAAG;AAClC,cAAM,oBAAoBA,UAAS,QAAQ,MAAM,GAAG,0BAA0B;AAC9E,YAAI,mBAAmB;AACrB,iBAAcH,MAAKG,UAAS,OAAoD;AAAA,QAClF;AAAA,MACF;AAEA,UAAI,GAAG,uBAAuBA,SAAQ,GAAG;AACvC,cAAM,UAAUA,UAAS,MAAM,IAAI,CAAC,SAAS,gBAAgB,IAAI,CAAC;AAClE,YAAI,QAAQ,MAAaD,OAAM,GAAG;AAChC,iBAAcF,MAAK,QAAQ,IAAI,CAAC,MAAaE,QAAO,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,EAAE,KAAK,CAAC;AAAA,QAC/E;AAAA,MACF;AAEA,aAAcH,MAAK;AAAA,IACrB;AAEA,UAAM,iBAAiB,gBAAgB,QAAQ;AAC/C,QAAWG,QAAO,cAAc,KAAK,eAAe,MAAM,SAAS,GAAG;AACpE,aAAO,GAAG,QAAQ,sBAAsB,eAAe,KAAK;AAAA,IAC9D;AACA,WAAO;AAAA,EACT;AAEA,WAAS,gCAAgC,eAAwB,MAAe,WAAoB;AAElG,QAAI,CAAC,GAAG,aAAa,IAAI,EAAG,QAAO;AAEnC,QAAI,GAAG,sBAAsB,aAAa,GAAG;AAE3C,UAAI,CAAC,cAAc,KAAM,QAAO;AAChC,UAAI,eAAe,GAAG,yBAAyB,aAAa;AAC5D,sBAAgB,CAAC,GAAG,cAAc;AAClC,YAAM,eAAe,YACjB,GAAG,QAAQ,iCAAiC,YAAY,IACxD,cAAc;AAClB,aAAO,GAAG,QAAQ;AAAA,QAChB;AAAA,QACA,GAAG,QAAQ;AAAA,UACT,CAAC,GAAG,QAAQ;AAAA,YACV,cAAc;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,UACD,GAAG,UAAU;AAAA,QACf;AAAA,MACF;AAAA,IACF,WAAW,GAAG,oBAAoB,aAAa,GAAG;AAChD,UAAI,eAAe,GAAG,yBAAyB,aAAa;AAC5D,sBAAgB,CAAC,GAAG,cAAc;AAClC,YAAM,eAAe,YACjB,GAAG,QAAQ,iCAAiC,YAAY,IACxD,cAAc;AAClB,aAAO,GAAG,QAAQ;AAAA,QAChB;AAAA,QACA,cAAc;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,qCACP,YACA,UACA;AAEA,UAAM,iBAAiB,GAAG,mBAAmB,UAAU,YAAY,QAAW,IAAI;AAClF,QAAI,CAAC,eAAgB;AAErB,QAAI,iBAAiB;AACrB,QAAI,kBAAkB,GAAG,eAAe,UAAU,CAAC;AACnD,QAAI,YAAqB;AACzB,QACE,GAAG,aAAa,cAAc,KAAK,eAAe,UAClD,GAAG,2BAA2B,eAAe,MAAM,GACnD;AAEA,YAAM,YAAY,GAAG,kBAAkB,eAAe,QAAQ,UAAU;AACxE,wBAAkB,GAAG;AAAA,QACnB;AAAA,QACA,eAAe,MAAM;AAAA,MACvB;AACA,uBAAiB,eAAe,OAAO;AACvC,kBAAY,eAAe;AAAA,IAC7B,WACE,GAAG,QAAQ,cAAc,KAAK,eAAe,SAAS,GAAG,WAAW,YACpE,GAAG,2BAA2B,eAAe,MAAM,GACnD;AAEA,YAAM,0BAA0B,GAAG,kBAAkB,eAAe,QAAQ,UAAU;AACtF,wBAAkB,GAAG;AAAA,QACnB;AAAA,QACA,eAAe,MAAM;AAAA,MACvB;AACA,uBAAiB,eAAe,OAAO;AACvC,kBAAY,eAAe;AAAA,IAC7B,WAAW,GAAG,aAAa,cAAc,KAAK,eAAe,QAAQ;AAEnE,YAAM,0BAA0B,GAAG,kBAAkB,gBAAgB,UAAU;AAC/E,wBAAkB,GAAG;AAAA,QACnB;AAAA,QACA,eAAe,MAAM;AAAA,MACvB;AACA,uBAAiB;AACjB,kBAAY;AAAA,IACd,OAAO;AACL;AAAA,IACF;AACA,WAAO,EAAE,gBAAgB,WAAW,gBAAgB;AAAA,EACtD;AAEA,WAAS,mCACP,YACA,UACA;AACA,UAAM,aAAa,qCAAqC,YAAY,QAAQ;AAC5E,QAAI,CAAC,WAAY;AACjB,UAAM,EAAE,gBAAgB,WAAW,gBAAgB,IAAI;AAEvD,QAAI,CAAC,GAAG,aAAa,cAAc,EAAG;AAGtC,QAAI,mBAA4B,UAAU;AAC1C,WACE,GAAG,8BAA8B,gBAAgB,KAAK,GAAG,iBAAiB,gBAAgB,GAC1F;AACA,UAAI,CAAC,iBAAiB,OAAQ;AAC9B,yBAAmB,iBAAiB;AAAA,IACtC;AACA,QAAI,CAAC,GAAG,mBAAmB,gBAAgB,EAAG;AAE9C,QAAI,CAAC,iBAAiB,KAAM;AAE5B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,WAAW,iBAAiB;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AAEA,WAAS,8BACP,4BACA,MACA;AACA,UAAM,YAAY,GAAG,QAAQ;AAAA,MAC3B;AAAA,MACA,GAAG,QAAQ,YAAY,GAAG,WAAW,aAAa;AAAA,MAClD;AAAA,MACA,CAAC;AAAA,MACD,CAAC;AAAA,MACD;AAAA,MACA;AAAA;AAAA,IACF;AAEA,WAAO,GAAG,QAAQ;AAAA,MAChB,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,iBAAiB,0BAA0B;AAAA,QACtD;AAAA,MACF;AAAA,MACA;AAAA,MACA,CAAC,SAAS;AAAA,IACZ;AAAA,EACF;AAEA,WAAS,uCACP,4BACA,WACA;AACA,WAAO;AAAA,MACL;AAAA,MACA,GAAG,QAAQ,YAAkB,QAAQ,SAAS,IAAI,YAAY,CAAC,SAAS,GAAG,KAAK;AAAA,IAClF;AAAA,EACF;AAEA,WAAS,+BACP,MACA;AACA,WAAO,GAAG,QAAQ;AAAA,MAChB,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,YAAY,GAAG,WAAW,aAAa;AAAA,QAClD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,iCACP,sBACA,MACA,QACA;AAEA,UAAM,oBAAoB,GAAG,QAAQ;AAAA,MACnC,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,iBAAiB,oBAAoB;AAAA,QAChD;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,QACE,GAAG,QAAQ,oBAAoB,IAAI;AAAA,MACrC;AAAA,IACF;AAEA,UAAM,iBAAiB,GAAG,QAAQ;AAAA,MAChC;AAAA,MACA;AAAA,QACE,GAAG,QAAQ,sBAAsB,MAAM;AAAA,MACzC;AAAA,IACF;AACA,WAAO,GAAG,QAAQ;AAAA,MAChB,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,MACvD;AAAA,MACA;AAAA,MACA;AAAA,QACE,GAAG,QAAQ;AAAA,UACT,GAAG,WAAW;AAAA,UACd;AAAA,YACE;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,CAAC;AAAA,IACH;AAAA,EACF;AAEA,WAAS,oBAAoB,SAAyD;AACpF,QAAI,OAAO;AACX,WAAO,QAAQ,KAAK,SAAS,GAAG,WAAW,YAAY;AACrD,aAAO,KAAK;AAAA,IACd;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AC1wBO,IAAM,6BAAN,MAAiC;AAAA,EAC7B,OAAO;AAClB;AA0BO,SAAS,eAAe,YAAoD;AACjF,SAAO;AACT;AA4CO,SAAS,iBAAiB,YAAwD;AACvF,SAAO;AACT;AAEO,SAAS,kBAAkB,IAA0B,IAAgD;AAC1G,QAAM,SAAS,GAAG,MAAM,CAAC;AACzB,aAAW,KAAK,IAAI;AAClB,UAAM,WAAW,OAAO;AAAA,MAAK,CAAC,MAC5B,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE,UACzG,EAAE,gBAAgB,EAAE;AAAA,IACtB;AACA,QAAI,CAAC,UAAU;AACb,aAAO,KAAK,CAAC;AAAA,IACf;AAAA,EACF;AACA,SAAO;AACT;AA8BO,SAAS,iBAAiB,YAAwD;AACvF,SAAO;AACT;AASO,IAAM,sCAA2C;AAAA,EACtD;AACF,EAAE,WACA,OACA,YACA;AACA,MAAI,oBAA0C,CAAC;AAC/C,MAAI,kBAA+E,CAAC;AACpF,QAAM,WAAW,OAAO,yBAAyB,UAAU;AAC3D,aAAW,QAAQ,OAAO;AACxB,UAAM,EAAE,WAAW,aAAAE,aAAY,IAAI,OAAQ,SAAS,QAAQ,IAAI;AAChE,wBAAoB,kBAAkB,OAAOA,YAAW;AACxD,sBAAkB,gBAAgB,OAAO,SAAS;AAAA,EACpD;AAEA,SAAQ;AAAA,IACN,aAAa;AAAA,IACb,WAAW;AAAA,EACb;AACF,CAAC;AAED,SAAS,iCAAiC,MAAc;AACtD,SAAO,sCAAsC,IAAI;AACnD;AAEO,IAAM,yBAA8B,GAAG,4BAA4B,EAAE,WAC1EC,YACA,YACA,iBACA;AACA,QAAM,YAAY,OAAO,oBAAoB,WACzC,EAAE,KAAK,iBAAiB,KAAK,gBAAgB,IAC7C;AACJ,QAAM,kBAAoD,CAAC;AAC3D,aAAW,YAAYA,YAAW;AAChC,WAAO;AAAA,MACL,SAAS,MAAM,YAAY,SAAS;AAAA,MAC/BC;AAAA,QAAI,CAAC,WACR,gBAAgB,KAAK;AAAA,UACnB,MAAM,iCAAiC,SAAS,IAAI;AAAA,UACpD,aAAa,SAAS;AAAA,UACtB,SAAS,CAAC;AAAA,YACR,MAAM,iCAAiC,SAAS,IAAI;AAAA,YACpD,aAAa,OAAO;AAAA,YACpB,MAAM,OAAO;AAAA,UACf,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,MACK;AAAA,IACP;AAAA,EACF;AACA,SAAO;AACT,CAAC;AAEM,IAAM,sBAA2B,GAAG,yBAAyB,EAAE,WACpED,YACA,YACA,iBACA,cACA;AACA,QAAM,WAAWA,WAAU,KAAK,CAACE,cAAa,iCAAiCA,UAAS,IAAI,MAAM,YAAY;AAC9G,MAAI,CAAC,UAAU;AACb,WAAO,OAAY,KAAK,IAAI,2BAA2B,CAAC;AAAA,EAC1D;AACA,QAAM,YAAY,OAAO,oBAAoB,WACzC,EAAE,KAAK,iBAAiB,KAAK,gBAAgB,IAC7C;AAEJ,SAAO,OAAO,SAAS,MAAM,YAAY,SAAS;AACpD,CAAC;AAEM,IAAM,2BAAgC,GAAG,8BAA8B,EAAE,WAC9EC,cACA,YACA,UACA,SACA,oBACA;AACA,MAAI,oBAA+C,CAAC;AACpD,aAAW,cAAcA,cAAa;AACpC,UAAM,SAAS,OAAO,WAAW,MAAM,YAAY,UAAU,SAAS,kBAAkB;AACxF,wBAAoB,kBAAkB;AAAA,MACpC,OAAO,IAAI,CAAC,OAAO,EAAE,UAAU,MAAM,GAAG,EAAE,EAA+B;AAAA,IAC3E;AAAA,EACF;AACA,SAAO;AACT,CAAC;AASD,IAAM,2BAAgC,GAAG,sCAAsC;AAAA,EAC7E,WAAU,YAA2B;AACnC,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,gBAAgB,OAAY,QAAqC,4BAA4B;AAEnG,aAAS,sCAAsC,MAAe;AAC5D,UAAI;AAEJ,eAAS,KAAKC,OAAe;AAC3B,YAAI,GAAG,YAAYA,KAAI,GAAG;AACxB,mBAASA;AACT;AAAA,QACF;AACA,YAAI,OAAQ;AACZ,YAAIA,MAAK,OAAQ,MAAKA,MAAK,MAAM;AAAA,MACnC;AACA,WAAK,IAAI;AACT,aAAO,UAAU;AAAA,IACnB;AAEA,UAAM,gBAGF,CAAC;AACL,UAAM,mBAGF,CAAC;AACL,UAAM,eAA8B,CAAC;AAErC,UAAM,QACJ;AACF,QAAIC;AACJ,YAAQA,SAAQ,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM;AACrD,YAAM,uBAAuBA,OAAM,CAAC;AACpC,YAAM,oBAAoBA,OAAM,CAAC;AAEjC,UAAI,mBAAmB;AACrB,cAAM,oBAAoB,kBAAkB,KAAK;AACjD,YAAI,mBAAmB;AACrB,gBAAM,kBAAkB,kBAAkB,MAAM,KAAK;AACrD,qBAAW,YAAY,iBAAiB;AACtC,kBAAM,CAAC,aAAa,SAAS,IAAI,SAAS,YAAY,EAAE,MAAM,GAAG;AAEjE,kBAAM,WAAW,YAAY,WAAW,SAAS,IAC7C,YAAY,UAAU,UAAU,MAAM,IACtC;AACJ,gBAAI,YAAY,WAAW;AACzB,kBAAI,cAAc,YAAa,cAAa,KAAK,QAAQ;AACzD,oBAAM,qBAAqB,wBACzB,qBAAqB,KAAK,EAAE,YAAY,MAAM;AAChD,kBAAI,oBAAoB;AACtB,sBAAM,YAAY,QAAQ,qCAAqC,YAAYA,OAAM,KAAK;AACtF,oBAAI,WAAW;AACb,gCAAc,QAAQ,IAAI,cAAc,QAAQ,KAAK,CAAC;AACtD,gCAAc,QAAQ,EAAE,QAAQ;AAAA,oBAC9B,KAAK,UAAU,KAAK;AAAA,oBACpB,KAAK,UAAU,KAAK;AAAA,oBACpB,OAAO;AAAA,oBACP,cAAc,UAAU;AAAA,kBAC1B,CAAC;AAAA,gBACH;AAAA,cACF,OAAO;AACL,iCAAiB,QAAQ,IAAI,iBAAiB,QAAQ,KAAK,CAAC;AAC5D,iCAAiB,QAAQ,EAAE,QAAQ;AAAA,kBACjC,KAAKA,OAAM;AAAA,kBACX,OAAO;AAAA,gBACT,CAAC;AAAA,cACH;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,4BAAmE;AAAA,MACvE,OAAO,GAAG,mBAAmB;AAAA,MAC7B,SAAS,GAAG,mBAAmB;AAAA,MAC/B,SAAS,GAAG,mBAAmB;AAAA,MAC/B,YAAY,GAAG,mBAAmB;AAAA,IACpC;AAEA,UAAM,UAAU,CACd,SAEK,IAAI,aAAY;AACnB,YAAMN,eAAoC,CAAC;AAC3C,YAAM,YAAyE,CAAC;AAChF,YAAM,kBAAkB,KAAK,KAAK,YAAY;AAC9C,YAAM,eAAe,cAAc,mBAAmB,eAAe,KAAK,KAAK;AAE/E,UAAI,aAAa,QAAQ,eAAe,IAAI,GAAI,QAAO,EAAE,aAAAA,cAAa,UAAU;AAEhF,UACE,iBAAiB,UACf,cAAc,eAAe,KAAK,iBAAiB,eAAe,KAAK,CAAC,GAAG,WAAW,GACxF;AACA,eAAO,EAAE,aAAAA,cAAa,UAAU;AAAA,MAClC;AAEA,YAAM,uBAAuB,CAC3B,UACuC;AAAA,QACvC,SAAS,KAAK,OAAO;AAAA,QACrB,aAAa,aAAa,KAAK,OAAO;AAAA,QACtC,OAAYO;AAAA,UACL,QAAsB,aAAa;AAAA,UACxC,CAAC,kBACM,IAAI,aAAY;AACnB,kBAAM,gBAAgB,sCAAsC,IAAI;AAChE,kBAAM,QAAQ,GAAG,kBAAkB,eAAe,UAAU;AAC5D,kBAAM,EAAE,KAAK,IAAI,GAAG,8BAA8B,YAAY,KAAK;AAEnE,0BAAc;AAAA,cACZ;AAAA,cACA;AAAA,cACA;AAAA,cACA,kCAAkC,KAAK,IAAI;AAAA,YAC7C;AAAA,UACF,CAAC;AAAA,QACL;AAAA,MACF;AAGA,YAAM,yBAA4D;AAAA,QAChE,SAAS,KAAK,OAAO;AAAA,QACrB,aAAa,aAAa,KAAK,OAAO;AAAA,QACtC,OAAYA;AAAA,UACL,QAAsB,aAAa;AAAA,UACxC,CAAC,kBACM;AAAA,YAAK,MACR,cAAc;AAAA,cACZ;AAAA,cACA;AAAA,cACA,2BAA2B,KAAK,IAAI;AAAA;AAAA,YACtC;AAAA,UACF;AAAA,QACJ;AAAA,MACF;AAEA,YAAM,wBAA+D,CAAC;AACtE,aAAO,KAAK,MAAM,YAAY,CAAC,UAAU;AACvC,cAAM,QAAQ,UAAU,MAAM,WAC1B,EAAE,KAAK,GAAG,kBAAkB,MAAM,UAAU,UAAU,GAAG,KAAK,MAAM,SAAS,IAAI,IACjF,MAAM;AACV,cAAM,OAAO,UAAU,MAAM,WACzB,MAAM,WACN,QAAQ,kCAAkC,YAAY,MAAM,SAAS,GAAG;AAC5E,8BAAsB,KAAK;AAAA,UACzB;AAAA,UACA,aAAa,cAAc,kBACvB,GAAG,MAAM,WAAW,cAAc,KAAK,IAAI,MAC3C,MAAM;AAAA,UACV,OAAO,MAAM,MAAM,OAAO,OAAO,CAAC,qBAAqB,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,sBAAsB,CAAC;AAAA,QACrG,CAAC;AAAA,MACH,CAAC;AAGD,YAAM,sBAAsB,IAAI,IAA6B,cAAc,eAAe,KAAK,CAAC,CAAC;AAGjG,iBAAW,WAAW,sBAAsB,MAAM,CAAC,GAAG;AAEpD,YAAI,WAA+B;AAEnC,cAAM,gBAAgB,cAAc,eAAe,KAAK,CAAC,GAAG;AAAA,UAAK,CAAC,MAChE,EAAE,MAAM,QAAQ,MAAM,OAAO,EAAE,OAAO,QAAQ,MAAM;AAAA,QACtD;AACA,YAAI,cAAc;AAChB,qBAAW,aAAa;AACxB,8BAAoB,OAAO,YAAY;AAAA,QACzC,OAAO;AAEL,gBAAM,mBAAmB,iBAAiB,eAAe,KAAK,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,MAAM,QAAQ,MAAM,GAAG;AACvG,cAAI,gBAAiB,YAAW,gBAAgB;AAAA,QAClD;AAEA,YAAI,EAAE,YAAY,2BAA4B;AAE9C,QAAAP,aAAY,KAAK;AAAA,UACf,MAAM;AAAA,UACN,OAAO,QAAQ,MAAM;AAAA,UACrB,QAAQ,QAAQ,MAAM,MAAM,QAAQ,MAAM;AAAA,UAC1C,aAAa,QAAQ;AAAA,UACrB,UAAU,0BAA0B,QAAQ;AAAA,UAC5C,MAAM,KAAK;AAAA,UACX,QAAQ;AAAA,QACV,CAAC;AAED,mBAAW,OAAO,QAAQ,OAAO;AAC/B,oBAAU,KAAK;AAAA,YACb,GAAG;AAAA,YACH,MAAM,KAAK;AAAA,YACX,OAAO,QAAQ,MAAM;AAAA,YACrB,KAAK,QAAQ,MAAM;AAAA,UACrB,CAAC;AAAA,QACH;AAAA,MACF;AAEA,UAAI,cAAc,8BAA8B,SAAS,oBAAoB,OAAO,GAAG;AACrF,mBAAW,sBAAsB,qBAAqB;AACpD,UAAAA,aAAY,KAAK;AAAA,YACf,MAAM;AAAA,YACN,OAAO,mBAAmB,aAAa;AAAA,YACvC,QAAQ,mBAAmB,aAAa,MAAM,mBAAmB,aAAa;AAAA,YAC9E,aACE,iCAAiC,KAAK,IAAI,IAAI,mBAAmB,KAAK;AAAA,YACxE,UAAU,0BAA0B,cAAc,yBAAyB;AAAA,YAC3E,MAAM;AAAA,YACN,QAAQ;AAAA,UACV,CAAC;AAAA,QACH;AAAA,MACF;AACA,aAAO,EAAE,aAAAA,cAAa,UAAU;AAAA,IAClC,CAAC;AAEH,WAAO,EAAE,QAAQ;AAAA,EACnB;AACF;AAEO,IAAM,SAAS,CAAC,KAAa,OAAO,MAAM;AAC/C,MAAI,KAAK,aAAa,MAAM,KAAK,aAAa;AAC9C,WAAS,IAAI,GAAG,IAAI,IAAI,IAAI,QAAQ,KAAK;AACvC,SAAK,IAAI,WAAW,CAAC;AACrB,SAAK,KAAK,KAAK,KAAK,IAAI,UAAU;AAClC,SAAK,KAAK,KAAK,KAAK,IAAI,UAAU;AAAA,EACpC;AACA,OAAK,KAAK,KAAK,KAAM,OAAO,IAAK,UAAU;AAC3C,QAAM,KAAK,KAAK,KAAM,OAAO,IAAK,UAAU;AAC5C,OAAK,KAAK,KAAK,KAAM,OAAO,IAAK,UAAU;AAC3C,QAAM,KAAK,KAAK,KAAM,OAAO,IAAK,UAAU;AAG5C,UAAQ,OAAO,GAAG,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,KAAK,OAAO,GAAG,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG;AAC3F;AAEO,IAAM,4BAAN,MAAgC;AAAA,EAErC,YACW,OACT;AADS;AAAA,EACR;AAAA,EAHM,OAAO;AAIlB;AAyBO,SAAS,cAAc,YAAkD;AAC9E,SAAO;AACT;AAEO,IAAM,2BAAgC,GAAG,2BAA2B,EAAE,WAC3EQ,WACA,YACA;AACA,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,SAAmF,CAAC;AAE1F,QAAM,QAAQ;AACd,MAAIF;AACJ,UAAQA,SAAQ,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM;AACrD,UAAM,MAAMA,OAAM,UAAU,CAAC,IAAI,CAAC;AAClC,QAAI,CAAC,IAAK;AACV,UAAM,eAAe,QAAQ,qBAAqB,YAAY,GAAG;AACjE,QAAI,CAAC,aAAc;AACnB,UAAM,cAAc,WAAW,KAAK,MAAM,KAAK,aAAa,GAAG;AAC/D,UAAM,eAAe;AACrB,QAAI;AACJ,YAAQ,eAAe,aAAa,KAAK,WAAW,OAAO,MAAM;AAC/D,YAAM,aAAa,aAAa,CAAC,KAAK;AACtC,YAAM,cAAc,aAAa,CAAC,KAAK;AACvC,YAAM,cAAc,aAAa,CAAC,KAAK;AACvC,YAAM,QAAsB;AAAA,QAC1B,KAAK,aAAa,QAAQ,MAAM,WAAW;AAAA,QAC3C,KAAK,aAAa,QAAQ,MAAM,aAAa,CAAC,EAAE;AAAA,MAClD;AACA,YAAM,UAAUE,UAAS,KAAK,CAACC,aAAYA,SAAQ,SAAS,WAAW;AACvE,UAAI,CAAC,QAAS;AACd,aAAO,KAAK,EAAE,SAAS,MAAM,aAAa,MAAM,CAAC;AAAA,IACnD;AAAA,EACF;AACA,SAAO;AACT,CAAC;AAEM,IAAM,qBAA0B,GAAG,wBAAwB,EAAE,WAClED,WACA,YACA,WACA;AACA,QAAM,qBAAqB,OAAO,yBAAyBA,WAAU,UAAU;AAC/E,QAAM,kBAAkB,mBAAmB;AAAA,IAAO,CAACC,aACjDA,SAAQ,MAAM,OAAO,UAAU,OAAOA,SAAQ,MAAM,OAAO,UAAU;AAAA,EACvE;AACA,MAAI,gBAAgB,WAAW,GAAG;AAChC,WAAO,OAAY,KAAK,IAAI,0BAA0B,oCAAoC,CAAC;AAAA,EAC7F;AACA,QAAM,EAAE,SAAS,MAAM,IAAI,gBAAgB,CAAC;AAC5C,QAAM,OAAO,OAAO,QAAQ,MAAM,YAAY,KAAK;AACnD,QAAM,oBAAoB;AAAA,IACnB,QAAsB,aAAa;AAAA,IACnCP,KAAI,CAAC,kBAAkB;AAC1B,oBAAc,YAAY,YAAY,KAAK;AAC3C,oBAAc,WAAW,YAAY,MAAM,KAAK,GAAG,QAAQ,IAAI,IAAI,KAAK,IAAI,EAAE;AAAA,IAChF,CAAC;AAAA,EACH;AACA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAO;AAAA,MACL,KAAK;AAAA,MACAK,SAAQ,MAAM,iBAAiB;AAAA,IACtC;AAAA,IACA,QAAQ;AAAA,EACV;AACF,CAAC;AAMM,IAAM,sCAAsC,CACjD,eACiD;AACjD,SAAQ,WAAmB,4BAA4B;AACzD;;;ACxjBO,IAAM,iBAAsB,GAAG,YAAY;AAAA,EAChD,WAAU,YAA2B;AACnC,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,UAAU,OAAY,QAAsB,iBAAiB;AACnE,UAAM,UAAU,OAAY,QAAqC,4BAA4B;AAG7F,UAAM,cAAc,QAAQ,2CAA2C,SAAS,UAAU;AAE1F,aAASG,cACP,eACA,MACoB;AACpB,UAAI,CAAC,YAAa;AAElB,iBAAW,cAAc,QAAQ,aAAa;AAE5C,YAAI,WAAW,WAAW,KAAM;AAGhC,cAAM,YAAY,WAAW,SAAS,YAAY,GAAG;AACrD,YAAI,eAAe,cAAc,KAAK,KAAK,WAAW,SAAS,MAAM,YAAY,CAAC;AAClF,cAAM,qBAAqB,aAAa,YAAY,GAAG;AACvD,YAAI,uBAAuB,GAAI,gBAAe,aAAa,MAAM,GAAG,kBAAkB;AACtF,YAAI,aAAa,YAAY,EAAE,SAAS,QAAQ,EAAG,gBAAe,aAAa,MAAM,GAAG,EAAE;AAC1F,YAAI,aAAa,WAAW,GAAG,EAAG,gBAAe,aAAa,MAAM,CAAC;AAGrE,YAAI,eAA6B,iBAAiB,IAAI,WAAW,QAAQ;AACzE,YAAI,CAAC,aAAa,WAAW,YAAY,gBAAgB,EAAG;AAC5D,uBAAe,aAAa,MAAM,YAAY,iBAAiB,MAAM;AACrE,YAAI,CAAC,aAAa,SAAS,GAAG,EAAG,gBAAe,eAAe;AAC/D,YAAI,aAAa,WAAW,GAAG,EAAG,gBAAe,aAAa,MAAM,CAAC;AACrE,mBAAW,UAAU,WAAW,iBAAiB;AAC/C,cAAI,aAAa,WAAW,MAAM,GAAG;AACnC,2BAAe,aAAa,MAAM,OAAO,MAAM;AAC/C;AAAA,UACF;AAAA,QACF;AAGA,YAAI,QAAQ,CAAC,YAAY,MAAM,cAAc,YAAY,EAAE;AAAA,UACzD,aAAa,YAAY,MAAM,cAAc,YAAY,IAAI,CAAC,IAAI,CAAC,aAAa;AAAA,QAClF;AACA,YAAI,WAAW,YAAY,sBAAsB;AAC/C,kBAAQ,CAAC,YAAY,MAAM,YAAY,EAAE;AAAA,YACvC,aAAa,YAAY,MAAM,cAAc,YAAY,IAAI,CAAC,IAAI,CAAC,aAAa;AAAA,UAClF;AAAA,QACF;AAGA,gBAAQ,MAAM,IAAI,CAAC,SAAS,KAAK,WAAW,GAAG,IAAI,KAAK,MAAM,CAAC,IAAI,IAAI,EAAE;AAAA,UAAI,CAAC,SAC5E,KAAK,SAAS,GAAG,IAAI,KAAK,MAAM,GAAG,EAAE,IAAI;AAAA,QAC3C;AAGA,cAAM,UAAU,MAAM,OAAO,CAAC,MAAM,OAAO,CAAC,EAAE,KAAK,EAAE,SAAS,CAAC,EAAE,KAAK,GAAG;AAGzE,eAAO,WAAW,YAAY,mBAAuB,OAAO,OAAO,IAAI;AAAA,MACzE;AAAA,IACF;AAEA,WAAO;AAAA,MACL,cAAAA;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,kBAAkB,oBAAI,IAAwB;AAE7C,IAAM,sBAA2B,GAAG,qBAAqB,EAAE,WAChE,YACA;AAEA,SAAO,gBAAgB,OAAO,GAAG;AAC/B,UAAM,SAAS,gBAAgB,KAAK,EAAE,KAAK,EAAE;AAC7C,QAAI,OAAQ,iBAAgB,OAAO,MAAM;AAAA,EAC3C;AACA,QAAM,aAAa,gBAAgB,IAAI,WAAW,QAAQ,MACvD,OAAO,eAAe,UAAU;AACnC,kBAAgB,IAAI,WAAW,UAAU,UAAU;AACnD,SAAO;AACT,CAAC;AAEM,SAAS,aACd,YACA,YACA,MACA;AACA,SAAYC;AAAA,IACV,oBAAoB,UAAU;AAAA,IAC9B,CAAC,sBAAsB,kBAAkB,aAAa,YAAY,IAAI;AAAA,EACxE;AACF;;;ACpGO,IAAM,uBAA2B,iBAAiB;AAAA,EACvD,MAAM;AAAA,EACN,OAAY,GAAG,sBAAsB,EAAE,WAAU,YAAY,UAAU;AACrE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,aAAa,QAAQ,mCAAmC,YAAY,QAAQ;AAClF,QAAI,CAAC,WAAY,QAAO,CAAC;AACzB,UAAM,EAAE,gBAAgB,WAAW,gBAAgB,IAAI;AAGvD,UAAM,oBAAoB,QAAQ;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAGL,QAAI,sBAAsB,GAAG,OAAO,cAAc,EAAG,QAAO,CAAC;AAC7D,UAAM,OAAO,GAAG,OAAO,SAAS;AAGhC,UAAM,UAAU,OAAkB,aAAa,YAAY,MAAM,SAAS,MAAM;AAEhF,WAAO,CAAC;AAAA,MACN,MAAM,QAAQ,IAAI;AAAA,MAClB,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,iBAAiB,SAAS,MAAM,MAAM,IAAI,KAAK,MAAM;AAAA,MACpE;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAAA,EACH,CAAC;AACH,CAAC;;;ACzBM,IAAM,iBAAsB,IAAoB,aAAa;AAE7D,SAAS,8BAA8B,aAA6B;AACzE,MAAI,EAAE,YAAY,aAAa,2BAA2B,KAAK,WAAW,YAAY,yBAAyB,IAAI;AACjH;AAAA,EACF;AACA,QAAM,YAAY,YAAY;AAC9B,SAAO,CAAC,oBAA0D;AAChE,WAAO,UAAU,eAAe;AAAA,EAClC;AACF;;;ACMO,IAAM,mBAAwB,IAAsB,kBAAkB;AAEtE,IAAMC,aAAY,CACvB,OAEA;AAAA,EACO,QAAsB,aAAa;AAAA,EACnCC;AAAA,IAAQ,CAAC,OACPA,SAAa,QAAuB,cAAc,GAAG,CAAC,gBACpDA,SAAa,QAAwB,eAAe,GAAG,CAAC,oBAC3D,KAAK,IAAS,eAAe,kBAAkB,qBAAqB,IAAI,aAAa,eAAe,CAAC,CAAC,CAAC,CAAC;AAAA,EAC9G;AACF;AAeK,SAAS,qBACd,IACA,aACA,SACkB;AAClB,WAAS,QAAQ,MAAqC;AACpD,WAAO,CAAC,EAAE,KAAK,QAAQ,GAAG,UAAU;AAAA,EACtC;AAEA,WAAS,YAAY,MAAqC;AACxD,WAAO,CAAC,EAAE,KAAK,QAAQ,GAAG,UAAU;AAAA,EACtC;AAEA,WAAS,oBAAoB,MAAwB;AACnD,WAAO,CAAC,EAAE,KAAK,QAAQ,GAAG,UAAU,iBAAkB,KAAa;AAAA,EACrE;AAEA,WAAS,2BAA2B,WAAyB,KAAsB;AACjF,UAAM,OAAO,YAAY,iBAAiB,WAAW,GAAG;AACxD,QAAI,YAAY,IAAI,KAAK,oBAAoB,KAAK,IAAI,GAAG;AACvD,YAAM,aAAa,YAAY,wBAAwB,KAAK,IAAI;AAChE,UAAI,YAAY;AACd,eAAO,YAAY,aAAa,UAAU;AAAA,MAC5C;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,QAAM,qBAAqB,CAAC,SAAkB;AAC5C,UAAM,SAAyB,CAAC;AAChC,QAAI,SAAyB,CAAC,IAAI;AAClC,WAAO,OAAO,SAAS,GAAG;AACxB,YAAMC,QAAO,OAAO,IAAI;AACxB,UAAI,QAAQA,KAAI,GAAG;AACjB,iBAAS,OAAO,OAAOA,MAAK,KAAK;AAAA,MACnC,OAAO;AACL,eAAO,KAAKA,KAAI;AAAA,MAClB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,QAAM,oCAAoC,SAAS,UAAmB,cAAuB;AAC3F,QAAI,aAAa,aAAc,QAAO,CAAC;AAEvC,UAAM,SAAyB,CAAC;AAChC,QAAI,SAAyB,CAAC,QAAQ;AACtC,WAAO,OAAO,SAAS,GAAG;AACxB,YAAM,OAAO,OAAO,IAAI;AACxB,UAAI,CAAC,KAAM,QAAO;AAClB,UAAI,QAAQ,IAAI,GAAG;AACjB,iBAAS,OAAO,OAAO,KAAK,KAAK;AAAA,MACnC,OAAO;AACL,cAAM,aAAa,YAAY,mBAAmB,MAAM,YAAY;AACpE,YAAI,CAAC,YAAY;AACf,iBAAO,KAAK,IAAI;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAaA,QAAM,yBAA8B;AAAA,IAClC;AAAA,EACF;AAAA,IACE,WACE,QACA,aACA,eACA;AACA,YAAM,aAA0B,oBAAI,IAAI;AACxC,YAAM,eAA4B,oBAAI,IAAI;AAC1C,UAAI,SAAyB,CAAC,WAAW;AACzC,aAAO,OAAO,SAAS,GAAG;AACxB,cAAM,OAAO,OAAO,IAAI;AACxB,YAAI,CAAC,KAAM;AACX,YAAI,OAAO,cAAc,IAAI,GAAG;AAC9B;AAAA,QACF;AACA,YAAI,QAAQ,IAAI,GAAG;AACjB,mBAAS,OAAO,OAAO,KAAK,KAAK;AAAA,QACnC,OAAO;AACL,gBAAM,aAA4B,CAAC;AACnC,qBAAW,CAAC,QAAQ,SAAS,KAAK,OAAO,QAAQ,GAAG;AAClD,kBAAM,UAAU,YAAY,mBAAmB,WAAW,IAAI,KAC5D,YAAY,mBAAmB,MAAM,SAAS;AAChD,gBAAI,SAAS;AACX,yBAAW,KAAK,MAAM;AACtB;AAAA,YACF;AAAA,UACF;AACA,cAAI,WAAW,WAAW,GAAG;AAC3B,kBAAM,QAAQ,OAAO,OAAO,OAAO;AACnC,mBAAO,IAAI,OAAO,IAAI;AACtB,uBAAW,IAAI,KAAK;AAAA,UACtB,OAAO;AACL,yBAAa,IAAI,WAAW,CAAC,CAAC;AAAA,UAChC;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,YAAY;AAAA,UACJ,aAAa,UAAU;AAAA,UACvB,UAAgB,aAAa,YAAY,CAAC;AAAA,QAClD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,yBAA+BC,MAAK,CAAC,GAAY,MAAe;AACpE,UAAM,QAAQ,YAAY,aAAa,CAAC;AACxC,UAAM,QAAQ,YAAY,aAAa,CAAC;AACxC,QAAI,QAAQ,MAAO,QAAO;AAC1B,QAAI,QAAQ,MAAO,QAAO;AAC1B,WAAO;AAAA,EACT,CAAC;AAED,QAAM,oCAAoC,CAAC,SAAkB;AAC3D,QAAI,UAA+B;AACnC,WAAO,SAAS;AACd,UACE,GAAG,sBAAsB,OAAO,KAChC,GAAG,qBAAqB,OAAO,KAC/B,GAAG,gBAAgB,OAAO,KAC1B,GAAG,oBAAoB,OAAO,GAC9B;AACA,eAAO;AAAA,MACT;AACA,gBAAU,QAAQ;AAAA,IACpB;AAAA,EACF;AAEA,QAAM,wBAAwB,CAC5B,gBACG;AACH,QAAI,CAAC,YAAY,MAAM;AACrB;AAAA,IACF;AAEA,QAAI;AAEJ,QAAI,YAAY,2BAA2B,WAAW,GAAG;AACvD,YAAM,aAAa,YAAY;AAAA,QAC7B,YAAY,kBAAkB,WAAW;AAAA,QACzC,GAAG,cAAc;AAAA,MACnB;AACA,UAAI,WAAW,SAAS,GAAG;AACzB,qBAAa,YAAY;AAAA,UACvB,WAAW,IAAI,CAAC,MAAM,YAAY,yBAAyB,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAAA,QAClF;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,YAAY;AACf,YAAM,YAAY,YAAY,4BAA4B,WAAW;AACrE,UAAI,WAAW;AACb,cAAM,gBAAgB,YAAY,4BAA4B,SAAS;AACvE,YAAI,iBAAiB,cAAc,MAAM;AACvC,iBAAO,cAAc;AAAA,QACvB,OAAO;AACL,uBAAa,YAAY,yBAAyB,SAAS;AAAA,QAC7D;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,QAAM,2BAA2B,oBAAI,QAAmD;AACxF,QAAM,sBAAsB,CAC1B,eACG;AACH,UAAMC,UAAS,yBAAyB,IAAI,UAAU;AACtD,QAAIA,QAAQ,QAAOA;AACnB,UAAM,SAAqC,CAAC;AAE5C,UAAM,cAA8B,CAAC,UAAU;AAC/C,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AAEA,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAE/B,UAAI,GAAG,sBAAsB,IAAI,KAAK,KAAK,aAAa;AAEtD,cAAM,eAAe,YAAY,kBAAkB,KAAK,IAAI;AAC5D,cAAM,WAAW,YAAY,kBAAkB,KAAK,WAAW;AAC/D,eAAO,KAAK,CAAC,KAAK,MAAM,cAAc,KAAK,aAAa,QAAQ,CAAC;AACjE,0BAAkB,KAAK,WAAW;AAClC;AAAA,MACF,WAAW,GAAG,iBAAiB,IAAI,GAAG;AAEpC,cAAM,oBAAoB,YAAY,qBAAqB,IAAI;AAC/D,YAAI,mBAAmB;AACrB,4BAAkB,WAAW,IAAI,CAAC,WAAW,UAAU;AACrD,kBAAM,eAAe,YAAY,0BAA0B,WAAW,IAAI;AAC1E,kBAAM,WAAW,YAAY,kBAAkB,KAAK,UAAU,KAAK,CAAC;AACpE,mBAAO,KAAK;AAAA,cACV,KAAK,UAAU,KAAK;AAAA,cACpB;AAAA,cACA,KAAK,UAAU,KAAK;AAAA,cACpB;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AACA,WAAG,aAAa,MAAM,iBAAiB;AACvC;AAAA,MACF,WACE,GAAG,aAAa,IAAI,KAAK,GAAG,gBAAgB,IAAI,KAAK,GAAG,iBAAiB,IAAI,KAC7E,GAAG,gCAAgC,IAAI,GACvC;AAEA,cAAM,SAAS,KAAK;AACpB,YAAI,GAAG,uBAAuB,MAAM,GAAG;AACrC,cAAI,GAAG,0BAA0B,OAAO,MAAM,KAAK,OAAO,SAAS,MAAM;AACvE,kBAAM,OAAO,YAAY,kBAAkB,OAAO,MAAM;AACxD,gBAAI,MAAM;AACR,oBAAM,OAAO,GAAG,aAAa,IAAI,IAAI,GAAG,OAAO,IAAI,IAAI,GAAG,gBAAgB,IAAI,IAAI,KAAK,OAAO;AAC9F,kBAAI,MAAM;AACR,sBAAMC,UAAS,YAAY,kBAAkB,MAAM,IAAI;AACvD,oBAAIA,SAAQ;AACV,wBAAM,eAAe,YAAY,0BAA0BA,SAAQ,IAAI;AACvE,wBAAM,WAAW,YAAY,kBAAkB,IAAI;AACnD,yBAAO,KAAK,CAAC,MAAM,cAAc,MAAM,QAAQ,CAAC;AAAA,gBAClD;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,WAAG,aAAa,MAAM,iBAAiB;AACvC;AAAA,MACF,WACE,GAAG,mBAAmB,IAAI,KAAK,KAAK,cAAc,SAAS,GAAG,WAAW,aACzE;AAEA,cAAM,eAAe,YAAY,kBAAkB,KAAK,IAAI;AAC5D,cAAM,WAAW,YAAY,kBAAkB,KAAK,KAAK;AACzD,eAAO,KAAK,CAAC,KAAK,MAAM,cAAc,KAAK,OAAO,QAAQ,CAAC;AAC3D,0BAAkB,KAAK,KAAK;AAC5B;AAAA,MACF,WAAW,GAAG,kBAAkB,IAAI,KAAK,KAAK,YAAY;AAExD,cAAM,oBAAoB,kCAAkC,IAAI;AAChE,YAAI,mBAAmB;AACrB,gBAAM,eAAe,sBAAsB,iBAAiB;AAC5D,gBAAM,WAAW,YAAY,kBAAkB,KAAK,UAAU;AAC9D,cAAI,cAAc;AAChB,mBAAO,KAAK,CAAC,MAAM,cAAc,MAAM,QAAQ,CAAC;AAAA,UAClD;AAAA,QACF;AACA,WAAG,aAAa,MAAM,iBAAiB;AACvC;AAAA,MACF,WACE,GAAG,gBAAgB,IAAI,MAAM,KAAK,kBAAkB,CAAC,GAAG,WAAW,KACnE,GAAG,aAAa,KAAK,IAAI,GACzB;AAEA,cAAM,OAAO,KAAK;AAClB,cAAM,eAAe,YAAY,kBAAkB,IAAI;AACvD,cAAM,WAAW,YAAY,kBAAkB,IAAI;AACnD,YAAI,cAAc;AAChB,iBAAO,KAAK,CAAC,MAAM,cAAc,MAAM,QAAQ,CAAC;AAAA,QAClD;AACA,WAAG,aAAa,MAAM,iBAAiB;AACvC;AAAA,MACF,WACE,GAAG,gBAAgB,IAAI,MAAM,KAAK,kBAAkB,CAAC,GAAG,SAAS,KACjE,GAAG,aAAa,KAAK,IAAI,GACzB;AAEA,cAAM,OAAO,KAAK;AAClB,cAAM,eAAe,sBAAsB,IAAI;AAC/C,cAAM,WAAW,YAAY,kBAAkB,IAAI;AACnD,YAAI,cAAc;AAChB,iBAAO,KAAK,CAAC,MAAM,cAAc,MAAM,QAAQ,CAAC;AAAA,QAClD;AACA,WAAG,aAAa,MAAM,iBAAiB;AACvC;AAAA,MACF,WAAW,GAAG,sBAAsB,IAAI,GAAG;AAEzC,cAAM,eAAe,YAAY,kBAAkB,KAAK,IAAI;AAC5D,cAAM,WAAW,YAAY,kBAAkB,KAAK,UAAU;AAC9D,eAAO,KAAK,CAAC,KAAK,YAAuB,cAAc,KAAK,YAAY,QAAQ,CAAC;AACjF,0BAAkB,KAAK,UAAU;AACjC;AAAA,MACF;AAGA,SAAG,aAAa,MAAM,iBAAiB;AAAA,IACzC;AACA,6BAAyB,IAAI,YAAY,MAAM;AAC/C,WAAO;AAAA,EACT;AAEA,WAAS,yBACP,MACA,eACA,OACyB;AACzB,WAAO,+BAA+B,MAAM,eAAe,OAAO,CAAC;AAAA,EACrE;AAEA,WAAS,+BACP,MACA,eACA,OACA,OACyB;AACzB,UAAM,mBAAmB,MAAM;AAC7B,YAAM,WAAW,YAAY,eAAe,MAAM,eAAe,KAAK;AACtE,UAAI,CAAC,SAAU,QAAO;AACtB,aAAO,QAAQ,iBAAiB,QAAQ;AAAA,IAC1C;AAEA,QAAI,QAAQ,GAAI,QAAO,iBAAiB;AAExC,UAAM,UAAU,mBAAmB,IAAI;AAEvC,QAAI,QAAQ,SAAS,KAAK,EAAE,KAAK,QAAQ,GAAG,UAAU,UAAU;AAC9D,YAAM,YAAgC,CAAC;AACvC,cAAQ,KAAK,sBAAsB;AACnC,iBAAW,UAAU,SAAS;AAC5B,cAAM,aAAa,+BAA+B,QAAQ,eAAe,OAAO,QAAQ,CAAC;AACzF,YAAI,CAAC,WAAY,QAAO,iBAAiB;AACzC,kBAAU,KAAK,UAAU;AAAA,MAC3B;AACA,aAAO,QAAQ,iBAAiB,GAAG,QAAQ,oBAAoB,SAAS,CAAC;AAAA,IAC3E;AAEA,QAAI,KAAK,QAAQ,GAAG,UAAU,cAAc;AAC1C,YAAM,mBAAmB;AACzB,YAAM,YAAgC,CAAC;AACvC,iBAAW,UAAU,iBAAiB,OAAO;AAC3C,cAAM,aAAa,+BAA+B,QAAQ,eAAe,OAAO,QAAQ,CAAC;AACzF,YAAI,CAAC,WAAY,QAAO,iBAAiB;AACzC,kBAAU,KAAK,UAAU;AAAA,MAC3B;AACA,aAAO,QAAQ,iBAAiB,GAAG,QAAQ,2BAA2B,SAAS,CAAC;AAAA,IAClF;AAEA,QAAI,KAAK,QAAQ,GAAG,UAAU,UAAW,KAAuB,cAAc,GAAG,YAAY,WAAW;AACtG,YAAM,gBAAgB;AAEtB,YAAMC,YAAW,iBAAiB;AAClC,UAAI,CAACA,UAAU,QAAO;AACtB,UAAI,CAAC,GAAG,oBAAoBA,SAAQ,EAAG,QAAOA;AAC9C,UAAI,cAAc,OAAO,gBAAgB,WAAW,cAAc,eAAe,OAAQ,QAAOA;AAChG,UAAIA,UAAS,eAAe,WAAW,cAAc,eAAe,OAAQ,QAAOA;AACnF,YAAM,uBAAuB,cAAc,OAAO,kBAAkB,CAAC,GAAG;AACxE,eAAS,IAAI,sBAAsB,GAAG,KAAK,GAAG,KAAK;AACjD,cAAM,gBAAgB,cAAc,OAAO,eAAgB,CAAC;AAC5D,cAAM,eAAe,cAAc,cAAe,CAAC;AACnD,cAAM,cAAc,YAAY,4BAA4B,aAAa;AACzE,YAAI,gBAAgB,gBAAgB,MAAM,GAAG;AAC3C,iBAAO,QAAQ,iBAAiB,GAAG,QAAQ;AAAA,YACzCA;AAAA,YACAA,UAAS;AAAA,YACT,GAAG,QAAQ,iBAAiBA,UAAS,iBAAiB,CAAC,GAAG,MAAM,GAAG,KAAK,IAAI,qBAAqB,IAAI,CAAC,CAAC,CAAC;AAAA,UAC1G,CAAC;AAAA,QACH;AAAA,MACF;AACA,aAAOA;AAAA,IACT;AAEA,QAAI,KAAK,QAAQ,GAAG,UAAU,QAAQ;AACpC,YAAMA,YAAW,iBAAiB;AAClC,UAAI,CAACA,UAAU,QAAO;AACtB,UAAI,CAAC,GAAG,mBAAmBA,SAAQ,EAAG,QAAOA;AAC7C,YAAM,aAAa,YAAY,oBAAoB,MAAM,GAAG,cAAc,IAAI;AAC9E,UAAI,WAAW,WAAW,EAAG,QAAOA;AACpC,YAAM,aAAa,YAAY,yBAAyB,WAAW,CAAC,CAAC;AACrE,UAAI,CAAC,WAAY,QAAOA;AACxB,YAAM,iBAAiB,+BAA+B,YAAY,eAAe,OAAO,QAAQ,CAAC;AACjG,UAAI,CAAC,eAAgB,QAAOA;AAC5B,aAAO,QAAQ,iBAAiB,GAAG,QAAQ;AAAA,QACzCA;AAAA,QACAA,UAAS;AAAA,QACTA,UAAS;AAAA,QACT;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,iBAAiB;AAAA,EAC1B;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACzcO,IAAM,gBAAoB,iBAAiB;AAAA,EAChD,MAAM;AAAA,EACN,OAAY,GAAG,eAAe,EAAE,WAAU,YAAY,UAAU;AAC9D,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,QAAI,aAAsB;AAC1B,UAAM,gBAAgB,GAAG,mBAAmB,UAAU,UAAU;AAChE,QAAI,iBAAiB,GAAG,2BAA2B,aAAa,GAAG;AACjE,YAAM,QAAQ,GAAG,kBAAkB,eAAe,UAAU;AAC5D,YAAM,MAAM,cAAc;AAM1B,UAAI,QAAQ,YAAY,WAAW,KAAK;AACtC,qBAAa;AAAA,MACf;AAEA,UAAI,aAAa,KAAK;AACpB,qBAAa,CAAC,CAAE,cAAuC;AAAA,MACzD;AAEA,UAAI,cAAc,GAAG,aAAa,aAAa,GAAG;AAChD,cAAM,OAAO,YAAY,kBAAkB,aAAa;AAExD,YAAI,MAAM;AAER,cAAI,CAAC,iBAAiB,QAAQ,IAAI,EAAG,QAAO,CAAC;AAE7C,qBAAW,UAAU,KAAK,OAAO;AAC/B,gBAAI,OAAO,QAAQ,GAAG,UAAU,iBAAiB;AAC/C,kBACE,YAAY,QAAQ,OAAO,KAAW,QAAQ,OAAO,KAAK,KAAK,OAAO,MAAM,WAAW,KACvF,OAAO,OAAO,MAAM,CAAC,CAAC,EAAE,KAAK,MAAM,SACnC;AAEA,uBAAO,CAAC,SAAS,UAAU,UAAU,WAAW,WAAW,SAAS,QAAQ,OAAO,EAAE;AAAA,kBACnF,CAAC,UAAU;AAAA,oBACT;AAAA,oBACA,MAAM,GAAG,kBAAkB;AAAA,oBAC3B,YAAY,GAAG,MAAM,IAAI,IAAI;AAAA,oBAC7B,WAAW;AAAA,kBACb;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,CAAC;AAAA,EACV,CAAC;AACH,CAAC;;;ACiIM,IAAM,aAAkB,IAAgB,qCAAqC;AAE7E,IAAMC,aAAY,CACvB,OAEK,IAAI,aAAY;AACnB,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,QAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,QAAM,UAAU,OAAY,QAAsB,iBAAiB;AAEnE,SAAO,OAAO;AAAA,IACZ;AAAA,IACK,eAAe,YAAYC,MAAK,IAAI,SAAS,aAAa,kBAAkB,OAAO,CAAC;AAAA,EAC3F;AACF,CAAC;AAEI,IAAM,kBAAN,MAAM,iBAAgB;AAAA,EAClB,OAAO;AAAA,EAChB,OAAO,QAAa,KAAK,IAAI,iBAAgB,CAAC;AAChD;AAEO,SAAS,gBACd,UACA,OACA,OAC0C;AAC1C,SAAO,gBAAgB;AACzB;AAEO,SAASA,MACd,IACA,SACA,aACA,kBACA,SACY;AACZ,QAAM,2BAAgC;AAAA,IAC/B,GAAG,qCAAqC,EAAE,WAAU,YAA2B;AAClF,aAAO,QAAQ,2CAA2C,SAAS,UAAU;AAAA,IAC/E,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,sCAAsC,CAC1C,gBAEK;AAAA,IACE,GAAG,gDAAgD,EAAE,WAAUC,SAAmB;AACrF,YAAM,SAA+B,CAAC;AACtC,UAAI,CAACA,QAAO,aAAc,QAAO,OAAO,gBAAgB,8BAA8B,QAAW,MAAS;AAC1G,iBAAW,cAAcA,QAAO,cAAc;AAC5C,YAAI,CAAC,GAAG,aAAa,UAAU,EAAG;AAClC,cAAM,cAAc,OAAO,yBAAyB,UAAU;AAC9D,YAAI,CAAC,eAAe,YAAY,KAAK,YAAY,MAAM,YAAY,YAAY,EAAG;AAClF,eAAO,KAAK,UAAU;AAAA,MACxB;AACA,UAAI,OAAO,SAAS,GAAG;AACrB,eAAO;AAAA,MACT;AACA,aAAO,OAAO,gBAAgB,0CAA0C,QAAW,MAAS;AAAA,IAC9F,CAAC;AAAA,IACD,kDAAkD,WAAW;AAAA,IAC7D,CAACA,YAAWA;AAAA,EACd;AAEF,QAAM,mCAAmC,CACvC,aACA,aACA,oBACG;AACH,QAAIA,UAAS;AACb,WAAOA,QAAO,QAAQ,GAAG,YAAY,OAAO;AAC1C,MAAAA,UAAS,YAAY,iBAAiBA,OAAM;AAAA,IAC9C;AACA,WAAO;AAAA,MACL,oCAAoC,WAAW,EAAEA,OAAM;AAAA,MAClDC;AAAA,QAAQ,CAAC,gBACP;AAAA,UACH,YAAY,IAAI,CAAC,MAAM,gBAAgB,CAAC,CAAC;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,iCAAiC,CACrC,WACA,aACA,wBAGG;AACH,UAAMD,UAAS,YAAY,oBAAoB,SAAS;AACxD,QAAI,CAACA,QAAQ,QAAO,gBAAgB,sBAAsB,QAAW,SAAS;AAC9E,WAAO,iCAAiCA,SAAQ,aAAa,mBAAmB;AAAA,EAClF;AAEA,QAAM,0DAA0D,CAC9D,aACA,eAEK;AAAA,IACE,GAAG,oEAAoE,EAAE,WAAUA,SAAmB;AACzG,YAAM,SAAiG,CAAC;AACxG,UAAI,CAACA,QAAO,aAAc,QAAO,OAAO,gBAAgB,8BAA8B,QAAW,MAAS;AAC1G,iBAAW,eAAeA,QAAO,cAAc;AAC7C,cAAM,aAAa,QAAQ,oBAAoB,WAAW;AAC1D,YAAI,CAAC,WAAY;AACjB,cAAM,cAAc,OAAO,yBAAyB,UAAU;AAC9D,YAAI,CAAC,eAAe,YAAY,KAAK,YAAY,MAAM,YAAY,YAAY,EAAG;AAClF,cAAM,eAAe,YAAY,oBAAoB,UAAU;AAC/D,YAAI,CAAC,aAAc;AACnB,cAAM,eAAe,YAAY,4BAA4B,YAAY,YAAY;AACrF,YAAI,gBAAgB,iBAAiBA,QAAQ,QAAO,KAAK,EAAE,cAAc,cAAc,WAAW,CAAC;AAAA,MACrG;AACA,UAAI,OAAO,SAAS,GAAG;AACrB,eAAO;AAAA,MACT;AACA,aAAO,OAAO,gBAAgB,8BAA8B,QAAW,MAAS;AAAA,IAClF,CAAC;AAAA,IACD,sEAAsE,WAAW,KAAK,UAAU;AAAA,IAChG,CAAC,QAAQ;AAAA,EACX;AAEF,QAAM,gCAAgC,CACpC,aACA,aACA,YACA,oBACG;AACH,QAAIA,UAAS;AACb,WAAOA,QAAO,QAAQ,GAAG,YAAY,OAAO;AAC1C,MAAAA,UAAS,YAAY,iBAAiBA,OAAM;AAAA,IAC9C;AACA,WAAO;AAAA,MACL,wDAAwD,aAAa,UAAU,EAAEA,OAAM;AAAA,MAClFC;AAAA,QAAQ,CAAC,gBACP;AAAA,UACH,YAAY,IAAI,CAAC,MAAM,gBAAgB,EAAE,YAAY,EAAE,cAAc,EAAE,YAAY,CAAC;AAAA,QACtF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,yCAAyC,CAC7C,WACA,aACA,qBAKA,eACG;AACH,UAAMD,UAAS,YAAY,oBAAoB,SAAS;AACxD,QAAI,CAACA,QAAQ,QAAO,gBAAgB,sBAAsB,QAAW,SAAS;AAC9E,WAAO,8BAA8BA,SAAQ,aAAa,YAAY,mBAAmB;AAAA,EAC3F;AAEA,WAAS,sBAAsB,MAAoD;AACjF,UAAM,aAAa,YAAY,oBAAoB,MAAM,GAAG,cAAc,IAAI;AAE9E,QAAI,WAAW,WAAW,GAAG;AAC3B,aAAO,gBAAgB,wCAAwC,IAAI;AAAA,IACrE;AAEA,WAAY,QAAQ,YAAY,yBAAyB,WAAW,CAAC,CAAC,CAAC;AAAA,EACzE;AAEA,WAAS,0BAA0B,MAAoD;AACrF,UAAM,aAAa,YAAY,oBAAoB,MAAM,GAAG,cAAc,IAAI;AAE9E,QAAI,WAAW,WAAW,GAAG;AAC3B,aAAO,gBAAgB,4CAA4C,IAAI;AAAA,IACzE;AAEA,WAAY,QAAQ,iBAAiB,2BAA2B,WAAW,CAAC,GAAG,CAAC,CAAC;AAAA,EACnF;AAEA,WAAS,sBAAsB,MAAoD;AACjF,UAAM,aAAa,YAAY,oBAAoB,MAAM,GAAG,cAAc,IAAI;AAE9E,QAAI,WAAW,WAAW,GAAG;AAC3B,aAAO,gBAAgB,wCAAwC,IAAI;AAAA,IACrE;AAEA,WAAY,QAAQ,YAAY,yBAAyB,WAAW,CAAC,CAAC,CAAC;AAAA,EACzE;AAEA,QAAM,eAAoB;AAAA,IACxB,SACE,MACA,YACA;AAEA,YAAM,aAAa,YAAY,kBAAkB,MAAM,MAAM;AAC7D,UAAI,CAAC,YAAY;AACf,eAAO,gBAAgB,+BAA+B,MAAM,UAAU;AAAA,MACxE;AAEA,YAAM,WAAW,YAAY,0BAA0B,YAAY,UAAU;AAC7E,YAAM,aAAa,YAAY,oBAAoB,UAAU,GAAG,cAAc,IAAI;AAClF,UAAI,WAAW,WAAW,GAAG;AAC3B,eAAO,gBAAgB,mCAAmC,MAAM,UAAU;AAAA,MAC5E;AACA,aAAY,QAAQ,IAAI;AAAA,IAC1B;AAAA,IACA;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,8BAA8B,CAClC,MACA,YACA,iBACG;AACH,UAAM,iBAAiB,YAAY,kBAAkB,MAAM,YAAY;AACvE,QAAI,CAAC,gBAAgB;AACnB,aAAO,gBAAgB,gBAAgB,YAAY,cAAc,MAAM,UAAU;AAAA,IACnF;AACA,UAAM,eAAe,YAAY,0BAA0B,gBAAgB,UAAU;AACrF,WAAO,sBAAsB,YAAY;AAAA,EAC3C;AAEA,QAAM,kCAAkC,CACtC,MACA,YACA,iBACG;AACH,UAAM,iBAAiB,YAAY,kBAAkB,MAAM,YAAY;AACvE,QAAI,CAAC,gBAAgB;AACnB,aAAO,gBAAgB,gBAAgB,YAAY,cAAc,MAAM,UAAU;AAAA,IACnF;AACA,UAAM,eAAe,YAAY,0BAA0B,gBAAgB,UAAU;AACrF,WAAO,0BAA0B,YAAY;AAAA,EAC/C;AAEA,QAAM,8BAA8B,CAClC,MACA,YACA,iBACG;AACH,UAAM,iBAAiB,YAAY,kBAAkB,MAAM,YAAY;AACvE,QAAI,CAAC,gBAAgB;AACnB,aAAO,gBAAgB,gBAAgB,YAAY,cAAc,MAAM,UAAU;AAAA,IACnF;AACA,UAAM,eAAe,YAAY,0BAA0B,gBAAgB,UAAU;AACrF,WAAO,sBAAsB,YAAY;AAAA,EAC3C;AAEA,QAAM,uBAAuB,CAC3B,MACA,eAEKE;AAAA,IACE;AAAA,MACH,4BAA4B,MAAM,YAAY,IAAI;AAAA,MAClD,4BAA4B,MAAM,YAAY,IAAI;AAAA,MAClD,4BAA4B,MAAM,YAAY,IAAI;AAAA,IACpD;AAAA,IACA,CAAC,CAAC,GAAG,GAAG,CAAC,OAAO,EAAE,GAAG,GAAG,EAAE;AAAA,EAC5B;AAEF,QAAM,sBAAsB,CAC1B,MACA,eAEKA;AAAA,IACE;AAAA,MACH,gCAAgC,MAAM,YAAY,OAAO;AAAA,MACzD,4BAA4B,MAAM,YAAY,IAAI;AAAA,MAClD,4BAA4B,MAAM,YAAY,MAAM;AAAA,IACtD;AAAA,IACA,CAAC,CAAC,MAAM,GAAG,GAAG,OAAO,EAAE,MAAM,GAAG,IAAI;AAAA,EACtC;AAEF,QAAM,aAAkB;AAAA,IACjB,GAAG,uBAAuB,EAAE,WAC/B,MACA,YACA;AACA,UAAI,SAQA,gBAAgB,sCAAsC,MAAM,UAAU;AAE1E,YAAM,oBAAoB,YAAY,oBAAoB,IAAI,EAAE;AAAA,QAAO,CAAC,MACtE,EAAE,QAAQ,GAAG,YAAY,YAAY,EAAE,EAAE,QAAQ,GAAG,YAAY,aAAa,EAAE,oBAC/E,GAAG,oBAAoB,EAAE,gBAAgB,KAAK,GAAG,uBAAuB,EAAE,iBAAiB,IAAI;AAAA,MACjG;AAEA,wBAAkB;AAAA,QAAK,CAAC,GAAG,MACzB,GAAG,WAAW,CAAC,EAAE,QAAQ,cAAc,IAAI,GAAG,WAAW,CAAC,EAAE,QAAQ,cAAc;AAAA,MACpF;AAEA,iBAAW,kBAAkB,mBAAmB;AAC9C,cAAM,eAAe,YAAY,0BAA0B,gBAAgB,UAAU;AACrF,iBAAS,KAAK,QAAaC,QAAO,MAAM,qBAAqB,cAAc,UAAU,CAAC,CAAC;AAAA,MACzF;AACA,aAAO,OAAO;AAAA,IAChB,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,mBAAwB;AAAA,IACvB,GAAG,6BAA6B,EAAE,WACrC,MACA,YACA;AAEA,UAAI,EAAE,KAAK,UAAU,GAAG,WAAW,KAAK,MAAM,MAAM,YAAY,CAAC,KAAK,cAAc;AAClF,eAAO,OAAO,gBAAgB,mDAAmD,MAAM,UAAU;AAAA,MACnG;AAEA,aAAO,OAAO,WAAW,MAAM,UAAU;AAAA,IAC3C,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,yBAA8B;AAAA,IAC7B,GAAG,mCAAmC,EAAE,WAC3C,YACA;AACA,YAAM,eAAe,YAAY,oBAAoB,UAAU;AAC/D,UAAI,CAAC,aAAc,QAAO,OAAO,gBAAgB,sBAAsB,QAAW,UAAU;AAC5F,YAAM,mBAAmB,YAAY,4BAA4B,UAAU,YAAY;AACvF,UAAI,CAAC,iBAAkB,QAAO,OAAO,gBAAgB,yBAAyB,QAAW,UAAU;AACnG,YAAM,OAAO,YAAY,wBAAwB,gBAAgB;AACjE,aAAO,WAAW,MAAM,UAAU;AAClC,aAAO;AAAA,IACT,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,mCAAmC,CAAC,eACnC;AAAA,IACE,GAAG,6CAA6C,EAAE,WACrD,MACA;AACA,aAAO,OAAO,uCAAuC,MAAM,UAAU,wBAAwB,UAAU;AAAA,IACzG,CAAC;AAAA,IACD,+CAA+C,UAAU;AAAA,IACzD,CAAC,SAAS;AAAA,EACZ;AAEF,QAAM,YAAiB;AAAA,IAChB,GAAG,sBAAsB,EAAE,WAC9B,MACA,YACA;AAEA,aAAO,aAAa,MAAM,UAAU;AAGpC,YAAM,oBAAoB,YAAY,oBAAoB,IAAI,EAAE;AAAA,QAAO,CAAC,MACtE,EAAE,QAAQ,GAAG,YAAY,YAAY,EAAE,EAAE,QAAQ,GAAG,YAAY,aAAa,EAAE,oBAC/E,GAAG,oBAAoB,EAAE,gBAAgB,KAAK,GAAG,uBAAuB,EAAE,iBAAiB,IAAI;AAAA,MACjG;AAEA,wBAAkB;AAAA,QAAK,CAAC,GAAG,MACzB,GAAG,WAAW,CAAC,EAAE,QAAQ,aAAa,IAAI,GAAG,WAAW,CAAC,EAAE,QAAQ,aAAa;AAAA,MAClF;AAEA,iBAAW,kBAAkB,mBAAmB;AAC9C,cAAM,eAAe,YAAY,0BAA0B,gBAAgB,UAAU;AACrF,cAAM,eAAe,OAAY,OAAO;AAAA,UACtC;AAAA,UACA;AAAA,QACF,CAAC;AACD,YAAWC,QAAO,YAAY,GAAG;AAC/B,iBAAO,aAAa;AAAA,QACtB;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,qCAAqC,MAAM,UAAU;AAAA,IACrF,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,YAAiB;AAAA,IAChB,GAAG,sBAAsB,EAAE,WAC9B,MACA,YACA;AAGA,YAAM,cAAc,YAAY,kBAAkB,MAAM,OAAO;AAC/D,YAAM,aAAa,YAAY,kBAAkB,MAAM,MAAM;AAC7D,UAAI,CAAC,eAAe,CAAC,YAAY;AAC/B,eAAO,OAAO;AAAA,UACZ;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,aAAO,OAAO,WAAW,MAAM,UAAU;AAAA,IAC3C,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,gBAAqB;AAAA,IACpB,GAAG,0BAA0B,EAAE,WAClC,MACA,YACA;AAKA,YAAM,YAAY,YAAY,kBAAkB,MAAM,MAAM;AAC5D,YAAM,YAAY,YAAY,kBAAkB,MAAM,KAAK;AAC3D,UAAI,EAAE,aAAa,YAAY;AAC7B,eAAO,OAAO;AAAA,UACZ;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,aAAO,OAAO,WAAW,MAAM,UAAU;AAAA,IAC3C,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,wBAA6B;AAAA,IAC5B,GAAG,kCAAkC,EAAE,WAC1C,MACA;AACA,YAAM,OAAO,YAAY,kBAAkB,IAAI;AAE/C,YAAM,iBAAiB,YAAY,kBAAkB,MAAM,KAAK;AAChE,UAAI,CAAC,gBAAgB;AACnB,eAAO,OAAO,gBAAgB,8BAA8B,MAAM,IAAI;AAAA,MACxE;AAEA,UAAI,CAAC,GAAG,aAAa,IAAI,GAAG;AAC1B,eAAO,OAAO,gBAAgB,6BAA6B,MAAM,IAAI;AAAA,MACvE;AACA,YAAM,aAAa,QAAQ,oBAAoB,IAAI;AACnD,UAAI,CAAC,YAAY;AACf,eAAO,OAAO,gBAAgB,gCAAgC,QAAW,IAAI;AAAA,MAC/E;AACA,YAAM,oBAAoB,QAAQ;AAAA,QAChC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,UAAI,CAAC,mBAAmB;AACtB,eAAO,OAAO,gBAAgB,4BAA4B,QAAW,IAAI;AAAA,MAC3E;AACA,UAAI,GAAG,OAAO,IAAI,MAAM,mBAAmB;AACzC,eAAO,OAAO,gBAAgB,0CAA0C,QAAW,IAAI;AAAA,MACzF;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,uBAAuB,CAAC,SAC5B;AAAA,IACE,+BAA+B,MAAM,UAAU,sBAAsB;AAAA,IAChEF,KAAI,MAAM,IAAI;AAAA,EACrB;AAEF,QAAM,qBAA0B;AAAA,IACzB,GAAG,+BAA+B,EAAE,WACvC,MACA;AACA,YAAM,OAAO,YAAY,kBAAkB,IAAI;AAE/C,YAAM,iBAAiB,YAAY,kBAAkB,MAAM,aAAa;AACxE,UAAI,CAAC,gBAAgB;AACnB,eAAO,OAAO,gBAAgB,sCAAsC,MAAM,IAAI;AAAA,MAChF;AAEA,UAAI,CAAC,GAAG,aAAa,IAAI,GAAG;AAC1B,eAAO,OAAO,gBAAgB,6BAA6B,MAAM,IAAI;AAAA,MACvE;AACA,YAAM,aAAa,QAAQ,oBAAoB,IAAI;AACnD,UAAI,CAAC,YAAY;AACf,eAAO,OAAO,gBAAgB,gCAAgC,QAAW,IAAI;AAAA,MAC/E;AACA,YAAM,iBAAiB,QAAQ;AAAA,QAC7B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,UAAI,CAAC,gBAAgB;AACnB,eAAO,OAAO,gBAAgB,yBAAyB,QAAW,IAAI;AAAA,MACxE;AACA,UAAI,GAAG,OAAO,IAAI,MAAM,gBAAgB;AACtC,eAAO,OAAO,gBAAgB,uCAAuC,QAAW,IAAI;AAAA,MACtF;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,YAAiB;AAAA,IACrB,SAAS,MAAe;AAEtB,UAAI,CAAC,GAAG,iBAAiB,IAAI,GAAG;AAC9B,eAAO,gBAAgB,iCAAiC,QAAW,IAAI;AAAA,MACzE;AAEA,UAAI,KAAK,UAAU,WAAW,GAAG;AAC/B,eAAO,gBAAgB,yBAAyB,QAAW,IAAI;AAAA,MACjE;AAEA,YAAM,oBAAoB,KAAK,UAAU,CAAC;AAC1C,UAAI,CAAC,GAAG,qBAAqB,iBAAiB,GAAG;AAC/C,eAAO,gBAAgB,qCAAqC,QAAW,IAAI;AAAA,MAC7E;AACA,UAAI,kBAAkB,kBAAkB,QAAW;AACjD,eAAO,gBAAgB,oCAAoC,QAAW,IAAI;AAAA,MAC5E;AAEA,UAAI,CAAC,GAAG,2BAA2B,KAAK,UAAU,GAAG;AACnD,eAAO,gBAAgB,4CAA4C,QAAW,IAAI;AAAA,MACpF;AACA,YAAM,iBAAiB,KAAK;AAC5B,aAAO;AAAA,QACL,iCAAiC,KAAK,EAAE,cAAc;AAAA,QACjDA,KAAI,OAAO;AAAA,UACd;AAAA,UACA,cAAc,eAAe;AAAA,UAC7B;AAAA,UACA,MAAM,kBAAkB;AAAA,QAC1B,EAAE;AAAA,MACJ;AAAA,IACF;AAAA,IACA;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,sBAA2B;AAAA,IAC/B,SAAS,MAAe;AAEtB,UAAI,CAAC,GAAG,iBAAiB,IAAI,GAAG;AAC9B,eAAO,gBAAgB,iCAAiC,QAAW,IAAI;AAAA,MACzE;AAEA,UAAI,KAAK,UAAU,WAAW,GAAG;AAC/B,eAAO,gBAAgB,yBAAyB,QAAW,IAAI;AAAA,MACjE;AAEA,YAAM,oBAAoB,KAAK,UAAU,CAAC;AAC1C,UAAI,CAAC,GAAG,qBAAqB,iBAAiB,GAAG;AAC/C,eAAO,gBAAgB,qCAAqC,QAAW,IAAI;AAAA,MAC7E;AACA,UAAI,kBAAkB,kBAAkB,QAAW;AACjD,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,UAAI,CAAC,GAAG,2BAA2B,KAAK,UAAU,GAAG;AACnD,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM,iBAAiB,KAAK;AAC5B,aAAO;AAAA,QACL,iCAAiC,YAAY,EAAE,cAAc;AAAA,QACxDA,KAAI,OAAO;AAAA,UACd;AAAA,UACA,cAAc,eAAe;AAAA,UAC7B;AAAA,UACA,MAAM,kBAAkB;AAAA,QAC1B,EAAE;AAAA,MACJ;AAAA,IACF;AAAA,IACA;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,cAAmB;AAAA,IACvB,SAAS,MAAe;AAEtB,UAAI,CAAC,GAAG,iBAAiB,IAAI,GAAG;AAC9B,eAAO,gBAAgB,iCAAiC,QAAW,IAAI;AAAA,MACzE;AAEA,UAAI,KAAK,UAAU,WAAW,GAAG;AAC/B,eAAO,gBAAgB,yBAAyB,QAAW,IAAI;AAAA,MACjE;AAEA,YAAM,oBAAoB,KAAK,UAAU,CAAC;AAC1C,UAAI,CAAC,GAAG,qBAAqB,iBAAiB,GAAG;AAC/C,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,UAAI,kBAAkB,kBAAkB,QAAW;AACjD,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,YAAM,mBAAmB,GAAG,iBAAiB,KAAK,UAAU,IACxD,KAAK,WAAW,aAChB,KAAK;AACT,UAAI,CAAC,GAAG,2BAA2B,gBAAgB,GAAG;AACpD,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM,iBAAiB;AACvB,aAAO;AAAA,QACL,iCAAiC,IAAI,EAAE,cAAc;AAAA,QAChDA,KAAI,OAAO;AAAA,UACd;AAAA,UACA;AAAA,UACA,cAAc,eAAe;AAAA,UAC7B,MAAM,kBAAkB;AAAA,QAC1B,EAAE;AAAA,MACJ;AAAA,IACF;AAAA,IACA;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAMG,wBAA4B;AAAA,IAC3B,GAAG,iCAAiC,EAAE,WACzC,MACA;AAEA,YAAM,EAAE,KAAK,IAAI,OAAO,UAAU,IAAI;AACtC,UAAI,KAAK,WAAW,WAAW,GAAG;AAChC,eAAO,OAAO;AAAA,UACZ;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,UAAI,iBAAiB;AACrB,UAAI,cAAuB,KAAK,WAAW,CAAC;AAC5C,aAAO,aAAa;AAElB,YAAI,GAAG,kBAAkB,WAAW,KAAK,YAAY,YAAY;AAC/D,wBAAc,YAAY;AAC1B,2BAAiB;AACjB;AAAA,QACF;AAEA,YAAI,GAAG,sBAAsB,WAAW,GAAG;AACzC,wBAAc,YAAY;AAC1B;AAAA,QACF;AAEA,YAAI,GAAG,kBAAkB,WAAW,KAAK,YAAY,iBAAiB,YAAY,YAAY;AAC5F,gBAAM,oBAAoB,YAAY;AACtC,gBAAM,OAAO,YAAY,kBAAkB,iBAAiB;AAC5D,gBAAM,EAAE,GAAG,YAAY,IAAI,OAAO,WAAW,MAAM,iBAAiB;AACpE,cAAI,kBAA2C,QAAQ,iBAAiB;AACxE,cAAI,CAAC,kBAAkB,EAAE,YAAY,QAAQ,GAAG,UAAU,WAAW;AACnE,8BAAkB;AAAA,cACX,IAAI,aAAY;AACnB,sBAAM,mBAAmB,QAAQ;AAAA,kBAC/B,KAAK,cAAc;AAAA,kBACnB;AAAA,kBACA;AAAA,gBACF,KAAK;AAEL,uBAAO,GAAG,QAAQ;AAAA,kBAChB,GAAG,QAAQ;AAAA,oBACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,oBAC5C;AAAA,kBACF;AAAA,kBACA;AAAA,kBACA;AAAA,oBACE;AAAA,kBACF;AAAA,gBACF;AAAA,cACF,CAAC;AAAA,cACI,eAA6B,eAAe,EAAE;AAAA,YACrD;AAAA,UACF;AACA,iBAAO,EAAE,MAAM,MAAM,mBAAmB,gBAAgB;AAAA,QAC1D;AAEA;AAAA,MACF;AAGA,aAAO,OAAO;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,6BAA6B,CACjC,MACA,eAEKH;AAAA,IACE;AAAA,MACH,4BAA4B,MAAM,YAAY,IAAI;AAAA,MAClD,4BAA4B,MAAM,YAAY,IAAI;AAAA,MAClD,4BAA4B,MAAM,YAAY,IAAI;AAAA,IACpD;AAAA,IACA,CAAC,CAAC,GAAG,GAAG,CAAC,OAAO,EAAE,GAAG,GAAG,EAAE;AAAA,EAC5B;AAEF,QAAM,mBAAwB;AAAA,IACvB,GAAG,6BAA6B,EAAE,WACrC,MACA,YACA;AAEA,aAAO,aAAa,MAAM,UAAU;AAEpC,YAAM,MAAM,YAAY,kBAAkB,MAAM,KAAK;AACrD,UAAI,CAAC,IAAK,QAAO,OAAO,gBAAgB,yBAAyB,MAAM,UAAU;AAEjF,YAAM,oBAAoB,YAAY,oBAAoB,IAAI,EAAE;AAAA,QAAO,CAAC,MACtE,EAAE,QAAQ,GAAG,YAAY,YAAY,EAAE,EAAE,QAAQ,GAAG,YAAY,aAAa,EAAE,oBAC/E,GAAG,oBAAoB,EAAE,gBAAgB,KAAK,GAAG,uBAAuB,EAAE,iBAAiB,IAAI;AAAA,MACjG;AAEA,wBAAkB,KAAK,CAAC,GAAG,MAAM,GAAG,WAAW,CAAC,EAAE,QAAQ,QAAQ,IAAI,GAAG,WAAW,CAAC,EAAE,QAAQ,QAAQ,CAAC;AAExG,iBAAW,kBAAkB,mBAAmB;AAC9C,cAAM,eAAe,YAAY,0BAA0B,gBAAgB,UAAU;AACrF,cAAM,eAAe,OAAY,OAAO;AAAA,UACtC;AAAA,UACA;AAAA,QACF,CAAC;AACD,YAAWE,QAAO,YAAY,GAAG;AAC/B,iBAAO,aAAa;AAAA,QACtB;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,sCAAsC,MAAM,UAAU;AAAA,IACtF,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,+BAAoC;AAAA,IACnC,GAAG,yCAAyC,EAAE,WACjD,YACA;AACA,YAAM,eAAe,YAAY,oBAAoB,UAAU;AAC/D,UAAI,CAAC,aAAc,QAAO,OAAO,gBAAgB,sBAAsB,QAAW,UAAU;AAC5F,YAAM,aAAa,YAAY,4BAA4B,UAAU,YAAY;AACjF,UAAI,CAAC,WAAY,QAAO,OAAO,gBAAgB,yBAAyB,QAAW,UAAU;AAC7F,YAAM,OAAO,YAAY,wBAAwB,UAAU;AAC3D,aAAO,iBAAiB,MAAM,UAAU;AACxC,aAAO;AAAA,IACT,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,yCAAyC,CAAC,eACzC;AAAA,IACE,GAAG,mDAAmD,EAAE,WAC3D,MACA;AACA,aAAO,OAAO,uCAAuC,MAAM,UAAU,8BAA8B,UAAU;AAAA,IAC/G,CAAC;AAAA,IACD,qDAAqD,UAAU;AAAA,IAC/D,CAAC,SAAS;AAAA,EACZ;AAEF,QAAM,2BAA2B,CAC/B,MACA,eAEKF;AAAA,IACE;AAAA,MACH,4BAA4B,MAAM,YAAY,aAAa;AAAA,MAC3D,4BAA4B,MAAM,YAAY,UAAU;AAAA,IAC1D;AAAA,IACA,CAAC,CAAC,YAAY,OAAO,OAAO,EAAE,YAAY,QAAQ;AAAA,EACpD;AAEF,QAAM,aAAkB;AAAA,IACjB,GAAG,uBAAuB,EAAE,WAC/B,MACA,YACA;AAEA,aAAO,aAAa,MAAM,UAAU;AAEpC,YAAM,oBAAoB,YAAY,oBAAoB,IAAI,EAAE;AAAA,QAAO,CAAC,MACtE,EAAE,QAAQ,GAAG,YAAY,YAAY,EAAE,EAAE,QAAQ,GAAG,YAAY,aAAa,EAAE,oBAC/E,GAAG,oBAAoB,EAAE,gBAAgB,KAAK,GAAG,uBAAuB,EAAE,iBAAiB,IAAI;AAAA,MACjG;AAEA,wBAAkB,KAAK,CAAC,GAAG,MAAM,GAAG,WAAW,CAAC,EAAE,QAAQ,QAAQ,IAAI,GAAG,WAAW,CAAC,EAAE,QAAQ,QAAQ,CAAC;AAExG,iBAAW,kBAAkB,mBAAmB;AAC9C,cAAM,eAAe,YAAY,0BAA0B,gBAAgB,UAAU;AACrF,cAAM,eAAe,OAAY,OAAO;AAAA,UACtC;AAAA,UACA;AAAA,QACF,CAAC;AACD,YAAWE,QAAO,YAAY,GAAG;AAC/B,iBAAO,aAAa;AAAA,QACtB;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,mCAAmC,MAAM,UAAU;AAAA,IACnF,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,WAAgB;AAAA,IACpB,SACE,MAKA;AAEA,UACE,GAAG,iBAAiB,IAAI,KAAK,GAAG,2BAA2B,KAAK,UAAU,KAC1E,GAAG,aAAa,KAAK,WAAW,IAAI,KACpC,GAAG,OAAO,KAAK,WAAW,IAAI,MAAM,QACpC;AACA,eAAY,QAAQ;AAAA,UAClB;AAAA,UACA,SAAS,KAAK,WAAW;AAAA,UACzB,MAAM,MAAM,KAAK,KAAK,SAAS;AAAA,UAC/B,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAGA,UACE,GAAG,iBAAiB,IAAI,KAAK,GAAG,aAAa,KAAK,UAAU,KAAK,GAAG,OAAO,KAAK,UAAU,MAAM,UAChG,KAAK,UAAU,SAAS,GACxB;AACA,cAAM,CAAC,SAAS,GAAGE,KAAI,IAAI,KAAK;AAChC,eAAY,QAAQ,EAAE,MAAM,SAAS,MAAAA,OAAM,MAAM,OAAO,CAAC;AAAA,MAC3D;AAEA,aAAO,gBAAgB,2BAA2B,QAAW,IAAI;AAAA,IACnE;AAAA,IACA;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,YAAiB;AAAA,IAChB,GAAG,sBAAsB,EAAE,WAC9B,MACA,YACA;AAEA,aAAO,aAAa,MAAM,UAAU;AAEpC,YAAM,oBAAoB,YAAY,oBAAoB,IAAI,EAAE;AAAA,QAAO,CAAC,MACtE,EAAE,QAAQ,GAAG,YAAY,YAAY,EAAE,EAAE,QAAQ,GAAG,YAAY,aAAa,EAAE,oBAC/E,GAAG,oBAAoB,EAAE,gBAAgB,KAAK,GAAG,uBAAuB,EAAE,iBAAiB,IAAI;AAAA,MACjG;AAEA,wBAAkB;AAAA,QAAK,CAAC,GAAG,MACzB,GAAG,WAAW,CAAC,EAAE,QAAQ,aAAa,IAAI,GAAG,WAAW,CAAC,EAAE,QAAQ,aAAa;AAAA,MAClF;AAEA,iBAAW,kBAAkB,mBAAmB;AAC9C,cAAM,6BAAuD,eAAe,iBAAyB;AACrG,cAAMN,UAAS,YAAY,oBAAoB,2BAA2B,UAAU;AACpF,YAAIA,WAAU,GAAG,WAAWA,OAAM,MAAM,eAAe;AACrD,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,6BAA6B,MAAM,UAAU;AAAA,IAC7E,CAAC;AAAA,IACD;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,cAAmB;AAAA,IACvB,SACE,MACA,YACA;AAEA,YAAM,eAAe,KAAK,YAAY,MAAM;AAC5C,UAAI,CAAC,aAAc,QAAO,gBAAgB,yCAAyC,MAAM,UAAU;AACnG,YAAM,WAAW,YAAY,0BAA0B,cAAc,UAAU;AAC/E,UAAI,CAAC,SAAU,QAAO,gBAAgB,yCAAyC,MAAM,UAAU;AAE/F,iBAAW,iBAAiB,YAAY,oBAAoB,UAAU,GAAG,cAAc,IAAI,GAAG;AAE5F,cAAM,YAAY,cAAc,WAAW,CAAC;AAC5C,YAAI,CAAC,UAAW;AAChB,cAAM,gBAAgB,iBAAiB,2BAA2B,eAAe,CAAC;AAClF,YAAI,CAAC,cAAe;AAEpB,YAAI,yBAA8C,CAAC;AACnD,YAAI,SAAS,CAAC,aAAa;AAC3B,eAAO,OAAO,SAAS,GAAG;AACxB,gBAAMO,QAAO,OAAO,MAAM;AAC1B,cAAI,CAACA,MAAM;AACX,gBAAM,iBAAiB,YAAY,oBAAoBA,OAAM,GAAG,cAAc,IAAI;AAClF,mCAAyB,uBAAuB,OAAO,cAAc;AACrE,cAAI,iBAAiB,QAAQA,KAAI,GAAG;AAClC,qBAAS,OAAO,OAAOA,MAAK,KAAK;AAAA,UACnC;AAAA,QACF;AACA,mBAAW,gBAAgB,wBAAwB;AACjD,gBAAM,oBAAoB,aAAa,WAAW,CAAC;AACnD,cAAI,CAAC,mBAAmB;AACtB;AAAA,UACF;AACA,gBAAM,wBAAwB,iBAAiB,2BAA2B,cAAc,CAAC;AACzF,cAAI,CAAC,uBAAuB;AAC1B;AAAA,UACF;AACA,iBAAY,QAAQ;AAAA,YAClB,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAAA,MACF;AACA,aAAO,gBAAgB,iBAAiB,MAAM,UAAU;AAAA,IAC1D;AAAA,IACA;AAAA,IACA,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,qBAA0B;AAAA,IACzB,GAAG,+BAA+B,EAAE,WACvC,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAC3C,kBAAM,aAAa,MAAM;AACzB,gBAAI,GAAG,iBAAiB,UAAU,GAAG;AAEnC,oBAAM,aAAa,WAAW;AAC9B,kBAAI,GAAG,iBAAiB,UAAU,KAAK,WAAW,iBAAiB,WAAW,cAAc,SAAS,GAAG;AACtG,sBAAM,0BAA0B,OAAO;AAAA,kBACrC,uCAAuC,OAAO,EAAE,WAAW,UAAU;AAAA,kBAChE;AAAA,gBACP;AACA,oBAAWH,QAAO,uBAAuB,GAAG;AAC1C,yBAAO;AAAA,oBACL,WAAW,WAAW;AAAA,oBACtB,cAAc,WAAW,cAAc,CAAC;AAAA,kBAC1C;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,sCAAsC,QAAW,UAAU;AAAA,IAC3F,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,2BAAgC;AAAA,IAC/B,GAAG,qCAAqC,EAAE,WAC7C,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAE3C,kBAAM,aAAa,MAAM;AACzB,gBAAI,GAAG,iBAAiB,UAAU,KAAK,WAAW,UAAU,SAAS,GAAG;AAEtE,oBAAM,yBAAyB,WAAW;AAC1C,kBACE,GAAG,iBAAiB,sBAAsB,KAAK,uBAAuB,iBACtE,uBAAuB,cAAc,SAAS,GAC9C;AACA,sBAAM,eAAe,uBAAuB,cAAc,CAAC;AAC3D,sBAAM,0BAA0B,OAAO;AAAA,kBACrC,uCAAuC,aAAa,EAAE,uBAAuB,UAAU;AAAA,kBAClF;AAAA,gBACP;AACA,oBAAWA,QAAO,uBAAuB,GAAG;AAC1C,yBAAO;AAAA,oBACL,WAAW,WAAW;AAAA,oBACtB;AAAA,oBACA,kBAAkB,uBAAuB,UAAU,SAAS,KACxD,GAAG,gBAAgB,uBAAuB,UAAU,CAAC,CAAC,IACtD,uBAAuB,UAAU,CAAC,IAClC;AAAA,oBACJ,kBAAkB,WAAW,UAAU,SAAS,KAC5C,GAAG,gBAAgB,WAAW,UAAU,CAAC,CAAC,IAC1C,WAAW,UAAU,CAAC,IACtB;AAAA,kBACN;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,4CAA4C,QAAW,UAAU;AAAA,IACjG,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,2BAAgC;AAAA,IAC/B,GAAG,qCAAqC,EAAE,WAC7C,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAE3C,kBAAM,aAAa,MAAM;AACzB,gBAAI,GAAG,iBAAiB,UAAU,GAAG;AAEnC,oBAAM,yBAAyB,WAAW;AAC1C,kBACE,GAAG,iBAAiB,sBAAsB,KAAK,uBAAuB,iBACtE,uBAAuB,cAAc,SAAS,GAC9C;AACA,sBAAM,eAAe,uBAAuB,cAAc,CAAC;AAC3D,sBAAM,0BAA0B,OAAO;AAAA,kBACrC,uCAAuC,aAAa,EAAE,uBAAuB,UAAU;AAAA,kBAClF;AAAA,gBACP;AACA,oBAAWA,QAAO,uBAAuB,GAAG;AAC1C,yBAAO;AAAA,oBACL,WAAW,WAAW;AAAA,oBACtB;AAAA,oBACA,kBAAkB,uBAAuB,UAAU,SAAS,KACxD,GAAG,gBAAgB,uBAAuB,UAAU,CAAC,CAAC,IACtD,uBAAuB,UAAU,CAAC,IAClC;AAAA,oBACJ,kBAAkB,WAAW,UAAU,SAAS,KAC5C,GAAG,gBAAgB,WAAW,UAAU,CAAC,CAAC,IAC1C,WAAW,UAAU,CAAC,IACtB;AAAA,kBACN;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,4CAA4C,QAAW,UAAU;AAAA,IACjG,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,6BAAkC;AAAA,IACjC,GAAG,uCAAuC,EAAE,WAC/C,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAE3C,kBAAM,aAAa,MAAM;AACzB,gBAAI,GAAG,iBAAiB,UAAU,GAAG;AAEnC,oBAAM,2BAA2B,WAAW;AAC5C,kBACE,GAAG,iBAAiB,wBAAwB,KAC5C,yBAAyB,iBACzB,yBAAyB,cAAc,SAAS,GAChD;AACA,sBAAM,eAAe,yBAAyB,cAAc,CAAC;AAC7D,sBAAM,0BAA0B,OAAO;AAAA,kBACrC,uCAAuC,eAAe,EAAE,yBAAyB,UAAU;AAAA,kBACtF;AAAA,gBACP;AACA,oBAAWA,QAAO,uBAAuB,GAAG;AAC1C,yBAAO;AAAA,oBACL,WAAW,WAAW;AAAA,oBACtB;AAAA,oBACA,kBAAkB,WAAW,UAAU,SAAS,KAAK,GAAG,gBAAgB,WAAW,UAAU,CAAC,CAAC,IAC3F,WAAW,UAAU,CAAC,IACtB;AAAA,oBACJ,kBAAkB,yBAAyB,UAAU,SAAS,KAC1D,GAAG,gBAAgB,yBAAyB,UAAU,CAAC,CAAC,IACxD,yBAAyB,UAAU,CAAC,IACpC;AAAA,kBACN;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,8CAA8C,QAAW,UAAU;AAAA,IACnG,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,yBAA8B;AAAA,IAC7B,GAAG,mCAAmC,EAAE,WAC3C,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAE3C,kBAAM,aAAa,MAAM;AACzB,gBAAI,GAAG,iBAAiB,UAAU,GAAG;AAEnC,oBAAM,sBAAsB;AAE5B,oBAAM,iBAAiB,oBAAoB;AAC3C,kBACE,GAAG,2BAA2B,cAAc,KAAK,GAAG,aAAa,eAAe,IAAI,KACpF,GAAG,OAAO,eAAe,IAAI,MAAM,eACnC;AACA,sBAAM,mBAAmB,OAAO;AAAA,kBAC9B,mBAAmB,eAAe,UAAU;AAAA,kBACvC;AAAA,gBACP;AACA,oBAAWA,QAAO,gBAAgB,GAAG;AAGnC,yBAAO;AAAA,oBACL,WAAW,WAAW;AAAA,oBACtB,kBAAkB,oBAAoB,UAAU,SAAS,KACrD,GAAG,gBAAgB,oBAAoB,UAAU,CAAC,CAAC,IACnD,oBAAoB,UAAU,CAAC,IAC/B;AAAA,oBACJ,MAAM,iBAAiB;AAAA,kBACzB;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,0CAA0C,QAAW,UAAU;AAAA,IAC/F,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,yBAA8B;AAAA,IAC7B,GAAG,mCAAmC,EAAE,WAC3C,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAE3C,kBAAM,aAAa,MAAM;AACzB,gBAAI,GAAG,iBAAiB,UAAU,GAAG;AAEnC,oBAAM,sBAAsB;AAE5B,oBAAM,iBAAiB,oBAAoB;AAC3C,kBACE,GAAG,2BAA2B,cAAc,KAAK,GAAG,aAAa,eAAe,IAAI,KACpF,GAAG,OAAO,eAAe,IAAI,MAAM,eACnC;AACA,sBAAM,mBAAmB,OAAO;AAAA,kBAC9B,mBAAmB,eAAe,UAAU;AAAA,kBACvC;AAAA,gBACP;AACA,oBAAWA,QAAO,gBAAgB,GAAG;AAGnC,yBAAO;AAAA,oBACL,WAAW,WAAW;AAAA,oBACtB,kBAAkB,oBAAoB,UAAU,SAAS,KACrD,GAAG,gBAAgB,oBAAoB,UAAU,CAAC,CAAC,IACnD,oBAAoB,UAAU,CAAC,IAC/B;AAAA,oBACJ,MAAM,iBAAiB;AAAA,kBACzB;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,0CAA0C,QAAW,UAAU;AAAA,IAC/F,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,oBAAyB;AAAA,IACxB,GAAG,8BAA8B,EAAE,WACtC,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAC3C,kBAAM,YAAY,MAAM;AACxB,gBAAI,GAAG,iBAAiB,SAAS,GAAG;AAClC,oBAAM,iBAAiB,UAAU;AACjC,kBACE,GAAG,iBAAiB,cAAc,KAClC,UAAU,iBAAiB,UAAU,cAAc,SAAS,GAC5D;AACA,sBAAM,uBAAuB,eAAe;AAC5C,sBAAM,eAAe,UAAU,cAAc,CAAC;AAC9C,oBACE,GAAG,2BAA2B,oBAAoB,KAClD,GAAG,aAAa,qBAAqB,IAAI,KAAK,GAAG,OAAO,qBAAqB,IAAI,MAAM,OACvF;AACA,wBAAM,sBAAsB,OAAO;AAAA,oBACjC,sBAAsB,qBAAqB,UAAU;AAAA,oBAChD;AAAA,kBACP;AACA,sBAAWA,QAAO,mBAAmB,GAAG;AACtC,0BAAM,WAAW,YAAY,oBAAoB,WAAW,IAAI;AAChE,wBAAI,CAAC,SAAU,QAAO,OAAO,gBAAgB,uBAAuB,QAAW,UAAU;AACzF,0BAAM,OAAO,YAAY,gBAAgB,QAAQ;AACjD,0BAAM,UAAU,OAAO,WAAW,MAAM,UAAU;AAClD,2BAAO;AAAA,sBACL,WAAW,WAAW;AAAA,sBACtB;AAAA,sBACA,kBAAkB,GAAG,gBAAgB,eAAe,UAAU,CAAC,CAAC,IAC5D,eAAe,UAAU,CAAC,IAC1B;AAAA,sBACJ,MAAM,eAAe;AAAA,sBACrB,YAAY,QAAQ;AAAA,sBACpB,KAAK,oBAAoB;AAAA,oBAC3B;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,qCAAqC,QAAW,UAAU;AAAA,IAC1F,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,mBAAwB;AAAA,IACvB,GAAG,6BAA6B,EAAE,WACrC,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,YAAM,WAAW,YAAY,oBAAoB,WAAW,IAAI;AAChE,UAAI,CAAC,SAAU,QAAO,OAAO,gBAAgB,uBAAuB,QAAW,UAAU;AACzF,YAAM,OAAO,YAAY,gBAAgB,QAAQ;AACjD,YAAM,UAAU,OAAO,WAAW,MAAM,UAAU;AAClD,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAC3C,kBAAM,YAAY,MAAM;AACxB,gBAAI,GAAG,iBAAiB,SAAS,GAAG;AAClC,oBAAM,gBAAgB,UAAU;AAChC,kBACE,GAAG,iBAAiB,aAAa,KACjC,UAAU,iBAAiB,UAAU,cAAc,SAAS,GAC5D;AACA,sBAAM,sBAAsB,cAAc;AAC1C,sBAAM,eAAe,UAAU,cAAc,CAAC;AAC9C,sBAAM,cAAc,OAAO;AAAA,kBACzB,iCAAiC,KAAK,EAAE,mBAAmB;AAAA,kBACtD;AAAA,gBACP;AACA,oBAAWA,QAAO,WAAW,GAAG;AAC9B,yBAAO;AAAA,oBACL,WAAW,WAAW;AAAA,oBACtB;AAAA,oBACA,kBAAkB,GAAG,gBAAgB,cAAc,UAAU,CAAC,CAAC,IAC3D,cAAc,UAAU,CAAC,IACzB;AAAA,oBACJ,MAAM,cAAc;AAAA,oBACpB,YAAY,QAAQ;AAAA,oBACpB,SAAS,QAAQ;AAAA,kBACnB;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,OAAO,gBAAgB,oCAAoC,QAAW,UAAU;AAAA,IACzF,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,QAAM,uBAA4B;AAAA,IAC3B,GAAG,iCAAiC,EAAE,WACzC,YACA;AACA,UAAI,CAAC,WAAW,MAAM;AACpB,eAAO,OAAO,gBAAgB,qBAAqB,QAAW,UAAU;AAAA,MAC1E;AACA,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,iBAAiB;AACpB,eAAO,OAAO,gBAAgB,iCAAiC,QAAW,UAAU;AAAA,MACtF;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,mBAAW,SAAS,eAAe,OAAO;AACxC,cAAI,GAAG,8BAA8B,KAAK,GAAG;AAC3C,kBAAM,YAAY,MAAM;AACxB,gBAAI,GAAG,iBAAiB,SAAS,GAAG;AAClC,oBAAM,oBAAoB,UAAU;AACpC,kBACE,GAAG,iBAAiB,iBAAiB,KACrC,kBAAkB,iBAAiB,kBAAkB,cAAc,SAAS,GAC5E;AACA,sBAAM,0BAA0B,kBAAkB;AAClD,sBAAM,eAAe,kBAAkB,cAAc,CAAC;AACtD,sBAAM,kBAAkB,OAAO;AAAA,kBAC7B,iCAAiC,SAAS,EAAE,uBAAuB;AAAA,kBAC9D;AAAA,gBACP;AACA,oBAAWA,QAAO,eAAe,GAAG;AAClC,wBAAM,WAAW,YAAY,oBAAoB,WAAW,IAAI;AAChE,sBAAI,CAAC,SAAU,QAAO,OAAO,gBAAgB,uBAAuB,QAAW,UAAU;AACzF,wBAAM,OAAO,YAAY,gBAAgB,QAAQ;AACjD,wBAAM,mBAAmB,OAAO;AAAA,oBAC9B,WAAW,MAAM,UAAU;AAAA,oBACtB;AAAA,kBACP;AACA,sBAAWA,QAAO,gBAAgB,GAAG;AAEnC,wBAAII,aAAiC;AACrC,wBAAI,eAAwD;AAC5D,wBAAI,UAAU,UAAU,UAAU,GAAG;AACnC,4BAAMF,QAAO,UAAU,UAAU,CAAC;AAClC,0BAAI,GAAG,0BAA0BA,KAAI,GAAG;AACtC,mCAAW,YAAYA,MAAK,YAAY;AACtC,8BACE,GAAG,qBAAqB,QAAQ,KAAK,SAAS,QAAQ,GAAG,aAAa,SAAS,IAAI,KACnF,GAAG,OAAO,SAAS,IAAI,MAAM,eAAe,SAAS,eACrD,SAAS,YAAY,SAAS,GAAG,WAAW,aAC5C;AACA,4BAAAE,aAAY;AAAA,0BACd;AACA,8BACE,GAAG,qBAAqB,QAAQ,KAAK,SAAS,QAAQ,GAAG,aAAa,SAAS,IAAI,KACnF,GAAG,OAAO,SAAS,IAAI,MAAM,kBAAkB,SAAS,eACxD,GAAG,yBAAyB,SAAS,WAAW,GAChD;AACA,2CAAe,SAAS,YAAY;AAAA,0BACtC;AAAA,wBACF;AAAA,sBACF;AAAA,oBACF;AACA,2BAAQ;AAAA,sBACN,GAAG,iBAAiB;AAAA,sBACpB,WAAW,WAAW;AAAA,sBACtB;AAAA,sBACA,MAAM,UAAU;AAAA,sBAChB,kBAAkB,GAAG,gBAAgB,UAAU,UAAU,CAAC,CAAC,IACvD,UAAU,UAAU,CAAC,IACrB;AAAA,sBACJ,SAAS,UAAU,UAAU,CAAC;AAAA,sBAC9B,WAAAA;AAAA,sBACA;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO,OAAO,gBAAgB,wCAAwC,QAAW,UAAU;AAAA,IAC7F,CAAC;AAAA,IACD;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,sBAAAH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACtoDO,IAAM,WAAgB,GAAG,iCAAiC,EAAE,WACjE,YACAI,UACA,WACA,YACA,iBACA;AACA,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,QAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,QAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,QAAM,iBAAiB,WAAW,QAAQ,SAAS,IAAI,WAAW,QAAQ,CAAC,EAAE,MAAM,WAAW,MAAM;AAEpG,QAAM,mBAAmB,QAAQ;AAAA,IAC/B;AAAA,IACA;AAAA,IACA;AAAA,EACF,KAAK;AAEL,QAAM,yBAAyB,CAC7BC,YACA,cACA,MACA,aACG;AACH,UAAM,YAAY,GAAG,QAAQ;AAAA,MAC3B,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,QAC5C;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,QACE,GAAG,QAAQ,iBAAiB,GAAG,OAAOA,UAAS,CAAC;AAAA,QAChD,GAAG,QAAQ;AAAA,UACT;AAAA,UACA;AAAA,UACA,CAAC,GAAG,QAAQ;AAAA,YACV;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,WAAW,GAAG,QAAQ,wBAAwB,KAAK,IAAI;AAAA,UACzD,CAAC;AAAA,UACD;AAAA,UACA;AAAA,UACA,GAAG,QAAQ;AAAA,YACT,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ,iBAAiB,GAAG;AAAA,cAC/B;AAAA,YACF;AAAA,YACA;AAAA,YACA;AAAA,cACE,GAAG,QAAQ,oBAAoB,GAAG,QAAQ,iBAAiB,MAAM,CAAC;AAAA,YACpE;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,WAAO,GAAG,QAAQ;AAAA,MAChB;AAAA,QACE,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa;AAAA,QACrD,GAAG,QAAQ,eAAe,GAAG,WAAW,eAAe;AAAA,MACzD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,GAAG,QAAQ;AAAA,QACT;AAAA,QACA;AAAA,QACA,CAAC,GAAG,QAAQ;AAAA,UACV;AAAA,UACA,GAAG,QAAQ,YAAY,GAAG,WAAW,cAAc;AAAA,UACnD;AAAA,UACA;AAAA,UACA,WAAW,GAAG,QAAQ,oBAAoB,GAAG,QAAQ,wBAAwB,KAAK,CAAC,IAAI;AAAA,QACzF,CAAC;AAAA,QACD;AAAA,QACA;AAAA,QACA,WAAW,GAAG,QAAQ,mBAAmB,WAAW,GAAG,QAAQ,wBAAwB,KAAK,CAAC,IAAI;AAAA,MACnG;AAAA,IACF;AAAA,EACF;AAEA,QAAM,qBAAqB,CAAC,MAAeC,aAAiCD,eAC1E;AAAA,IACE,WAAW,WAAW,MAAMC,WAAU;AAAA,IACjCC,SAAQ,CAAC,mBAAmB;AAE/B,YAAM,cAAe,eAAe,EAAE,QAAQ,GAAG,UAAU,QACzD,GAAG,QAAQ,wBAAwB,GAAG,OAAOF,UAAS,CAAC,IACvD,GAAG,QAAQ;AAAA,QACT;AAAA,UACE,GAAG,QAAQ,wBAAwB,GAAG,OAAOA,UAAS,CAAC;AAAA,UACvD,YAAY,eAAe,eAAe,GAAGC,aAAY,GAAG,iBAAiB,YAAY;AAAA,QAC3F;AAAA,MACF;AAEF,YAAM,cAAc,YAAY;AAAA,QAC9B,eAAe;AAAA,QACfA;AAAA,QACA,GAAG,iBAAiB;AAAA,MACtB;AACA,UAAI,CAAC,YAAa,QAAY,KAAK,+BAA+B;AAElE,YAAM,cAAc,YAAY;AAAA,QAC9B,eAAe;AAAA,QACfA;AAAA,QACA,GAAG,iBAAiB;AAAA,MACtB;AACA,UAAI,CAAC,YAAa,QAAY,KAAK,+BAA+B;AAElE,YAAM,WAAW,GAAG,QAAQ;AAAA,QAC1B,GAAG,QAAQ;AAAA,UACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,UAC5C,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,QACtC;AAAA,QACA,CAAC,aAAa,aAAa,WAAW;AAAA,MACxC;AACA,aAAY,QAAQ,QAAQ;AAAA,IAC9B,CAAC;AAAA,IACIE;AAAA,MAAO,MACV;AAAA,QACE,WAAW,YAAY,MAAMF,WAAU;AAAA,QAClCC,SAAQ,CAAC,EAAE,MAAAE,MAAK,MAAM;AACzB,gBAAM,cAAc,YAAY;AAAA,YAC9BA;AAAA,YACAH;AAAA,YACA,GAAG,iBAAiB;AAAA,UACtB;AACA,cAAI,CAAC,YAAa,QAAY,KAAK,+BAA+B;AAClE,iBAAY,QAAQ,GAAG,QAAQ;AAAA,YAC7B,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,cAC5C,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,YACtC;AAAA,YACA;AAAA,cACE;AAAA,cACA,GAAG,QAAQ;AAAA,gBACT,GAAG,QAAQ;AAAA,kBACT,GAAG,QAAQ,iBAAiB,OAAO;AAAA,kBACnC,GAAG,QAAQ,iBAAiB,kBAAkB;AAAA,gBAChD;AAAA,cACF;AAAA,cACA,GAAG,QAAQ,wBAAwB,GAAG,OAAOD,UAAS,CAAC;AAAA,YACzD;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACKG,QAAO,MAAM;AAEhB,YAAM,cAAc,YAAY,eAAe,MAAMF,aAAY,GAAG,iBAAiB,YAAY;AACjG,UAAI,CAAC,YAAa,QAAY,KAAK,+BAA+B;AAClE,YAAM,WAAW,GAAG,QAAQ;AAAA,QAC1B,GAAG,QAAQ;AAAA,UACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,UAC5C,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,QACtC;AAAA,QACA;AAAA,UACE;AAAA,UACA,GAAG,QAAQ,wBAAwB,OAAO;AAAA,UAC1C,GAAG,QAAQ,wBAAwB,GAAG,OAAOD,UAAS,CAAC;AAAA,QACzD;AAAA,MACF;AAEA,aAAY,QAAQ,QAAQ;AAAA,IAC9B,CAAC;AAAA,EACH;AAEF,QAAM,iBAAiB,CAAC,WAAyBC,aAAiCD,eAC3E,IAAI,aAAY;AAEnB,UAAM,uBAAuB,YAAY;AAAA,MACvC;AAAA,MACA,GAAG,WAAW;AAAA,MACdC;AAAA,MACA,GAAG,iBAAiB;AAAA,IACtB;AAEA,QAAI,CAAC,qBAAsB,QAAO,OAAY,KAAK,4BAA4B;AAG/E,UAAM,aAAa,OAAO;AAAA,MACxB,YAAY,yBAAyB,SAAS;AAAA,MAC9CA;AAAA,MACAD;AAAA,IACF;AAGA,WAAO,GAAG,QAAQ;AAAA,MAChB,qBAAqB;AAAA,MACrB,qBAAqB;AAAA,MACrB;AAAA,IACF;AAAA,EACF,CAAC;AAEH,aAAW,EAAE,UAAU,aAAa,KAAK,iBAAiB;AACxD,UAAM,iBAA6C,CAAC;AACpD,QAAI,sBAA0D;AAC9D,eAAW,aAAa,YAAY,oBAAoB,cAAc,GAAG,cAAc,IAAI,GAAG;AAC5F,aAAO;AAAA,QACL,eAAe,WAAW,YAAY,SAAS;AAAA,QAC1CK,KAAI,CAAC,QAAQ;AAChB,yBAAe,KAAK,GAAG;AAAA,QACzB,CAAC;AAAA,QACI;AAAA,MACP;AAAA,IACF;AAGA,UAAM,gBAAgB,GAAG,QAAQ,2BAA2B,cAAc;AAC1E,UAAM,OAAO,QAAQ,iBAAiB,aAAa;AACnD,0BAAsB,uBAAuB,WAAW,GAAG,WAAW,QAAQ,GAAG,MAAM,eAAe,SAAS,CAAC;AAGhH,UAAM,cAAc,WAAW,QAAQ,OAAO,GAAG,qBAAqB,EAAE,KAAK,CAAC,MAAM;AAClF,YAAMC,UAAS,YAAY,oBAAoB,EAAE,IAAI;AACrD,aAAOA,WAAU,GAAG,WAAWA,OAAM,MAAM,GAAG,WAAW,QAAQ;AAAA,IACnE,CAAC;AACD,QAAI,aAAa;AACf,YAAM,QAAQ,GAAG,kBAAkB,aAAa,UAAU;AAC1D,oBAAc,YAAY,YAAY;AAAA,QACpC,KAAK;AAAA,QACL,KAAK,YAAY;AAAA,MACnB,CAAC;AACD,oBAAc,aAAa,YAAY,OAAO,mBAAmB;AAAA,IACnE,OAAO;AACL,oBAAc,aAAa,YAAY,gBAAgB,qBAAqB,EAAE,QAAQ,KAAK,CAAC;AAAA,IAC9F;AAAA,EACF;AACF,CAAC;AAEM,IAAMC,SAAa,GAAG,8BAA8B,EAAE,WAAU,MAAe;AACpF,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,QAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,QAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAG9E,MAAI,CAAC,GAAG,mBAAmB,IAAI,EAAG,QAAO,OAAY,KAAK,yBAAyB;AAEnF,QAAM,EAAE,SAAS,WAAAC,YAAW,UAAU,IAAI,OAAO;AAAA,IAC/C,WAAW,qBAAqB,IAAI;AAAA,IAC/BL,QAAO,MAAWE,KAAI,WAAW,iBAAiB,IAAI,GAAG,CAAC,OAAO,EAAE,WAAW,MAAM,GAAG,EAAE,EAAE,CAAC;AAAA,IAC5FF,QAAO,MAAW,KAAK,2CAA2C,CAAC;AAAA,EAC1E;AACA,MAAIK,eAAc,KAAM,QAAO,OAAY,KAAK,sDAAsD;AAEtG,QAAM,kBAAyE,CAAC;AAEhF,QAAM,uBAAuB,iBAAiB,mBAAmB,OAAO,EAAE;AAAA,IAAO,CAAC,MAChF,EAAG,EAAE,QAAQ,GAAG,UAAU,UAAY,EAAE,QAAQ,GAAG,UAAU,UAAY,EAAE,QAAQ,GAAG,UAAU,WAC7F,EAAE,QAAQ,GAAG,UAAU;AAAA,EAC5B;AAEA,MAAI,qBAAqB,WAAW,EAAG,QAAO,OAAY,KAAK,kCAAkC;AAEjG,aAAW,gBAAgB,sBAAsB;AAC/C,eAAW,YAAY,YAAY,oBAAoB,YAAY,GAAG;AACpE,YAAM,eAAe,YAAY,0BAA0B,UAAU,IAAI;AACzE,YAAM,iBAAiB,YAAY,oBAAoB,cAAc,GAAG,cAAc,IAAI;AAC1F,UAAI,eAAe,SAAS,GAAG;AAC7B,cAAM,qBAAqB,eAAe,OAAO,CAAC,MAAM,EAAE,kBAAkB,EAAE,eAAe,SAAS,CAAC;AACvG,YAAI,eAAe,SAAS,KAAK,mBAAmB,SAAS,EAAG,iBAAgB,KAAK,EAAE,UAAU,aAAa,CAAC;AAAA,MACjH;AAAA,IACF;AAAA,EACF;AAEA,QAAMC,QAAO,gBAAgB,IAAI,CAAC,EAAE,UAAU,aAAa,MAAM;AAC/D,WAAO,GAAG,WAAW,QAAQ,IAAI,OAAO,YAAY,aAAa,YAAY;AAAA,EAC/E,CAAC,EAAE,OAAO,CAAC,GAAG,OAAO,SAAS,CAAC,CAAC,EAAE,KAAK,IAAI;AAE3C,SAAO,EAAE,SAAS,WAAW,YAAY,MAAM,MAAU,OAAOA,KAAI,GAAG,gBAAgB;AACzF,CAAC;AAEM,IAAM,yBAA6B,eAAe;AAAA,EACvD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,8BAA8B,EAAE,WAAU,YAAY,WAAW;AAC9E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,YAAY,CAAC,SACjB;AAAA,MACEF,OAAM,IAAI;AAAA,MACLF,KAAI,CAAC,EAAE,SAAS,YAAY,WAAW,gBAAgB,OAAO;AAAA,QACjE,MAAM;AAAA,QACN,aAAa;AAAA,QACb,OAAO;AAAA,UACL,SAAS,YAAY,SAAS,WAAW,YAAY,eAAe;AAAA,UAC/D,eAA+B,iBAAiB,OAAO;AAAA,UACvD,eAA0B,YAAY,UAAU;AAAA,UAChD,eAA8B,gBAAgB,WAAW;AAAA,UACzD,eAA6B,eAAe,EAAE;AAAA,QACrD;AAAA,MACF,EAAE;AAAA,IACJ;AAEF,UAAM,cAAc,QAAQ,wBAAwB,YAAY,SAAS;AAEzE,WAAO,OAAO;AAAA,MACP,eAAe,YAAY,IAAI,SAAS,CAAC;AAAA,MACzCF,QAAO,MAAW,KAAK,IAAQ,2BAA2B,CAAC,CAAC;AAAA,IACnE;AAAA,EACF,CAAC;AACH,CAAC;;;ACrTM,IAAM,YAAgB,cAAc;AAAA,EACzC,MAAM;AAAA,EACN,OAAY,GAAG,iBAAiB,EAAE,WAAU,YAAY,WAAW;AACjE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,UAAM,sBAAsB,QAAQ,qCAAqC,YAAY,UAAU,GAAG;AAClG,QAAI,CAAC,oBAAqB,QAAO,OAAY,KAAK,IAAQ,0BAA0B,2BAA2B,CAAC;AAEhH,WAAO,OAAO;AAAA,MACHO,OAAM,oBAAoB,IAAI;AAAA,MAClCC;AAAA,QAAI,CAAC,OACP;AAAA,UACC,MAAM,EAAE;AAAA,UACR,aAAa;AAAA,UACb,OAAO;AAAA,YACI,SAAS,YAAY,EAAE,SAAS,EAAE,WAAW,EAAE,YAAY,EAAE,eAAe;AAAA,YAChF,eAA6B,eAAe,EAAE;AAAA,YAC9C,eAA+B,iBAAiB,OAAO;AAAA,YACvD,eAA8B,gBAAgB,WAAW;AAAA,YACzD,eAA0B,YAAY,UAAU;AAAA,YAChD,eAAgC,kBAAkB,gBAAgB;AAAA,UACzE;AAAA,QACF;AAAA,MACF;AAAA,MACKC,QAAO,CAAC,UAAe,KAAK,IAAQ,0BAA0B,KAAK,CAAC,CAAC;AAAA,IAC5E;AAAA,EACF,CAAC;AACH,CAAC;;;ACvCM,IAAM,WAAW,CAAC,SAAS;;;ACM3B,IAAM,wBAA4B,iBAAiB;AAAA,EACxD,MAAM;AAAA,EACN,OAAY,GAAG,uBAAuB,EAAE,WAAU,YAAY,UAAU;AACtE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAG1D,UAAM,aAAa,WAAW;AAG9B,UAAMC,SAAS,iCAAkC,KAAK,WAAW,UAAU,GAAG,QAAQ,CAAC;AACvF,QAAIA,UAASA,OAAM,SAAS;AAC1B,YAAM,YAAYA,OAAM,QAAQ,CAAC,EAAE,CAAC;AACpC,YAAM,kBAA+B;AAAA,QACnC,OAAO;AAAA,QACP,QAAQ,KAAK,IAAI,GAAG,WAAW,SAAS;AAAA,MAC1C;AAEA,YAAM,cAAoB,KAAK,OAAO,OAAO,QAAQ,EAAE,IAAI,CAAC,YAAY,QAAQ,IAAI,GAASC,OAAM,EAChG,KAAK,GAAG;AACX,YAAM,gBAAgB,SAAS,cAAc;AAE7C,aAAO,CAAC;AAAA,QACN,MAAM;AAAA,QACN,MAAM,GAAG,kBAAkB;AAAA,QAC3B,YAAY,sBAAsB;AAAA,QAClC,WAAW;AAAA,QACX;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,CAAC;AAAA,EACV,CAAC;AACH,CAAC;;;AClCM,IAAM,oBAAwB,iBAAiB;AAAA,EACpD,MAAM;AAAA,EACN,OAAY,GAAG,mBAAmB,EAAE,WAAU,YAAY,UAAU;AAClE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,aAAa,QAAQ,mCAAmC,YAAY,QAAQ;AAClF,QAAI,CAAC,WAAY,QAAO,CAAC;AACzB,UAAM,EAAE,gBAAgB,WAAW,gBAAgB,IAAI;AAGvD,UAAM,uBAAuB,QAAQ;AAAA,MACnC;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAGL,QAAI,yBAAyB,GAAG,OAAO,cAAc,EAAG,QAAO,CAAC;AAChE,UAAM,OAAO,GAAG,OAAO,SAAS;AAGhC,UAAM,eAAe,OAAkB,aAAa,YAAY,MAAM,OAAO,MAAM;AAEnF,WAAO,CAAC;AAAA,MACN,MAAM,gBAAgB,IAAI;AAAA,MAC1B,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,oBAAoB,iBAAiB,WAAW,OAAO,MAAM;AAAA,MAC5E;AAAA,MACA,WAAW;AAAA,IACb,GAAG;AAAA,MACD,MAAM,gBAAgB,IAAI;AAAA,MAC1B,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,oBAAoB,iBAAiB,IAAI,OAAO,MAAM;AAAA,MACrE;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAAA,EACH,CAAC;AACH,CAAC;;;ACnCM,IAAM,wBAA4B,iBAAiB;AAAA,EACxD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,6BAA6B,EAAE,WAAU,YAAY,QAAQ;AAC1E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAGvC,UAAI,GAAG,iBAAiB,IAAI,GAAG;AAE7B,cAAM,iBAAiB,CAAC,YAAY,SAAS,WAAW,aAAa,YAAY,WAAW;AAC5F,cAAM,cAAc,OAAO;AAAA,UACpB;AAAA,YACH,eAAe,IAAI,CAAC,YAAY,WAAW,iCAAiC,OAAO,EAAE,KAAK,UAAU,CAAC;AAAA,UACvG;AAAA,UACK;AAAA,QACP;AAEA,YAAWC,QAAO,WAAW,GAAG;AAE9B,gBAAM,SAAS,KAAK;AACpB,cAAI,UAAU,GAAG,iBAAiB,MAAM,GAAG;AACzC,kBAAM,iBAAiB,OAAO;AAAA,cAC5B,WAAW,SAAS,MAAM;AAAA,cACrB;AAAA,YACP;AAEA,gBAAWA,QAAO,cAAc,GAAG;AACjC,oBAAM,EAAE,MAAAC,OAAM,MAAM,cAAc,QAAQ,IAAI,eAAe;AAG7D,oBAAM,WAAWA,MAAK,UAAU,CAAC,QAAQ,QAAQ,IAAI;AAErD,kBAAI,aAAa,IAAI;AACnB,oBAAI;AAGJ,oBAAI,aAAa,GAAG;AAElB,sCAAoB,YAAY,kBAAkB,OAAO;AAAA,gBAC3D,OAAO;AAEL,wBAAM,YAAY,YAAY,qBAAqB,YAAY;AAC/D,sBAAI,WAAW;AACb,0BAAM,gBAAgB,YAAY,qCAAqC,SAAS;AAChF,wBAAI,iBAAiB,cAAc,SAAS,UAAU;AACpD,0CAAoB,cAAc,QAAQ;AAAA,oBAC5C;AAAA,kBACF;AAAA,gBACF;AAGA,oBAAI,mBAAmB;AACrB,wBAAM,aAAa,OAAO;AAAA,oBACxB,WAAW,WAAW,mBAAmB,IAAI;AAAA,oBACxC;AAAA,kBACP;AAGA,sBAAWD,QAAO,UAAU,GAAG;AAC7B,0BAAM,EAAE,EAAE,IAAI,WAAW;AAGzB,wBAAI,EAAE,QAAQ,GAAG,UAAU,OAAO;AAChC,6BAAO;AAAA,wBACL,UAAU,KAAK;AAAA,wBACf,aACE;AAAA,wBACF,OAAO,CAAC;AAAA,sBACV,CAAC;AAAA,oBACH;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACjFD,IAAME,UAAwBC,uBAAOC,IAAI,cAAc;AA2EvD,SAASC,KACPC,KACAC,QACAC,MACAC,SACAC,KAAW;AAEX,WAASC,IAAIJ,QAAQI,IAAIC,KAAKC,IAAIP,IAAIQ,QAAQP,SAASG,GAAG,GAAGC,KAAK;AAChEH,SAAKC,UAAUE,IAAIJ,MAAM,IAAID,IAAIK,CAAC;EACpC;AACA,SAAOH;AACT;AAEA,IAAMO,aAAmC,CAAA;AAQlC,IAAMC,iBAAqBC,kBACpBC,KAAK,CAACC,MAAMC,SACtBD,KAAKL,WAAWM,KAAKN,UAAUO,gBAAgBF,IAAI,EAAEG,MAAM,CAACC,OAAOZ,MAAMM,aAAaM,OAAOC,WAAUJ,MAAMT,CAAC,CAAC,CAAC,CAAC;AAGrH,IAAMc,gBAAeT,+BAAqBU,MAAM;AAEhD,IAAMC,aAAsF;EAC1F,CAACzB,OAAM,GAAG;IACR0B,IAAKC,OAAaA;;EAEpBC,WAAQ;AACN,WAAOC,OAAO,KAAKC,OAAM,CAAE;EAC7B;EACAA,SAAM;AACJ,WAAO;MACLC,KAAK;MACLC,QAAQb,gBAAgB,IAAI,EAAEc,IAAIH,MAAM;;EAE5C;EACA,CAACI,iBAAiB,IAAC;AACjB,WAAO,KAAKJ,OAAM;EACpB;EACA,CAAOK,OAAM,EAAqBjB,MAAa;AAC7C,WAAOkB,QAAQlB,IAAI,KAAKK,cAAa,MAAML,IAAI;EACjD;EACA,CAAMiB,MAAM,IAAC;AACX,WAAYE,OAAO,MAAWC,OAAMnB,gBAAgB,IAAI,CAAC,CAAC;EAC5D;EACA,CAAClB,OAAOsC,QAAQ,IAAC;AACf,YAAQ,KAAKC,QAAQC,MAAI;MACvB,KAAK,UAAU;AACb,eAAO,KAAKD,QAAQF,MAAMrC,OAAOsC,QAAQ,EAAC;MAC5C;MACA,KAAK,UAAU;AACb,eAAO1B,WAAWZ,OAAOsC,QAAQ,EAAC;MACpC;MACA,SAAS;AACP,eAAOpB,gBAAgB,IAAI,EAAElB,OAAOsC,QAAQ,EAAC;MAC/C;IACF;EACF;EACAG,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;;AAGF,IAAMC,YAAgBL,aAAiC;AACrD,QAAMM,QAAQC,OAAOC,OAAOvB,UAAU;AACtCqB,QAAMN,UAAUA;AAChB,UAAQA,QAAQC,MAAI;IAClB,KAAK,UAAU;AACbK,YAAMlC,SAAS;AACfkC,YAAMG,QAAQ;AACdH,YAAMI,OAAOJ;AACbA,YAAMK,QAAQL;AACd;IACF;IACA,KAAK,WAAW;AACdA,YAAMlC,SAAS4B,QAAQU,KAAKtC,SAAS4B,QAAQW,MAAMvC;AACnDkC,YAAMG,QAAQ,IAAIvC,KAAK0C,IAAIZ,QAAQU,KAAKD,OAAOT,QAAQW,MAAMF,KAAK;AAClEH,YAAMI,OAAOV,QAAQU;AACrBJ,YAAMK,QAAQX,QAAQW;AACtB;IACF;IACA,KAAK,UAAU;AACbL,YAAMlC,SAAS4B,QAAQF,MAAM1B;AAC7BkC,YAAMG,QAAQ;AACdH,YAAMI,OAAOG;AACbP,YAAMK,QAAQE;AACd;IACF;IACA,KAAK,cAAc;AACjBP,YAAMlC,SAAS;AACfkC,YAAMG,QAAQ;AACdH,YAAMI,OAAOG;AACbP,YAAMK,QAAQE;AACd;IACF;IACA,KAAK,UAAU;AACbP,YAAMlC,SAAS4B,QAAQ5B;AACvBkC,YAAMG,QAAQT,QAAQM,MAAMG,QAAQ;AACpCH,YAAMI,OAAOG;AACbP,YAAMK,QAAQE;AACd;IACF;EACF;AACA,SAAOP;AACT;AAQO,IAAMV,UAeRkB,OAAoCC,YAAYD,GAAGtD,OAAM;AAE9D,IAAMqD,SAASR,0BAAiB;EAAEJ,MAAM;AAAQ,CAAE;AAM3C,IAAMe,SAAmCA,MAAMH;AAQ/C,IAAMrC,QAAOA,IAAsDyC,OACxEC,wBAAwBD,EAAE;AAQrB,IAAME,KAASC,OAA2Bf,UAAU;EAAEJ,MAAM;EAAcmB;AAAC,CAAE;AAQ7E,IAAMC,gBAAmB5C,UAC9BmB,QAAQnB,IAAI,IAAIA,OAAO6C,gBAAmBD,aAAa5C,IAAI,CAAC;AAE9D,IAAM8C,cAAcA,CAAI9C,MAAgBqB,QAAmB0B,YAAyB;AAClF,UAAQ/C,KAAKuB,QAAQC,MAAI;IACvB,KAAK,UAAU;AACbtC,WAAKc,KAAKuB,QAAQF,OAAO,GAAGA,QAAO0B,SAAS/C,KAAKL,MAAM;AACvD;IACF;IACA,KAAK,WAAW;AACdmD,kBAAY9C,KAAKiC,MAAMZ,QAAO0B,OAAO;AACrCD,kBAAY9C,KAAKkC,OAAOb,QAAO0B,UAAU/C,KAAKiC,KAAKtC,MAAM;AACzD;IACF;IACA,KAAK,cAAc;AACjB0B,MAAAA,OAAM0B,OAAO,IAAI/C,KAAKuB,QAAQoB;AAC9B;IACF;IACA,KAAK,UAAU;AACb,UAAInD,IAAI;AACR,UAAIwD,IAAID;AACR,aAAOvD,IAAIQ,KAAKL,QAAQ;AACtB0B,QAAAA,OAAM2B,CAAC,IAAI3C,WAAUL,MAAMR,CAAC;AAC5BA,aAAK;AACLwD,aAAK;MACP;AACA;IACF;EACF;AACF;AAgBA,IAAMC,mBAAuBC,UAAoC;AAC/D,UAAQA,KAAKC,QAAQC,MAAI;IACvB,KAAK,UAAU;AACb,aAAOC;IACT;IACA,KAAK,UAAU;AACb,aAAOH,KAAKC,QAAQG;IACtB;IACA,SAAS;AACP,YAAMC,MAAM,IAAIC,MAASN,KAAKO,MAAM;AACpCC,kBAAYR,MAAMK,KAAK,CAAC;AACxBL,WAAKC,UAAU;QACbC,MAAM;QACNE,OAAOC;;AAETL,WAAKS,OAAOC;AACZV,WAAKW,QAAQD;AACbV,WAAKY,QAAQ;AACb,aAAOP;IACT;EACF;AACF;AAUO,IAAMQ,kBAGXd;AAEF,IAAMe,eAAmBd,UAA4B;AACnD,UAAQA,KAAKC,QAAQC,MAAI;IACvB,KAAK;IACL,KAAK;AACH,aAAOF;IACT,KAAK,UAAU;AACb,aAAOe,UAAU;QAAEb,MAAM;QAAUE,OAAUY,QAAQhB,KAAKC,QAAQG,KAAK;MAAC,CAAE;IAC5E;IACA,KAAK,WAAW;AACd,aAAOW,UAAU;QAAEb,MAAM;QAAWO,MAAMO,SAAQhB,KAAKC,QAAQU,KAAK;QAAGA,OAAOK,SAAQhB,KAAKC,QAAQQ,IAAI;MAAC,CAAE;IAC5G;IACA,KAAK;AACH,aAAOQ,gBAAmBD,QAAQH,gBAAgBb,IAAI,CAAC,CAAC;EAC5D;AACF;AAqBO,IAAMgB,WAA4EF;AAmClF,IAAMI,kBAAsBC,UACjCA,KAAKC,WAAW,IAAIC,OAAK,IAAKF,KAAKC,WAAW,IAAIE,GAAGH,KAAK,CAAC,CAAC,IAAII,UAAU;EAAEC,MAAM;EAAUC,OAAON;AAAI,CAAE;AAQpG,IAAMO,0BAA8BP,UACzCD,gBAAgBC,IAAI;AAQf,IAAMQ,aAeTC,qBAAK,GAAG,CAAIT,MAAgBU,UAAoB;AAClD,UAAQV,KAAKW,QAAQN,MAAI;IACvB,KAAK,UAAU;AACb,YAAM,IAAIO,MAAM,qBAAqB;IACvC;IACA,KAAK,cAAc;AACjB,UAAIF,UAAU,GAAG;AACf,cAAM,IAAIE,MAAM,qBAAqB;MACvC;AACA,aAAOZ,KAAKW,QAAQE;IACtB;IACA,KAAK,UAAU;AACb,UAAIH,SAASV,KAAKC,UAAUS,QAAQ,GAAG;AACrC,cAAM,IAAIE,MAAM,qBAAqB;MACvC;AACA,aAAOZ,KAAKW,QAAQL,MAAMI,KAAK;IACjC;IACA,KAAK,WAAW;AACd,aAAOA,QAAQV,KAAKc,KAAKb,SACrBO,WAAUR,KAAKc,MAAMJ,KAAK,IAC1BF,WAAUR,KAAKe,OAAOL,QAAQV,KAAKc,KAAKb,MAAM;IACpD;IACA,KAAK,UAAU;AACb,aAAOO,WAAUR,KAAKW,QAAQK,OAAON,QAAQV,KAAKW,QAAQM,MAAM;IAClE;EACF;AACF,CAAC;AA+BM,IAAMC,UAeTC,qBAAK,GAAG,CAAOC,MAAgBC,SAAkCC,WAAUC,GAAGF,IAAI,GAAGD,IAAI,CAAC;AAoRvF,IAAMI,aA6ETC,qBAAK,GAAG,CAAOC,MAAgBC,SAAgC;AACjE,MAAID,KAAKE,QAAQC,SAAS,UAAU;AAClC,WAAOF;EACT;AACA,MAAIA,KAAKC,QAAQC,SAAS,UAAU;AAClC,WAAOH;EACT;AACA,QAAMI,OAAOH,KAAKI,QAAQL,KAAKK;AAC/B,MAAIC,KAAKC,IAAIH,IAAI,KAAK,GAAG;AACvB,WAAOI,UAkBA;MAAEL,MAAM;MAAWM,MAAMT;MAAMU,OAAOT;IAAI,CAAE;EACrD,WAAWG,OAAO,IAAI;AACpB,QAAIJ,KAAKS,KAAKJ,SAASL,KAAKU,MAAML,OAAO;AACvC,YAAMM,KAAKb,WAAUE,KAAKU,OAAOT,IAAI;AACrC,aAAOO,UAAU;QAAEL,MAAM;QAAWM,MAAMT,KAAKS;QAAMC,OAAOC;MAAE,CAAE;IAClE,OAAO;AACL,YAAMC,MAAMd,WAAUE,KAAKU,MAAMA,OAAOT,IAAI;AAC5C,UAAIW,IAAIP,UAAUL,KAAKK,QAAQ,GAAG;AAChC,cAAMM,KAAKH,UAAU;UAAEL,MAAM;UAAWM,MAAMT,KAAKU,MAAMD;UAAMC,OAAOE;QAAG,CAAE;AAC3E,eAAOJ,UAAU;UAAEL,MAAM;UAAWM,MAAMT,KAAKS;UAAMC,OAAOC;QAAE,CAAE;MAClE,OAAO;AACL,cAAME,KAAKL,UAAU;UAAEL,MAAM;UAAWM,MAAMT,KAAKS;UAAMC,OAAOV,KAAKU,MAAMD;QAAI,CAAE;AACjF,eAAOD,UAAU;UAAEL,MAAM;UAAWM,MAAMI;UAAIH,OAAOE;QAAG,CAAE;MAC5D;IACF;EACF,OAAO;AACL,QAAIX,KAAKS,MAAML,SAASJ,KAAKQ,KAAKJ,OAAO;AACvC,YAAMQ,KAAKf,WAAUE,MAAMC,KAAKQ,IAAI;AACpC,aAAOD,UAAU;QAAEL,MAAM;QAAWM,MAAMI;QAAIH,OAAOT,KAAKS;MAAK,CAAE;IACnE,OAAO;AACL,YAAMI,MAAMhB,WAAUE,MAAMC,KAAKQ,KAAKA,IAAI;AAC1C,UAAIK,IAAIT,UAAUJ,KAAKI,QAAQ,GAAG;AAChC,cAAMQ,KAAKL,UAAU;UAAEL,MAAM;UAAWM,MAAMK;UAAKJ,OAAOT,KAAKQ,KAAKC;QAAK,CAAE;AAC3E,eAAOF,UAAU;UAAEL,MAAM;UAAWM,MAAMI;UAAIH,OAAOT,KAAKS;QAAK,CAAE;MACnE,OAAO;AACL,cAAMC,KAAKH,UAAU;UAAEL,MAAM;UAAWM,MAAMR,KAAKQ,KAAKC;UAAOA,OAAOT,KAAKS;QAAK,CAAE;AAClF,eAAOF,UAAU;UAAEL,MAAM;UAAWM,MAAMK;UAAKJ,OAAOC;QAAE,CAAE;MAC5D;IACF;EACF;AACF,CAAC;AA2QM,IAAMI,UAAcC,UAA4BA,KAAKC,WAAW;AAQhE,IAAMC,aAAiBF,UAA6CA,KAAKC,SAAS;AAkBlF,IAAME,aAAiBC,UAAsBC,WAAUD,MAAM,CAAC;AAQ9D,IAAME,gBAAiDH;;;AC3sCvD,IAAMI,OAAO;AAGb,IAAMC,cAAcC,qBAAKC,IAAI,GAAGH,IAAI;AAGpC,IAAMI,OAAOH,cAAc;AAG3B,IAAMI,iBAAiBJ,cAAc;AAGrC,IAAMK,iBAAiBL,cAAc;;;ACJtC,SAAUM,SAASC,GAAS;AAChCA,OAAMA,KAAK,IAAK;AAChBA,OAAKA,IAAI,cAAgBA,KAAK,IAAK;AACnCA,MAAKA,KAAKA,KAAK,KAAM;AACrBA,OAAKA,KAAK;AACVA,OAAKA,KAAK;AACV,SAAOA,IAAI;AACb;AAGM,SAAUC,aAAaC,OAAeC,GAAS;AACnD,SAAQA,MAAMD,QAASE;AACzB;AAGM,SAAUC,SAASL,GAAS;AAChC,SAAO,KAAKA;AACd;AAGM,SAAUM,WAAWC,QAAgBC,KAAW;AACpD,SAAOT,SAASQ,SAAUC,MAAM,CAAE;AACpC;;;ACzBO,IAAMC,QAAOA,CAAIC,OAAUC,cAAmC;EACnED;EACAC;;;;ACPI,SAAUC,YAAeC,SAAiBC,IAAYC,GAAMC,KAAa;AAC7E,MAAIC,MAAMD;AACV,MAAI,CAACH,SAAQ;AACX,UAAMK,MAAMF,IAAIG;AAChBF,UAAM,IAAIG,MAAMF,GAAG;AACnB,aAASG,IAAI,GAAGA,IAAIH,KAAK,EAAEG,EAAGJ,KAAII,CAAC,IAAIL,IAAIK,CAAC;EAC9C;AACAJ,MAAIH,EAAE,IAAIC;AACV,SAAOE;AACT;AAGM,SAAUK,eAAkBT,SAAiBC,IAAYE,KAAa;AAC1E,QAAMO,SAASP,IAAIG,SAAS;AAC5B,MAAIE,IAAI;AACR,MAAIG,IAAI;AACR,MAAIP,MAAMD;AACV,MAAIH,SAAQ;AACVQ,QAAIG,IAAIV;EACV,OAAO;AACLG,UAAM,IAAIG,MAAMG,MAAM;AACtB,WAAOF,IAAIP,GAAIG,KAAIO,GAAG,IAAIR,IAAIK,GAAG;EACnC;AACA,IAAEA;AACF,SAAOA,KAAKE,OAAQN,KAAIO,GAAG,IAAIR,IAAIK,GAAG;AACtC,MAAIR,SAAQ;AACVI,QAAIE,SAASI;EACf;AACA,SAAON;AACT;AAGM,SAAUQ,cAAiBZ,SAAiBC,IAAYC,GAAMC,KAAa;AAC/E,QAAME,MAAMF,IAAIG;AAChB,MAAIN,SAAQ;AACV,QAAIQ,KAAIH;AACR,WAAOG,MAAKP,GAAIE,KAAIK,IAAG,IAAIL,IAAIK,EAAC;AAChCL,QAAIF,EAAE,IAAIC;AACV,WAAOC;EACT;AACA,MAAIK,IAAI,GACNG,IAAI;AACN,QAAMP,MAAM,IAAIG,MAASF,MAAM,CAAC;AAChC,SAAOG,IAAIP,GAAIG,KAAIO,GAAG,IAAIR,IAAIK,GAAG;AACjCJ,MAAIH,EAAE,IAAIC;AACV,SAAOM,IAAIH,IAAKD,KAAI,EAAEO,CAAC,IAAIR,IAAIK,GAAG;AAClC,SAAOJ;AACT;;;ACzBM,IAAOS,YAAP,MAAOA,WAAS;EACXC,OAAO;EAEhBC,OACEC,MACAC,QACAC,GACAC,OACAC,KACAC,OAAa;AAEb,UAAMC,IAAIJ,EAAIK,MAAI,CAAE;AACpB,QAAMC,QAAOF,CAAC,EAAG,QAAO,IAAIT,WAAS;AACrC,MAAEQ,MAAKI;AACP,WAAO,IAAIC,SAASV,MAAMG,OAAMC,KAAKE,CAAC;EACxC;;AAII,SAAUK,YAAYC,GAAU;AACpC,SAAOC,SAASD,GAAG,WAAW;AAChC;AAGM,SAAUE,WACdC,MAAgB;AAEhB,SAAOJ,YAAYI,IAAI,KAAKA,KAAKjB,SAAS,cAAciB,KAAKjB,SAAS;AACxE;AAGM,SAAUkB,YAAkBD,MAAkBf,MAAY;AAC9D,SAAOW,YAAYI,IAAI,IAAI,QAAQf,SAASe,KAAKf;AACnD;AAGM,IAAOU,WAAP,MAAOA,UAAQ;EAIRV;EACAG;EACAC;EACFK;EANAX,OAAO;EAEhBmB,YACWjB,MACAG,OACAC,KACFK,OAAkB;AAHhB,SAAAT,OAAAA;AACA,SAAAG,OAAAA;AACA,SAAAC,MAAAA;AACF,SAAAK,QAAAA;EACN;EAEHV,OACEC,MACAkB,OACAhB,GACAC,OACAC,KACAC,OAAa;AAEb,QAAIc,OAAOf,KAAK,KAAKA,GAAG,GAAG;AACzB,YAAME,KAAIJ,EAAE,KAAKO,KAAK;AACtB,UAAIH,OAAM,KAAKG,MAAO,QAAO;eAClBD,QAAOF,EAAC,GAAG;AACpB,UAAED,MAAKI;AACP,eAAO,IAAIZ,UAAS;MACtB;AACA,UAAImB,YAAY,MAAMhB,IAAI,GAAG;AAC3B,aAAKS,QAAQH;AACb,eAAO;MACT;AACA,aAAO,IAAII,UAASV,MAAMG,OAAMC,KAAKE,EAAC;IACxC;AACA,UAAMA,IAAIJ,EAAIK,MAAI,CAAE;AACpB,QAAMC,QAAOF,CAAC,EAAG,QAAO;AACxB,MAAED,MAAKI;AACP,WAAOW,YACLpB,MACAkB,OACA,KAAKf,MACL,MACAA,OACA,IAAIO,UAASV,MAAMG,OAAMC,KAAKE,CAAC,CAAC;EAEpC;;AAII,IAAOe,gBAAP,MAAOA,eAAa;EAIbrB;EACAG;EACAmB;EALFxB,OAAO;EAEhBmB,YACWjB,MACAG,OACAmB,UAA2B;AAF3B,SAAAtB,OAAAA;AACA,SAAAG,OAAAA;AACA,SAAAmB,WAAAA;EACR;EAEHvB,OACEC,MACAkB,OACAhB,GACAC,OACAC,KACAC,OAAa;AAEb,QAAIF,UAAS,KAAKA,MAAM;AACtB,YAAMoB,UAAUP,YAAY,MAAMhB,IAAI;AACtC,YAAMwB,OAAO,KAAKC,oBAChBF,SACAvB,MACA,KAAKG,MACL,KAAKmB,UACLpB,GACAE,KACAC,KAAI;AAEN,UAAImB,SAAS,KAAKF,SAAU,QAAO;AAEnC,aAAOE,KAAKE,SAAS,IAAI,IAAIL,eAAcrB,MAAM,KAAKG,MAAMqB,IAAI,IAAIA,KAAK,CAAC;IAC5E;AACA,UAAMlB,IAAIJ,EAAIK,MAAI,CAAE;AACpB,QAAMC,QAAOF,CAAC,EAAG,QAAO;AACxB,MAAED,MAAKI;AACP,WAAOW,YACLpB,MACAkB,OACA,KAAKf,MACL,MACAA,OACA,IAAIO,SAASV,MAAMG,OAAMC,KAAKE,CAAC,CAAC;EAEpC;EAEAmB,oBACEE,SACA3B,MACAG,OACAqB,MACAtB,GACAE,KACAC,OAAa;AAEb,UAAMuB,MAAMJ,KAAKE;AACjB,aAASG,IAAI,GAAGA,IAAID,KAAK,EAAEC,GAAG;AAC5B,YAAMC,QAAQN,KAAKK,CAAC;AACpB,UAAI,SAASC,SAASX,OAAOf,KAAK0B,MAAM1B,GAAG,GAAG;AAC5C,cAAMK,QAAQqB,MAAMrB;AACpB,cAAMsB,YAAW7B,EAAEO,KAAK;AACxB,YAAIsB,cAAatB,MAAO,QAAOe;AAC/B,YAAMhB,QAAOuB,SAAQ,GAAG;AACtB,YAAE1B,MAAKI;AACP,iBAAOuB,eAAeL,SAAQE,GAAGL,IAAI;QACvC;AACA,eAAOS,YAAYN,SAAQE,GAAG,IAAInB,SAASV,MAAMG,OAAMC,KAAK2B,SAAQ,GAAGP,IAAI;MAC7E;IACF;AAEA,UAAMO,WAAW7B,EAAIK,MAAI,CAAE;AAC3B,QAAMC,QAAOuB,QAAQ,EAAG,QAAOP;AAC/B,MAAEnB,MAAKI;AACP,WAAOwB,YAAYN,SAAQC,KAAK,IAAIlB,SAASV,MAAMG,OAAMC,KAAK2B,QAAQ,GAAGP,IAAI;EAC/E;;AAII,IAAOU,cAAP,MAAOA,aAAW;EAIXlC;EACFmC;EACAb;EALAxB,OAAO;EAEhBmB,YACWjB,MACFmC,MACAb,UAA2B;AAFzB,SAAAtB,OAAAA;AACF,SAAAmC,OAAAA;AACA,SAAAb,WAAAA;EACN;EAEHvB,OACEC,MACAkB,OACAhB,GACAC,OACAC,KACAC,OAAa;AAEb,UAAM8B,OAAO,KAAKA;AAClB,UAAMb,WAAW,KAAKA;AACtB,UAAMc,OAAOC,aAAanB,OAAOf,KAAI;AACrC,UAAMmC,MAAMC,SAASH,IAAI;AACzB,UAAMI,OAAOC,WAAWN,MAAMG,GAAG;AACjC,UAAMI,SAASP,OAAOG;AACtB,UAAMf,UAAUP,YAAY,MAAMhB,IAAI;AAEtC,QAAI,CAAC0C,QAAQ;AACX,YAAMC,YAAY,IAAI9C,UAAS,EAASE,OAAOC,MAAMkB,QAAQ0B,MAAM1C,GAAGC,OAAMC,KAAKC,KAAI;AACrF,UAAI,CAACsC,UAAW,QAAO;AACvB,aAAOrB,SAASI,UAAUmB,iBACxBC,OAAO9C,MAAMoC,MAAMO,WAAWR,MAAMb,QAAQ,IAC5C,IAAIY,aAAYlC,MAAMmC,OAAOG,KAAKS,cAAcxB,SAASiB,MAAMG,WAAWrB,QAAQ,CAAC;IACvF;AAEA,UAAM0B,UAAU1B,SAASkB,IAAI;AAC7B,UAAMV,QAAQkB,QAAQjD,OAAOC,MAAMkB,QAAQ0B,MAAM1C,GAAGC,OAAMC,KAAKC,KAAI;AAEnE,QAAI2C,YAAYlB,MAAO,QAAO;AAC9B,QAAImB,SAASd;AACb,QAAIe;AACJ,QAAIvC,YAAYmB,KAAK,GAAG;AAEtBmB,gBAAU,CAACX;AACX,UAAI,CAACW,OAAQ,QAAO,IAAIpD,UAAS;AACjC,UAAIyB,SAASI,UAAU,KAAKZ,WAAWQ,SAASkB,OAAO,CAAC,CAAE,GAAG;AAC3D,eAAOlB,SAASkB,OAAO,CAAC;MAC1B;AAEAU,oBAAclB,eAAeT,SAASiB,MAAMlB,QAAQ;IACtD,OAAO;AAEL4B,oBAAcjB,YAAYV,SAASiB,MAAMV,OAAOR,QAAQ;IAC1D;AAEA,QAAIC,SAAS;AACX,WAAKY,OAAOc;AACZ,WAAK3B,WAAW4B;AAChB,aAAO;IACT;AAEA,WAAO,IAAIhB,aAAYlC,MAAMiD,QAAQC,WAAW;EAClD;;AAII,IAAOC,YAAP,MAAOA,WAAS;EAITnD;EACFK;EACAiB;EALAxB,OAAO;EAEhBmB,YACWjB,MACFK,OACAiB,UAA2B;AAFzB,SAAAtB,OAAAA;AACF,SAAAK,OAAAA;AACA,SAAAiB,WAAAA;EACN;EAEHvB,OACEC,MACAkB,OACAhB,GACAC,OACAC,KACAC,OAAa;AAEb,QAAI+C,QAAQ,KAAK/C;AACjB,UAAMiB,WAAW,KAAKA;AACtB,UAAMc,OAAOC,aAAanB,OAAOf,KAAI;AACrC,UAAM2B,QAAQR,SAASc,IAAI;AAC3B,UAAMiB,YAAYvB,SAAS,IAAIjC,UAAS,GAAUE,OAChDC,MACAkB,QAAQ0B,MACR1C,GACAC,OACAC,KACAC,KAAI;AAGN,QAAIyB,UAAUuB,SAAU,QAAO;AAE/B,UAAM9B,UAAUP,YAAY,MAAMhB,IAAI;AACtC,QAAIkD;AACJ,QAAIvC,YAAYmB,KAAK,KAAK,CAACnB,YAAY0C,QAAQ,GAAG;AAEhD,QAAED;AACFF,oBAAcjB,YAAYV,SAASa,MAAMiB,UAAU/B,QAAQ;IAC7D,WAAW,CAACX,YAAYmB,KAAK,KAAKnB,YAAY0C,QAAQ,GAAG;AAEvD,QAAED;AACF,UAAIA,SAASE,gBAAgB;AAC3B,eAAOC,KAAKvD,MAAMoD,OAAOhB,MAAMd,QAAQ;MACzC;AACA4B,oBAAcjB,YAAYV,SAASa,MAAM,IAAIvC,UAAS,GAAUyB,QAAQ;IAC1E,OAAO;AAEL4B,oBAAcjB,YAAYV,SAASa,MAAMiB,UAAU/B,QAAQ;IAC7D;AAEA,QAAIC,SAAS;AACX,WAAKlB,OAAO+C;AACZ,WAAK9B,WAAW4B;AAChB,aAAO;IACT;AACA,WAAO,IAAIC,WAAUnD,MAAMoD,OAAOF,WAAW;EAC/C;;AAGF,SAASK,KACPvD,MACAoD,OACAI,SACAC,UAA2B;AAE3B,QAAMnC,WAAW,IAAIoC,MAAkBN,QAAQ,CAAC;AAChD,MAAIO,IAAI;AACR,MAAIV,SAAS;AACb,WAASpB,IAAI,GAAGD,MAAM6B,SAAS/B,QAAQG,IAAID,KAAK,EAAEC,GAAG;AACnD,QAAIA,MAAM2B,SAAS;AACjB,YAAMI,OAAOH,SAAS5B,CAAC;AACvB,UAAI+B,QAAQ,CAACjD,YAAYiD,IAAI,GAAG;AAC9BtC,iBAASqC,GAAG,IAAIC;AAChBX,kBAAU,KAAKpB;MACjB;IACF;EACF;AACA,SAAO,IAAIK,YAAYlC,MAAMiD,QAAQ3B,QAAQ;AAC/C;AAEA,SAASwB,OACP9C,MACAoC,MACAN,OACAmB,QACAY,UAA2B;AAE3B,QAAMC,MAAM,CAAA;AACZ,MAAIxB,MAAMW;AACV,MAAIG,QAAQ;AACZ,WAASvB,IAAI,GAAGS,KAAK,EAAET,GAAG;AACxB,QAAIS,MAAM,EAAGwB,KAAIjC,CAAC,IAAIgC,SAAST,OAAO;AACtCd,aAAS;EACX;AACAwB,MAAI1B,IAAI,IAAIN;AACZ,SAAO,IAAIqB,UAAUnD,MAAMoD,QAAQ,GAAGU,GAAG;AAC3C;AAEA,SAASC,iBACP/D,MACAkB,OACA8C,IACAC,IACAC,IACAC,IAAc;AAEd,MAAIH,OAAOE,GAAI,QAAO,IAAI7C,cAAcrB,MAAMgE,IAAI,CAACG,IAAIF,EAAE,CAAC;AAC1D,QAAMG,QAAQ/B,aAAanB,OAAO8C,EAAE;AACpC,QAAMK,QAAQhC,aAAanB,OAAOgD,EAAE;AAEpC,MAAIE,UAAUC,OAAO;AACnB,WAAQvC,WAAU,IAAII,YAAYlC,MAAMuC,SAAS6B,KAAK,IAAI7B,SAAS8B,KAAK,GAAG,CAACvC,KAAK,CAAC;EACpF,OAAO;AACL,UAAMR,WAAW8C,QAAQC,QAAQ,CAACJ,IAAIE,EAAE,IAAI,CAACA,IAAIF,EAAE;AACnD,WAAO,IAAI/B,YAAYlC,MAAMuC,SAAS6B,KAAK,IAAI7B,SAAS8B,KAAK,GAAG/C,QAAQ;EAC1E;AACF;AAEA,SAASF,YACPpB,MACAkB,OACA8C,IACAC,IACAC,IACAC,IAAc;AAEd,MAAIG,QAAmEC;AACvE,MAAIC,eAAetD;AAEnB,SAAO,MAAM;AACX,UAAMuD,MAAMV,iBAAiB/D,MAAMwE,cAAcR,IAAIC,IAAIC,IAAIC,EAAE;AAE/D,QAAI,OAAOM,QAAQ,YAAY;AAC7BH,cAAcI,MAAKD,KAAKH,KAAK;AAC7BE,qBAAeA,eAAe5B;IAChC,OAAO;AACL,UAAI+B,QAAQF;AACZ,aAAOH,SAAS,MAAM;AACpBK,gBAAQL,MAAM7D,MAAMkE,KAAK;AACzBL,gBAAQA,MAAMM;MAChB;AACA,aAAOD;IACT;EACF;AACF;;;ACxXA,IAAME,mBAAmB;AAGlB,IAAMC,gBAA2BC,uBAAOC,IAAIH,gBAAgB;AA2BnE,IAAMI,eAA6C;EACjD,CAACH,aAAa,GAAGA;EACjB,CAACC,OAAOG,QAAQ,IAAC;AACf,WAAO,IAAIC,gBAAgB,MAAM,CAACC,GAAGC,MAAM,CAACD,GAAGC,CAAC,CAAC;EACnD;EACA,CAAMC,MAAM,IAAC;AACX,QAAIC,QAAYA,KAAKV,gBAAgB;AACrC,eAAWW,QAAQ,MAAM;AACvBD,MAAAA,SAAQE,KAAUF,KAAKC,KAAK,CAAC,CAAC,GAAQE,QAAaH,KAAKC,KAAK,CAAC,CAAC,CAAC,CAAC;IACnE;AACA,WAAYG,OAAO,MAAMJ,KAAI;EAC/B;EACA,CAAOD,OAAM,EAAiCM,MAAa;AACzD,QAAIC,UAAUD,IAAI,GAAG;AACnB,UAAKA,KAA2BE,UAAU,KAAKA,OAAO;AACpD,eAAO;MACT;AACA,iBAAWN,QAAQ,MAAM;AACvB,cAAMO,OAAON,KACXG,MACAI,QAAQR,KAAK,CAAC,GAAQD,KAAKC,KAAK,CAAC,CAAC,CAAC,CAAC;AAEtC,YAAWS,QAAOF,IAAI,GAAG;AACvB,iBAAO;QACT,OAAO;AACL,cAAI,CAAOG,OAAOV,KAAK,CAAC,GAAGO,KAAKI,KAAK,GAAG;AACtC,mBAAO;UACT;QACF;MACF;AACA,aAAO;IACT;AACA,WAAO;EACT;EACAC,WAAQ;AACN,WAAOC,OAAO,KAAKC,OAAM,CAAE;EAC7B;EACAA,SAAM;AACJ,WAAO;MACLC,KAAK;MACLC,QAAQC,MAAMC,KAAK,IAAI,EAAEC,IAAIL,MAAM;;EAEvC;EACA,CAACM,iBAAiB,IAAC;AACjB,WAAO,KAAKN,OAAM;EACpB;EACAb,OAAI;AACF,WAAOoB,cAAc,MAAMC,SAAS;EACtC;;AAGF,IAAMC,WAAWA,CACfC,UACAC,MACAC,MACAC,UACqB;AACrB,QAAMR,OAAMS,OAAOC,OAAOpC,YAAY;AACtC0B,EAAAA,KAAIW,YAAYN;AAChBL,EAAAA,KAAIY,QAAQN;AACZN,EAAAA,KAAIa,QAAQN;AACZP,EAAAA,KAAIb,QAAQqB;AACZ,SAAOR;AACT;AAEA,IAAMxB,kBAAN,MAAMA,iBAAe;EAGEwB;EAAiCc;EAFtDpC;EAEAqC,YAAqBf,MAAiCc,GAAuB;AAAxD,SAAAd,MAAAA;AAAiC,SAAAc,IAAAA;AACpD,SAAKpC,IAAIsC,UAAU,KAAKhB,IAAIa,OAAO,KAAKC,GAAGG,MAAS;EACtD;EAEAC,OAAI;AACF,QAAW5B,QAAO,KAAKZ,CAAC,GAAG;AACzB,aAAO;QAAEyC,MAAM;QAAM3B,OAAOyB;MAAS;IACvC;AACA,UAAMG,KAAK,KAAK1C,EAAEc;AAClB,SAAKd,IAAI2C,UAAUD,GAAGE,IAAI;AAC1B,WAAO;MAAEH,MAAM;MAAO3B,OAAO4B,GAAG5B;IAAK;EACvC;EAEA,CAACpB,OAAOG,QAAQ,IAAC;AACf,WAAO,IAAIC,iBAAgB,KAAKwB,KAAK,KAAKc,CAAC;EAC7C;;AAGF,IAAMO,YAAsBC,UAC1BA,OACIC,kBAAkBD,KAAK,CAAC,GAAGA,KAAK,CAAC,GAAGA,KAAK,CAAC,GAAGA,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,IACtDE,MAAI;AAEjB,IAAMR,YAAYA,CAChBS,MACAX,GACAQ,OAAsBL,WACiB;AACvC,UAAQQ,KAAKC,MAAI;IACf,KAAK,YAAY;AACf,UAAWC,QAAOF,KAAKjC,KAAK,GAAG;AAC7B,eAAcoC,MAAK;UACjBpC,OAAOsB,EAAEW,KAAKI,KAAKJ,KAAKjC,MAAMA,KAAK;UACnC8B;SACD;MACH;AACA,aAAOD,UAAUC,IAAI;IACvB;IACA,KAAK;IACL,KAAK;IACL,KAAK,eAAe;AAClB,YAAMQ,WAAWL,KAAKK;AACtB,aAAOP,kBAAkBO,SAASC,QAAQD,UAAU,GAAGhB,GAAGQ,IAAI;IAChE;IACA,SAAS;AACP,aAAOD,UAAUC,IAAI;IACvB;EACF;AACF;AAEA,IAAMC,oBAAoBA,CACxBS,KACAF,UACAG,GACAnB,GACAQ,SACuC;AACvC,SAAOW,IAAID,KAAK;AACd,UAAME,QAAQJ,SAASG,GAAG;AAC1B,QAAIC,SAAS,CAAMC,YAAYD,KAAK,GAAG;AACrC,aAAOlB,UAAUkB,OAAOpB,GAAG,CAACkB,KAAKF,UAAUG,GAAGnB,GAAGQ,IAAI,CAAC;IACxD;EACF;AACA,SAAOD,UAAUC,IAAI;AACvB;AAEA,IAAMc,UAAShC,yBAAuB,OAAO,GAAG,oBAASiC,UAAS,GAAI,CAAC;AAGhE,IAAMC,SAAQA,MAA8CF;AAoB5D,IAAMG,YAGRC,OAAkDC,YAAYD,GAAGE,aAAa;AAa5E,IAAMC,UAAUC,gBAAKC,KAG1B,GAAG,CAAqBC,MAAwBC,KAASC,UAAgB;AACzE,MAAIC,OAAQH,KAA2BI;AACvC,MAAIC,QAAQ;AAEZ,SAAO,MAAM;AACX,YAAQF,KAAKG,MAAI;MACf,KAAK,YAAY;AACf,eAAaC,OAAON,KAAKE,KAAKF,GAAG,IAAIE,KAAKK,QAAeC,MAAI;MAC/D;MACA,KAAK,iBAAiB;AACpB,YAAIP,UAASC,KAAKD,MAAM;AACtB,gBAAMQ,WAAWP,KAAKO;AACtB,mBAASC,IAAI,GAAGC,MAAMF,SAASG,QAAQF,IAAIC,KAAK,EAAED,GAAG;AACnD,kBAAMG,QAAQJ,SAASC,CAAC;AACxB,gBAAI,SAASG,SAAeP,OAAON,KAAKa,MAAMb,GAAG,GAAG;AAClD,qBAAOa,MAAMN;YACf;UACF;QACF;AACA,eAAcC,MAAI;MACpB;MACA,KAAK,eAAe;AAClB,cAAMM,OAAOC,aAAaX,OAAOH,KAAI;AACrC,cAAMe,MAAMC,SAASH,IAAI;AACzB,YAAIZ,KAAKgB,OAAOF,KAAK;AACnBd,iBAAOA,KAAKO,SAASU,WAAWjB,KAAKgB,MAAMF,GAAG,CAAC;AAC/CZ,mBAASgB;AACT;QACF;AACA,eAAcZ,MAAI;MACpB;MACA,KAAK,aAAa;AAChBN,eAAOA,KAAKO,SAASM,aAAaX,OAAOH,KAAI,CAAC;AAC9C,YAAIC,MAAM;AACRE,mBAASgB;AACT;QACF;AACA,eAAcZ,MAAI;MACpB;MACA;AACE,eAAcA,MAAI;IACtB;EACF;AACF,CAAC;AAiCM,IAAMa,MAAMC,gBAAKC,KAGtB,GAAG,CAACC,MAAMC,KAAKC,UAAUC,SAASH,MAAMC,KAAK,MAAaG,MAAKF,KAAK,CAAC,CAAC;AAGjE,IAAMG,UAAUP,gBAAKC,KAG1B,GAAG,CAAOC,MAAwBM,SAA0BC,YAAmB;AAC/E,MAAKP,KAA2BQ,WAAW;AACzC;AAAER,SAA2BS,QAAQH;AACnCN,SAA2BU,QAAQH;AACrC,WAAOP;EACT;AACA,SAAOM,YAAaN,KAA2BS,QAC3CT,OACAW,SACCX,KAA2BQ,WAC3BR,KAA2BY,OAC5BN,SACAC,OAAO;AAEb,CAAC;AAGM,IAAMM,QAAcb,UACzB,IAAIc,gBAAgBd,MAA4BC,SAAQA,GAAG;AAWtD,IAAMc,OAAcC,UAAoCA,KAA2BC;AAiBnF,IAAMC,gBAAuBC,UAClCC,SACE,MACCD,KAA2BE,QAAQ,GACnCF,KAA2BG,OAC3BH,KAA2BI,KAAK;AAoB9B,IAAMC,WAAWC,gBAAKC,KAG3B,GAAG,CAACC,MAAMC,KAAKC,MAAMC,WAAWH,MAAMC,KAAUG,KAAKH,GAAG,GAAGC,CAAC,CAAC;AAGxD,IAAMC,aAAaL,gBAAKC,KAG7B,GAAG,CAAOC,MAAwBC,KAAQG,OAAcF,MAA6B;AACrF,QAAMG,QAAO;IAAEC,OAAQN,KAA2BO;EAAK;AACvD,QAAMC,UAAWR,KAA2BS,MAAMC,OAC/CV,KAA2BW,YACzBX,KAA2BY,QAC5BC,KACF,GACAX,GACAE,OACAH,KACAI,KAAI;AAEN,SAAOS,KAAKd,MAAMe,QAAQP,SAASH,MAAKC,KAAK,CAAC;AAChD,CAAC;AAyEM,IAAMU,UAAUC,gBAAKC,KAG1B,GAAG,CAACC,MAAMC,MAAMC,QAAOF,MAAM,QAAgB,CAACG,GAAGC,OAAOC,QAAQJ,EAAEG,OAAOC,GAAG,CAAC,CAAC;AAGzE,IAAMH,UAASJ,gBAAKC,KAGzB,GAAG,CAAUC,MAAwBM,OAASL,MAA8C;AAC5F,QAAMM,OAAQP,KAA2BQ;AACzC,MAAID,KAAKE,SAAS,YAAY;AAC5B,WAAcC,QAAOH,KAAKH,KAAK,IAAIH,EAAEK,OAAMC,KAAKH,MAAMA,OAAOG,KAAKF,GAAG,IAAIC;EAC3E;AACA,MAAIC,KAAKE,SAAS,aAAa;AAC7B,WAAOH;EACT;AACA,QAAMK,UAAU,CAACJ,KAAKK,QAAQ;AAC9B,MAAIA;AACJ,SAAQA,WAAWD,QAAQE,IAAG,GAAK;AACjC,aAASC,IAAI,GAAGC,MAAMH,SAASI,QAAQF,IAAIC,OAAM;AAC/C,YAAME,QAAQL,SAASE,GAAG;AAC1B,UAAIG,SAAS,CAAMC,YAAYD,KAAK,GAAG;AACrC,YAAIA,MAAMR,SAAS,YAAY;AAC7B,cAAWC,QAAOO,MAAMb,KAAK,GAAG;AAC9BE,YAAAA,QAAOL,EAAEK,OAAMW,MAAMb,MAAMA,OAAOa,MAAMZ,GAAG;UAC7C;QACF,OAAO;AACLM,kBAAQQ,KAAKF,MAAML,QAAQ;QAC7B;MACF;IACF;EACF;AACA,SAAON;AACT,CAAC;;;AC7eD,IAAMc,mBAAmB;AAGlB,IAAMC,gBAA2BC,uBAAOC,IAAIH,gBAAgB;AAOnE,IAAMI,eAAsD;EAC1D,CAACH,aAAa,GAAGA;EACjB,CAACC,OAAOG,QAAQ,IAAC;AACf,WAAUC,MAAK,KAAKC,OAAO;EAC7B;EACA,CAAMC,MAAM,IAAC;AACX,WAAYC,OACV,MACKC,QAAaC,KAAK,KAAKJ,OAAO,CAAC,EAAOI,KAAKX,gBAAgB,CAAC,CAAC;EAEtE;EACA,CAAOQ,OAAM,EAA2BI,MAAa;AACnD,QAAIC,UAAUD,IAAI,GAAG;AACnB,aACKE,KAAK,KAAKP,OAAO,MAASO,KAAMF,KAAwBL,OAAO,KAC5DQ,OAAO,KAAKR,SAAUK,KAAwBL,OAAO;IAE/D;AACA,WAAO;EACT;EACAS,WAAQ;AACN,WAAOC,OAAO,KAAKC,OAAM,CAAE;EAC7B;EACAA,SAAM;AACJ,WAAO;MACLC,KAAK;MACLC,QAAQC,MAAMC,KAAK,IAAI,EAAEC,IAAIL,MAAM;;EAEvC;EACA,CAACM,iBAAiB,IAAC;AACjB,WAAO,KAAKN,OAAM;EACpB;EACAO,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;;AAIK,IAAMC,YAAeC,YAA+C;AACzE,QAAMC,OAAMC,OAAOC,OAAO5B,YAAY;AACtC0B,EAAAA,KAAIvB,UAAUsB;AACd,SAAOC;AACT;AAGO,IAAMjB,YAGRoB,OAAyCC,YAAYD,GAAGhC,aAAa;AAE1E,IAAMkC,UAASP,gBAAAA,UAAgBQ,gBAAGC,OAAK,CAAE;AAGlC,IAAMA,SAAQA,MAAgCF;AA+D9C,IAAMG,QAAWC,UAAmCD,KAAMC,KAAwBC,OAAO;AAGzF,IAAMC,iBAAoBF,UAC/BG,UAAYD,cAAeF,KAAwBC,OAAO,CAAC;AAGtD,IAAMG,cAAkBJ,UAAsC;AACnE;AAAGA,OAAwBC,QAAuCI,YAAY;AAC9E,SAAOL;AACT;AAGO,IAAMM,SAASC,qBAGpB,GAAG,CAACP,MAAMQ,MAAK;AACf,QAAMC,YAAYP,eAAcF,IAAI;AACpCQ,IAAEC,SAAS;AACX,SAAOL,YAAYK,SAAS;AAC9B,CAAC;AAGM,IAAMC,MAAMH,qBAIjB,GACA,CAAIP,MAAqBW,UACrBX,KAAwBC,QAAuCI,aACzDO,IAAID,OAAY,IAAe,EAAGX,KAAwBC,OAAO,GAAGD,QACxEG,UAAYS,IAAID,OAAY,IAAe,EAAGX,KAAwBC,OAAO,CAAC,CAAC;AAwChF,IAAMY,SAAQC,qBAGnB,GAAG,CAACC,MAAMC,SACVC,OAAOC,OAAK,GAAKC,CAAAA,SAAO;AACtBC,EAAAA,SAAQL,MAAOM,WAAUC,IAAIH,MAAKE,KAAK,CAAC;AACxC,aAAWA,SAASL,MAAM;AACxBM,QAAIH,MAAKE,KAAK;EAChB;AACF,CAAC,CAAC;AAsCG,IAAME,WAAUC,qBAGrB,GAAG,CAAIC,MAAqBC,MACzBH,QACAE,KAAwBE,SACzB,CAACC,GAAGC,MAAMH,EAAEG,CAAC,CAAC,CACf;;;AC+GI,IAAMC,SAAwCA;AAqoB9C,IAAMC,QAA2CA;AAiPjD,IAAMC,OA0CNA;AAiSA,IAAMC,SA4ENA;;;AC7nDA,IAAMC,aAA0BC,uBAAOC,OAAOD,uBAAOE,OAAOC,MAAMC,SAAS,GAAG;EACnF,CAAMC,MAAM,IAAC;AACX,WAAYC,OAAO,MAAWC,OAAM,IAAI,CAAC;EAC3C;EACA,CAAOF,OAAM,EAAoBG,MAAiB;AAChD,QAAIL,MAAMM,QAAQD,IAAI,KAAK,KAAKE,WAAWF,KAAKE,QAAQ;AACtD,aAAO,KAAKC,MAAM,CAACC,GAAGC,MAAYC,OAAOF,GAAIJ,KAAoBK,CAAC,CAAC,CAAC;IACtE,OAAO;AACL,aAAO;IACT;EACF;CACD;AAGM,IAAME,aAGF,4BAAA;AACT,WAASA,YAAsBC,OAAS;AACtC,QAAIA,OAAM;AACRhB,aAAOC,OAAO,MAAMe,KAAI;IAC1B;EACF;AACAD,EAAAA,YAAWX,YAAYa;AACvB,SAAOF;AACT,GAAE;;;AC9BK,IAAMG,SAAS;AAMf,IAAMC,WAAW;AAMjB,IAAMC,UAAU;AAMhB,IAAMC,eAAe;AAMrB,IAAMC,cAAc;AAMpB,IAAMC,gBAAgB;;;ACN7B,IAAMC,iBAAiB;AAGhB,IAAMC,cAAiCC,uBAAOC,IACnDH,cAAc;AAGhB,IAAMI,WAAW;;EAEfC,IAAKC,OAAaA;;AAIpB,IAAMC,QAAQ;EACZ,CAACN,WAAW,GAAGG;EACf,CAAMI,MAAM,IAAC;AACX,WAAOC,KACAC,KAAKV,cAAc,GACnBW,QAAaD,KAAKE,aAAa,IAAI,CAAC,CAAC,GACrCC,OAAO,IAAI,CAAC;EAErB;EACA,CAAOL,OAAM,EAA0BM,MAAa;AAClD,WAAOC,QAAQD,IAAI,KAAKE,YAAY,MAAMF,IAAI;EAChD;EACAL,OAAI;AACF,WAAOQ,cAAc,MAAMC,SAAS;EACtC;EACAC,SAAM;AACJ,YAAQ,KAAKC,MAAI;MACf,KAAK;AACH,eAAO;UAAEC,KAAK;UAASD,MAAM,KAAKA;QAAI;MACxC,KAAK;AACH,eAAO;UAAEC,KAAK;UAASD,MAAM,KAAKA;UAAME,QAAQH,OAAO,KAAKG,MAAM;QAAC;MACrE,KAAK;AACH,eAAO;UAAED,KAAK;UAASD,MAAM,KAAKA;UAAMG,SAAS,KAAKA,QAAQJ,OAAM;QAAE;MACxE,KAAK;AACH,eAAO;UAAEE,KAAK;UAASD,MAAM,KAAKA;UAAMI,SAASL,OAAO,KAAKM,KAAK;QAAC;MACrE,KAAK;MACL,KAAK;AACH,eAAO;UAAEJ,KAAK;UAASD,MAAM,KAAKA;UAAMM,MAAMP,OAAO,KAAKO,IAAI;UAAGC,OAAOR,OAAO,KAAKQ,KAAK;QAAC;IAC9F;EACF;EACAC,WAAQ;AACN,WAAOC,OAAO,IAAI;EACpB;EACA,CAACC,iBAAiB,IAAC;AACjB,WAAO,KAAKX,OAAM;EACpB;;AAeK,IAAMY,QAAWC,WAA4B;AAClD,QAAMC,IAAIC,OAAOC,OAAOC,KAAK;AAC7BH,IAAEI,OAAeC;AACjBL,IAAED,QAAQA;AACV,SAAOC;AACT;AAmBO,IAAMM,WAAWA,CAAQC,OAAsBC,WAA+C;AACnG,QAAMC,IAAIC,OAAOC,OAAOC,KAAK;AAC7BH,IAAEI,OAAeC;AACjBL,IAAEF,OAAOA;AACTE,IAAED,QAAQA;AACV,SAAOC;AACT;AAGO,IAAMM,aAAaA,CAAQR,OAAsBC,WAA+C;AACrG,QAAMC,IAAIC,OAAOC,OAAOC,KAAK;AAC7BH,IAAEI,OAAeG;AACjBP,IAAEF,OAAOA;AACTE,IAAED,QAAQA;AACV,SAAOC;AACT;AAOO,IAAMQ,UAAWC,OAA0CC,YAAYD,GAAGE,WAAW;AA4DrF,IAAMC,oBAAwBC,UACnCC,kBAAkBC,QAAWC,6BAA6B,EAAEH,IAAI;AAiOlE,IAAMI,cAAcA,CAACC,OAA4BC,WAAwC;AACvF,MAAIC,YAAqDC,GAAGH,KAAI;AAChE,MAAII,aAAsDD,GAAGF,MAAK;AAClE,SAAaI,WAAWH,SAAS,KAAWG,WAAWD,UAAU,GAAG;AAClE,UAAM,CAACE,cAAcC,cAAc,IAAIC,KAC/BC,cAAaP,SAAS,GAC5BQ,QACE,CAASC,OAAK,GAAmBA,OAAK,CAAwB,GAC9D,CAAC,CAACC,WAAUC,WAAU,GAAGC,UAAS;AAChC,YAAM,CAACC,KAAKC,GAAG,IAAIC,cAAcH,KAAK;AACtC,aAAcI,MACZ,CACEV,KAAKI,WAAkBO,OAAMJ,GAAG,CAAC,GACjCP,KAAKK,aAAkBO,WAAUJ,GAAG,CAAC,CAAC,CAC9B;IAEd,CAAC,CACF;AAEH,UAAM,CAACK,eAAeC,eAAe,IAAId,KACjCC,cAAaL,UAAU,GAC7BM,QACE,CAASC,OAAK,GAAmBA,OAAK,CAAwB,GAC9D,CAAC,CAACC,WAAUC,WAAU,GAAGC,UAAS;AAChC,YAAM,CAACC,KAAKC,GAAG,IAAIC,cAAcH,KAAK;AACtC,aAAcI,MACZ,CACEV,KAAKI,WAAkBO,OAAMJ,GAAG,CAAC,GACjCP,KAAKK,aAAkBO,WAAUJ,GAAG,CAAC,CAAC,CAC9B;IAEd,CAAC,CACF;AAEH,QAAI,CAAOO,OAAOjB,cAAce,aAAa,GAAG;AAC9C,aAAO;IACT;AACAnB,gBAAYK;AACZH,iBAAakB;EACf;AACA,SAAO;AACT;AAaA,IAAME,eAAgBV,WAAsE;AAC1F,SAAOW,iBAAuBtB,GAAGW,KAAK,GAASH,OAAK,CAAE;AACxD;AAGA,IAAMc,mBAAmBA,CACvBC,QACAC,cACyC;AAEzC,SAAO,GAAG;AACR,UAAM,CAACf,WAAUC,WAAU,IAAIL,KAC7BkB,QACIhB,OACF,CAASC,OAAK,GAAmBA,OAAK,CAAwB,GAC9D,CAAC,CAACC,WAAUC,WAAU,GAAGC,UAAS;AAChC,YAAM,CAACC,KAAKC,GAAG,IAAIC,cAAcH,KAAK;AACtC,aAAO,CACLN,KAAKI,WAAkBO,OAAMJ,GAAG,CAAC,GACjCP,KAAKK,aAAkBO,WAAUJ,GAAG,CAAC,CAAC;IAE1C,CAAC,CACF;AAEH,UAAMY,UAAkBC,MAAKjB,SAAQ,IAAI,IACvCJ,KAAKmB,WAAiBG,QAAQlB,SAAQ,CAAC,IACvCe;AACF,QAAUI,QAAQlB,WAAU,GAAG;AAC7B,aAAamB,SAAQJ,OAAO;IAC9B;AACAF,aAASb;AACTc,gBAAYC;EACd;AACA,QAAM,IAAIK,MAAMC,mBAAmB,wBAAwB,CAAC;AAC9D;AA+DA,IAAMC,gBACJC,UACiE;AACjE,MAAIC,QAA0CD;AAC9C,QAAME,QAAqC,CAAA;AAC3C,MAAIC,YAAoBC,OAAK;AAC7B,MAAIC,cAAoBD,OAAK;AAC7B,SAAOH,UAAUK,QAAW;AAC1B,YAAQL,MAAMM,MAAI;MAChB,KAAaC,UAAU;AACrB,YAAIN,MAAMO,WAAW,GAAG;AACtB,iBAAO,CAACN,WAAWE,WAAW;QAChC;AACAJ,gBAAQC,MAAMQ,IAAG;AACjB;MACF;MACA,KAAaC,SAAS;AACpBR,oBAAoBS,KAAIT,WAAiBU,MAAKZ,MAAMM,MAAMN,MAAMa,KAAK,CAAC;AACtE,YAAIZ,MAAMO,WAAW,GAAG;AACtB,iBAAO,CAACN,WAAWE,WAAW;QAChC;AACAJ,gBAAQC,MAAMQ,IAAG;AACjB;MACF;MACA,KAAaK,QAAQ;AACnBZ,oBAAoBS,KAAIT,WAAiBU,MAAKZ,MAAMM,MAAMN,MAAMe,MAAM,CAAC;AACvE,YAAId,MAAMO,WAAW,GAAG;AACtB,iBAAO,CAACN,WAAWE,WAAW;QAChC;AACAJ,gBAAQC,MAAMQ,IAAG;AACjB;MACF;MACA,KAAaO,cAAc;AACzBd,oBAAoBS,KAAIT,WAAiBU,MAAKZ,MAAMM,MAAMN,MAAMiB,OAAkB,CAAC;AACnF,YAAIhB,MAAMO,WAAW,GAAG;AACtB,iBAAO,CAACN,WAAWE,WAAW;QAChC;AACAJ,gBAAQC,MAAMQ,IAAG;AACjB;MACF;MACA,KAAaS,eAAe;AAC1B,gBAAQlB,MAAMmB,KAAKb,MAAI;UACrB,KAAaC,UAAU;AACrBP,oBAAQA,MAAMoB;AACd;UACF;UACA,KAAaF,eAAe;AAC1BlB,oBAAQqB,WAAWrB,MAAMmB,KAAKA,MAAME,WAAWrB,MAAMmB,KAAKC,OAAOpB,MAAMoB,KAAK,CAAC;AAC7E;UACF;UACA,KAAaE,aAAa;AACxBtB,oBAAQuB,SACNF,WAAWrB,MAAMmB,KAAKA,MAAMnB,MAAMoB,KAAK,GACvCC,WAAWrB,MAAMmB,KAAKC,OAAOpB,MAAMoB,KAAK,CAAC;AAE3C;UACF;UACA,SAAS;AACPhB,0BAAoBoB,QAAQpB,aAAaJ,MAAMoB,KAAK;AACpDpB,oBAAQA,MAAMmB;AACd;UACF;QACF;AACA;MACF;MACA,KAAaG,aAAa;AACxBrB,cAAMwB,KAAKzB,MAAMoB,KAAK;AACtBpB,gBAAQA,MAAMmB;AACd;MACF;IACF;EACF;AACA,QAAM,IAAIO,MAAMC,mBAAmB,yBAAyB,CAAC;AAC/D;AAiBA,IAAMC,gCAA+E;EACnFC,WAAWC;EACXC,UAAUC;EACVC,SAASD;EACTE,eAAeJ;EACfK,gBAAgBA,CAACC,GAAGC,OAAMC,WAAUD,SAAQC;EAC5CC,cAAcA,CAACH,GAAGC,OAAMC,WAAUD,SAAQC;;AAwC5C,IAAME,qBAAqB;AAE3B,IAAMC,mBAAmB;AA+ClB,IAAMC,UAASC,qBAGpB,GAAG,CAAOC,MAAsBC,OAASC,OAAmE;AAC5G,MAAIC,cAAiBF;AACrB,MAAIG,QAAoCJ;AACxC,QAAMK,SAAgC,CAAA;AACtC,SAAOD,UAAUE,QAAW;AAC1B,UAAMC,UAASL,GAAGC,aAAaC,KAAK;AACpCD,kBAAqBK,QAAOD,OAAM,IAAIA,QAAOE,QAAQN;AACrD,YAAQC,MAAMM,MAAI;MAChB,KAAaC,eAAe;AAC1BN,eAAOO,KAAKR,MAAMS,KAAK;AACvBT,gBAAQA,MAAMU;AACd;MACF;MACA,KAAaC,aAAa;AACxBV,eAAOO,KAAKR,MAAMS,KAAK;AACvBT,gBAAQA,MAAMU;AACd;MACF;MACA,SAAS;AACPV,gBAAQE;AACR;MACF;IACF;AACA,QAAIF,UAAUE,UAAaD,OAAOW,SAAS,GAAG;AAC5CZ,cAAQC,OAAOY,IAAG;IACpB;EACF;AACA,SAAOd;AACT,CAAC;AAGM,IAAMe,oBAAoBnB,qBAG/B,GAAG,CAAUC,MAAsBmB,SAAYC,YAAwC;AACvF,QAAMC,QAA+B,CAACrB,IAAI;AAC1C,QAAMsB,SAA6C,CAAA;AACnD,SAAOD,MAAML,SAAS,GAAG;AACvB,UAAMZ,QAAQiB,MAAMJ,IAAG;AACvB,YAAQb,MAAMM,MAAI;MAChB,KAAaa,UAAU;AACrBD,eAAOV,KAAYC,OAAMO,QAAQI,UAAUL,OAAO,CAAC,CAAC;AACpD;MACF;MACA,KAAaM,SAAS;AACpBH,eAAOV,KAAYC,OAAMO,QAAQM,SAASP,SAASf,MAAMuB,KAAK,CAAC,CAAC;AAChE;MACF;MACA,KAAaC,QAAQ;AACnBN,eAAOV,KAAYC,OAAMO,QAAQS,QAAQV,SAASf,MAAM0B,MAAM,CAAC,CAAC;AAChE;MACF;MACA,KAAaC,cAAc;AACzBT,eAAOV,KAAYC,OAAMO,QAAQY,cAAcb,SAASf,MAAM6B,OAAO,CAAC,CAAC;AACvE;MACF;MACA,KAAatB,eAAe;AAC1BU,cAAMT,KAAKR,MAAMS,KAAK;AACtBQ,cAAMT,KAAKR,MAAMU,IAAI;AACrBQ,eAAOV,KAAYE,MAAK;UAAEJ,MAAMwB;QAAkB,CAAE,CAAC;AACrD;MACF;MACA,KAAanB,aAAa;AACxBM,cAAMT,KAAKR,MAAMS,KAAK;AACtBQ,cAAMT,KAAKR,MAAMU,IAAI;AACrBQ,eAAOV,KAAYE,MAAK;UAAEJ,MAAMyB;QAAgB,CAAE,CAAC;AACnD;MACF;IACF;EACF;AACA,QAAMhC,cAAwB,CAAA;AAC9B,SAAOmB,OAAON,SAAS,GAAG;AACxB,UAAMoB,SAASd,OAAOL,IAAG;AACzB,YAAQmB,OAAO1B,MAAI;MACjB,KAAK,QAAQ;AACX,gBAAQ0B,OAAOtB,KAAKJ,MAAI;UACtB,KAAKwB,oBAAoB;AACvB,kBAAMpB,QAAOX,YAAYc,IAAG;AAC5B,kBAAMJ,SAAQV,YAAYc,IAAG;AAC7B,kBAAMR,QAAQW,QAAQiB,eAAelB,SAASL,OAAMD,MAAK;AACzDV,wBAAYS,KAAKH,KAAK;AACtB;UACF;UACA,KAAK0B,kBAAkB;AACrB,kBAAMrB,QAAOX,YAAYc,IAAG;AAC5B,kBAAMJ,SAAQV,YAAYc,IAAG;AAC7B,kBAAMR,QAAQW,QAAQkB,aAAanB,SAASL,OAAMD,MAAK;AACvDV,wBAAYS,KAAKH,KAAK;AACtB;UACF;QACF;AACA;MACF;MACA,KAAK,SAAS;AACZN,oBAAYS,KAAKwB,OAAOvB,KAAK;AAC7B;MACF;IACF;EACF;AACA,MAAIV,YAAYa,WAAW,GAAG;AAC5B,UAAM,IAAIuB,MACR,qGAAqG;EAEzG;AACA,SAAOpC,YAAYc,IAAG;AACxB,CAAC;AAOM,IAAMuB,SAASA,CAAIpC,OAAuBqC,YAEpC;AACX,MAAIC,kBAAkBtC,KAAK,GAAG;AAC5B,WAAO;EACT;AACA,SAAOuC,aAAgBvC,KAAK,EAAEwC,IAAI,SAASC,GAAC;AAC1C,QAAIJ,SAASK,qBAAqB,QAAQD,EAAEzC,UAAUE,QAAW;AAC/D,aAAOuC,EAAEE;IACX;AACA,WAAO,GAAGF,EAAEE,KAAK;EAAOD,iBAAiBD,EAAEzC,OAAsB,IAAI,CAAC;;EACxE,CAAC,EAAE4C,KAAK,IAAI;AACd;AAEA,IAAMF,mBAAmBA,CAAC1C,OAAoB6C,WAAkB;AAC9D,QAAMC,QAAQ9C,MAAM2C,MAAOI,MAAM,IAAI;AACrC,MAAIJ,QAAQ,GAAGE,MAAM,YAAYC,MAAM,CAAC,CAAC;AACzC,WAASE,IAAI,GAAGC,MAAMH,MAAMlC,QAAQoC,IAAIC,KAAKD,KAAK;AAChDL,aAAS;EAAKE,MAAM,GAAGC,MAAME,CAAC,CAAC;EACjC;AACA,MAAIhD,MAAMA,OAAO;AACf2C,aAAS;EAAOD,iBAAiB1C,MAAMA,OAAsB,GAAG6C,MAAM,IAAI,CAAC;EAAKA,MAAM;EACxF;AACA,SAAOF;AACT;AAGM,IAAOO,cAAP,MAAOA,qBAAoBC,WAAWhB,MAAK;EAC/CiB,OAAyBlD;EACzBmD,YAAYC,eAAsB;AAChC,UAAMC,wBAAwB,OAAOD,kBAAkB,YAAYA,kBAAkB;AACrF,UAAME,YAAYrB,MAAMsB;AACxBtB,UAAMsB,kBAAkB;AACxB,UACEC,mBAAmBJ,aAAa,GAChCC,yBAAyB,WAAWD,iBAAiB,OAAOA,cAActD,UAAU,cAChF;MAAEA,OAAO,IAAIkD,aAAYI,cAActD,KAAK;IAAC,IAC7CE,MAAS;AAEf,QAAI,KAAKyD,YAAY,IAAI;AACvB,WAAKA,UAAU;IACjB;AACAxB,UAAMsB,kBAAkBD;AACxB,SAAKI,OAAON,yBAAyBnB,QAAQmB,cAAcM,OAAO;AAClE,QAAIL,uBAAuB;AACzB,UAAIM,cAAcP,eAAe;AAC/B,aAAKF,OAAOE,cAAcO,UAAU;MACtC;AACAC,aAAOC,KAAKT,aAAa,EAAEU,QAASC,SAAO;AACzC,YAAI,EAAEA,OAAO,OAAO;AAElB,eAAKA,GAAG,IAAIX,cAAcW,GAAG;QAC/B;MACF,CAAC;IACH;AACA,SAAKtB,QAAQuB,iBACX,GAAG,KAAKN,IAAI,KAAK,KAAKD,OAAO,IAC7BL,yBAAyBnB,SAASmB,cAAcX,QAC5CW,cAAcX,QACd,IACJ,KAAKS,IAAI;EAEb;;AAgBK,IAAMM,qBAAsBS,OAAsB;AAEvD,MAAI,OAAOA,MAAM,UAAU;AACzB,WAAOA;EACT;AAEA,MAAI,OAAOA,MAAM,YAAYA,MAAM,QAAQA,aAAahC,OAAO;AAC7D,WAAOgC,EAAER;EACX;AAEA,MAAI;AACF,QACES,YAAYD,GAAG,UAAU,KACzBE,YAAWF,EAAE,UAAU,CAAC,KACxBA,EAAE,UAAU,MAAML,OAAOQ,UAAUC,YACnCJ,EAAE,UAAU,MAAMhB,WAAWqB,MAAMF,UAAUC,UAC7C;AACA,aAAOJ,EAAE,UAAU,EAAC;IACtB;EACF,QAAQ;EACN;AAGF,SAAOM,kBAAkBN,CAAC;AAC5B;AAEA,IAAMO,gBAAgB;AAGf,IAAMC,cAAcC,4BAAY,6BAA6B,MAAM,oBAAIC,QAAO,CAAE;AAEvF,IAAMX,mBAAmBA,CAACP,SAAiBhB,OAAeS,SAAmC;AAC3F,QAAM0B,MAAqB,CAACnB,OAAO;AACnC,QAAMb,QAAQH,MAAMoC,WAAWpB,OAAO,IAAIhB,MAAMqC,MAAMrB,QAAQ/C,MAAM,EAAEmC,MAAM,IAAI,IAAIJ,MAAMI,MAAM,IAAI;AAEpG,WAASC,IAAI,GAAGA,IAAIF,MAAMlC,QAAQoC,KAAK;AACrC,QAAIF,MAAME,CAAC,EAAEiC,SAAS,yBAAyB,KAAKnC,MAAME,CAAC,EAAEiC,SAAS,wBAAwB,GAAG;AAC/FjC;AACA;IACF;AACA,QAAIF,MAAME,CAAC,EAAEiC,SAAS,gBAAgB,GAAG;AACvC;IACF;AACA,QAAInC,MAAME,CAAC,EAAEiC,SAAS,0BAA0B,GAAG;AACjD;IACF;AACAH,QAAItE,KACFsC,MAAME,CAAC,EACJkC,QAAQ,uCAAuC,OAAO,EACtDA,QAAQ,wBAAwB,aAAa,CAAC;EAErD;AAEA,MAAI9B,MAAM;AACR,QAAI+B,UAAsC/B;AAC1C,QAAIJ,IAAI;AACR,WAAOmC,WAAWA,QAAQ7E,SAAS,UAAU0C,IAAI,IAAI;AACnD,YAAMoC,UAAUT,YAAYU,IAAIF,OAAO;AACvC,UAAI,OAAOC,YAAY,YAAY;AACjC,cAAMzC,SAAQyC,QAAO;AACrB,YAAI,OAAOzC,WAAU,UAAU;AAC7B,gBAAM2C,mBAAmB3C,OAAM4C,SAASb,aAAa;AACrD,cAAIc,SAAQ;AACZ,qBAAW,CAAA,EAAGC,QAAQ,KAAKH,kBAAkB;AAC3CE,YAAAA,SAAQ;AACRV,gBAAItE,KAAK,UAAU2E,QAAQvB,IAAI,KAAK6B,QAAQ,GAAG;UACjD;AACA,cAAI,CAACD,QAAO;AACVV,gBAAItE,KAAK,UAAU2E,QAAQvB,IAAI,KAAKjB,OAAMuC,QAAQ,QAAQ,EAAE,CAAC,GAAG;UAClE;QACF,OAAO;AACLJ,cAAItE,KAAK,UAAU2E,QAAQvB,IAAI,EAAE;QACnC;MACF,OAAO;AACLkB,YAAItE,KAAK,UAAU2E,QAAQvB,IAAI,EAAE;MACnC;AACAuB,gBAAiBO,eAAeP,QAAQQ,MAAM;AAC9C3C;IACF;EACF;AAEA,SAAO8B,IAAIlC,KAAK,IAAI;AACtB;AAGO,IAAMiB,aAAa+B,uBAAOC,IAAI,uBAAuB;AAGrD,IAAMtD,eAAmBvC,WAC9Bc,kBAAkBd,OAAO,QAAQ;EAC/BoB,WAAWA,MAA0B,CAAA;EACrCK,SAASA,CAACqE,GAAGC,iBAAgB;AAC3B,WAAO,CAAC,IAAI7C,YAAY6C,YAAY,CAAC;EACvC;EACAzE,UAAUA,CAACwE,GAAGvE,UAAS;AACrB,WAAO,CAAC,IAAI2B,YAAY3B,KAAK,CAAC;EAChC;EACAK,eAAeA,MAAM,CAAA;EACrBM,cAAcA,CAAC4D,GAAGE,GAAGC,MAAM,CAAC,GAAGD,GAAG,GAAGC,CAAC;EACtChE,gBAAgBA,CAAC6D,GAAGE,GAAGC,MAAM,CAAC,GAAGD,GAAG,GAAGC,CAAC;CACzC;;;ACxhCG,IAAOC,iBAAP,MAAOA,eAAa;EAGHC;EAFrBC,SAAS;EAETC,YAAqBF,MAAO;AAAP,SAAAA,OAAAA;EACrB;EAEAG,KAAKC,GAAI;AACP,WAAO,KAAKH,SACT;MACCI,OAAOD;MACPE,MAAM;SAEP,KAAKL,SAAS,MACZ;MACCI,OAAO,KAAKL;MACZM,MAAM;;EAEd;EAEAC,OAAOH,GAAI;AACT,WAAQ;MACNC,OAAOD;MACPE,MAAM;;EAEV;EAEAE,MAAMC,GAAU;AACd,UAAMA;EACR;EAEA,CAACC,OAAOC,QAAQ,IAAC;AACf,WAAO,IAAIZ,eAAoB,KAAKC,IAAI;EAC1C;;;;ACiDK,IAAMY,gBAAoCC,uBAAOC,IAAI,eAAe;AA4C3E,IAAMC,kBAAN,MAAqB;EAMEC;EALdC,wBAAwBC;EACxBC,wBAAwBD;EACxBE,wBAAwBF;EACxBG,QAAQH;EACf,CAACI,aAAY,IAAIC;EACjBC,YAAqBR,KAAqB;AAArB,SAAAA,MAAAA;EAAwB;EAC7C,CAAOS,OAAM,EAAYC,MAAa;AACpC,WAAO,SAASA;EAClB;EACA,CAAMD,MAAM,IAAC;AACX,WAAYE,OAAO,MAAWC,OAAO,IAAI,CAAC;EAC5C;EACAC,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;EACAC,SAAM;AACJ,WAAO;MACLC,KAAK;MACLjB,KAAK,KAAKA;MACVC,uBAAuBe,OAAO,KAAKf,qBAAqB;MACxDE,uBAAuBa,OAAO,KAAKb,qBAAqB;MACxDC,uBAAuBY,OAAO,KAAKZ,qBAAqB;;EAE5D;EACAc,WAAQ;AACN,WAAOC,OAAO,KAAKH,OAAM,CAAE;EAC7B;EACA,CAACI,iBAAiB,IAAC;AACjB,WAAO,KAAKJ,OAAM;EACpB;EACA,CAACK,OAAOC,QAAQ,IAAC;AACf,WAAO,IAAIC,eAAc,IAAIC,UAAU,IAAI,CAAC;EAC9C;;AAIF,IAAMC,yBAAN,MAA4B;EAMLzB;EALdC,wBAAwBC;EACxBC,wBAAwBD;EACxBE,wBAAwBF;EACxBG,QAAQH;EACf,CAACI,aAAY,IAAIC;EACjBC,YAAqBR,KAAqB;AAArB,SAAAA,MAAAA;AAEnB,SAAK0B,OAAO1B;EACd;EACA,CAAOS,OAAM,EAAYC,MAAa;AACpC,WAAOiB,WAAWjB,IAAI,KAAKA,KAAKV,QAAQ;IAEhC4B,OAAO,KAAK3B,uBAAuBS,KAAKT,qBAAqB;EACvE;EACA,CAAMQ,MAAM,IAAC;AACX,WAAOI;;MAEAgB,OAAO,KAAKH,IAAI;;MAEhBI,QAAaC,KAAK,KAAK9B,qBAAqB,CAAC;MAC7CU,OAAO,IAAI;IAAC;EAErB;EACA,IAAIqB,QAAK;AACP,WAAO,KAAK/B;EACd;EACAY,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;EACAC,SAAM;AACJ,WAAO;MACLC,KAAK;MACLS,MAAM,KAAK1B;MACXgC,OAAQ,KAAKA,MAAchB,OAAM;;EAErC;EACAE,WAAQ;AACN,WAAOC,OAAO,KAAKH,OAAM,CAAE;EAC7B;EACA,CAACI,iBAAiB,IAAC;AACjB,WAAO,KAAKJ,OAAM;EACpB;EACA,CAACK,OAAOC,QAAQ,IAAC;AACf,WAAO,IAAIC,eAAc,IAAIC,UAAU,IAAI,CAAC;EAC9C;;AAIF,IAAMS,yBAAN,MAA4B;EAMLjC;EALdC,wBAAwBC;EACxBC,wBAAwBD;EACxBE,wBAAwBF;EACxBG,QAAQH;EACf,CAACI,aAAY,IAAIC;EACjBC,YAAqBR,KAAqB;AAArB,SAAAA,MAAAA;AAEnB,SAAK0B,OAAO1B;EACd;EACA,CAAOS,OAAM,EAAYC,MAAa;AACpC,WAAOiB,WAAWjB,IAAI,KAAKA,KAAKV,QAAQ;IAEhC4B,OAAO,KAAK3B,uBAAuBS,KAAKT,qBAAqB;EACvE;EACA,CAAMQ,MAAM,IAAC;AACX,WAAOI;;MAEAgB,OAAO,KAAKH,IAAI;;MAEhBI,QAAaC,KAAK,KAAK9B,qBAAqB,CAAC;MAC7CU,OAAO,IAAI;IAAC;EAErB;EACA,IAAIuB,QAAK;AACP,WAAO,KAAKjC;EACd;EACAY,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;EACAC,SAAM;AACJ,WAAO;MACLC,KAAK;MACLS,MAAM,KAAK1B;MACXkC,OAAOlB,OAAO,KAAKkB,KAAK;;EAE5B;EACAhB,WAAQ;AACN,WAAOC,OAAO,KAAKH,OAAM,CAAE;EAC7B;EACA,CAACI,iBAAiB,IAAC;AACjB,WAAO,KAAKJ,OAAM;EACpB;EACA,CAACK,OAAOC,QAAQ,IAAC;AACf,WAAO,IAAIC,eAAc,IAAIC,UAAU,IAAI,CAAC;EAC9C;;AA6HK,IAAMW,WAAYC,OAA8DC,YAAYD,GAAG9B,aAAY;AAG3G,IAAMgC,mBACXC,iBAC0B;AAC1B,QAAMC,SAAS,IAAIzC,gBAAwB0C,eAAe;AAC1DD,SAAOvC,wBAAwBsC;AAC/B,SAAOC;AACT;AAwQA,IAAME,iBAAiBC,uBAAOC,IAAI,2BAA2B;AAYtD,IAAMC,UAAUA,CAAIC,KAAiBC,SAAuC;AACjF,MAAWC,QAAOD,IAAI,GAAG;AACvB,WAAO,IAAIE,MAAMH,KAAK;MACpBI,IAAIC,QAAQC,GAAC;AACX,eAAOA,MAAoBC,cAAcD,MAAME,kBAAkBF,KAAKD;MACxE;MACAI,IAAIJ,QAAQC,GAAC;AACX,YAAIA,MAAoBC,YAAY;AAClC,iBAAON,KAAKS;QACd;AACA,YAAIJ,MAAME,gBAAgB;AACxB,iBAAOR;QACT;AAEA,eAAOK,OAAOC,CAAC;MACjB;KACD;EACH;AACA,SAAON;AACT;AA8BO,IAAMW,QAAWC,WACtBC,SAASD,KAAK,KAAK,EAAgBE,cAAcF,SAC/CG,iBAAkBC,WAAUC,UAAwBN,MAAKO,QAAQN,OAAOO,qBAAqBH,KAAK,CAAC,CAAC,CAAC,CAAC,IACpGC,UAAwBN,MAAKC,KAAK,CAAC;AAMlC,IAAMQ,YAAgBC,WAAkD;AAC7E,QAAMC,SAAS,IAAIC,uBAA+BC,UAAU;AAC5DF,SAAOG,wBAAwBJ;AAC/B,SAAOC;AACT;AAu2BO,IAAMI,cAAiC;EAC5CC,MAAM;EACNC,QAAQ;EACRC,OAAO;EACPC,SAASC,OAAOC;EAChBC,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;;AAsEK,IAAMC,eAAkC;EAC7CC,MAAM;EACNC,QAAQ;EACRC,OAAO;EACPC,SAASC,OAAOC;EAChBC,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;;AAwIF,IAAMC,2BAA2B;AAG1B,IAAMC,wBAA+DC,uBAAOC,IACjFH,wBAAwB;AAG1B,IAAMI,0BAA0B;;EAE9BC,IAAKC,OAAeA;;EAEpBC,IAAKD,OAAaA;;AAId,IAAOE,sBAAP,MAAOA,qBAAmB;EAGnBC;EAGAC;EALF,CAACT,qBAAqB,IAAIG;EACnCO,YACWF,QAGAC,QAAgB;AAHhB,SAAAD,SAAAA;AAGA,SAAAC,SAAAA;EAEX;EACA,CAAME,MAAM,IAAC;AACX,WAAYC,OAAO,MAAM,KAAKH,SAAcI,KAAK,KAAKJ,MAAM,IAASK,OAAO,IAAI,CAAC;EACnF;EACA,CAAOH,OAAM,EAAEI,MAAa;AAC1B,WAAO,KAAKN,SACVO,kBAAkBD,IAAI,KAAWE,OAAO,KAAKR,QAASM,KAAuCN,MAAM,IACnG,SAASM;EACb;EACAG,cAAcC,KAAmB;AAC/B,WAAO,IAAIZ,qBAAoB,KAAKC,QAAcY,cAAaD,GAAG,CAAC;EACrE;EACAE,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;;AAIK,IAAMP,oBAAqBQ,OAChCC,YAAYD,GAAGxB,qBAAqB;AA+W/B,IAAM0B,iBAAyF,4BAAA;EACpG,MAAMA,wBAAuBC,WAAWC,MAAK;IAC3CC,SAAM;AACJ,aAAOC,MAAK,IAAI;IAClB;IACAC,SAAM;AACJ,YAAMC,MAAM;QAAE,GAAG;MAAI;AACrB,UAAI,KAAKC,QAASD,KAAIC,UAAU,KAAKA;AACrC,UAAI,KAAKC,MAAOF,KAAIE,QAAQ,KAAKA;AACjC,aAAOF;IACT;IACA,CAACG,iBAAiB,IAAC;AACjB,UAAI,KAAKC,aAAaT,WAAWC,MAAMS,UAAUD,UAAU;AACzD,eAAO,KAAKE,QAAQ,GAAG,KAAKF,SAAQ,CAAE;EAAK,KAAKE,MAAMC,MAAM,IAAI,EAAEC,MAAM,CAAC,EAAEC,KAAK,IAAI,CAAC,KAAK,KAAKL,SAAQ;MACzG,WAAW,SAAST,YAAY;AAC9B,eAAqBe,OAAqBZ,MAAK,IAAI,GAAG;UAAEa,kBAAkB;QAAI,CAAE;MAClF;AACA,aAAO;IACT;;AAGFC,SAAOC,OAAOnB,gBAAeW,WAAWS,yBAAyB;AACjE,SAAOpB;AACT,GAAE;AAEF,IAAMqB,gBAAgBA,CACpBC,QACAC,QAC0C;EAC1C,MAAMC,aAAaxB,eAAc;IACtByB,OAAOF;;AAElBL,SAAOC,OAAOK,KAAKb,WAAWW,MAAK;AACjCE,OAAKb,UAAkBe,OAAOH;AAChC,SAAOC;AACT;AAGO,IAAMG,yBAAuDC,uBAAOC,IACzE,sCAAsC;AAIjC,IAAMC,mBAAmBT,8BAAsC;EACpE,CAACM,sBAAsB,GAAGA;GACzB,kBAAkB;AAMd,IAAMI,6BAA+DC,uBAAOC,IACjF,0CAA0C;AAIrC,IAAMC,uBAAuBC,8BAA0C;EAC5E,CAACJ,0BAA0B,GAAGA;GAC7B,sBAAsB;AAOlB,IAAMK,iCAAuEC,uBAAOC,IACzF,qCAAqC;AAIhC,IAAMC,2BAA2BC,8BAA8C;EACpF,CAACJ,8BAA8B,GAAGA;GACjC,0BAA0B;AAOtB,IAAMK,+BAAmEC,uBAAOC,IACrF,mCAAmC;AAI9B,IAAMC,yBAAyBC,8BAA4C;EAChF,CAACJ,4BAA4B,GAAGA;GAC/B,wBAAwB;AAOpB,IAAMK,uCAAmFC,uBAAOC,IACrG,oDAAoD;AAI/C,IAAMC,iCAAiCC,8BAAoD;EAChG,CAACJ,oCAAoC,GAAGA;GACvC,gCAAgC;AAG5B,IAAMK,kCAAyEJ,uBAAOC,IAC3F,+CAA+C;AAI1C,IAAMI,4BAA4BF,8BAA+C;EACtF,CAACC,+BAA+B,GAAGA;GAClC,2BAA2B;AAWvB,IAAME,yBAAuDC,uBAAOC,IACzE,6BAA6B;AAIxB,IAAMC,mBAAmBC,8BAAsC;EACpE,CAACJ,sBAAsB,GAAGA;GACzB,kBAAkB;AAwCd,IAAMK,aAAcC,OACzBC,SAASD,CAAC,KAAK,UAAUA,MAAMA,EAAEE,SAAS,aAAaF,EAAEE,SAAS;AAiuB7D,IAAMC,uBAA8BC,WAA+D;AACxG,QAAMC,OAAOD,MAAME;AACnB,SAAOD,SAASE,UAAaF,KAAKG,SAAS,SAAgBC,MAAKJ,IAAI,IAAWK,MAAI;AACrF;;;ACv3FO,IAAMC,SAGeC;AA8gBrB,IAAMC,SAG8B,4BAAA;AACzC,QAAMC,kBAAkBC,uBAAOC,IAAI,6BAA6B;AAChE,QAAMC,IAAI;IACRC,iBAAiB,cAAmBC,eAAc;MAChDC,YAAYC,OAAS;AACnB,cAAMA,OAAMC,SAASD,OAAME,QAAQ;UAAEA,OAAOF,MAAKE;QAAK,IAAKC,MAAS;AACpE,YAAIH,OAAM;AACRI,iBAAOC,OAAO,MAAML,KAAI;AAExBI,iBAAOE,eAAe,MAAMb,iBAAiB;YAAEc,OAAOP;YAAMQ,YAAY;UAAK,CAAE;QACjF;MACF;MACAC,SAAM;AACJ,eAAO;UAAE,GAAI,KAAahB,eAAe;UAAG,GAAG;QAAI;MACrD;;;AAGJ,SAAOG,EAAEC;AACX,GAAE;AAMK,IAAMa,cAAmCC,SAGmB;AACjE,QAAMf,IAAI;IACRC,iBAAiB,cAAcL,OAAS;MAC7BoB,OAAOD;;;AAGlBf,IAAEC,gBAAgBgB,UAAkBC,OAAOH;AAC7C,SAAOf,EAAEC;AACX;;;ACntBO,IAAMkB,UAAU,oBAAIC,YAAW;;;AC1C/B,IAAMC,SAAUC,WAAqB;AAC1C,QAAMC,SAASD,MAAMC;AAErB,MAAIC,SAAS;AACb,MAAIC;AAEJ,OAAKA,IAAI,GAAGA,IAAIF,QAAQE,KAAK,GAAG;AAC9BD,cAAUE,UAAUJ,MAAMG,IAAI,CAAC,KAAK,CAAC;AACrCD,cAAUE,WAAYJ,MAAMG,IAAI,CAAC,IAAI,MAAS,IAAMH,MAAMG,IAAI,CAAC,KAAK,CAAE;AACtED,cAAUE,WAAYJ,MAAMG,IAAI,CAAC,IAAI,OAAS,IAAMH,MAAMG,CAAC,KAAK,CAAE;AAClED,cAAUE,UAAUJ,MAAMG,CAAC,IAAI,EAAI;EACrC;AAEA,MAAIA,MAAMF,SAAS,GAAG;AAEpBC,cAAUE,UAAUJ,MAAMG,IAAI,CAAC,KAAK,CAAC;AACrCD,cAAUE,WAAWJ,MAAMG,IAAI,CAAC,IAAI,MAAS,CAAC;AAC9CD,cAAU;EACZ;AAEA,MAAIC,MAAMF,QAAQ;AAEhBC,cAAUE,UAAUJ,MAAMG,IAAI,CAAC,KAAK,CAAC;AACrCD,cAAUE,WAAYJ,MAAMG,IAAI,CAAC,IAAI,MAAS,IAAMH,MAAMG,IAAI,CAAC,KAAK,CAAE;AACtED,cAAUE,WAAWJ,MAAMG,IAAI,CAAC,IAAI,OAAS,CAAC;AAC9CD,cAAU;EACZ;AAEA,SAAOA;AACT;AA2DA,IAAMG,YAAY,CAChB,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GAAG;;;ACvJE,IAAMC,UAAUC,UACdD,OAAOC,IAAI,EAAEC,QAAQ,MAAM,EAAE,EAAEA,QAAQ,OAAO,GAAG,EAAEA,QAAQ,OAAO,GAAG;;;ACuCvE,IAAMC,kBAA2DC,WACtE,OAAOA,UAAU,WAAqBC,QAAcC,QAAQD,OAAOD,KAAK,CAAC,IAAcC,QAAOD,KAAK;;;ACzB9F,IAAMG,UAA0B;AAgCjC,IAAOC,OAAP,cAA4BC,OAIhC;AAAA;AAsFF,IAAMC,aAAa;EACjB,CAACH,OAAM,GAAGA;EACV,CAACI,OAAOC,QAAQ,IAAC;AACf,WAAO,KAAKC,MAAMF,OAAOC,QAAQ,EAAC;EACpC;EACA,CAACE,iBAAiB,IAAC;AACjB,WAAO,KAAKC,OAAM;EACpB;EACA,CAAOC,OAAM,EAAyBC,MAAiB;AACrD,QAAIC,QAAQD,IAAI,GAAG;AACjB,UACE,KAAKJ,MAAMM,SAASF,KAAKJ,MAAMM,QAC/B,KAAKC,MAAMD,SAASF,KAAKG,MAAMD,QAC/B,KAAKE,SAASJ,KAAKI,MACnB;AACA,eAAO;MACT;AAEA,iBAAW,CAACC,WAAWC,QAAQ,KAAK,KAAKV,OAAO;AAC9C,YAAI,CAACI,KAAKJ,MAAMW,IAAIF,SAAS,GAAG;AAC9B,iBAAO;QACT;AACA,cAAMG,gBAAgBR,KAAKJ,MAAMa,IAAIJ,SAAS;AAC9C,YAAI,CAAOK,OAAOJ,UAAUE,aAAa,GAAG;AAC1C,iBAAO;QACT;MACF;AAEA,iBAAW,CAACG,WAAWC,QAAQ,KAAK,KAAKT,OAAO;AAC9C,YAAI,CAACH,KAAKG,MAAMI,IAAII,SAAS,GAAG;AAC9B,iBAAO;QACT;AACA,cAAME,YAAYb,KAAKG,MAAMM,IAAIE,SAAS;AAC1C,YAAI,CAAOD,OAAOE,UAAUC,SAAS,GAAG;AACtC,iBAAO;QACT;MACF;AACA,aAAO;IACT;AACA,WAAO;EACT;EACA,CAAMd,MAAM,IAAC;AACX,QAAIe,QAAYC,OAAO,OAAO;AAC9BD,IAAAA,QAAOA,QAAYC,OAAO,KAAKX,IAAI;AACnCU,IAAAA,QAAOA,QAAYE,OAAO,KAAKpB,MAAMM,IAAI;AACzCY,IAAAA,QAAOA,QAAYE,OAAO,KAAKb,MAAMD,IAAI;AACzC,eAAW,CAACG,WAAWC,QAAQ,KAAK,KAAKV,OAAO;AAC9CkB,MAAAA,QAAOA,QAAaA,KAAKT,SAAS,IAASS,KAAKR,QAAQ;IAC1D;AACA,eAAW,CAACK,WAAWC,QAAQ,KAAK,KAAKT,OAAO;AAC9CW,MAAAA,QAAOA,QAAaA,KAAKH,SAAS,IAASG,KAAKF,QAAQ;IAC1D;AACA,WAAOE;EACT;EACAhB,SAAM;AACJ,WAAO;MACLmB,KAAK;MACLC,WAAW,KAAKtB,MAAMM;MACtBiB,WAAW,KAAKhB,MAAMD;MACtBE,MAAM,KAAKA;;EAEf;EACAgB,WAAQ;AACN,WAAOC,OAAO,IAAI;EACpB;EACAC,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;;AAaI,IAAOC,aAAP,eAA0BC,gBAAKC,YAAY,YAAY,GAE3D;AAAA;AAGF,IAAMC,cAAeC,UAAiB,IAAIJ,WAAW;EAAEK,SAAS,QAAQD,IAAI;AAAiB,CAAE;AAOxF,IAAM5B,UAAW8B,OAA6C,OAAOA,MAAM,YAAYA,MAAM,QAAQzC,WAAUyC;AAsB/G,IAAMC,WAAkBC,CAAAA,YAA+E;AAC5G,QAAMC,QAAsCC,OAAOC,OAAO3C,UAAU;AACpEyC,QAAM9B,OAAO;AACb8B,QAAMtC,QAAQ,oBAAIyC,IAAG;AACrBH,QAAM/B,QAAQ,oBAAIkC,IAAG;AACrBH,QAAMI,YAAY,oBAAID,IAAG;AACzBH,QAAMK,mBAAmB,oBAAIF,IAAG;AAChCH,QAAMM,gBAAgB;AACtBN,QAAMO,gBAAgB;AACtBP,QAAMQ,YAAmBC,MAAK,IAAI;AAClCT,QAAMU,UAAU;AAEhB,MAAIX,SAAQ;AACV,UAAMW,UAAUC,eAAcX,KAA4B;AAC1DD,IAAAA,QAAOW,OAAqC;AAC5C,WAAOE,aAAYF,OAAO;EAC5B;AAEA,SAAOV;AACT;AA8DO,IAAMa,iBACXC,WACyB;AAEzB,QAAMC,YAAY,oBAAIC,IAAG;AACzB,QAAMC,mBAAmB,oBAAID,IAAG;AAEhC,aAAW,CAACE,WAAWC,MAAK,KAAKL,MAAMC,WAAW;AAChDA,cAAUK,IAAIF,WAAW,CAAC,GAAGC,MAAK,CAAC;EACrC;AAEA,aAAW,CAACD,WAAWC,MAAK,KAAKL,MAAMG,kBAAkB;AACvDA,qBAAiBG,IAAIF,WAAW,CAAC,GAAGC,MAAK,CAAC;EAC5C;AAEA,QAAME,UAA0CC,OAAOC,OAAOC,UAAU;AACxEH,UAAQI,OAAOX,MAAMW;AACrBJ,UAAQK,QAAQ,IAAIV,IAAIF,MAAMY,KAAK;AACnCL,UAAQF,QAAQ,IAAIH,IAAIF,MAAMK,KAAK;AACnCE,UAAQN,YAAYA;AACpBM,UAAQJ,mBAAmBA;AAC3BI,UAAQM,gBAAgBb,MAAMa;AAC9BN,UAAQO,gBAAgBd,MAAMc;AAC9BP,UAAQQ,YAAYf,MAAMe;AAC1BR,UAAQA,UAAU;AAElB,SAAOA;AACT;AAkBO,IAAMS,eACXT,aACkB;AAClB,QAAMP,QAAiCQ,OAAOC,OAAOC,UAAU;AAC/DV,QAAMW,OAAOJ,QAAQI;AACrBX,QAAMY,QAAQ,IAAIV,IAAIK,QAAQK,KAAK;AACnCZ,QAAMK,QAAQ,IAAIH,IAAIK,QAAQF,KAAK;AACnCL,QAAMC,YAAYM,QAAQN;AAC1BD,QAAMG,mBAAmBI,QAAQJ;AACjCH,QAAMa,gBAAgBN,QAAQM;AAC9Bb,QAAMc,gBAAgBP,QAAQO;AAC9Bd,QAAMe,YAAYR,QAAQQ;AAC1Bf,QAAMO,UAAU;AAEhB,SAAOP;AACT;AAmBO,IAAMiB,UAqCTC,qBAAK,GAAG,CACVlB,OACAmB,MACkB;AAClB,QAAMZ,UAAUR,eAAcC,KAAK;AACnCmB,IAAEZ,OAAO;AACT,SAAOS,aAAYT,OAAO;AAC5B,CAAC;AAwBM,IAAMa,UAAUA,CACrBb,SACAc,SACa;AACb,QAAMjB,YAAYG,QAAQM;AAG1BN,UAAQK,MAAMN,IAAIF,WAAWiB,IAAI;AAGjCd,UAAQN,UAAUK,IAAIF,WAAW,CAAA,CAAE;AACnCG,UAAQJ,iBAAiBG,IAAIF,WAAW,CAAA,CAAE;AAG1CG,UAAQM,gBAAgBN,QAAQM,gBAAgB;AAEhD,SAAOT;AACT;AAwBO,IAAMkB,UAAUA,CACrBtB,OACAI,cACqBJ,MAAMY,MAAMW,IAAInB,SAAS,IAAWoB,MAAKxB,MAAMY,MAAMa,IAAIrB,SAAS,CAAE,IAAWsB,MAAI;AAyBnG,IAAMC,UAAUA,CACrB3B,OACAI,cACYJ,MAAMY,MAAMW,IAAInB,SAAS;AAwBhC,IAAMwB,YACX5B,WACWA,MAAMY,MAAMiB;AAyTlB,IAAMC,WACXC,aACQ;AAER,aAAW,CAACC,OAAOC,QAAQ,KAAKF,QAAQG,OAAO;AAC7CH,YAAQG,MAAMC,IAAIH,OAAO;MACvBI,QAAQH,SAASI;MACjBA,QAAQJ,SAASG;MACjBE,MAAML,SAASK;KAChB;EACH;AAGAP,UAAQQ,UAAUC,MAAK;AACvBT,UAAQU,iBAAiBD,MAAK;AAG9B,aAAW,CAACE,WAAWT,QAAQ,KAAKF,QAAQG,OAAO;AAEjD,UAAMS,cAAcZ,QAAQQ,UAAUK,IAAIX,SAASG,MAAM,KAAK,CAAA;AAC9DO,gBAAYE,KAAKH,SAAS;AAC1BX,YAAQQ,UAAUJ,IAAIF,SAASG,QAAQO,WAAW;AAGlD,UAAMG,cAAcf,QAAQU,iBAAiBG,IAAIX,SAASI,MAAM,KAAK,CAAA;AACrES,gBAAYD,KAAKH,SAAS;AAC1BX,YAAQU,iBAAiBN,IAAIF,SAASI,QAAQS,WAAW;EAC3D;AAGAf,UAAQgB,YAAmBC,MAAI;AACjC;AA0MA,IAAMC,+BACJC,aACQ;AAGR,MAAWC,QAAOD,QAAQE,SAAS,KAAKF,QAAQE,UAAUC,UAAU,OAAO;AACzEH,YAAQE,YAAmBE,MAAI;EACjC;AACF;AAGA,IAAMC,gCACJL,aACQ;AAGR,MAAWC,QAAOD,QAAQE,SAAS,KAAKF,QAAQE,UAAUC,UAAU,MAAM;AACxEH,YAAQE,YAAmBE,MAAI;EACjC;AACF;AAwBO,IAAME,UAAUA,CACrBN,SACAO,QACAC,QACAC,SACa;AAEb,MAAI,CAACT,QAAQU,MAAMC,IAAIJ,MAAM,GAAG;AAC9B,UAAMK,YAAYL,MAAM;EAC1B;AACA,MAAI,CAACP,QAAQU,MAAMC,IAAIH,MAAM,GAAG;AAC9B,UAAMI,YAAYJ,MAAM;EAC1B;AAEA,QAAMK,YAAYb,QAAQc;AAG1B,QAAMC,WAAW,IAAIC,KAAK;IAAET;IAAQC;IAAQC;EAAI,CAAE;AAClDT,UAAQiB,MAAMC,IAAIL,WAAWE,QAAQ;AAGrC,QAAMI,kBAAkBnB,QAAQoB,UAAUC,IAAId,MAAM;AACpD,MAAIY,oBAAoBG,QAAW;AACjCH,oBAAgBI,KAAKV,SAAS;EAChC;AAEA,QAAMW,yBAAyBxB,QAAQyB,iBAAiBJ,IAAIb,MAAM;AAClE,MAAIgB,2BAA2BF,QAAW;AACxCE,2BAAuBD,KAAKV,SAAS;EACvC;AAGA,MAAIb,QAAQ0B,SAAS,cAAc;AACjC,UAAMC,kBAAkB3B,QAAQoB,UAAUC,IAAIb,MAAM;AACpD,QAAImB,oBAAoBL,QAAW;AACjCK,sBAAgBJ,KAAKV,SAAS;IAChC;AAEA,UAAMe,yBAAyB5B,QAAQyB,iBAAiBJ,IAAId,MAAM;AAClE,QAAIqB,2BAA2BN,QAAW;AACxCM,6BAAuBL,KAAKV,SAAS;IACvC;EACF;AAGAb,UAAQc,gBAAgBd,QAAQc,gBAAgB;AAIhDT,gCAA8BL,OAAO;AAErC,SAAOa;AACT;AAsBO,IAAMgB,aAAaA,CACxB7B,SACA8B,cACQ;AAER,MAAI,CAAC9B,QAAQU,MAAMC,IAAImB,SAAS,GAAG;AACjC;EACF;AAGA,QAAMC,gBAAkC,CAAA;AAGxC,QAAMC,gBAAgBhC,QAAQoB,UAAUC,IAAIS,SAAS;AACrD,MAAIE,kBAAkBV,QAAW;AAC/B,eAAWW,QAAQD,eAAe;AAChCD,oBAAcR,KAAKU,IAAI;IACzB;EACF;AAGA,QAAMC,gBAAgBlC,QAAQyB,iBAAiBJ,IAAIS,SAAS;AAC5D,MAAII,kBAAkBZ,QAAW;AAC/B,eAAWW,QAAQC,eAAe;AAChCH,oBAAcR,KAAKU,IAAI;IACzB;EACF;AAGA,aAAWpB,aAAakB,eAAe;AACrCI,uBAAmBnC,SAASa,SAAS;EACvC;AAGAb,UAAQU,MAAM0B,OAAON,SAAS;AAC9B9B,UAAQoB,UAAUgB,OAAON,SAAS;AAClC9B,UAAQyB,iBAAiBW,OAAON,SAAS;AAIzC/B,+BAA6BC,OAAO;AACtC;AAoCA,IAAMqC,qBAAqBA,CACzBC,SACAC,cACW;AAEX,QAAMC,OAAOF,QAAQG,MAAMC,IAAIH,SAAS;AACxC,MAAIC,SAASG,QAAW;AACtB,WAAO;EACT;AAEA,QAAM;IAAEC;IAAQC;EAAM,IAAKL;AAG3B,QAAMM,kBAAkBR,QAAQS,UAAUL,IAAIE,MAAM;AACpD,MAAIE,oBAAoBH,QAAW;AACjC,UAAMK,QAAQF,gBAAgBG,QAAQV,SAAS;AAC/C,QAAIS,UAAU,IAAI;AAChBF,sBAAgBI,OAAOF,OAAO,CAAC;IACjC;EACF;AAEA,QAAMG,yBAAyBb,QAAQc,iBAAiBV,IAAIG,MAAM;AAClE,MAAIM,2BAA2BR,QAAW;AACxC,UAAMK,QAAQG,uBAAuBF,QAAQV,SAAS;AACtD,QAAIS,UAAU,IAAI;AAChBG,6BAAuBD,OAAOF,OAAO,CAAC;IACxC;EACF;AAGA,MAAIV,QAAQe,SAAS,cAAc;AACjC,UAAMC,kBAAkBhB,QAAQS,UAAUL,IAAIG,MAAM;AACpD,QAAIS,oBAAoBX,QAAW;AACjC,YAAMK,QAAQM,gBAAgBL,QAAQV,SAAS;AAC/C,UAAIS,UAAU,IAAI;AAChBM,wBAAgBJ,OAAOF,OAAO,CAAC;MACjC;IACF;AAEA,UAAMO,yBAAyBjB,QAAQc,iBAAiBV,IAAIE,MAAM;AAClE,QAAIW,2BAA2BZ,QAAW;AACxC,YAAMK,QAAQO,uBAAuBN,QAAQV,SAAS;AACtD,UAAIS,UAAU,IAAI;AAChBO,+BAAuBL,OAAOF,OAAO,CAAC;MACxC;IACF;EACF;AAGAV,UAAQG,MAAMe,OAAOjB,SAAS;AAE9B,SAAO;AACT;AA8LO,IAAMkB,oBAAoBA,CAC/BC,OACAC,WACAC,cACoB;AACpB,QAAMC,eAAeD,cAAc,aAC/BF,MAAMI,mBACNJ,MAAMK;AAEV,QAAMC,gBAAgBH,aAAaI,IAAIN,SAAS;AAChD,MAAIK,kBAAkBE,QAAW;AAC/B,WAAO,CAAA;EACT;AAEA,QAAMC,SAA2B,CAAA;AACjC,aAAWC,aAAaJ,eAAe;AACrC,UAAMK,OAAOX,MAAMY,MAAML,IAAIG,SAAS;AACtC,QAAIC,SAASH,QAAW;AAEtB,YAAMK,eAAeX,cAAc,aAC/BS,KAAKG,SACLH,KAAKI;AACTN,aAAOO,KAAKH,YAAY;IAC1B;EACF;AAEA,SAAOJ;AACT;AAqIA,IAAMQ,qBAAsBC,WAAyB;AAGnD,SAAOA,MACJC,QAAQ,MAAM,MAAM,EACpBA,QAAQ,MAAM,QAAQ,EACtBA,QAAQ,MAAM,MAAM,EACpBA,QAAQ,MAAM,MAAM,EACpBA,QAAQ,MAAM,OAAO,EACrBA,QAAQ,OAAO,MAAM,EACrBA,QAAQ,OAAO,MAAM,EACrBA,QAAQ,OAAO,OAAO,EACtBA,QAAQ,OAAO,OAAO,EACtBA,QAAQ,OAAO,MAAM,EACrBA,QAAQ,OAAO,MAAM,EACrBA,QAAQ,OAAO,OAAO,EACtBA,QAAQ,OAAO,MAAM,EACrBA,QAAQ,OAAO,OAAO;AAC3B;AAGA,IAAMC,oBAAoBA,CAACC,QAAgBH,OAAeI,UAAmC;AAC3F,UAAQA,OAAK;IACX,KAAK;AACH,aAAO,GAAGD,MAAM,KAAKH,KAAK;IAC5B,KAAK;AACH,aAAO,GAAGG,MAAM,KAAKH,KAAK;IAC5B,KAAK;AACH,aAAO,GAAGG,MAAM,MAAMH,KAAK;IAC7B,KAAK;AACH,aAAO,GAAGG,MAAM,KAAKH,KAAK;IAC5B,KAAK;AACH,aAAO,GAAGG,MAAM,MAAMH,KAAK;IAC7B,KAAK;AACH,aAAO,GAAGG,MAAM,MAAMH,KAAK;IAC7B,KAAK;AACH,aAAO,GAAGG,MAAM,MAAMH,KAAK;IAC7B,KAAK;AACH,aAAO,GAAGG,MAAM,MAAMH,KAAK;EAC/B;AACF;AA8BO,IAAMK,YAAYA,CACvBC,OACAC,YACU;AAEV,QAAM;IACJC;IACAC,YAAY;IACZC,YAAaC,UAAYC,OAAOD,IAAI;IACpCE,YAAaF,UAAYC,OAAOD,IAAI;IACpCG,YAAYA,MAAM;EAAoB,IACpCP,WAAW,CAAA;AAGf,QAAMQ,mBAAmBP,gBACtBF,MAAMU,SAAS,aAAa,cAAc;AAG7C,QAAMC,QAAuB,CAAA;AAC7BA,QAAMC,KAAK,GAAGH,gBAAgB,IAAIN,SAAS,EAAE;AAG7C,aAAW,CAACU,WAAWC,QAAQ,KAAKd,MAAMe,OAAO;AAC/C,UAAMlB,SAASS,OAAOO,SAAS;AAC/B,UAAMnB,QAAQD,mBAAmBc,UAAUO,QAAQ,CAAC;AACpD,UAAMhB,QAAQU,UAAUM,QAAQ;AAChC,UAAME,gBAAgBpB,kBAAkBC,QAAQH,OAAOI,KAAK;AAC5Da,UAAMC,KAAK,KAAKI,aAAa,EAAE;EACjC;AAGA,QAAMC,eAAeR,qBAAqB,cAAc,QAAQ;AAChE,aAAW,CAAA,EAAGS,QAAQ,KAAKlB,MAAMmB,OAAO;AACtC,UAAMC,WAAWd,OAAOY,SAASG,MAAM;AACvC,UAAMC,WAAWhB,OAAOY,SAASK,MAAM;AACvC,UAAM7B,QAAQD,mBAAmBW,UAAUc,SAASb,IAAI,CAAC;AAEzD,QAAIX,OAAO;AACTiB,YAAMC,KAAK,KAAKQ,QAAQ,IAAIH,YAAY,KAAKvB,KAAK,MAAM4B,QAAQ,EAAE;IACpE,OAAO;AACLX,YAAMC,KAAK,KAAKQ,QAAQ,IAAIH,YAAY,IAAIK,QAAQ,EAAE;IACxD;EACF;AAEA,SAAOX,MAAMa,KAAK,IAAI;AACxB;AAmpCM,IAAOC,SAAP,MAAa;;EAER,CAACC,OAAOC,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiChBC;EAETC,YAgCED,OAAsD;AAEtD,SAAKA,QAAQA;AACb,SAAKF,OAAOC,QAAQ,IAAIC,MAAM,CAACE,OAAOC,SAAS,CAACD,OAAOC,IAAI,CAAW,EAAEL,OAAOC,QAAQ;EACzF;;AA0CK,IAAMK,UAAiBC,YAAsCA,OAAOL,MAAM,CAACE,OAAOI,MAAMJ,KAAK;AAuB7F,IAAMK,UAAgBF,YAAsCA,OAAOL,MAAM,CAACM,GAAGH,SAASA,IAAI;AAuB1F,IAAMK,UAAiBH,YAC5BA,OAAOL,MAAM,CAACE,OAAOC,SAAS,CAACD,OAAOC,IAAI,CAAW;AA0VhD,IAAMM,eAAeA,CAC1BC,OACAC,SAAuB,CAAA,MACN;AACjB,QAAMC,QAAQD,OAAOC,SAAS,CAAA;AAC9B,QAAMC,YAAYF,OAAOE,aAAa;AAGtC,aAAWC,aAAaF,OAAO;AAC7B,QAAI,CAACG,QAAQL,OAAOI,SAAS,GAAG;AAC9B,YAAME,YAAYF,SAAS;IAC7B;EACF;AAEA,SAAO,IAAIG,OAAQC,QAAO;IACxB,CAACC,OAAOC,QAAQ,GAAG,MAAK;AACtB,YAAMC,QAA8D,CAAA;AACpE,YAAMC,aAAa,oBAAIC,IAAG;AAC1B,YAAMC,WAAW,oBAAID,IAAG;AAGxB,eAASE,IAAIb,MAAMc,SAAS,GAAGD,KAAK,GAAGA,KAAK;AAC1CJ,cAAMM,KAAK;UAAEC,MAAMhB,MAAMa,CAAC;UAAGI,iBAAiB;QAAK,CAAE;MACvD;AAEA,YAAMC,aAAaA,MAAK;AACtB,eAAOT,MAAMK,SAAS,GAAG;AACvB,gBAAMK,UAAUV,MAAMA,MAAMK,SAAS,CAAC;AAEtC,cAAI,CAACJ,WAAWU,IAAID,QAAQH,IAAI,GAAG;AACjCN,uBAAWW,IAAIF,QAAQH,IAAI;AAC3BG,oBAAQF,kBAAkB;UAC5B;AAEA,cAAI,CAACE,QAAQF,iBAAiB;AAC5BE,oBAAQF,kBAAkB;AAC1B,kBAAMK,YAAYC,kBAAkBzB,OAAOqB,QAAQH,MAAMf,SAAS;AAElE,qBAASY,IAAIS,UAAUR,SAAS,GAAGD,KAAK,GAAGA,KAAK;AAC9C,oBAAMW,WAAWF,UAAUT,CAAC;AAC5B,kBAAI,CAACH,WAAWU,IAAII,QAAQ,KAAK,CAACZ,SAASQ,IAAII,QAAQ,GAAG;AACxDf,sBAAMM,KAAK;kBAAEC,MAAMQ;kBAAUP,iBAAiB;gBAAK,CAAE;cACvD;YACF;UACF,OAAO;AACL,kBAAMQ,aAAahB,MAAMiB,IAAG,EAAIV;AAEhC,gBAAI,CAACJ,SAASQ,IAAIK,UAAU,GAAG;AAC7Bb,uBAASS,IAAII,UAAU;AAEvB,oBAAME,WAAWC,QAAQ9B,OAAO2B,UAAU;AAC1C,kBAAWI,QAAOF,QAAQ,GAAG;AAC3B,uBAAO;kBAAEG,MAAM;kBAAOC,OAAOzB,EAAEmB,YAAYE,SAASI,KAAK;gBAAC;cAC5D;AACA,qBAAOb,WAAU;YACnB;UACF;QACF;AAEA,eAAO;UAAEY,MAAM;UAAMC,OAAOC;QAAS;MACvC;AAEA,aAAO;QAAEC,MAAMf;MAAU;IAC3B;IACA;AACJ;AA0BO,IAAMgB,QACXpC,WAEA,IAAIO,OAAQC,QAAO;EACjB,CAACC,OAAOC,QAAQ,IAAC;AACf,UAAM2B,UAAUrC,MAAMoC;AACtB,UAAM1B,WAAW2B,QAAQC,QAAO;AAEhC,WAAO;MACLH,OAAI;AACF,cAAMI,SAAS7B,SAASyB,KAAI;AAC5B,YAAII,OAAOP,MAAM;AACf,iBAAO;YAAEA,MAAM;YAAMC,OAAOC;UAAS;QACvC;AACA,cAAM,CAAC9B,WAAWyB,QAAQ,IAAIU,OAAON;AACrC,eAAO;UAAED,MAAM;UAAOC,OAAOzB,EAAEJ,WAAWyB,QAAQ;QAAC;MACrD;;EAEJ;EACA;AA2BG,IAAMW,QACXxC,WAEA,IAAIO,OAAQC,QAAO;EACjB,CAACC,OAAOC,QAAQ,IAAC;AACf,UAAM+B,UAAUzC,MAAMwC;AACtB,UAAM9B,WAAW+B,QAAQH,QAAO;AAEhC,WAAO;MACLH,OAAI;AACF,cAAMI,SAAS7B,SAASyB,KAAI;AAC5B,YAAII,OAAOP,MAAM;AACf,iBAAO;YAAEA,MAAM;YAAMC,OAAOC;UAAS;QACvC;AACA,cAAM,CAACQ,WAAWC,QAAQ,IAAIJ,OAAON;AACrC,eAAO;UAAED,MAAM;UAAOC,OAAOzB,EAAEkC,WAAWC,QAAQ;QAAC;MACrD;;EAEJ;EACA;AA6CG,IAAMC,YAAYA,CACvB5C,OACAC,SAA0B,CAAA,MACT;AACjB,QAAME,YAAYF,OAAOE,aAAa;AAEtC,SAAO,IAAII,OAAQC,QAAO;IACxB,CAACC,OAAOC,QAAQ,GAAG,MAAK;AACtB,YAAM2B,UAAUrC,MAAMoC;AACtB,YAAMS,eAAe1C,cAAc,aAC/BH,MAAM8C,mBACN9C,MAAM+C;AAEV,YAAMC,eAAeX,QAAQC,QAAO;AAEpC,YAAMlB,aAAaA,MAAK;AACtB,YAAIC,UAAU2B,aAAab,KAAI;AAC/B,eAAO,CAACd,QAAQW,MAAM;AACpB,gBAAM,CAAC5B,WAAWyB,QAAQ,IAAIR,QAAQY;AACtC,gBAAMgB,gBAAgBJ,aAAaK,IAAI9C,SAAS;AAGhD,cAAI6C,kBAAkBf,UAAae,cAAcjC,WAAW,GAAG;AAC7D,mBAAO;cAAEgB,MAAM;cAAOC,OAAOzB,EAAEJ,WAAWyB,QAAQ;YAAC;UACrD;AACAR,oBAAU2B,aAAab,KAAI;QAC7B;AAEA,eAAO;UAAEH,MAAM;UAAMC,OAAOC;QAAS;MACvC;AAEA,aAAO;QAAEC,MAAMf;MAAU;IAC3B;IACA;AACJ;;;ACpqHO,IAAM,oBAAwB,iBAAiB;AAAA,EACpD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,yBAAyB,EAAE,WAAU,YAAY,QAAQ;AACtE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAG/B,UAAI,GAAG,mBAAmB,IAAI,KAAK,KAAK,QAAQ,KAAK,iBAAiB;AAEpE,cAAM,SAAS,OAAO;AAAA,UACpB,WAAW,qBAAqB,IAAI;AAAA,UAC/B+B,QAAO,MAAM,WAAW,kBAAkB,IAAI,CAAC;AAAA,UAC/CA,QAAO,MAAM,WAAW,iBAAiB,IAAI,CAAC;AAAA,UAC9CA,QAAO,MAAM,WAAW,mBAAmB,IAAI,CAAC;AAAA,UAChDA,QAAO,MAAM,WAAW,yBAAyB,IAAI,CAAC;AAAA,UACtDA,QAAO,MAAM,WAAW,yBAAyB,IAAI,CAAC;AAAA,UACtDA,QAAO,MAAM,WAAW,2BAA2B,IAAI,CAAC;AAAA,UACxDA,QAAO,MAAW,KAAK;AAAA,QAC9B;AAEA,YAAI,QAAQ;AAEV,gBAAM,EAAE,WAAW,aAAa,IAAI;AAGpC,cAAI,aAAa,WAAW,KAAK,UAAU,aAAa,KAAK,aAAa,GAAG;AAC7E,cAAI,GAAG,oBAAoB,YAAY,GAAG;AACxC,gBAAI,GAAG,aAAa,aAAa,QAAQ,GAAG;AAC1C,2BAAa,GAAG,OAAO,aAAa,QAAQ;AAAA,YAC9C,WAAW,GAAG,gBAAgB,aAAa,QAAQ,GAAG;AACpD,2BAAa,GAAG,OAAO,aAAa,SAAS,KAAK;AAAA,YACpD;AAAA,UACF;AAGA,gBAAM,eAAe,GAAG,OAAO,SAAS;AACxC,cAAI,eAAe,cAAc;AAC/B,mBAAO;AAAA,cACL,UAAU;AAAA,cACV,aAAa,kCAAkC,YAAY;AAAA,cAC3D,OAAO,CAAC;AAAA,gBACN,SAAS;AAAA,gBACT,aAAa,YAAY,UAAU,WAAW,YAAY;AAAA,gBAC1D,OAAY,IAAI,aAAY;AAC1B,wBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAGrE,wBAAM,WAAW,GAAG,oBAAoB,YAAY,IAAI,aAAa,gBAAgB;AACrF,wBAAM,mBAAmB,GAAG,QAAQ;AAAA,oBAClC,GAAG,QAAQ,iBAAiB,YAAY;AAAA,oBACxC;AAAA,kBACF;AAGA,gCAAc,YAAY,YAAY,cAAc,gBAAgB;AAAA,gBACtE,CAAC;AAAA,cACH,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAEA,SAAG,aAAa,MAAM,iBAAiB;AAAA,IACzC;AAAA,EACF,CAAC;AACH,CAAC;;;ACzEM,IAAM,oBAAwB,iBAAiB;AAAA,EACpD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,yBAAyB,EAAE,WAAU,YAAY,QAAQ;AACtE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,kBAAkB,OAAY,QAAwB,eAAe;AAC3E,UAAM,UAAU,OAAY,QAAqC,4BAA4B;AAE7F,UAAM,qBAA0B;AAAA,MACzB,GAAG,oBAAoB,EAAE,WAAU,kBAAuC;AAC7E,YAAI,CAAC,QAAQ,sBAAsB;AACjC,iBAAO,OAAkB,gBAAgB,sCAAsC,QAAW,gBAAgB;AAAA,QAC5G;AACA,YAAI,CAAC,iBAAiB,MAAM;AAC1B,iBAAO,OAAkB,gBAAgB,qBAAqB,QAAW,gBAAgB;AAAA,QAC3F;AACA,YAAI,CAAC,GAAG,aAAa,iBAAiB,IAAI,GAAG;AAC3C,iBAAO,OAAkB,gBAAgB,mCAAmC,QAAW,gBAAgB;AAAA,QACzG;AACA,cAAM,kBAAkB,iBAAiB;AACzC,YAAI,CAAC,iBAAiB;AACpB,iBAAO,OAAkB,gBAAgB,iCAAiC,QAAW,gBAAgB;AAAA,QACvG;AAEA,cAAMC,eAA8B,CAAC,GAAG,iBAAiB,eAAe;AACxE,cAAMC,qBAAoB,CAAC,SAAkB;AAC3C,UAAAD,aAAY,KAAK,IAAI;AACrB,iBAAO;AAAA,QACT;AAEA,eAAOA,aAAY,SAAS,GAAG;AAC7B,gBAAM,OAAOA,aAAY,MAAM;AAC/B,cAAI,GAAG,iBAAiB,IAAI,GAAG;AAC7B,qBAAS,IAAI,GAAG,IAAI,KAAK,UAAU,QAAQ,KAAK;AAC9C,oBAAM,MAAM,KAAK,UAAU,CAAC;AAC5B,kBAAI,CAAC,GAAG,gBAAgB,GAAG,EAAG;AAC9B,oBAAM,oBAAoB,YAAY,qBAAqB,IAAI;AAC/D,kBAAI,mBAAmB;AACrB,sBAAM,YAAY,kBAAkB,WAAW,CAAC;AAChD,oBAAI,CAAC,UAAW;AAChB,oBAAI,UAAU,cAAc;AAC1B,6BAAW,eAAe,UAAU,cAAc;AAChD,0BAAM,sBAAsB,gBAAgB,oBAAoB,WAAW;AAC3E,0BAAM,YAAY,oBAAoB,KAAK,UAAU,YAAY,KAAK,YAAY,GAAG;AACrF,wBAAI,UAAU,YAAY,EAAE,SAAS,oBAAoB,GAAG;AAC1D,6BAAO,EAAE,WAAW,iBAAiB,MAAM,kBAAkB,KAAK,QAAQ,SAAkB;AAAA,oBAC9F;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA,aAAG,aAAa,MAAMC,kBAAiB;AAAA,QACzC;AAEA,eAAO,OAAkB;AAAA,UACvB;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF,CAAC;AAAA,MACD;AAAA,MACA,CAAC,qBAAqB;AAAA,IACxB;AAEA,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAG/B,UAAI,GAAG,mBAAmB,IAAI,KAAK,KAAK,QAAQ,KAAK,iBAAiB;AAGpE,cAAM,SAAS,OAAO;AAAA,UACpB;AAAA,YACE,WAAW,qBAAqB,IAAI;AAAA,YAC/BC,QAAO,MAAM,WAAW,kBAAkB,IAAI,CAAC;AAAA,YAC/CA,QAAO,MAAM,WAAW,iBAAiB,IAAI,CAAC;AAAA,YAC9CC,KAAI,CAAC,EAAE,WAAW,iBAAiB,OAAO,EAAE,kBAAkB,WAAW,QAAQ,UAAmB,EAAE;AAAA,UAC7G;AAAA,UACKD;AAAA,YAAO,MACV;AAAA,cACE,WAAW,uBAAuB,IAAI;AAAA,cACjCA,QAAO,MAAM,WAAW,yBAAyB,IAAI,CAAC;AAAA,cACtDC,KAAI,CAAC,EAAE,WAAW,iBAAiB,OAAO,EAAE,kBAAkB,WAAW,QAAQ,QAAiB,EAAE;AAAA,YAC3G;AAAA,UACF;AAAA,UACKD,QAAO,MAAM,mBAAmB,IAAI,CAAC;AAAA,UACrCA,QAAO,MAAW,KAAK;AAAA,QAC9B;AAEA,YAAI,UAAU,OAAO,kBAAkB;AACrC,gBAAM,EAAE,WAAW,kBAAkB,OAAO,IAAI;AAGhD,gBAAM,gBAAgB,GAAG,OAAO,SAAS;AAGzC,gBAAM,cAAc,OAAkB,aAAa,YAAY,eAAe,MAAM;AACpF,cAAI,CAAC,YAAa;AAGlB,gBAAM,mBAAmB,iBAAiB;AAG1C,cAAI,qBAAqB,aAAa;AACpC,mBAAO;AAAA,cACL,UAAU;AAAA,cACV,aAAa,kBAAkB,WAAW;AAAA,cAC1C,OAAO,CAAC;AAAA,gBACN,SAAS;AAAA,gBACT,aAAa,YAAY,gBAAgB,WAAW,WAAW;AAAA,gBAC/D,OAAY,IAAI,aAAY;AAC1B,wBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAGrE,wBAAM,mBAAmB,GAAG,QAAQ,oBAAoB,WAAW;AAGnE,gCAAc,YAAY,YAAY,kBAAkB,gBAAgB;AAAA,gBAC1E,CAAC;AAAA,cACH,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAEA,SAAG,aAAa,MAAM,iBAAiB;AAAA,IACzC;AAAA,EACF,CAAC;AACH,CAAC;;;AC7ID,IAAM,uBAAuB,oBAAI,IAAmC;AACpE,IAAM,2BAA2B,oBAAI,IAAoB;AAElD,IAAM,mBAAuB,iBAAiB;AAAA,EACnD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,wBAAwB,EAAE,WAAU,YAAY,QAAQ;AACrE,UAAM,UAAU,OAAY,QAAsB,iBAAiB;AACnE,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,UAAU,OAAY,QAAqC,4BAA4B;AAE7F,QAAI,WAAW,WAAW,SAAS,EAAG;AAItC,QAAI,mBAA0C,qBAAqB,IAAI,WAAW,QAAQ,KACxF,CAAC;AACH,UAAM,wBACJ,YAAY,SAAS,iBAAiB,KAAK,YAAY,QAAQ,iBAAiB,MAAM,KACpF,SAAS,QAAQ,gBAAgB,IAAI,IACrC,QAAQ,gBAAgB,OACxB;AACJ,UAAM,kBAAkB,yBAAyB,IAAI,WAAW,QAAQ,KAAK;AAC7E,QAAI,0BAA0B,iBAAiB;AAC7C,YAAM,eAAe,oBAAI,IAAY;AACrC,yBAAmB,CAAC;AACpB,cAAQ,eAAe,EAAE,IAAI,CAAC,MAAM;AAClC,cAAM,cAAc,QAAQ,2CAA2C,CAAC;AACxE,YAAI,CAAC,YAAa;AAClB,cAAM,wBAAwB,YAAY,OAAO,MAAM,YAAY;AACnE,YAAI,aAAa,IAAI,qBAAqB,EAAG;AAC7C,qBAAa,IAAI,qBAAqB;AACtC,YACE,EAAE,YAAY,SAAS,YAAY,YAAY,6BAC/C;AACF,YAAI,QAAQ,0BAA0B,QAAQ,YAAY,IAAI,IAAI,GAAI;AACtE,yBAAiB,YAAY,IAAI,IAAI,iBAAiB,YAAY,IAAI,KAAK,CAAC;AAC5E,yBAAiB,YAAY,IAAI,EAAE,YAAY,OAAO,IAAI,YAAY;AAAA,MACxE,CAAC;AACD,2BAAqB,IAAI,WAAW,UAAU,gBAAgB;AAC9D,+BAAyB,IAAI,WAAW,UAAU,qBAAqB;AAAA,IACzE;AAEA,eAAW,eAAe,OAAO,KAAK,gBAAgB,GAAG;AACvD,UAAI,OAAO,KAAK,iBAAiB,WAAW,CAAC,EAAE,SAAS,GAAG;AACzD,cAAM,WAAW,OAAO,KAAK,iBAAiB,WAAW,CAAC;AAC1D,eAAO;AAAA,UACL,UAAU,WAAW,WAAW,CAAC;AAAA,UACjC,aAAa,WAAW,WAAW,0DACjC,SAAS,KAAK,IAAI,CACpB;AAAA;AAAA,wEACE,KAAK,UAAU,QAAQ,0BAA0B,OAAO,CAAC,WAAW,CAAC,CAAC,CACxE;AAAA;AAAA,EACE,SAAS,IAAI,CAAC,YAAY,WAAW,OAAO,OAAO,iBAAiB,WAAW,EAAE,OAAO,CAAC,EAAE,EAAE,KAAK,IAAI,CACxG;AAAA,UACA,OAAO,CAAC;AAAA,QACV,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC/DM,IAAM,uBAA2B,iBAAiB;AAAA,EACvD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,4BAA4B,EAAE,WAAU,YAAY,QAAQ;AACzE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAEvC,UAAI,GAAG,iBAAiB,IAAI,GAAG;AAC7B,eAAO;AAAA,UACL,WAAW,UAAU,IAAI;AAAA,UACpBE,KAAI,CAAC,EAAE,kBAAkB,MAAM;AAElC,gBAAI,kBAAkB,WAAW,SAAS,GAAG;AAC3C,oBAAM,UAAU,kBAAkB,WAAW,CAAC;AAE9C,qBAAO;AAAA,gBACL,UAAU;AAAA,gBACV,aAAa;AAAA,gBACb,OAAO,CAAC;AAAA,cACV,CAAC;AAAA,YACH;AAAA,UACF,CAAC;AAAA,UACI;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACrCM,IAAM,sBAA0B,iBAAiB;AAAA,EACtD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,2BAA2B,EAAE,WAAU,YAAY,QAAQ;AACxE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,UAAM,uBAA4B,GAAG,0CAA0C,EAAE,WAC/E,MACA,cACA,WACA,UACA;AACA,YAAM,iBAAiB,OAAO,WAAW,WAAW,cAAc,IAAI;AACtE,YAAM,aAAa,OAAO,WAAW,WAAW,UAAU,SAAS;AACnE,UAAI,eAAe,EAAE,QAAQ,GAAG,UAAU,MAAM;AAC9C,cAAM,iBAAiB,iBAAiB,mBAAmB,WAAW,CAAC;AACvE,cAAM,eAAe,OAAY;AAAA,UAC/B,eAAe,IAAI,CAAC,MAAWC,KAAI,WAAW,iBAAiB,GAAG,IAAI,GAAG,MAAM,CAAC,CAAC;AAAA,QACnF;AACA,eAAO,EAAE,aAAa;AAAA,MACxB;AACA,aAAO,OAAY,KAAgB,gBAAgB,oCAAoC,CAAC;AAAA,IAC1F,CAAC;AAED,UAAMC,WAAU,iBAAiB,oBAAoB,UAAU;AAC/D,eAAW,CAAC,MAAM,cAAc,WAAW,QAAQ,KAAKA,UAAS;AAC/D,UAAI,iBAAiB,UAAU;AAC7B,eAAO;AAAA,UACL;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,UACKD,KAAI,CAAC,EAAE,aAAa,MAAM;AAC7B;AAAA,cACE;AAAA,gBACE,UAAU;AAAA,gBACV,aAAa,sBACX,YAAY,aAAa,YAAY,CACvC;AAAA,gBACA,OAAO,CAAC;AAAA,cACV;AAAA,YACF;AAAA,UACF,CAAC;AAAA,UACI;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACtDM,IAAM,iBAAqB,iBAAiB;AAAA,EACjD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,sBAAsB,EAAE,WAAU,YAAY,QAAQ;AACnE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,aAAS,qBAAqB,MAA+C;AAE3E,UAAI,CAAC,GAAG,sBAAsB,IAAI,EAAG,QAAO;AAE5C,UAAI,EAAE,GAAG,QAAQ,KAAK,MAAM,KAAK,GAAG,aAAa,KAAK,MAAM,GAAI,QAAO;AACvE,YAAM,aAAa,KAAK;AAExB,UACE,GAAG,mBAAmB,UAAU,KAAK,WAAW,kBAC/C,WAAW,cAAc,SAAS,GAAG,WAAW,eAC/C,WAAW,cAAc,SAAS,GAAG,WAAW,+BAChD,WAAW,cAAc,SAAS,GAAG,WAAW,iCAChD,WAAW,cAAc,SAAS,GAAG,WAAW,mBAClD,QAAO;AACT,aAAO;AAAA,IACT;AAEA,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AAEA,OAAG,aAAa,YAAY,iBAAiB;AAC7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAEvC,UAAI,CAAC,qBAAqB,IAAI,EAAG;AAEjC,YAAM,OAAO,YAAY,kBAAkB,KAAK,UAAU;AAE1D,YAAM,SAAS,OAAY,OAAO,WAAW,WAAW,MAAM,KAAK,UAAU,CAAC;AAC9E,UAAWE,QAAO,MAAM,GAAG;AAEzB,cAAM,yBAAyB,OAAO;AAAA,UACpC,WAAW,UAAU,MAAM,KAAK,UAAU;AAAA,UACrCC,QAAO,MAAM,WAAW,cAAc,MAAM,KAAK,UAAU,CAAC;AAAA,UAC5D;AAAA,QACP;AACA,YAAWC,QAAO,sBAAsB,GAAG;AAEzC,gBAAM,iBAAiB,OAAY,OAAO,WAAW,iBAAiB,MAAM,KAAK,UAAU,CAAC;AAC5F,gBAAM,OAAcF,QAAO,cAAc,IAAI,WAAW,iBAAiB,YAAY,aAAa,IAAI;AACtG,iBAAO;AAAA,YACL,UAAU;AAAA,YACV,aAAa,GAAG,IAAI;AAAA,YACpB,OAAO,CAAC;AAAA,UACV,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC/DM,IAAM,wBAA4B,iBAAiB;AAAA,EACxD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,6BAA6B,EAAE,WAAU,YAAY,QAAQ;AAC1E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,YAAM,eAA0C,CAAC;AAEjD,UAAI,GAAG,mBAAmB,IAAI,KAAK,KAAK,QAAQ,KAAK,kBAAkB,KAAK,iBAAiB;AAC3F,cAAM,WAAW,YAAY,oBAAoB,KAAK,IAAI;AAC1D,YAAI,UAAU;AACZ,gBAAM,OAAO,YAAY,gBAAgB,QAAQ;AACjD,uBAAa,KAAK,CAAC,MAAM,KAAK,IAAK,CAAC;AAAA,QACtC;AAAA,MACF,OAAO;AACL,WAAG,aAAa,MAAM,iBAAiB;AACvC;AAAA,MACF;AAGA,iBAAW,CAAC,MAAM,QAAQ,KAAK,cAAc;AAC3C,eAAO;AAAA,UACL,WAAW,WAAW,MAAM,IAAI;AAAA,UAC3BG,KAAI,MAAM;AACb,mBAAO;AAAA,cACL,UAAU;AAAA,cACV,aACE;AAAA,cACF,OAAO,CAAC;AAAA,YACV,CAAC;AAAA,UACH,CAAC;AAAA,UACIC,QAAO,MAAW,KAAK,MAAM,GAAG,aAAa,MAAM,iBAAiB,CAAC,CAAC;AAAA,UACtE;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AChDM,IAAM,mBAAuB,iBAAiB;AAAA,EACnD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,wBAAwB,EAAE,WAAU,YAAY,QAAQ;AAErE,UAAM,+BAA+B,OAAY,QAAqC,4BAA4B;AAClH,QAAI,6BAA6B,wBAAwB,WAAW,EAAG;AAEvE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,UAAU,OAAY,QAAsB,iBAAiB;AAEnE,UAAM,qBAAmC,uBAAuB,EAAE;AAClE,UAAM,4BAA2C,8BAA8B,WAAW;AAC1F,UAAM,sBAA4B;AAAA,MAChC,6BAA6B,wBAAwB;AAAA,QAAI,CAAC,gBACxD,QAAQ,qBAAqB,SAAS,YAAY,WAAW;AAAA,MAC/D;AAAA,IACF;AAEA,UAAM,6BAA6B,CACjC,YACG;AACH,UAAI,EAAE,sBAAsB,2BAA4B;AAExD,YAAM,oBAAoB,GAAG,aAAa,SAAS,CAAC,SAAS,GAAG,oBAAoB,IAAI,CAAC;AACzF,UAAI,CAAC,kBAAmB;AACxB,UAAI,CAAC,GAAG,gBAAgB,kBAAkB,eAAe,EAAG;AAC5D,YAAM,eAAe,kBAAkB;AACvC,UAAI,CAAC,aAAc;AACnB,YAAM,gBAAgB,aAAa;AACnC,UAAI,CAAC,cAAe;AACpB,UAAI,CAAC,GAAG,eAAe,aAAa,EAAG;AAEvC,YAAM,mBAAmB,kBAAkB,gBAAgB;AAC3D,UAAI,oBAAoB,QAAQ,iBAAiB,YAAY,CAAC,MAAM,GAAI;AACxE,YAAM,eAAe,0BAA0B,kBAAkB,eAAe;AAChF,UAAI,CAAC,aAAc;AACnB,UAAI,CAAC,aAAa,QAAS;AAC3B,YAAMC,cAAa,QAAQ,oBAAoB,iBAAiB;AAChE,UAAI,CAACA,YAAY;AAEjB,YAAM,gBAAgB,QAAQ,gBAAgB,QAAQ;AACtD,YAAM,cAAc,QAAQ,QAAQ,QAAQ;AAC5C,YAAM,cAAc,GAAG,OAAO,WAAW;AAGzC,UAAI,CAAC,GAAG,aAAa,aAAa,EAAG;AACrC,YAAM,eAAe,GAAG,OAAO,aAAa;AAC5C,UAAI,CAAC,aAAc;AAEnB,YAAM,mBAAmB,aAAa,QAAQ,IAAI,GAAG,yBAAyB,YAAY,CAAC;AAC3F,UAAI,CAAC,iBAAkB;AAEvB,UAAI,EAAE,iBAAiB,gBAAgB,iBAAiB,aAAa,WAAW,GAAI;AAEpF,YAAM,kBAAkB,iBAAiB,aAAa,CAAC;AACvD,UAAI,CAAC,GAAG,kBAAkB,eAAe,EAAG;AAE5C,YAAM,oBAAoB,gBAAgB;AAC1C,UAAI,CAAC,GAAG,oBAAoB,iBAAiB,EAAG;AAEhD,UAAI,CAAC,kBAAkB,gBAAiB;AACxC,YAAM,uBAAuB,0BAA0B,kBAAkB,eAAe;AACxF,UAAI,CAAC,qBAAsB;AAE3B,UAAI,CAAC,qBAAqB,iBAAkB;AAC5C,YAAM,qBAAqB,QAAQ,oBAAoB,qBAAqB,gBAAgB;AAC5F,UAAI,CAAC,mBAAoB;AACzB,YAAM,sBAAsB;AAAA,QAC1B,QAAQ,mBAAmB;AAAA,QAC3BA;AAAA,QACAA,YAAW;AAAA,QACX,mBAAmB;AAAA,QACnB;AAAA,MACF;AAEA,UAAI,oBAAoB,YAAY,EAAE,QAAQ,iBAAiB,YAAY,IAAI,GAAG,MAAM,GAAI;AAC5F,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,YAAM,SAAS,KAAK;AAEpB,UAAI,EAAE,GAAG,kBAAkB,IAAI,KAAK,GAAG,eAAe,MAAM,IAAI;AAC9D,WAAG,aAAa,MAAM,iBAAiB;AACvC;AAAA,MACF;AAEA,YAAM,SAAS,2BAA2B,IAAI;AAC9C,UAAI,CAAC,OAAQ;AACb,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI;AAEJ,aAAO;AAAA,QACL,UAAU;AAAA,QACV,aAAa,gCAAgC,gBAAgB;AAAA,QAC7D,OAAO;AAAA,UACL;AAAA,YACE,SAAS;AAAA,YACT,aAAa,eAAe,WAAW,SAAS,mBAAmB;AAAA,YACnE,OAAY,IAAI,aAAY;AAC1B,oBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,oBAAM,YAAY,GAAG,QAAQ;AAAA,gBAC3B;AAAA,gBACA,GAAG,QAAQ;AAAA,kBACT,aAAa,cAAc,KAAK;AAAA,kBAChC;AAAA,kBACA,GAAG,QAAQ,sBAAsB,GAAG,QAAQ,iBAAiB,WAAW,CAAC;AAAA,gBAC3E;AAAA,gBACA,GAAG,QAAQ,oBAAoB,mBAAmB;AAAA,cACpD;AAEA,kBAAI,cAAc,SAAS,WAAW,GAAG;AACvC,8BAAc;AAAA,kBACZ;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF;AAAA,cACF,OAAO;AACL,8BAAc,gBAAgB,YAAY,mBAAmB,SAAS;AACtE,8BAAc;AAAA,kBACZ;AAAA,kBACA;AAAA,kBACA,GAAG,QAAQ;AAAA,oBACT;AAAA,oBACA,cAAc,SAAS,OAAO,CAAC,MAAM,MAAM,IAAI;AAAA,kBACjD;AAAA,gBACF;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH,CAAC;;;AC/JM,IAAM,sBAA0B,iBAAiB;AAAA,EACtD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,2BAA2B,EAAE,WAAU,YAAY,QAAQ;AACxE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,0BAA+B;AAAA,MAC9B,GAAG,qCAAqC;AAAA,QAC3C,WAAUC,UAAkB,YAAqB;AAC/C,gBAAM,aAAa,YAAY,oBAAoBA,QAAO;AAE1D,cAAI,WAAW,SAAS,EAAG,QAAO,CAAC;AAEnC,gBAAM,SAAS,oBAAI,IAAqB;AACxC,cAAI,yBAAoD;AACxD,cAAI,gBAAgB;AACpB,qBAAW,YAAY,YAAY;AAEjC,kBAAM,sBAAsB,YAAY,0BAA0B,UAAU,UAAU;AACtF,gBAAI,oBAAyC;AAC7C,mBAAO;AAAA,cACL,WAAW,WAAW,qBAAqB,UAAU;AAAA,cAChDC,KAAI,CAAC,MAAM,oBAAoB,EAAE,CAAC;AAAA,cAClCC,QAAO,MAAM;AAChB,sBAAM,gCAAgC,YAAY;AAAA,kBAChD;AAAA,kBACA,GAAG,cAAc;AAAA,gBACnB;AACA,oBAAI,8BAA8B,WAAW,GAAG;AAC9C,yBAAO;AAAA,oBACL,WAAW;AAAA,sBACT,YAAY,yBAAyB,8BAA8B,CAAC,CAAC;AAAA,sBACrE;AAAA,oBACF;AAAA,oBACKD,KAAI,CAAC,MAAM;AACd,0CAAoB,EAAE;AAAA,oBACxB,CAAC;AAAA,kBACH;AAAA,gBACF;AACA,uBAAY;AAAA,cACd,CAAC;AAAA,cACI;AAAA,YACP;AAEA,gBAAI,mBAAmB;AACrB;AACA,oBAAM,EAAE,WAAW,IAAI,OAAO,iBAAiB;AAAA,gBAC7C;AAAA,gBACA;AAAA,gBACA,CAAC,SAAS;AAER,sBAAI,KAAK,QAAQ,GAAG,UAAU,MAAO,QAAY,QAAQ,IAAI;AAE7D,yBAAO;AAAA,oBACL,WAAW,UAAU,MAAM,UAAU;AAAA,oBAChCA,KAAI,MAAM,IAAI;AAAA,oBACdC,QAAO,MAAW,QAAQ,KAAK,CAAC;AAAA,kBACvC;AAAA,gBACF;AAAA,cACF;AACA,kBAAI,CAAC,wBAAwB;AAC3B,yCAAyB;AAAA,cAC3B,OAAO;AACL,yCAA+B,aAAa,wBAAwB,UAAU;AAC9E,oBAAI,uBAAuB,WAAW,EAAG,QAAO,CAAC;AAAA,cACnD;AAAA,YACF;AAAA,UACF;AAEA,cAAI,0BAA0B,uBAAuB,SAAS,KAAK,iBAAiB,GAAG;AACrF,mBAAO,uBAAuB,IAAI,CAAC,QAAQ,OAAO,IAAI,GAAG,CAAE,EAAE;AAAA,cAC3D,CAAC,SAAS;AACR,oBAAIC,UAAS,KAAK;AAClB,oBAAIA,WAAUA,QAAO,QAAQ,GAAG,YAAY,OAAO;AACjD,kBAAAA,UAAS,YAAY,iBAAiBA,OAAM;AAAA,gBAC9C;AACA,uBAAO,EAAEA,QAAO,gBAAgB,CAAC,GAAG,KAAK,CAAC,gBAAgB;AACxD,wBAAM,oBAAoB,QAAQ,oBAAoB,WAAW;AACjE,sBAAI,CAAC,kBAAmB,QAAO;AAC/B,yBAAQ,kBAAkB,KAAK,UAAU,YAAY,KAAK,YAAY,GAAG,EAAE,YAAY,EAAE;AAAA,oBACvF;AAAA,kBACF,IAAI;AAAA,gBACN,CAAC;AAAA,cACH;AAAA,YACF;AAAA,UACF;AACA,iBAAO,CAAC;AAAA,QACV;AAAA,MACF;AAAA,MACA;AAAA,MACA,CAAC,GAAGH,aAAYA;AAAA,IAClB;AAEA,aAAS,0BAA0B,MAAe,cAA8B;AAC9E,UAAI,aAAa,WAAW,EAAG;AAC/B,aAAO;AAAA,QACL,UAAU;AAAA,QACV,aAAa,+BACX,aAAa,IAAI,CAAC,MAAM,YAAY,aAAa,CAAC,CAAC,EAAE,KAAK,KAAK,CACjE;AAAA;AAAA;AAAA,QACA,OAAO,CAAC;AAAA,MACV,CAAC;AAAA,IACH;AAEA,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAG/B,YAAM,eAA4D,CAAC;AACnE,UACE,GAAG,iBAAiB,IAAI,KAAK,GAAG,2BAA2B,KAAK,UAAU,KAC1E,GAAG,aAAa,KAAK,WAAW,IAAI,KAAK,GAAG,OAAO,KAAK,WAAW,IAAI,MAAM,cAC7E;AACA,qBAAa,KAAK,CAAC,YAAY,kBAAkB,IAAI,GAAG,IAAI,CAAC;AAAA,MAC/D,WAAW,GAAG,mBAAmB,IAAI,KAAK,KAAK,QAAQ,KAAK,iBAAiB;AAC3E,cAAM,WAAW,YAAY,oBAAoB,KAAK,IAAI;AAC1D,YAAI,UAAU;AACZ,gBAAM,OAAO,YAAY,gBAAgB,QAAQ;AACjD,uBAAa,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC;AAAA,QACrC;AAAA,MACF,OAAO;AACL,WAAG,aAAa,MAAM,iBAAiB;AACvC;AAAA,MACF;AAGA,iBAAW,CAAC,MAAM,QAAQ,KAAK,cAAc;AAC3C,eAAO;AAAA,UACL,WAAW,WAAW,MAAM,IAAI;AAAA,UAC3BI;AAAA,YAAQ,CAAC,EAAE,QAAQ,MACtB;AAAA,cACE,wBAAwB,SAAS,IAAI;AAAA,cAChCH;AAAA,gBAAI,CAAC,iBACR,0BAA0B,UAAgB,KAAK,cAAc,iBAAiB,sBAAsB,CAAC;AAAA,cACvG;AAAA,YACF;AAAA,UACF;AAAA,UACKC,QAAO,MAAW,KAAK,MAAM,GAAG,aAAa,MAAM,iBAAiB,CAAC,CAAC;AAAA,UACtE;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC5JM,IAAM,4BAAgC,iBAAiB;AAAA,EAC5D,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,iCAAiC,EAAE,WAAU,YAAY,QAAQ;AAC9E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,UAAU,OAAY,QAAqC,4BAA4B;AAE7F,UAAM,cAA8B,CAAC,UAAU;AAC/C,UAAM,qBAAqB,CAAC,SAAkB;AAC5C,kBAAY,QAAQ,IAAI;AACxB,aAAO;AAAA,IACT;AAEA,UAAM,iBAAiB,oBAAI,QAA2C;AAEtE,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAE/B,UAAI,GAAG,iBAAiB,IAAI,KAAK,KAAK,UAAU,WAAW,KAAK,KAAK,QAAQ;AAE3E,cAAM,cAAc,eAAe,IAAI,KAAK,MAAM,KAAK,CAAC;AACxD,uBAAe,IAAI,MAAM,YAAY,OAAO,IAAI,CAAC;AAAA,MACnD,WAAW,KAAK,UAAU,eAAe,IAAI,KAAK,MAAM,KAAK,GAAG,aAAa,IAAI,GAAG;AAElF,cAAM,cAAoC,eAAe,IAAI,KAAK,MAAM,KAAK,CAAC;AAC9E,cAAM,sBAAsB,YAAY,MAAM;AAC9C,oBAAY,KAAK,IAAI;AACrB,eAAO,YAAY,SAAS,QAAQ,qBAAqB;AACvD,gBAAM,UAAU,YAAY,IAAI;AAChC,gBAAM,aAAa,YAAY,kBAAkB,OAAO;AACxD,gBAAM,eAAe,OAAO,KAAK,WAAW,aAAa,YAAY,OAAO,GAAQG,QAAO,MAAW,KAAK,CAAC;AAC5G,cAAI,cAAc;AAChB,mBAAO;AAAA,cACL,UAAU,YAAY,CAAC;AAAA,cACvB,aAAa;AAAA,cACb,OAAO,CAAC;AAAA,gBACN,SAAS;AAAA,gBACT,aAAa;AAAA,gBACb,OAAY,IAAI,aAAY;AAC1B,wBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAGrE,gCAAc;AAAA,oBACZ;AAAA,oBACA,YAAY,CAAC;AAAA,oBACb,GAAG,QAAQ;AAAA,sBACT,GAAG,QAAQ;AAAA,wBACT;AAAA,wBACA;AAAA,sBACF;AAAA,sBACA;AAAA,sBACA;AAAA,wBACE;AAAA,wBACM,OAAO,GAAG,gBAAgB;AAAA,wBAC1BC,KAAI,CAAC,SAAS,KAAK,UAAU;AAAA,wBAC7B;AAAA,sBACR;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF,CAAC;AAAA,cACH,CAAC;AAAA,YACH,CAAC;AAED,gCAAoB,QAAQ,CAACC,UAAS,eAAe,OAAOA,KAAI,CAAC;AACjE;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAGA,SAAG,aAAa,MAAM,kBAAkB;AAAA,IAC1C;AAAA,EACF,CAAC;AACH,CAAC;;;AC7EM,IAAM,uBAA2B,iBAAiB;AAAA,EACvD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,4BAA4B,EAAE,WAAU,YAAY,QAAQ;AACzE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,UAAM,8BAA8B,CAClC,MACA,cACA,WACA,aAEA;AAAA,MACO;AAAA,QACH,WAAW,WAAW,cAAc,IAAI;AAAA,QACxC,WAAW,WAAW,UAAU,SAAS;AAAA,MAC3C;AAAA,MACKC;AAAA,QAAI,CAAC,CAAC,gBAAgB,UAAU,MACnC,iBAAiB;AAAA,UACf,WAAW;AAAA,UACX,eAAe;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AAEF,UAAM,YAA0B,KAAK,iBAAiB,sBAAsB;AAE5E,UAAMC,WAAc,oCAAoC,UAAU,GAAG,kBACnE,iBAAiB,oBAAoB,UAAU;AACjD,eAAW,CAAC,MAAM,cAAc,WAAW,QAAQ,KAAKA,UAAS;AAE/D,UAAI,iBAAiB,UAAU;AAC7B,eAAO;AAAA,UACL;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,UACKD;AAAA,YAAI,CAAC,iBACR,aAAa,SAAS,IACpB;AAAA,cACE;AAAA,gBACE,UAAU;AAAA,gBACV,aAAa,YACX,UAAU,YAAY,EAAE,IAAI,CAAC,MAAM,YAAY,aAAa,CAAC,CAAC,EAAE,KAAK,KAAK,CAC5E;AAAA,gBACA,OAAO,CAAC;AAAA,cACV;AAAA,YACF,IACE;AAAA,UACN;AAAA,UACK;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACzDM,IAAM,qBAAyB,iBAAiB;AAAA,EACrD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,0BAA0B,EAAE,WAAU,YAAY,QAAQ;AACvE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,yBAAyB,QAAQ;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAEL,UAAM,mBAAmB,CAAC,YACxB,GAAG,QAAQ;AAAA,MACT,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,iBAAiB,sBAAsB;AAAA,QAClD;AAAA,MACF;AAAA,MACA;AAAA,MACA,CAAC,GAAG,QAAQ,oBAAoB,OAAO,CAAC;AAAA,IAC1C;AAEF,UAAM,4BAA4B,CAChC,MACA,cACA,WACA,aAEA;AAAA,MACO;AAAA,QACH,WAAW,WAAW,cAAc,IAAI;AAAA,QACxC,WAAW,WAAW,UAAU,SAAS;AAAA,MAC3C;AAAA,MACKE;AAAA,QAAI,CAAC,CAAC,gBAAgB,UAAU,MACnC;AAAA,UACE,iBAAiB;AAAA,YACf,WAAW;AAAA,YACX,eAAe;AAAA,UACjB;AAAA,UACA,CAAC,uBAAuB,EAAE,mBAAmB,mBAAmB,eAAe,EAAE;AAAA,QACnF;AAAA,MACF;AAAA,IACF;AAEF,UAAM,YAA0B,KAAK,iBAAiB,sBAAsB;AAE5E,UAAMC,WAAc,oCAAoC,UAAU,GAAG,kBACnE,iBAAiB,oBAAoB,UAAU;AACjD,eAAW,CAAC,MAAM,cAAc,WAAW,QAAQ,KAAKA,UAAS;AAE/D,UAAI,iBAAiB,UAAU;AAC7B,eAAO;AAAA,UACL;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,UACKD,KAAI,CAAC,WAAW;AACnB,gBAAI,OAAO,kBAAkB,WAAW,EAAG;AAC3C,kBAAM,QAAsD,CAAC;AAE7D,gBAAI,GAAG,aAAa,SAAS,KAAK,OAAO,kBAAkB,QAAQ,GAAG,UAAU,OAAO;AACrF,oBAAM,KAAK;AAAA,gBACT,SAAS;AAAA,gBACT,aAAa;AAAA,gBACb,OAAY,IAAI,aAAY;AAC1B,wBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,gCAAc;AAAA,oBACZ;AAAA,oBACA,GAAG,kBAAkB,WAAW,UAAU;AAAA,oBAC1C,yBAAyB;AAAA,kBAC3B;AACA,gCAAc,WAAW,YAAY,UAAU,KAAK,UAAU;AAC9D,gCAAc;AAAA,oBACZ;AAAA,oBACA,UAAU;AAAA,oBACV,iBAAiB,gCAAgC;AAAA,kBACnD;AACA,gCAAc,WAAW,YAAY,UAAU,KAAK,GAAG;AAAA,gBACzD,CAAC;AAAA,cACH,CAAC;AAAA,YACH;AAEA,gBAAI,GAAG,aAAa,SAAS,GAAG;AAC9B,oBAAM,sBAAsB;AAAA,gBAC1B,OAAO;AAAA,gBACOA,KAAI,CAAC,MAAM,YAAY,kBAAkB,GAAG,MAAM,CAAC;AAAA,gBACnD,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAAA,gBACjBA,KAAI,CAAC,MAAM,YAAY,0BAA0B,GAAG,SAAS,CAAC;AAAA,gBAC9D,OAAO,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,GAAG,UAAU,QAAQ;AAAA,gBAChDA,KAAI,CAAC,MAAM,YAAY,eAAe,GAAG,QAAW,GAAG,iBAAiB,YAAY,CAAC;AAAA,gBACrF,OAAO,CAAC,MAAM,CAAC,CAAC,KAAK,GAAG,kBAAkB,CAAC,CAAC;AAAA,gBAC5CA,KAAI,CAAC,MAAM,EAAE,OAAO;AAAA,gBACpB,OAAO,CAAC,MAAM,GAAG,oBAAoB,CAAC,CAAC;AAAA,gBACvCA,KAAI,CAAC,MAAM,EAAE,IAAI;AAAA,gBACjB,KAAWE,OAAM;AAAA,gBACjBF;AAAA,kBAAI,CAAC,MACjB,GAAG,QAAQ;AAAA,oBACT,GAAG,QAAQ,iBAAiB,CAAC;AAAA,oBAC7B,GAAG,QAAQ;AAAA,sBACT;AAAA,sBACA;AAAA,sBACA,CAAC;AAAA,sBACD;AAAA,sBACA;AAAA,sBACA,iBAAiB,yCAAyC,CAAC,EAAE;AAAA,oBAC/D;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AACA,kBAAI,oBAAoB,WAAW,OAAO,kBAAkB,QAAQ;AAClE,sBAAM,KAAK;AAAA,kBACT,SAAS;AAAA,kBACT,aAAa;AAAA,kBACb,OAAY,IAAI,aAAY;AAC1B,0BAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,kCAAc;AAAA,sBACZ;AAAA,sBACA,GAAG,kBAAkB,WAAW,UAAU;AAAA,sBAC1C,yBAAyB;AAAA,oBAC3B;AACA,kCAAc,WAAW,YAAY,UAAU,KAAK,IAAI;AACxD,kCAAc;AAAA,sBACZ;AAAA,sBACA,UAAU;AAAA,sBACV,GAAG,QAAQ,8BAA8B,mBAAmB;AAAA,oBAC9D;AACA,kCAAc,WAAW,YAAY,UAAU,KAAK,GAAG;AAAA,kBACzD,CAAC;AAAA,gBACH,CAAC;AAAA,cACH;AAAA,YACF;AAEA,kBAAM,YAAY,UAAU,OAAO,iBAAiB,EAAE,IAAI,CAAC,MAAM,YAAY,aAAa,CAAC,CAAC;AAC5F;AAAA,cACE;AAAA,gBACE,UAAU;AAAA,gBACV,aAAa,YAAY,UAAU,KAAK,KAAK,CAAC;AAAA,gBAC9C;AAAA,cACF;AAAA,YACF;AAAA,UACF,CAAC;AAAA,UACI;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC9JM,IAAM,iCAAqC,iBAAiB;AAAA,EACjE,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,sCAAsC,EAAE,WAAU,YAAY,QAAQ;AACnF,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAG/B,UAAI,GAAG,mBAAmB,IAAI,KAAK,KAAK,QAAQ,KAAK,iBAAiB;AACpE,cAAM,gBAAgB,OAAO;AAAA,UAC3B,WAAW,qBAAqB,IAAI;AAAA,UAC/BG,QAAO,MAAW,KAAK;AAAA,QAC9B;AAEA,YAAI,eAAe;AACjB,gBAAM,EAAE,WAAW,QAAQ,IAAI;AAG/B,gBAAM,cAAc,YAAY,oBAAoB,SAAS;AAC7D,cAAI,aAAa;AACf,kBAAM,YAAY,YAAY,gBAAgB,WAAW;AAGzD,kBAAM,6BAA6B,YAAY,kBAAkB,WAAW,4BAA4B;AACxG,kBAAM,kBAAkB,8BAA8B,YAAY,kBAAkB,WAAW,SAAS;AAExG,gBAAI,iBAAiB;AACnB,oBAAM,cAAc,YAAY,0BAA0B,iBAAiB,IAAI;AAG/E,oBAAM,cAAc,OAAO;AAAA,gBACzB,WAAW,UAAU,aAAa,IAAI;AAAA,gBACjCA,QAAO,MAAW,KAAK;AAAA,cAC9B;AAEA,kBAAI,aAAa;AAEf,sBAAM,iBAAiB,oBAAI,IAAqB;AAChD,sBAAM,eAAe,CAAC,SAAuB,SAAS,KAAK,QAAQ,GAAG,UAAU,WAAW,CAAC;AAG5F,sBAAM,EAAE,YAAY,gBAAgB,IAAI,OAAO,iBAAiB;AAAA,kBAC9D;AAAA,kBACA,YAAY;AAAA,kBACZ;AAAA,gBACF;AAGA,sBAAM,kBAAkB,oBAAI,IAAY;AAExC,sBAAM,cAAc,YAAY,kBAAkB,OAAO;AACzD,sBAAM,uBAAuB,YAAY,kBAAkB,aAAa,cAAc;AACtF,oBAAI,QAAwB,CAAC;AAE7B,oBAAI,sBAAsB;AACxB,wBAAM,oBAAoB,YAAY,0BAA0B,sBAAsB,OAAO;AAC7F,wBAAM,kBAAkB,YAAY,mBAAmB,mBAAmB,GAAG,UAAU,MAAM;AAC7F,0BAAQ,kBAAkB,iBAAiB,mBAAmB,eAAe,IAAI,CAAC;AAAA,gBACpF;AAGA,2BAAW,WAAW,OAAO;AAE3B,wBAAM,iBAAiB,OAAO;AAAA,oBAC5B,WAAW,UAAU,SAAS,OAAO;AAAA,oBAChCA,QAAO,MAAW,KAAK;AAAA,kBAC9B;AAEA,sBAAI,gBAAgB;AAElB,0BAAM,EAAE,WAAW,IAAI,OAAO,iBAAiB;AAAA,sBAC7C;AAAA,sBACA,eAAe;AAAA,sBACf;AAAA,oBACF;AAEA,+BAAW,SAAS,YAAY;AAC9B,sCAAgB,IAAI,KAAK;AAAA,oBAC3B;AAAA,kBACF;AAAA,gBACF;AAGA,sBAAM,iBAAiB,gBAAgB,OAAO,CAAC,UAAU,CAAC,gBAAgB,IAAI,KAAK,CAAC;AAGpF,oBAAI,eAAe,SAAS,GAAG;AAC7B,wBAAM,eAAe,eAAe,IAAI,CAAC,UAAU,eAAe,IAAI,KAAK,CAAE;AAC7E,wBAAM,mBAAmB,aAAa,IAAI,CAAC,MAAM,YAAY,aAAa,CAAC,CAAC;AAE5E,wBAAM,UAAU,iBAAiB,WAAW,IACxC,YAAY,iBAAiB,CAAC,CAAC,mDAC/B,YACA,iBAAiB,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI,CACjD;AAEF,yBAAO;AAAA,oBACL,UAAU;AAAA,oBACV,aAAa;AAAA,oBACb,OAAO,CAAC;AAAA,kBACV,CAAC;AAAA,gBACH;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,SAAG,aAAa,MAAM,iBAAiB;AAAA,IACzC;AAAA,EACF,CAAC;AACH,CAAC;;;AC5HM,IAAM,yBAA6B,iBAAiB;AAAA,EACzD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,8BAA8B,EAAE,WAAU,YAAY,QAAQ;AAC3E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAGvC,UACE,GAAG,kBAAkB,IAAI,KAAK,KAAK,cACnC,KAAK,eACL;AAEA,cAAM,OAAO,YAAY,kBAAkB,KAAK,UAAU;AAC1D,cAAM,cAAc,OAAY,OAAO,WAAW,WAAW,MAAM,KAAK,UAAU,CAAC;AAEnF,YAAWC,QAAO,WAAW,KAAK,YAAY,MAAM,EAAE,QAAQ,GAAG,UAAU,OAAO;AAEhF,gBAAM,qCAAqC,GAAG;AAAA,YAC5C;AAAA,YACA,CACE,MACI,GAAG,qBAAqB,CAAC,KAAK,GAAG,sBAAsB,CAAC,KAAK,GAAG,oBAAoB,CAAC,KACzF,GAAG,kBAAkB,CAAC,KAAK,GAAG,iBAAiB,CAAC;AAAA,UACpD;AAGA,cACE,sCAAsC,CAAC,GAAG,kBAAkB,kCAAkC,KAC9F,CAAC,GAAG,iBAAiB,kCAAkC,GACvD;AAEA,gBAAI,sCAAsC,mCAAmC,QAAQ;AACnF,oBAAM,gBAAgB,mCAAmC;AAEzD,oBAAM,gBAAgB,OAAO;AAAA,gBAC3B,WAAW,UAAU,aAAa;AAAA,gBAC7BC,QAAO,MAAM,WAAW,oBAAoB,aAAa,CAAC;AAAA,gBAC1DA,QAAO,MAAM,WAAW,YAAY,aAAa,CAAC;AAAA,gBAClD;AAAA,cACP;AACA,kBAAWD,QAAO,aAAa,GAAG;AAEhC,sBAAM,MAAM,KAAK,aACf,CAAC;AAAA,kBACC,SAAS;AAAA,kBACT,aAAa;AAAA,kBACb,OAAY,IAAI,aAAY;AAC1B,0BAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,kCAAc;AAAA,sBACZ;AAAA,sBACA;AAAA,sBACA,GAAG,QAAQ;AAAA,wBACT;AAAA,sBACF;AAAA,oBACF;AAAA,kBACF,CAAC;AAAA,gBACH,CAAC,IACD,CAAC;AAEH,uBAAO;AAAA,kBACL,UAAU;AAAA,kBACV,aACE;AAAA,kBACF,OAAO;AAAA,gBACT,CAAC;AAAA,cACH;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACxFM,IAAM,8BAAkC,iBAAiB;AAAA,EAC9D,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,mCAAmC,EAAE,WAAU,YAAY,QAAQ;AAChF,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,mBAAmB,oBAAI,IAAY;AACzC,UAAM,eAAe,oBAAI,IAAwB;AAEjD,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAGvC,UACE,GAAG,kBAAkB,IAAI,KAAK,KAAK,cACnC,KAAK,kBAAkB,QACvB;AAEA,cAAM,mBAAmB,GAAG;AAAA,UAC1B;AAAA,UACA,CAAC,MAAO,GAAG,qBAAqB,CAAC,KAAK,GAAG,sBAAsB,CAAC,KAAK,GAAG,oBAAoB,CAAC;AAAA,QAC/F;AAGA,YAAI,oBAAoB,iBAAiB,QAAQ;AAC/C,gBAAM,gBAAgB,iBAAiB;AAEvC,iBAAO;AAAA,YACL,WAAW,UAAU,aAAa;AAAA,YAC7BE,QAAO,MAAM,WAAW,oBAAoB,aAAa,CAAC;AAAA,YAC1DA,QAAO,MAAM,WAAW,YAAY,aAAa,CAAC;AAAA,YAClDC,KAAI,CAAC,EAAE,kBAAkB,MAAM;AAClC,kBAAI,mBAAmB;AACrB,iCAAiB,IAAI,GAAG,kBAAkB,mBAAmB,QAAQ,oBAAoB,IAAI,CAAE,CAAC;AAAA,cAClG;AACA,2BAAa,IAAI,IAAI;AAAA,YACvB,CAAC;AAAA,YACI;AAAA,UACP;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,qBAAiB;AAAA,MAAQ,CAAC,QACxB,OAAO;AAAA,QACL,UAAW,EAAE,KAAK,KAAK,MAAM,WAAW,OAAO;AAAA,QAC/C,aAAa;AAAA,QACb,OAAO,CAAC;AAAA,MACV,CAAC;AAAA,IACH;AACA,iBAAa,QAAQ,CAAC,SAAS;AAC7B,YAAM,MAAM,KAAK,aACf,CAAC;AAAA,QACC,SAAS;AAAA,QACT,aAAa;AAAA,QACb,OAAY,IAAI,aAAY;AAC1B,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,wBAAc;AAAA,YACZ;AAAA,YACA;AAAA,YACA,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ,YAAY,GAAG,WAAW,aAAa;AAAA,cAClD,KAAK;AAAA,YACP;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH,CAAC,IACD,CAAC;AAEH,aAAO;AAAA,QACL,UAAU;AAAA,QACV,aAAa;AAAA,QACb,OAAO;AAAA,MACT,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACH,CAAC;;;ACxFM,IAAM,wBAA4B,iBAAiB;AAAA,EACxD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,6BAA6B,EAAE,WAAU,YAAY,QAAQ;AAC1E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,yBAAyB,QAAQ;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAEL,UAAM,wBAAwB,QAAQ;AAAA,MACpC;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAEL,UAAM,0BAA0B,CAAC,SAAkB;AACjD,UACE,GAAG,iBAAiB,IAAI,KACxB,KAAK,UAAU,SAAS,GACxB;AACA,cAAM,QAAQ,KAAK,UAAU,CAAC;AAC9B,cAAM,OAAO,YAAY,kBAAkB,KAAK;AAChD,eAAO;AAAA,UACL,WAAW,iCAAiC,SAAS,EAAE,KAAK,UAAU;AAAA,UACjEC,SAAQ,MAAM,WAAW,UAAU,MAAM,KAAK,CAAC;AAAA,UAC/CC,KAAI,OAAO,EAAE,OAAO,KAAK,EAAE;AAAA,UAC3BC,QAAO,MAAW,KAAK;AAAA,QAC9B;AAAA,MACF;AACA,aAAY;AAAA,IACd;AAEA,UAAM,gBAAgB,CAAC,SAChB,IAAI,aAAY;AACnB,YAAM,EAAE,MAAAC,MAAK,IAAI,OAAO,WAAW,SAAS,IAAI;AAChD,UAAI,eAAe;AACnB,YAAM,iBAAkF,CAAC,CAAC,CAAC;AAC3F,iBAAW,WAAWA,OAAM;AAC1B,cAAM,gBAAgB,OAAQ,wBAAwB,OAAO;AAC7D,YAAI,eAAe;AACjB,yBAAe,YAAY,EAAE,KAAK,aAAa;AAAA,QACjD,OAAO;AACL;AACA,yBAAe,KAAK,CAAC,CAAC;AAAA,QACxB;AAAA,MACF;AAEA,iBAAW,SAAS,gBAAgB;AAClC,YAAI,MAAM,SAAS,EAAG;AACtB,eAAO;AAAA,UACL,UAAU,MAAM,CAAC,EAAE;AAAA,UACnB,aACE;AAAA,UACF,OAAO,CAAC;AAAA,YACN,SAAS;AAAA,YACT,aAAa;AAAA,YACb,OAAY,IAAI,aAAY;AAC1B,oBAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,4BAAc,YAAY,YAAY;AAAA,gBACpC,KAAK,GAAG,kBAAkB,MAAM,CAAC,EAAE,MAAM,UAAU;AAAA,gBACnD,KAAK,MAAM,MAAM,SAAS,CAAC,EAAE,KAAK;AAAA,cACpC,CAAC;AACD,oBAAM,UAAU,GAAG,QAAQ;AAAA,gBACzB,GAAG,QAAQ;AAAA,kBACT,GAAG,QAAQ,iBAAiB,sBAAsB;AAAA,kBAClD,GAAG,QAAQ,iBAAiB,SAAS;AAAA,gBACvC;AAAA,gBACA;AAAA,gBACA,CAAC,GAAG,QAAQ;AAAA,kBACV,GAAG,QAAQ;AAAA,oBACT,GAAG,QAAQ,iBAAiB,qBAAqB;AAAA,oBACjD,GAAG,QAAQ,iBAAiB,UAAU;AAAA,kBACxC;AAAA,kBACA;AAAA,kBACA,MAAM,IAAI,CAAC,MAAM,EAAE,KAAK;AAAA,gBAC1B,CAAC;AAAA,cACH;AACA,4BAAc,aAAa,YAAY,GAAG,kBAAkB,MAAM,CAAC,EAAE,MAAM,UAAU,GAAG,OAAO;AAAA,YACjG,CAAC;AAAA,UACH,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAEH,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAEvC,UAAI,GAAG,iBAAiB,IAAI,GAAG;AAC7B,eAAO,KAAK,cAAc,IAAI,GAAQ,MAAM;AAAA,MAC9C;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC3GM,IAAM,6BAAiC,iBAAiB;AAAA,EAC7D,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,kCAAkC,EAAE,WAAU,YAAY,QAAQ;AAC/E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,aAAS,gBAAgB,MAAwB;AAC/C,aAAO,iBAAiB,mBAAmB,IAAI,EAAE;AAAA,QAAK,CAACC,UACrD,CAAC,EACCA,MAAK,QAAQ,GAAG,UAAU,UAC1BA,MAAK,QAAQ,GAAG,UAAU,UAC1BA,MAAK,QAAQ,GAAG,UAAU,WAC1BA,MAAK,QAAQ,GAAG,UAAU,iBAC1BA,MAAK,QAAQ,GAAG,UAAU,iBAC1BA,MAAK,QAAQ,GAAG,UAAU,kBAC1BA,MAAK,QAAQ,GAAG,UAAU,aAC1BA,MAAK,QAAQ,GAAG,UAAU;AAAA,MAE9B;AAAA,IACF;AAEA,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAE/B,UAAI,GAAG,mBAAmB,IAAI,KAAK,KAAK,QAAQ,KAAK,iBAAiB;AACpE,cAAM,gBAAgB,OAAO;AAAA,UAC3B,WAAW,qBAAqB,IAAI;AAAA,UAC/BC,QAAO,MAAW,KAAK;AAAA,QAC9B;AAEA,YAAI,iBAAiB,cAAc,WAAW,GAAG,0BAA0B,cAAc,OAAO,GAAG;AACjG,gBAAM,UAAU,cAAc;AAE9B,qBAAW,YAAY,QAAQ,YAAY;AACzC,gBAAI,CAAC,GAAG,qBAAqB,QAAQ,KAAK,CAAC,GAAG,aAAa,SAAS,IAAI,GAAG;AACzE;AAAA,YACF;AAEA,kBAAM,eAAe,GAAG,OAAO,SAAS,IAAI;AAC5C,kBAAM,gBAAgB,SAAS;AAE/B,kBAAM,gBAAgB;AAAA,cACpB,UAAU,SAAS;AAAA,cACnB,aACE;AAAA,cACF,OAAO,CAAC;AAAA,YACV;AAEA,gBAAI,iBAAiB,WAAW;AAC9B,oBAAM,YAAY,YAAY,kBAAkB,aAAa;AAC7D,kBAAI,gBAAgB,SAAS,GAAG;AAC9B,uBAAO,aAAa;AAAA,cACtB;AAAA,YACF,WAAW,iBAAiB,QAAQ;AAClC,oBAAM,YAAY,YAAY,kBAAkB,aAAa;AAC7D,oBAAM,aAAa,YAAY,oBAAoB,WAAW,GAAG,cAAc,IAAI;AAEnF,yBAAW,aAAa,YAAY;AAClC,sBAAM,aAAa,YAAY,yBAAyB,SAAS;AACjE,oBAAI,gBAAgB,UAAU,GAAG;AAC/B,yBAAO,aAAa;AACpB;AAAA,gBACF;AAAA,cACF;AAAA,YACF,WAAW,iBAAiB,YAAY,iBAAiB,UAAU;AACjE,oBAAM,YAAY,YAAY,kBAAkB,aAAa;AAE7D,oBAAM,eAAe,OAAO;AAAA,gBAC1B,WAAW,WAAW,WAAW,aAAa;AAAA,gBACzCA,QAAO,MAAW,KAAK;AAAA,cAC9B;AAEA,kBAAI,cAAc;AAChB,oBAAI,gBAAgB,aAAa,CAAC,GAAG;AACnC,yBAAO,aAAa;AACpB;AAAA,gBACF;AAAA,cACF,OAAO;AACL,sBAAM,aAAa,YAAY,oBAAoB,WAAW,GAAG,cAAc,IAAI;AACnF,2BAAW,aAAa,YAAY;AAClC,wBAAM,aAAa,YAAY,yBAAyB,SAAS;AAEjE,wBAAM,qBAAqB,OAAO;AAAA,oBAChC,WAAW,WAAW,YAAY,aAAa;AAAA,oBAC1CA,QAAO,MAAW,KAAK;AAAA,kBAC9B;AAEA,sBAAI,sBAAsB,gBAAgB,mBAAmB,CAAC,GAAG;AAC/D,2BAAO,aAAa;AACpB;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,SAAG,aAAa,MAAM,iBAAiB;AAAA,IACzC;AAAA,EACF,CAAC;AACH,CAAC;;;ACpHM,IAAM,wBAA4B,iBAAiB;AAAA,EACxD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,6BAA6B,EAAE,WAAU,YAAY,SAAS;AAC3E,UAAM,qBAAqB,OAAW,yBAAyB,UAAU,UAAU;AACnF,eAAW,EAAE,SAAS,MAAAC,OAAM,MAAM,KAAK,oBAAoB;AACzD,aAAO;AAAA,QACD,mBAAmB,CAAC,OAAO,GAAG,YAAY,KAAK;AAAA,QAC9CC,KAAI,CAAC,eAAe;AACvB,cAAI,WAAW,SAASD,OAAM;AAC5B,oBAAQ;AAAA,cACN,UAAU;AAAA,cACV,aAAa,WAAW,QAAQ,IAAI;AAAA,cACpC,OAAO;AAAA,gBACL;AAAA,kBACE,SAAS;AAAA,kBACT,aAAa,UAAU,QAAQ,IAAI;AAAA,kBACnC,OAAO,WAAW;AAAA,gBACpB;AAAA,gBACA;AAAA,kBACE,SAAS;AAAA,kBACT,aAAa,eAAe,QAAQ,IAAI;AAAA,kBACxC,OAAO,WAAW;AAAA,gBACpB;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,QACIE;AAAA,UAAO,CAAC,MACN,KAAK,MAAM;AACd,oBAAQ;AAAA,cACN,UAAU;AAAA,cACV,aAAa,WAAW,QAAQ,IAAI,4BAA4B,EAAE,KAAK;AAAA,cACvE,OAAO,CAAC;AAAA,YACV,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,QACK;AAAA,MACP;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACvCM,IAAM,8BAAkC,iBAAiB;AAAA,EAC9D,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,mCAAmC,EAAE,WAAU,YAAY,QAAQ;AAChF,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAG/B,UAAI,GAAG,mBAAmB,IAAI,KAAK,KAAK,iBAAiB;AAEvD,YAAI,gBAAgB;AAEpB,mBAAW,kBAAkB,KAAK,iBAAiB;AACjD,cAAI,eAAe,UAAU,GAAG,WAAW,gBAAgB;AACzD,uBAAW,QAAQ,eAAe,OAAO;AACvC,oBAAM,iBAAiB,YAAY,kBAAkB,KAAK,UAAU;AAEpE,oBAAM,WAAW,OAAO;AAAA,gBACtB,WAAW,iBAAiB,gBAAgB,KAAK,UAAU;AAAA,gBACtDC,KAAI,MAAM,IAAI;AAAA,gBACdC,QAAO,MAAW,QAAQ,KAAK,CAAC;AAAA,cACvC;AAEA,kBAAI,UAAU;AACZ,gCAAgB;AAChB;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA,cAAI,cAAe;AAAA,QACrB;AAGA,YAAI,eAAe;AACjB,gBAAM,UAAU,KAAK;AACrB,qBAAW,UAAU,SAAS;AAC5B,gBAAI,GAAG,yBAAyB,MAAM,GAAG;AAEvC,oBAAM,iBAAiB;AAAA,gBACrB,SAAS;AAAA,gBACT,aAAa;AAAA,gBACb,OAAY,IAAI,aAAY;AAC1B,wBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,wBAAM,UAAsB,CAACC,UAAS;AACpC,wBACE,GAAG,sBAAsBA,KAAI,KAC7B,GAAG,iBAAiBA,MAAK,UAAU,KAAK,GAAG,QAAQA,MAAK,WAAW,UAAU,KAC7EA,MAAK,WAAW,WAAW,SAAS,GAAG,WAAW,cAClD;AACA,4BAAM,gBAAgB,GAAG,QAAQ;AAAA,wBAC/B,GAAG,QAAQ,iBAAiB,MAAM;AAAA,wBAClC;AAAA,wBACAA,MAAK,WAAW;AAAA,sBAClB;AACA,6BAAO,GAAG,QAAQ;AAAA,wBAChB;AAAA,wBACA,GAAG,QAAQ;AAAA,0BACT,CAAC,GAAG,QAAQ;AAAA,4BACV;AAAA,4BACA;AAAA,4BACA;AAAA,4BACA;AAAA,0BACF,CAAC;AAAA,0BACD,GAAG,UAAU;AAAA,wBACf;AAAA,sBACF;AAAA,oBACF;AACA,wBAAI,GAAG,QAAQA,KAAI,KAAKA,MAAK,SAAS,GAAG,WAAW,aAAa;AAC/D,6BAAO,GAAG,QAAQ,iBAAiB,OAAO;AAAA,oBAC5C;AACA,2BAAO,GAAG,eAAeA,OAAM,SAAS,GAAG,yBAAyB;AAAA,kBACtE;AACA,wBAAM,UAAU,QAAQ,OAAO,IAAK;AACpC,wBAAM,iBAAiB,GAAG,QAAQ;AAAA,oBAChC;AAAA,oBACA,QAAQ,WAAW,OAAO;AAAA,sBACxB,GAAG,QAAQ,sBAAsB,GAAG,QAAQ,iBAAiB,OAAO,CAAC;AAAA,oBACvE,CAAC;AAAA,kBACH;AAEA,wBAAM,YAAY,GAAG,QAAQ;AAAA,oBAC3B,GAAG,QAAQ,iCAAiC,GAAG,cAAc,SAAS,GAAG,cAAc,MAAM;AAAA,oBAC7F;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA,OAAO;AAAA,oBACP,OAAO;AAAA,oBACP,OAAO;AAAA,oBACP;AAAA,kBACF;AAEA,gCAAc,YAAY,YAAY,QAAQ,SAAS;AAAA,gBACzD,CAAC;AAAA,cACH;AAGA,qBAAO;AAAA,gBACL,UAAU;AAAA,gBACV,aACE;AAAA,gBACF,QAAQ,OAAO,OAAO,CAAC,cAAc,IAAI,CAAC,GAAG,OAAO,CAAC;AAAA,kBACnD,SAAS;AAAA,kBACT,aAAa;AAAA,kBACb,OAAY,IAAI,aAAY;AAC1B,0BAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,kCAAc,OAAO,YAAY,MAAM;AAAA,kBACzC,CAAC;AAAA,gBACH,CAAC,CAAC;AAAA,cACJ,CAAC;AACD;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,SAAG,aAAa,MAAM,iBAAiB;AAAA,IACzC;AAAA,EACF,CAAC;AACH,CAAC;;;AClIM,IAAM,oBAAwB,iBAAiB;AAAA,EACpD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,yBAAyB,EAAE,WAAU,YAAY,QAAQ;AACtE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAGvC,UACE,GAAG,kBAAkB,IAAI,KAAK,KAAK,YACnC;AAEA,YAAI,GAAG,kBAAkB,KAAK,UAAU,EAAG;AAG3C,cAAM,6BAA6B,GAAG;AAAA,UACpC;AAAA,UACA,CACE,MACI,GAAG,qBAAqB,CAAC,KAAK,GAAG,sBAAsB,CAAC,KAAK,GAAG,oBAAoB,CAAC,KACzF,GAAG,gBAAgB,CAAC,KAAK,GAAG,cAAc,CAAC;AAAA,QAC/C;AAEA,YACE,EAAE,8BAA8B,mBAAmB,8BACjD,2BAA2B,eAC7B;AAGF,cAAM,OAAO,YAAY,kBAAkB,KAAK,UAAU;AAC1D,cAAM,cAAc,OAAY,OAAO,WAAW,iBAAiB,MAAM,KAAK,UAAU,CAAC;AAEzF,YAAWC,QAAO,WAAW,GAAG;AAE9B,cAAI,8BAA8B,2BAA2B,QAAQ;AACnE,kBAAM,gBAAgB,2BAA2B;AAEjD,mBAAO;AAAA,cACL,WAAW,UAAU,aAAa;AAAA,cAC7BC,QAAO,MAAM,WAAW,oBAAoB,aAAa,CAAC;AAAA,cAC1DA,QAAO,MAAM,WAAW,YAAY,aAAa,CAAC;AAAA,cAClDC,KAAI,MAAM;AACb,sBAAM,MAAM,KAAK,aACf,CAAC;AAAA,kBACC,SAAS;AAAA,kBACT,aAAa;AAAA,kBACb,OAAY,IAAI,aAAY;AAC1B,0BAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,kCAAc;AAAA,sBACZ;AAAA,sBACA,KAAK;AAAA,sBACL,GAAG,QAAQ;AAAA,wBACT,GAAG,QAAQ,YAAY,GAAG,WAAW,aAAa;AAAA,wBAClD,KAAK;AAAA,sBACP;AAAA,oBACF;AAAA,kBACF,CAAC;AAAA,gBACH,CAAC,IACD,CAAC;AAEH,uBAAO;AAAA,kBACL,UAAU;AAAA,kBACV,aACE;AAAA;AAAA;AAAA,kBACF,OAAO;AAAA,gBACT,CAAC;AAAA,cACH,CAAC;AAAA,cACI;AAAA,YACP;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACvFM,IAAM,qBAAyB,iBAAiB;AAAA,EACrD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,0BAA0B,EAAE,WAAU,YAAY,QAAQ;AACvE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,UAAM,wBAAwB,QAAQ;AAAA,MACpC;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAEL,aAAS,wBAAwB,MAAgE;AAI/F,UAAI,CAAC,GAAG,iBAAiB,IAAI,EAAG;AAChC,YAAM,aAAa,KAAK;AACxB,UAAI,CAAC,GAAG,2BAA2B,UAAU,EAAG;AAEhD,YAAM,eAAe,WAAW;AAChC,UAAI,EAAE,GAAG,aAAa,YAAY,KAAK,GAAG,OAAO,YAAY,MAAM,uBAAwB;AAC3F,YAAM,mBAAmB,WAAW;AAEpC,UAAI,EAAE,GAAG,aAAa,gBAAgB,KAAK,GAAG,OAAO,gBAAgB,EAAE,YAAY,EAAE,WAAW,QAAQ,GAAI;AAC5G,aAAO,EAAE,iBAAiB;AAAA,IAC5B;AAEA,UAAM,4BAA4B,CAAC,MAAe,MAAe,qBAAgD;AAC/G,YAAMC,WAA0B,iBAAiB,mBAAmB,IAAI;AACxE,aAAO;AAAA,QACA,eAAeA,SAAQ,IAAI,CAACC,UAAS,WAAW,UAAUA,OAAM,IAAI,CAAC,CAAC;AAAA,QACtEC;AAAA,UAAI,MACP,OAAO;AAAA,YACL,UAAU;AAAA,YACV,aACE;AAAA;AAAA,YACF,OAAO,mBACL,CAAC;AAAA,cACC,SAAS;AAAA,cACT,aAAa;AAAA,cACb,OAAY,IAAI,aAAY;AAC1B,sBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,8BAAc;AAAA,kBACZ;AAAA,kBACA;AAAA,kBACA,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,gBACtC;AAAA,cACF,CAAC;AAAA,YACH,CAAC,IACD,CAAC;AAAA,UACL,CAAC;AAAA,QACH;AAAA,QACK;AAAA,MACP;AAAA,IACF;AAEA,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AAEA,OAAG,aAAa,YAAY,iBAAiB;AAC7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAE/B,YAAM,qBAAqB,wBAAwB,IAAI;AACvD,UAAI,oBAAoB;AACtB,cAAM,OAAO,YAAY,kBAAkB,IAAI;AAC/C,eAAO;AAAA,UACL,WAAW,UAAU,MAAM,IAAI;AAAA,UAC1BC,SAAQ,CAAC,EAAE,IAAI,MAAM,0BAA0B,KAAK,MAAM,mBAAmB,gBAAgB,CAAC;AAAA,UAC9F;AAAA,QACP;AACA;AAAA,MACF;AAEA,UAAI,GAAG,mBAAmB,IAAI,KAAK,KAAK,QAAQ,KAAK,iBAAiB;AACpE,cAAM,WAAW,YAAY,oBAAoB,KAAK,IAAI;AAC1D,YAAI,UAAU;AACZ,gBAAM,YAAY,YAAY,gBAAgB,QAAQ;AACtD,gBAAM,eAAe,YAAY,kBAAkB,WAAW,SAAS;AACvE,cAAI,cAAc;AAChB,kBAAM,OAAO,YAAY,0BAA0B,cAAc,IAAI;AACrE,mBAAO;AAAA,cACL,WAAW,UAAU,MAAM,IAAI;AAAA,cAC1BA,SAAQ,CAAC,EAAE,IAAI,MAAM,0BAA0B,KAAK,MAAM,MAAS,CAAC;AAAA,cACpE;AAAA,YACP;AACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,SAAG,aAAa,MAAM,iBAAiB;AAAA,IACzC;AAAA,EACF,CAAC;AACH,CAAC;;;AC3GM,IAAM,2BAA+B,iBAAiB;AAAA,EAC3D,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,gCAAgC,EAAE,WAAU,YAAY,QAAQ;AAC7E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,UAAM,kBAAkB,oBAAI,QAA0B;AAEtD,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAEvC,YAAMC,SAAwB,CAAC;AAC/B,UAAI,GAAG,cAAc,IAAI,GAAG;AAC1B,wBAAgB,IAAI,MAAM,IAAI;AAC9B,QAAAA,OAAM,KAAK,KAAK,UAAU;AAAA,MAC5B,WAAW,GAAG,iBAAiB,IAAI,GAAG;AACpC,wBAAgB,IAAI,MAAM,IAAI;AAC9B,QAAAA,OAAM,KAAK,KAAK,UAAU;AAAA,MAC5B,WAAW,GAAG,wBAAwB,IAAI,GAAG;AAC3C,wBAAgB,IAAI,MAAM,IAAI;AAC9B,QAAAA,OAAM,KAAK,KAAK,SAAS;AAAA,MAC3B,WAAW,GAAG,wBAAwB,IAAI,KAAK,KAAK,aAAa,GAAG,WAAW,kBAAkB;AAC/F,wBAAgB,IAAI,MAAM,IAAI;AAC9B,QAAAA,OAAM,KAAK,KAAK,OAAO;AAAA,MACzB,WAAW,GAAG,mBAAmB,IAAI,KAAK,KAAK,cAAc,SAAS,GAAG,WAAW,aAAa;AAC/F,YAAI,gBAAgB,IAAI,KAAK,MAAM,EAAG,iBAAgB,IAAI,MAAM,IAAI;AACpE,QAAAA,OAAM,KAAK,KAAK,IAAI;AACpB,QAAAA,OAAM,KAAK,KAAK,KAAK;AAAA,MACvB,WAAW,GAAG,mBAAmB,IAAI,KAAK,KAAK,cAAc,SAAS,GAAG,WAAW,yBAAyB;AAC3G,YAAI,gBAAgB,IAAI,KAAK,MAAM,EAAG,iBAAgB,IAAI,MAAM,IAAI;AACpE,QAAAA,OAAM,KAAK,KAAK,IAAI;AACpB,QAAAA,OAAM,KAAK,KAAK,KAAK;AAAA,MACvB;AAEA,iBAAW,eAAeA,QAAO;AAC/B,YAAI,CAAC,YAAa;AAClB,YAAI,CAAC,gBAAgB,IAAI,YAAY,MAAM,EAAG;AAE9C,cAAM,WAAW,YAAY,kBAAkB,WAAW;AAC1D,cAAM,kBAAkB,YAAY,wBAAwB,QAAQ;AACpE,YAAI,eAAe,CAAC,mBAAmB,QAAQ;AAE/C,eAAO,aAAa,SAAS,GAAG;AAC9B,gBAAM,OAAO,aAAa,IAAI;AAG9B,cAAI,iBAAiB,QAAQ,IAAI,GAAG;AAClC,2BAAe,aAAa,OAAO,KAAK,KAAK;AAC7C;AAAA,UACF;AAGA,cAAI,KAAK,QAAQ,GAAG,UAAU,QAAS;AACvC,cAAI,KAAK,QAAQ,GAAG,UAAU,MAAO;AACrC,cAAI,KAAK,QAAQ,GAAG,UAAU,eAAgB;AAG9C,gBAAM,WAAW,YAAY,aAAa,IAAI;AAC9C,iBAAO;AAAA,YACL,UAAU;AAAA,YACV,aAAa,gBAAgB,QAAQ;AAAA,YACrC,OAAO,CAAC;AAAA,UACV,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC3EM,IAAM,sBAA0B,iBAAiB;AAAA,EACtD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,2BAA2B,EAAE,WAAU,YAAY,QAAQ;AACxE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,8BAA8B,CAAC,SAC9B,IAAI,aAAY;AAEnB,UACE,CAAC,GAAG,iBAAiB,IAAI,KACzB,KAAK,UAAU,WAAW,GAC1B;AACA,eAAO,OAAkB,gBAAgB,4BAA4B;AAAA,MACvE;AAGA,aAAO,WAAW,iCAAiC,SAAS,EAAE,KAAK,UAAU;AAG7E,aAAO,OAAY;AAAA,QACjB,KAAK,UAAU,IAAI,CAAC,QAAQ;AAC1B,gBAAM,UAAU,YAAY,kBAAkB,GAAG;AACjD,iBAAO,WAAW,UAAU,SAAS,GAAG;AAAA,QAC1C,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAEH,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAEvC,UAAI,GAAG,iBAAiB,IAAI,GAAG;AAC7B,cAAM,aAAa,OAAO,KAAK,4BAA4B,IAAI,GAAQ,MAAM;AAC7E,YAAWC,QAAO,UAAU,GAAG;AAC7B,iBAAO;AAAA,YACL,UAAU;AAAA,YACV,aACE;AAAA,YACF,OAAO,CAAC;AAAA,UACV,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACzDM,IAAM,sBAA0B,iBAAiB;AAAA,EACtD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,2BAA2B,EAAE,WAAU,YAAY,QAAQ;AACxE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAGvC,UAAI,GAAG,eAAe,IAAI,KAAK,KAAK,aAAa;AAG/C,cAAM,6BAA6B,GAAG;AAAA,UACpC;AAAA,UACA,CACE,MACI,GAAG,qBAAqB,CAAC,KAAK,GAAG,sBAAsB,CAAC,KAAK,GAAG,oBAAoB,CAAC,KACzF,GAAG,gBAAgB,CAAC,KAAK,GAAG,cAAc,CAAC,KAAK,GAAG,eAAe,CAAC;AAAA,QACvE;AAEA,YACE,EAAE,8BAA8B,mBAAmB,8BACjD,2BAA2B,eAC7B;AAEF,YAAI,CAAC,2BAA4B;AAGjC,YAAI,8BAA8B,2BAA2B,QAAQ;AACnE,gBAAM,gBAAgB,2BAA2B;AAGjD,iBAAO;AAAA,YACL,WAAW,UAAU,aAAa;AAAA,YAC7BC,QAAO,MAAM,WAAW,oBAAoB,aAAa,CAAC;AAAA,YAC1DA,QAAO,MAAM,WAAW,YAAY,aAAa,CAAC;AAAA,YAClDC,KAAI,MAAM;AACb,qBAAO;AAAA,gBACL,UAAU;AAAA,gBACV,aACE;AAAA,gBACF,OAAO,CAAC;AAAA,cACV,CAAC;AAAA,YACH,CAAC;AAAA,YACI;AAAA,UACP;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC7DM,IAAM,uBAA2B,iBAAiB;AAAA,EACvD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,4BAA4B,EAAE,WAAU,YAAY,QAAQ;AACzE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAEvC,UAAI,GAAG,iBAAiB,IAAI,GAAG;AAC7B,eAAO;AAAA,UACL,WAAW,qBAAqB,IAAI;AAAA,UAC/BC;AAAA,YAAI,CAAC,EAAE,gBAAgB,MAC1B,OAAO;AAAA,cACL,UAAU;AAAA,cACV,aAAa;AAAA,cACb,OAAO,CAAC;AAAA,gBACN,SAAS;AAAA,gBACT,aAAa;AAAA,gBACb,OAAY,IAAI,aAAY;AAC1B,wBAAM,cAAc,OAAY;AAAA,oBAChB;AAAA,kBAChB;AACA,8BAAY,YAAY,YAAY,MAAM,OAAO,eAAe;AAAA,gBAClE,CAAC;AAAA,cACH,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAAA,UACK;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC3CM,IAAM,kBAAsB,iBAAiB;AAAA,EAClD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,uBAAuB,EAAE,WAAU,YAAY,QAAQ;AACpE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAEvC,UAAI,GAAG,iBAAiB,IAAI,GAAG;AAC7B,eAAO;AAAA,UACL,WAAW,SAAS,IAAI;AAAA,UACnBC,KAAI,CAAC,EAAE,MAAAC,OAAM,QAAQ,MAAM;AAC9B,gBAAIA,MAAK,WAAW,GAAG;AACrB,qBAAO;AAAA,gBACL,UAAU;AAAA,gBACV,aAAa;AAAA,gBACb,OAAO,CAAC;AAAA,kBACN,SAAS;AAAA,kBACT,aAAa;AAAA,kBACb,OAAY,IAAI,aAAY;AAC1B,0BAAM,cAAc,OAAY;AAAA,sBAChB;AAAA,oBAChB;AACA,gCAAY,YAAY,YAAY,MAAM,OAAO;AAAA,kBACnD,CAAC;AAAA,gBACH,CAAC;AAAA,cACH,CAAC;AAAA,YACH;AAAA,UACF,CAAC;AAAA,UACI;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC7CM,IAAM,uBAA2B,iBAAiB;AAAA,EACvD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,4BAA4B,EAAE,WAAU,YAAY,QAAQ;AACzE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AACA,OAAG,aAAa,YAAY,iBAAiB;AAE7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAEvC,UAAI,GAAG,iBAAiB,IAAI,GAAG;AAC7B,eAAO;AAAA,UACL,WAAW,SAAS,IAAI;AAAA,UACnBC;AAAA,YAAQ,CAAC,aACPC,KAAI,WAAW,SAAS,SAAS,OAAO,GAAG,CAAC,eAAe,EAAE,UAAU,UAAU,EAAE;AAAA,UAC1F;AAAA,UACKA,KAAI,CAAC,EAAE,WAAW,SAAS,MAAM;AACpC,mBAAO;AAAA,cACL,UAAU;AAAA,cACV,aAAa;AAAA,cACb,OAAO,CAAC;AAAA,gBACN,SAAS;AAAA,gBACT,aAAa;AAAA,gBACb,OAAY,IAAI,aAAY;AAC1B,wBAAM,gBAAgB,OAAY;AAAA,oBAClB;AAAA,kBAChB;AACA,0BAAQ,UAAU,MAAM;AAAA,oBACtB,KAAK,QAAQ;AACX,oCAAc;AAAA,wBACZ;AAAA,wBACA;AAAA,wBACA,GAAG,QAAQ;AAAA,0BACT,GAAG,QAAQ,iBAAiB,MAAM;AAAA,0BAClC;AAAA,0BACA,CAAC,UAAU,SAAS,GAAG,UAAU,MAAM,GAAG,SAAS,IAAI;AAAA,wBACzD;AAAA,sBACF;AACA;AAAA,oBACF;AAAA,oBACA,KAAK,YAAY;AACf,oCAAc;AAAA,wBACZ;AAAA,wBACA;AAAA,wBACA,GAAG,QAAQ;AAAA,0BACT,GAAG,QAAQ;AAAA,4BACT,UAAU;AAAA,4BACV;AAAA,0BACF;AAAA,0BACA;AAAA,0BACA,CAAC,GAAG,UAAU,MAAM,GAAG,SAAS,IAAI;AAAA,wBACtC;AAAA,sBACF;AACA;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF,CAAC;AAAA,cACH,CAAC;AAAA,YACH,CAAC;AAAA,UACH,CAAC;AAAA,UACI;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC1EM,IAAM,8BAAkC,iBAAiB;AAAA,EAC9D,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAY,GAAG,mCAAmC,EAAE,WAAU,YAAY,QAAQ;AAChF,UAAM,KAAK,OAAY,QAAsB,aAAa;AAE1D,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AAEA,OAAG,aAAa,YAAY,iBAAiB;AAC7C,WAAO,YAAY,SAAS,GAAG;AAC7B,YAAM,OAAO,YAAY,MAAM;AAC/B,SAAG,aAAa,MAAM,iBAAiB;AAGvC,UAAI,GAAG,mBAAmB,IAAI,GAAG;AAC/B,cAAM,cAAc,OAAO;AAAA,UACFC,OAAM,IAAI;AAAA,UAC5BC,QAAO,MAAW,QAAQ,IAAI,CAAC;AAAA,QACtC;AAEA,YAAI,eAAe,YAAY,gBAAgB,SAAS,GAAG;AAEzD,gBAAM,wBAAwB,oBAAI,IAAY;AAC9C,eAAK,SAAS,QAAQ,CAAC,WAAW;AAChC,gBACE,GAAG,sBAAsB,MAAM,KAC/B,OAAO,WAAW,KAAK,CAAC,QAAQ,IAAI,SAAS,GAAG,WAAW,aAAa,GACxE;AACA,kBAAI,OAAO,QAAQ,GAAG,aAAa,OAAO,IAAI,GAAG;AAC/C,sCAAsB,IAAI,GAAG,OAAO,OAAO,IAAI,CAAC;AAAA,cAClD;AAAA,YACF;AAAA,UACF,CAAC;AAGD,gBAAM,iBAAiB,YAAY,gBAAgB;AAAA,YAAO,CAAC,EAAE,SAAS,MACpE,CAAC,sBAAsB,IAAI,GAAG,WAAW,QAAQ,CAAC;AAAA,UACpD;AAEA,cAAI,eAAe,SAAS,GAAG;AAC7B,kBAAM,cAAc,eAAe,IAAI,CAAC,EAAE,SAAS,MAAM,IAAI,GAAG,WAAW,QAAQ,CAAC,GAAG,EAAE,KAAK,IAAI;AAElG,mBAAO;AAAA,cACL,UAAU,YAAY;AAAA,cACtB,aACE,gDAAgD,WAAW;AAAA,cAC7D,OAAO,CAAC;AAAA,gBACN,SAAS;AAAA,gBACT,aAAa;AAAA,gBACb,OAAY,IAAI,aAAY;AAC1B,wBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAGrE,wBAAM,UAAU;AAChB,gCAAc,WAAW,YAAY,GAAG,kBAAkB,MAAM,UAAU,GAAG,OAAO;AAAA,gBACtF,CAAC;AAAA,cACH,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC7CM,IAAM,cAAc;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;ACpDO,IAAM,2BAA+B,iBAAiB;AAAA,EAC3D,MAAM;AAAA,EACN,OAAY,GAAG,0BAA0B,EAAE,WAAU,YAAY,UAAU;AACzE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAG1D,UAAM,aAAa,WAAW;AAG9B,UAAMC,SAAS,iCAAkC,KAAK,WAAW,UAAU,GAAG,QAAQ,CAAC;AACvF,QAAIA,UAASA,OAAM,SAAS;AAC1B,YAAM,YAAYA,OAAM,QAAQ,CAAC,EAAE,CAAC;AACpC,YAAM,kBAA+B;AAAA,QACnC,OAAO;AAAA,QACP,QAAQ,KAAK,IAAI,GAAG,WAAW,SAAS;AAAA,MAC1C;AAEA,YAAM,iBAAuB,KAAK,OAAO,OAAO,WAAW,EAAE,IAAI,CAAC,eAAe,WAAW,IAAI,GAASC,OAAM,EAC5G,KAAK,GAAG;AACX,YAAM,iBAAiB,SAAS,iBAAiB;AAEjD,aAAO,CAAC;AAAA,QACN,MAAM;AAAA,QACN,MAAM,GAAG,kBAAkB;AAAA,QAC3B,YAAY,yBAAyB;AAAA,QACrC,WAAW;AAAA,QACX;AAAA,MACF,GAAG;AAAA,QACD,MAAM;AAAA,QACN,MAAM,GAAG,kBAAkB;AAAA,QAC3B,YAAY,mCAAmC;AAAA,QAC/C,WAAW;AAAA,QACX;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,CAAC;AAAA,EACV,CAAC;AACH,CAAC;;;ACzCM,IAAM,qBAAyB,iBAAiB;AAAA,EACrD,MAAM;AAAA,EACN,OAAY,GAAG,oBAAoB,EAAE,WAAU,YAAY,UAAU;AACnE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAG1D,UAAM,aAAa,WAAW;AAG9B,UAAMC,SAAS,iCAAkC,KAAK,WAAW,UAAU,GAAG,QAAQ,CAAC;AACvF,QAAIA,UAASA,OAAM,SAAS;AAC1B,YAAM,YAAYA,OAAM,QAAQ,CAAC,EAAE,CAAC;AACpC,YAAM,kBAA+B;AAAA,QACnC,OAAO;AAAA,QACP,QAAQ,KAAK,IAAI,GAAG,WAAW,SAAS;AAAA,MAC1C;AAEA,aAAO,CAAC;AAAA,QACN,MAAM;AAAA,QACN,MAAM,GAAG,kBAAkB;AAAA,QAC3B,YAAY;AAAA,QACZ,WAAW;AAAA,QACX;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,CAAC;AAAA,EACV,CAAC;AACH,CAAC;;;AC3BM,IAAM,4BAAgC,iBAAiB;AAAA,EAC5D,MAAM;AAAA,EACN,OAAY,GAAG,2BAA2B,EAAE,WAAU,YAAY,UAAU;AAC1E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,aAAa,QAAQ,mCAAmC,YAAY,QAAQ;AAClF,QAAI,CAAC,WAAY,QAAO,CAAC;AACzB,UAAM,EAAE,gBAAgB,WAAW,gBAAgB,IAAI;AAGvD,UAAM,mBAAmB,QAAQ;AAAA,MAC/B;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAGL,QAAI,qBAAqB,GAAG,OAAO,cAAc,EAAG,QAAO,CAAC;AAC5D,UAAM,OAAO,GAAG,OAAO,SAAS;AAGhC,UAAM,eAAe,OAAkB,aAAa,YAAY,MAAM,OAAO,MAAM;AAEnF,WAAO,CAAC;AAAA,MACN,MAAM,SAAS,IAAI;AAAA,MACnB,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,gBAAgB,UAAU,IAAI,MAAM,IAAI,OAAO,MAAM;AAAA,MACpE;AAAA,MACA,WAAW;AAAA,IACb,GAAG;AAAA,MACD,MAAM,eAAe,IAAI;AAAA,MACzB,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,gBAAgB,gBAAgB,IAAI,MAAM,WAAW,OAAO,WAAW,OAAO,MAAM;AAAA,MACnG;AAAA,MACA,WAAW;AAAA,IACb,GAAG;AAAA,MACD,MAAM,eAAe,IAAI;AAAA,MACzB,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,gBAAgB,gBAAgB,IAAI,MAAM,IAAI,OAAO,IAAI,OAAO,MAAM;AAAA,MACrF;AAAA,MACA,WAAW;AAAA,IACb,GAAG;AAAA,MACD,MAAM,iBAAiB,IAAI;AAAA,MAC3B,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,gBAAgB,kBAAkB,IAAI,MAAM,IAAI,OAAO,IAAI,OAAO,MAAM;AAAA,MACvF;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAAA,EACH,CAAC;AACH,CAAC;;;AClDM,IAAM,sBAA0B,iBAAiB;AAAA,EACtD,MAAM;AAAA,EACN,OAAY,GAAG,qBAAqB,EAAE,WAAU,YAAY,UAAU;AACpE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,aAAa,QAAQ,mCAAmC,YAAY,QAAQ;AAClF,QAAI,CAAC,WAAY,QAAO,CAAC;AACzB,UAAM,EAAE,gBAAgB,WAAW,gBAAgB,IAAI;AAGvD,UAAM,mBAAmB,QAAQ;AAAA,MAC/B;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAGL,QAAI,qBAAqB,GAAG,OAAO,cAAc,EAAG,QAAO,CAAC;AAC5D,UAAM,OAAO,GAAG,OAAO,SAAS;AAGhC,UAAM,UAAU,OAAkB,aAAa,YAAY,MAAM,SAAS,MAAM;AAEhF,WAAO,CAAC;AAAA,MACN,MAAM,WAAW,IAAI;AAAA,MACrB,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,gBAAgB,YAAY,IAAI,QAAQ,MAAM,OAAO,MAAM;AAAA,MAC1E;AAAA,MACA,WAAW;AAAA,IACb,GAAG;AAAA,MACD,MAAM,QAAQ,IAAI;AAAA,MAClB,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,gBAAgB,SAAS,MAAM,MAAM,IAAI,MAAM,MAAM;AAAA,MACpE;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAAA,EACH,CAAC;AACH,CAAC;;;ACnCM,IAAM,iBAAqB,iBAAiB;AAAA,EACjD,MAAM;AAAA,EACN,OAAY,GAAG,gBAAgB,EAAE,WAAU,YAAY,UAAU;AAC/D,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,aAAa,QAAQ,qCAAqC,YAAY,QAAQ;AACpF,QAAI,CAAC,WAAY,QAAO,CAAC;AACzB,UAAM,EAAE,eAAe,IAAI;AAG3B,UAAM,iBAAiB,OAAY,OAAO,WAAW,qBAAqB,cAAc,CAAC;AACzF,QAAWC,QAAO,cAAc,EAAG,QAAO,CAAC;AAE3C,UAAM,OAAO,GAAG;AAAA,MACd,eAAe,MAAM;AAAA,MACrB,KAAK,IAAI,GAAG,WAAW,eAAe,MAAM,CAAC;AAAA,IAC/C;AAEA,UAAM,cAAoD;AAAA,MACxD,QAAQ,wBAAwB,YAAY,QAAQ,YAAY,eAAe,GAAG,CAAC;AAAA,MAC7E,OAAO,GAAG,qBAAqB;AAAA,MAC/BC,KAAI,CAAC,MAAM,EAAE,QAAQ,GAAG,aAAa,EAAE,IAAI,IAAI,GAAG,OAAO,EAAE,IAAI,IAAI,EAAE;AAAA,MACrE,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC;AAAA,MAC1B;AAAA,MACCA,KAAI,CAAC,SAAS;AAAA,QACnB;AAAA,UACE,MAAM,OAAO,IAAI;AAAA,UACjB,MAAM,GAAG,kBAAkB;AAAA,UAC3B,YAAY,OAAO,IAAI,gBAAgB,MAAM,KAAK,MAAM;AAAA,UACxD,iBAAiB;AAAA,UACjB,WAAW;AAAA,QACb;AAAA,MACF,CAAC;AAAA,MACMC,WAAU,MAAM,CAAC,CAAyC;AAAA,IACnE;AAEA,WAAO,YAAY,OAAO,CAAC;AAAA,MACzB,MAAM;AAAA,MACN,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,gBAAgB,MAAM,KAAK,MAAM;AAAA,MAC7C,iBAAiB;AAAA,MACjB,WAAW;AAAA,IACb,GAAG;AAAA,MACD,MAAM;AAAA,MACN,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,wBAAwB,MAAM,KAAK,MAAM;AAAA,MACrD,iBAAiB;AAAA,MACjB,WAAW;AAAA,IACb,CAAC,CAAC;AAAA,EACJ,CAAC;AACH,CAAC;;;ACvDM,IAAM,kBAAsB,iBAAiB;AAAA,EAClD,MAAM;AAAA,EACN,OAAY,GAAG,iBAAiB,EAAE,WAAU,YAAY,UAAU;AAChE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,aAAa,QAAQ,qCAAqC,YAAY,QAAQ;AACpF,QAAI,CAAC,WAAY,QAAO,CAAC;AACzB,UAAM,EAAE,eAAe,IAAI;AAE3B,UAAM,OAAO,YAAY,kBAAkB,cAAc;AACzD,UAAM,kBAAkB,KAAK,YAAY,KAAK;AAC9C,QAAI,CAAC,gBAAiB,QAAO,CAAC;AAC9B,UAAM,UAAU,YAAY,0BAA0B,iBAAiB,cAAc;AACrF,QAAI,YAAY,oBAAoB,SAAS,GAAG,cAAc,IAAI,EAAE,WAAW,EAAG,QAAO,CAAC;AAE1F,UAAM,OAAO,GAAG;AAAA,MACd,eAAe,MAAM;AAAA,MACrB,KAAK,IAAI,GAAG,WAAW,eAAe,MAAM,CAAC;AAAA,IAC/C;AAEA,WAAO,CAAC;AAAA,MACN,MAAM;AAAA,MACN,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,mBAAmB,MAAM;AAAA,MACrC,iBAAiB;AAAA,MACjB,WAAW;AAAA,IACb,CAAC;AAAA,EACH,CAAC;AACH,CAAC;;;AC/BM,IAAM,iBAAqB,iBAAiB;AAAA,EACjD,MAAM;AAAA,EACN,OAAY,GAAG,gBAAgB,EAAE,WAAU,YAAY,UAAU;AAC/D,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,aAAa,QAAQ,mCAAmC,YAAY,QAAQ;AAClF,QAAI,CAAC,WAAY,QAAO,CAAC;AACzB,UAAM,EAAE,gBAAgB,WAAW,gBAAgB,IAAI;AAGvD,UAAM,gBAAgB,QAAQ;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAGL,QAAI,kBAAkB,GAAG,OAAO,cAAc,EAAG,QAAO,CAAC;AACzD,UAAM,OAAO,GAAG,OAAO,SAAS;AAEhC,WAAO,CAAC;AAAA,MACN,MAAM,SAAS,IAAI;AAAA,MACnB,MAAM,GAAG,kBAAkB;AAAA,MAC3B,YAAY,GAAG,aAAa,UAAU,IAAI,OAAO,MAAM;AAAA,MACvD;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAAA,EACH,CAAC;AACH,CAAC;;;AC1BM,IAAM,cAAkB,iBAAiB;AAAA,EAC9C,MAAM;AAAA,EACN,OAAY,GAAG,aAAa,EAAE,WAAU,YAAY,UAAU;AAC5D,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,aAAa,QAAQ,qCAAqC,YAAY,QAAQ;AACpF,QAAI,CAAC,WAAY,QAAO,CAAC;AACzB,UAAM,EAAE,eAAe,IAAI;AAE3B,QAAI,CAAC,GAAG,aAAa,cAAc,EAAG,QAAO,CAAC;AAE9C,UAAM,aAAa,QAAQ;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAEL,QAAI,eAAe,GAAG,OAAO,cAAc,EAAG,QAAO,CAAC;AAEtD,UAAM,OAAO,GAAG;AAAA,MACd,eAAe,MAAM;AAAA,MACrB,KAAK,IAAI,GAAG,WAAW,eAAe,MAAM,CAAC;AAAA,IAC/C;AAEA,WAAO;AAAA,MACL,QAAQ,wBAAwB,YAAY,QAAQ,YAAY,eAAe,GAAG,CAAC;AAAA,MAC7E,OAAO,GAAG,qBAAqB;AAAA,MAC/BC,KAAI,CAAC,MAAM,EAAE,QAAQ,GAAG,aAAa,EAAE,IAAI,IAAI,GAAG,OAAO,EAAE,IAAI,IAAI,EAAE;AAAA,MACrE,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC;AAAA,MAC1B;AAAA,MACCA,KAAI,CAAC,SAAS;AAAA,QACnB;AAAA,UACE,MAAM,UAAU,IAAI;AAAA,UACpB,MAAM,GAAG,kBAAkB;AAAA,UAC3B,YAAY,UAAU,IAAI;AAAA,UAC1B,iBAAiB;AAAA,UACjB,WAAW;AAAA,QACb;AAAA,MACF,CAAC;AAAA,MACMC,WAAU,MAAM,CAAC,CAAC;AAAA,IAC3B;AAAA,EACF,CAAC;AACH,CAAC;;;ACtCM,IAAM,cAAc;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;ACYO,IAAM,yBASJ,GAAG,eAAe,EAAE,WAC3B,gBACA;AACA,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,UAAU,OAAY,QAAsB,iBAAiB;AACnE,QAAM,+BAA+B,OAAY,QAAqC,4BAA4B;AAElH,QAAM,OAAO;AACb,QAAM,qBAAmC,uBAAuB,EAAE;AAClE,QAAM,kCAAgD,oCAAoC,EAAE;AAC5F,QAAM,oCAAkD,sCAAsC,EAAE;AAEhG,WAAS,2BACP,YACA;AACA,UAAM,mBAEF,CAAC;AACL,UAAM,eAEF,CAAC;AAEL,eAAW,aAAa,WAAW,YAAY;AAC7C,UAAI,CAAC,GAAG,oBAAoB,SAAS,EAAG;AACxC,UAAI,CAAC,UAAU,aAAc;AAC7B,YAAM,kBAAkB,UAAU;AAClC,UAAI,CAAC,gBAAiB;AACtB,UAAI,CAAC,GAAG,gBAAgB,eAAe,EAAG;AAC1C,YAAM,eAAe,UAAU;AAC/B,UAAI,GAAG,kBAAkB,YAAY,GAAG;AACtC,YAAI,CAAC,aAAa,KAAM;AACxB,YAAI,CAAC,GAAG,aAAa,aAAa,IAAI,EAAG;AACzC,yBAAiB,KAAK;AAAA,UACpB;AAAA,UACA;AAAA,UACA,MAAM,GAAG,OAAO,aAAa,IAAI;AAAA,QACnC,CAAC;AAAA,MACH;AACA,UAAI,GAAG,eAAe,YAAY,GAAG;AACnC,mBAAW,mBAAmB,aAAa,UAAU;AACnD,gBAAM,aAAa,gBAAgB,gBAAgB,gBAAgB;AACnE,cAAI,CAAC,GAAG,aAAa,UAAU,EAAG;AAClC,cAAI,CAAC,GAAG,aAAa,gBAAgB,IAAI,EAAG;AAC5C,uBAAa,KAAK;AAAA,YAChB;AAAA,YACA;AAAA,YACA,MAAM,GAAG,OAAO,UAAU;AAAA,YAC1B,WAAW,GAAG,OAAO,gBAAgB,IAAI;AAAA,UAC3C,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAEA,WAAO,EAAE,kBAAkB,aAAa;AAAA,EAC1C;AAEA,WAAS,eACP,cACA,aACyE;AACzE,QAAI;AAEF,UAAI,CAAC,mCAAmC,CAAC,kCAAmC;AAG5E,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA;AAAA,QACA,QAAQ,mBAAmB;AAAA,QAC3B;AAAA,MACF;AACA,UAAI,CAAC,gBAAiB;AAEtB,YAAM,eAAe;AAAA,QACnB;AAAA,QACA,QAAQ,mBAAmB;AAAA,QAC3B;AAAA,MACF;AAEA,UAAI,CAAC,aAAc;AACnB,UAAI,CAAO,QAAQ,YAAY,EAAG;AAClC,UAAI,CAAO,MAAgB,QAAQ,EAAG;AACtC,YAAM,cAAc,aAAa,IAAI,CAAC,MAAM,OAAO,CAAC,CAAC;AACrD,YAAM,OAAO,QAAQ,2CAA2C,EAAE,kBAAkB,gBAAgB,CAAC;AACrG,UAAI,CAAC,KAAM,QAAO,EAAE,aAAa,cAAc,CAAC,EAAE;AAClD,aAAO,EAAE,aAAa,cAAc,KAAK,YAAY;AAAA,IAEvD,SAAS,GAAG;AACV,aAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,2BAA2B,oBAAI,IAAoC;AACzE,QAAM,wBAAwB,oBAAI,IAAsE;AACxG,QAAM,2BAA2B,oBAAI,IAAiD;AACtF,QAAM,2BAA2B,oBAAI,IAAoB;AACzD,QAAM,8BAA8B,oBAAI,IAA2B;AACnE,QAAM,0BAA0B,oBAAI,IAAoB;AAExD,QAAM,qBAAqB,CAAC,aAAqB,gBAAwB;AACvE,UAAM,aAAa,gBAAgB,MAAM,KAAM,YAAY,WAAW,IAAI,IAAI,YAAY,MAAM,CAAC,IAAI;AACrG,UAAM,eAAe,cAAc;AACnC,UAAM,mBAAmB,GAAG;AAAA,MAC1B;AAAA,MACA,eAAe;AAAA,MACf,QAAQ,mBAAmB;AAAA,MAC3B;AAAA,IACF;AACA,QAAI,CAAC,iBAAkB;AACvB,QAAI,CAAC,iBAAiB,eAAgB;AACtC,UAAM,WAAW,KAAK,WAClB,KAAK,SAAS,iBAAiB,eAAe,gBAAgB,IAC9D,iBAAiB,eAAe;AACpC,QAAI,wBAAwB,IAAI,QAAQ,EAAG;AAC3C,4BAAwB,IAAI,UAAU,YAAY;AAAA,EACpD;AAEA,QAAM,qBAA0B,GAAG,eAAe;AAAA,IAChD,WACE,iBACA,MACA,wBACA;AACA,iBAAW,kBAAkB,iBAAiB;AAC5C,cAAM,eAAe,QAAQ,qBAAqB,SAAS,gBAAgB,cAAc;AACzF,mBAAW,eAAe,cAAc;AACtC,gBAAM,cAAc,eAAe,eAAe,UAAU,WAAW;AACvE,cAAI,CAAC,YAAa;AAClB,qBAAW,eAAe,YAAY,cAAc;AAClD,+BAAmB,aAAa,WAAW;AAAA,UAC7C;AACA,qBAAW,aAAa,YAAY,aAAa;AAC/C,kBAAM,eAAe,KAAK,WAAW,KAAK,SAAS,SAAS,IAAI;AAChE,kBAAM,gBAAgB,wBAAwB,IAAI,YAAY,MAAM;AACpE,kBAAM,mBAAmB,QAAQ,cAAc,YAAY,KACzD,GAAG,iBAAiB,cAAc,KAAK,SAAS,YAAY,KAAK,IAAI,eAAe,iBAAiB,IAAI;AAC3G,kBAAM,YAAY,2BAA2B,gBAAgB;AAC7D,gBAAI,CAAC,UAAW;AAEhB,gBAAI,UAAU,iBAAiB,WAAW,EAAG;AAC7C,uBAAW,qBAAqB,UAAU,kBAAkB;AAC1D,oBAAM,iBAAiB,GAAG;AAAA,gBACxB,kBAAkB,gBAAgB;AAAA,gBAClC,iBAAiB;AAAA,gBACjB,QAAQ,mBAAmB;AAAA,gBAC3B;AAAA,cACF;AACA,kBAAI,CAAC,eAAgB;AACrB,kBAAI,CAAC,eAAe,eAAgB;AACpC,sBAAQ,MAAM;AAAA,gBACZ,KAAK,aAAa;AAChB,2CAAyB;AAAA,oBACvB,iBAAiB;AAAA,oBACjB;AAAA,sBACE,GAAI,yBAAyB,IAAI,iBAAiB,QAAQ,KAAK,CAAC;AAAA,sBAChE,CAAC,kBAAkB,IAAI,GAAG,eAAe,eAAe;AAAA,oBAC1D;AAAA,kBACF;AACA,2CAAyB;AAAA,oBACvB,eAAe,eAAe;AAAA,oBAC9B,kBAAkB;AAAA,kBACpB;AACA;AAAA,gBACF;AAAA,gBACA,KAAK,UAAU;AACb,2CAAyB,IAAI,eAAe,eAAe,kBAAkB;AAAA,oBAC3E,UAAU,iBAAiB;AAAA,oBAC3B,OAAO,kBAAkB;AAAA,kBAC3B,CAAC;AAAA,gBACH;AAAA,cACF;AAAA,YACF;AACA,gBAAI,eAAe;AACjB,yBAAW,eAAe,UAAU,cAAc;AAChD,oBAAI,2BAA2B,UAAU;AACvC,8CAA4B,IAAI,iBAAiB,UAAU;AAAA,oBACzD,GAAI,4BAA4B,IAAI,iBAAiB,QAAQ,KAAK,CAAC;AAAA,oBACnE,YAAY;AAAA,kBACd,CAAC;AAAA,gBACH,WAAW,2BAA2B,UAAU;AAC9C,wBAAM,iBAAiB,GAAG;AAAA,oBACxB,YAAY,gBAAgB;AAAA,oBAC5B,iBAAiB;AAAA,oBACjB,QAAQ,mBAAmB;AAAA,oBAC3B;AAAA,kBACF;AACA,sBAAI,CAAC,eAAgB;AACrB,sBAAI,CAAC,eAAe,eAAgB;AACpC,wCAAsB,IAAI,iBAAiB,UAAU;AAAA,oBACnD,GAAI,sBAAsB,IAAI,iBAAiB,QAAQ,KAAK,CAAC;AAAA,oBAC7D,CAAC,YAAY,IAAI,GAAG;AAAA,sBAClB,UAAU,eAAe,eAAe;AAAA,sBACxC,YAAY,YAAY;AAAA,oBAC1B;AAAA,kBACF,CAAC;AACD,wCAAsB,IAAI,eAAe,eAAe,kBAAkB;AAAA,oBACxE,GAAI,sBAAsB,IAAI,eAAe,eAAe,gBAAgB,KAAK,CAAC;AAAA,oBAClF,CAAC,YAAY,IAAI,GAAG;AAAA,sBAClB,UAAU,eAAe,eAAe;AAAA,sBACxC,YAAY,YAAY;AAAA,oBAC1B;AAAA,kBACF,CAAC;AAAA,gBACH;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,6BAA6B;AAAA,IAC7B;AAAA,IACA,6BAA6B;AAAA,EAC/B;AACA,SAAO,mBAAmB,6BAA6B,sBAAsB,UAAU,QAAQ;AAE/F,QAAM,oBAAoB,CAAC,aAAqB;AAC9C,UAAM,kBAAkB,wBAAwB,IAAI,QAAQ;AAC5D,QAAI,gBAAiB,QAAO;AAC5B,QAAI,CAAC,mBAAoB,QAAO;AAChC,UAAM,kBAAkB;AAAA,MACtB,QAAQ,mBAAmB;AAAA,MAC3B;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA;AAAA,IACF;AACA,QAAI,CAAC,gBAAiB,QAAO;AAC7B,WAAO;AAAA,EACT;AAEA,QAAM,mBAAmB,CAAC,eAAuB;AAC/C,UAAM,YAAY,6BAA6B,cAAc,UAAU;AACvE,QAAI,UAAW,QAAO;AACtB,WAAO;AAAA,EACT;AAEA,QAAM,UAAU,CAAC,gBAAwB,eAA0E;AAEjH,UAAM,kBAAkB,4BAA4B,IAAI,cAAc;AACtE,QAAI,mBAAmB,gBAAgB,SAAS,UAAU,EAAG;AAE7D,UAAM,uBAAuB,sBAAsB,IAAI,cAAc;AACrE,QAAI,wBAAwB,cAAc,sBAAsB;AAC9D,YAAM,iBAAiB,qBAAqB,UAAU;AACtD,UAAI,gBAAgB;AAClB,eAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,eAAe;AAAA,UACzB,YAAY,kBAAkB,eAAe,QAAQ;AAAA,UACrD,MAAM;AAAA,UACN,WAAW,iBAAiB,UAAU;AAAA,UACtC,kBAAkB;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAEA,UAAM,iBAAiB,yBAAyB,IAAI,cAAc;AAClE,QAAI,kBAAkB,cAAc,gBAAgB;AAClD,YAAM,qBAAqB,eAAe,UAAU;AACpD,UAAI,oBAAoB;AACtB,cAAMC,mBAAkB,yBAAyB,IAAI,kBAAkB;AACvE,YAAIA,kBAAiB;AACnB,iBAAQ;AAAA,YACN,MAAM;AAAA,YACN,UAAU;AAAA,YACV,YAAY,kBAAkB,kBAAkB;AAAA,YAChD,MAAMA;AAAA,YACN,WAAW,iBAAiBA,gBAAe;AAAA,YAC3C,kBAAkB;AAAA,UACpB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,kBAAkB,yBAAyB,IAAI,cAAc;AACnE,QAAI,iBAAiB;AACnB,aAAQ;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,YAAY,kBAAkB,cAAc;AAAA,QAC5C,MAAM;AAAA,QACN,WAAW,iBAAiB,eAAe;AAAA,QAC3C,kBAAkB,iBAAiB,eAAe,KAAK;AAAA,MACzD;AAAA,IACF;AAEA,UAAM,cAAc,yBAAyB,IAAI,cAAc;AAC/D,QAAI,aAAa;AACf,aAAQ;AAAA,QACN,MAAM;AAAA,QACN,UAAU,YAAY;AAAA,QACtB,YAAY,kBAAkB,YAAY,QAAQ;AAAA,QAClD,MAAM,YAAY;AAAA,QAClB,WAAW,iBAAiB,YAAY,KAAK;AAAA,QAC7C,kBAAkB,iBAAiB,YAAY,KAAK,KAAK,YAAY;AAAA,MACvE;AAAA,IACF;AAAA,EACF;AAEA,QAAM,WAAW,CAAC,gBAAwB,eAAuB;AAE/D,UAAM,kBAAkB,4BAA4B,IAAI,cAAc;AACtE,QAAI,mBAAmB,gBAAgB,SAAS,UAAU,EAAG;AAE7D,UAAM,iBAAiB,yBAAyB,IAAI,cAAc;AAClE,QAAI,kBAAkB,cAAc,eAAgB,QAAO;AAAA,EAC7D;AAEA,SAAO,EAAE,SAAS,SAAS;AAC7B,CAAC;AAED,IAAM,uBAAuB,oBAAI,IAAgC;AAE1D,IAAM,8BAAmC,GAAG,6BAA6B,EAAE,WAChF,YACA;AAEA,SAAO,qBAAqB,OAAO,GAAG;AACpC,UAAM,SAAS,qBAAqB,KAAK,EAAE,KAAK,EAAE;AAClD,QAAI,OAAQ,sBAAqB,OAAO,MAAM;AAAA,EAChD;AACA,QAAM,qBAAqB,qBAAqB,IAAI,WAAW,QAAQ,MACpE,OAAO,uBAAuB,UAAU;AAC3C,uBAAqB,IAAI,WAAW,UAAU,kBAAkB;AAChE,SAAO;AACT,CAAC;AAEM,IAAM,yBAA8B,GAAG,wBAAwB,EAAE,WACtE,YACA,SACA;AACA,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,YAAkC,CAAC;AACzC,QAAM,UAA6C,CAAC;AAEpD,aAAW,UAAU,SAAS;AAE5B,QAAI,OAAO,QAAQ,WAAW,GAAG;AAC/B,gBAAU,KAAK,MAAM;AACrB;AAAA,IACF;AAEA,QAAI,OAAO,QAAQ,KAAK,EAAE,WAAW,QAAQ,KAAK,OAAO,QAAQ,KAAK,EAAE,SAAS,MAAM,GAAG;AACxF,UAAI;AACF,cAAM,eAAe,GAAG,iBAAiB,WAAW,OAAO,SAAS,WAAW,iBAAiB,KAAK;AACrG,mBAAW,aAAa,aAAa,YAAY;AAC/C,cAAI,CAAC,GAAG,oBAAoB,SAAS,EAAG;AACxC,gBAAM,kBAAkB,UAAU;AAClC,cAAI,CAAC,GAAG,gBAAgB,eAAe,EAAG;AAC1C,gBAAM,aAAa,gBAAgB;AACnC,gBAAM,eAAe,UAAU;AAC/B,cAAI,CAAC,aAAc;AACnB,gBAAM,gBAAgB,aAAa;AACnC,cAAI,CAAC,cAAe;AACpB,cAAI,GAAG,eAAe,aAAa,GAAG;AACpC,uBAAW,mBAAmB,cAAc,UAAU;AACpD,kBAAI,CAAC,GAAG,aAAa,gBAAgB,IAAI,EAAG;AAC5C,oBAAM,aAAa,GAAG,OAAO,gBAAgB,IAAI;AACjD,sBAAQ,KAAK,EAAE,YAAY,WAAW,CAAC;AACvC;AAAA,YACF;AAAA,UACF,WAAW,GAAG,kBAAkB,aAAa,GAAG;AAC9C,oBAAQ,KAAK,EAAE,YAAY,YAAY,OAAU,CAAC;AAClD;AAAA,UACF;AAAA,QACF;AAAA,MAEF,SAAS,GAAG;AACV;AAAA,MACF;AAAA,IACF,OAAO;AAEL,YAAM,gBAAgB,QAAQ,wBAAwB,YAAY;AAAA,QAChE,KAAK,OAAO,KAAK;AAAA,QACjB,KAAK,OAAO,KAAK;AAAA,MACnB,CAAC;AACD,YAAM,cAAc,cAAc,OAAO,CAAC,SAAS,GAAG,oBAAoB,IAAI,CAAC;AAC/E,YAAM,aAAa,YAAY,CAAC;AAChC,UAAI,CAAC,WAAY;AACjB,YAAM,kBAAkB,WAAW;AACnC,UAAI,CAAC,GAAG,gBAAgB,eAAe,EAAG;AAC1C,YAAM,aAAa,gBAAgB;AACnC,YAAM,aAAa,OAAO,QAAQ,QAAQ,OAAO,EAAE,EAAE,KAAK;AAC1D,UAAI,WAAW,WAAW,EAAG;AAC7B,cAAQ,KAAK,EAAE,YAAY,WAAW,CAAC;AAAA,IACzC;AAAA,EACF;AAEA,SAAO,EAAE,WAAW,QAAQ;AAC9B,CAAC;AAEM,IAAM,YAAY,CACvB,IACA,YACA,eACA,aACA,qBACG;AACH,MAAI,cAAc;AAGlB,UAAQ,iBAAiB,MAAM;AAAA,IAC7B,KAAK,mBAAmB;AACtB,YAAM,YAAY,iBAAiB,aAAa,iBAAiB;AACjE,YAAM,eAAe,iBAAiB,cAAc,iBAAiB;AACrE,oBAAc,eAAe,SAAS,UAAU,YAAY;AAC5D,SAAG;AAAA,QACD;AAAA,QACA;AAAA,QACA,GAAG,QAAQ;AAAA,UACT;AAAA,UACA,GAAG,QAAQ;AAAA,YACT;AAAA,YACA;AAAA,YACA,GAAG,QAAQ,sBAAsB,GAAG,QAAQ,iBAAiB,SAAS,CAAC;AAAA,UACzE;AAAA,UACA,GAAG,QAAQ,oBAAoB,YAAY;AAAA,QAC7C;AAAA,QACA;AAAA,QACA,eAAe,CAAC;AAAA,MAClB;AACA;AAAA,IACF;AAAA,IACA,KAAK,eAAe;AAClB,YAAM,eAAe,iBAAiB,cAAc,iBAAiB;AACrE,UAAI,iBAAiB,WAAW;AAC9B,sBAAc,YAAY,iBAAiB,IAAI,OAAO,iBAAiB,SAAS,YAAY,YAAY;AAAA,MAC1G,OAAO;AACL,sBAAc,YAAY,iBAAiB,IAAI,YAAY,YAAY;AAAA,MACzE;AAGA,UAAI,yBAAyB;AAC7B,iBAAW,aAAa,WAAW,YAAY;AAC7C,YAAI,GAAG,oBAAoB,SAAS,GAAG;AACrC,gBAAM,kBAAkB,UAAU;AAClC,cACE,mBAAmB,GAAG,gBAAgB,eAAe,KAAK,gBAAgB,SAAS,cACnF;AAEA,kBAAM,eAAe,UAAU;AAC/B,gBAAI,gBAAgB,aAAa,iBAAiB,GAAG,eAAe,aAAa,aAAa,GAAG;AAC/F,oBAAM,eAAe,aAAa;AAClC,oBAAM,0BAA0B,aAAa,SAAS,KAAK,CAAC,YAAY;AACtE,oBAAI,iBAAiB,WAAW;AAC9B,yBAAO,GAAG,OAAO,QAAQ,IAAI,MAAM,iBAAiB,QAAQ,QAAQ,gBAClE,GAAG,aAAa,QAAQ,YAAY,KACpC,GAAG,OAAO,QAAQ,YAAY,MAAM,iBAAiB;AAAA,gBACzD;AACA,uBAAO,GAAG,OAAO,QAAQ,IAAI,MAAM,iBAAiB;AAAA,cACtD,CAAC;AAED,kBAAI,yBAAyB;AAC3B,yCAAyB;AACzB;AAAA,cACF;AAEA,4BAAc;AAAA,gBACZ;AAAA,gBACA;AAAA,gBACA,GAAG,QAAQ;AAAA,kBACT,aAAa,SAAS,OAAO;AAAA,oBAC3B,GAAG,QAAQ;AAAA,sBACT;AAAA,sBACA,iBAAiB,YAAY,GAAG,QAAQ,iBAAiB,iBAAiB,IAAI,IAAI;AAAA,sBAClF,GAAG,QAAQ,iBAAiB,iBAAiB,aAAa,iBAAiB,IAAI;AAAA,oBACjF;AAAA,kBACF,CAAC;AAAA,gBACH;AAAA,cACF;AACA,uCAAyB;AACzB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,CAAC,wBAAwB;AAC3B,WAAG;AAAA,UACD;AAAA,UACA;AAAA,UACA,GAAG,QAAQ;AAAA,YACT;AAAA,YACA,GAAG,QAAQ;AAAA,cACT;AAAA,cACA;AAAA,cACA,GAAG,QAAQ;AAAA,gBACT;AAAA,kBACE,GAAG,QAAQ;AAAA,oBACT;AAAA,oBACA,iBAAiB,YAAY,GAAG,QAAQ,iBAAiB,iBAAiB,IAAI,IAAI;AAAA,oBAClF,GAAG,QAAQ,iBAAiB,iBAAiB,aAAa,iBAAiB,IAAI;AAAA,kBACjF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,YACA,GAAG,QAAQ,oBAAoB,YAAY;AAAA,UAC7C;AAAA,UACA;AAAA,UACA,eAAe,CAAC;AAAA,QAClB;AAAA,MACF;AACA;AAAA,IACF;AAAA,EACF;AAEA,SAAO,EAAE,YAAY;AACvB;;;ACxiBO,IAAM,kCAAuC,GAAG,iCAAiC;AAAA,EACtF,WAAU,aAA4B,uBAAuE;AAE3G,UAAM,+BAA+B,OAAY,QAAqC,4BAA4B;AAClH,QACE,6BAA6B,wBAAwB,WAAW,KAChE,6BAA6B,qBAAqB,WAAW,EAC7D,QAAO;AAGT,QAAI,uBAAuB;AACzB,aAAO;AAAA,QACL,GAAG;AAAA,QACH,SAAS,sBAAsB,QAAQ;AAAA,UAAI,CAAC,UAC1C,MAAM,OACH;AAAA,YACC,GAAG;AAAA,YACH,MAAM;AAAA,cACJ,GAAG,MAAM;AAAA,cACT,mBAAmB,MAAM,mBAAmB,sBAAsB;AAAA,YACpE;AAAA,UACF,IACA;AAAA,QACJ;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AAEA,IAAM,8BAAmC,GAAG,6BAA6B;AAAA,EACvE,WAAU,YAA2B,aAA+C,YAAoB;AAEtG,QAAI,CAAC,YAAa;AAElB,QAAI,YAAY,WAAW,EAAG;AAC9B,UAAM,SAAS,YAAY,CAAC;AAC5B,UAAM,UAAU,OAAO;AACvB,QAAI,QAAQ,WAAW,EAAG;AAC1B,UAAM,kBAAkB,OAAO,QAAQ,CAAC;AACxC,QAAI,gBAAgB,aAAa,WAAW,SAAU;AACtD,UAAM,cAAc,gBAAgB;AACpC,UAAM,sBAAsB,OAAkB,uBAAuB,YAAY,WAAW;AAC5F,QAAI,CAAC,oBAAqB;AAC1B,QAAI,oBAAoB,UAAU,WAAW,EAAG;AAChD,QAAI,oBAAoB,QAAQ,WAAW,EAAG;AAC9C,QAAI,oBAAoB,QAAQ,CAAC,EAAE,eAAe,WAAY;AAC9D,WAAO,oBAAoB,QAAQ,CAAC;AAAA,EACtC;AACF;AAEA,IAAM,sBAA2B,GAAG,mCAAmC,EAAE,WACvE,eACA,aACA,qBACA,YACA,mBACA,kBACA;AACA,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,MAAI,cAAc;AAGlB,QAAM,gBAAgB,GAAG,WAAW;AAAA,IAClC,iBAAiB,CAAC;AAAA,IAClB;AAAA,EACF;AAEA,QAAM,UAAU,GAAG,YAAY,cAAc;AAAA,IAC3C;AAAA,MACE;AAAA,MACA,MAAM;AAAA,MACN,aAAa,eAAe,CAAC;AAAA,IAC/B;AAAA,IACA,CAAC,kBAAkB;AAEjB,UAAI,iBAAiB,kBAAkB;AACrC,sBAAc;AAAA,UACZ;AAAA,UACA,kBAAkB;AAAA,UAClB,iBAAiB,mBAAmB;AAAA,QACtC;AAAA,MACF;AAGA,oBAAyB;AAAA,QACvB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAE;AAAA,IACJ;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,MACE;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF,CAAC;AAEM,IAAM,oCAAyC,GAAG,mCAAmC;AAAA,EAC1F,WACE,YACA,MACA,kCACA,eACA,aACA,qBACA;AAEA,UAAM,+BAA+B,OAAY,QAAqC,4BAA4B;AAClH,QACE,6BAA6B,wBAAwB,WAAW,KAChE,6BAA6B,qBAAqB,WAAW,EAC7D,QAAO;AAGT,QAAI,CAAC,iCAAkC,QAAO;AAE9C,QAAI,CAAC,KAAM,QAAO;AAElB,UAAM,EAAE,YAAY,UAAU,gBAAgB,IAAI;AAClD,QAAI,CAAC,SAAU,QAAO;AACtB,QAAI,CAAC,WAAY,QAAO;AACxB,QAAI,CAAC,gBAAiB,QAAO;AAE7B,QAAI,EAAE,uBAAuB,MAAO,QAAO;AAC3C,UAAM,oBAAoB,KAAK;AAE/B,UAAM,SAAS,OAAO;AAAA,MACpB;AAAA,MACA,iCAAiC;AAAA,MACjC;AAAA,IACF;AACA,QAAI,CAAC,OAAQ,QAAO;AAGpB,UAAM,qBAAqB,OAAkB,4BAA4B,UAAU;AAGnF,UAAM,mBAAmB,mBAAmB,QAAQ,UAAU,UAAU;AACxE,QAAI,CAAC,iBAAkB,QAAO;AAG9B,UAAM,cAAc,OAAO;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;;;AClKO,IAAM,iCAAsC,GAAG,gCAAgC,EAAE,WACtF,YACA,qBACA,eACA,aACA,WACA;AACA,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,UAAU,OAAY,QAAsB,iBAAiB;AACnE,QAAM,qBAAqB,OAAkB,4BAA4B,UAAU;AACnF,QAAM,mBAA4C,CAAC;AAEnD,QAAM,yBAAyB,CAAC,YACzB,IAAI,aAAY;AACnB,UAAM,aAA2C,CAAC;AAClD,eAAW,eAAe,SAAS;AAEjC,UAAI,CAAC,YAAY,WAAY;AAE7B,YAAM,WAAW,GAAG;AAAA,QAClB,YAAY;AAAA,QACZ,WAAW;AAAA,QACX,QAAQ,mBAAmB;AAAA,QAC3B;AAAA,MACF;AACA,UAAI,CAAC,SAAS,eAAgB;AAE9B,YAAM,aAAa,mBAAmB,QAAQ,SAAS,eAAe,kBAAkB,YAAY,UAAU;AAC9G,UAAI,CAAC,WAAY;AAEjB,UAAI,WAAW,iBAAkB;AACjC,iBAAW,KAAK,UAAU;AAAA,IAC5B;AAEA,UAAM,gBAAgB,GAAG,WAAW;AAAA,MAClC;AAAA,MACA;AAAA,IACF;AAEA,UAAM,QAAQ,GAAG,YAAY,cAAc;AAAA,MACzC;AAAA,QACE;AAAA,QACA,MAAM;AAAA,QACN,aAAa,eAAe,CAAC;AAAA,MAC/B;AAAA,MACA,CAAC,kBACC,WAAW,QAAQ,CAAC,MAAiB,UAAU,IAAI,YAAY,eAAe,aAAa,CAAC,CAAC;AAAA,IACjG;AACA,WAAO;AAAA,EACT,CAAC;AAEH,aAAW,WAAW,WAAW;AAC/B,UAAM,kBAAkB,QAAQ;AAEhC,QAAI,gBAAgB,WAAW,GAAG;AAChC,uBAAiB,KAAK,OAAO;AAC7B;AAAA,IACF;AAEA,QAAI,gBAAgB,CAAC,EAAE,aAAa,WAAW,UAAU;AACvD,uBAAiB,KAAK,OAAO;AAC7B;AAAA,IACF;AAEA,UAAM,gBAAgB,OAAkB,uBAAuB,YAAY,gBAAgB,CAAC,EAAE,WAAW;AACzG,QAAI,CAAC,eAAe;AAClB,uBAAiB,KAAK,OAAO;AAC7B;AAAA,IACF;AAEA,QAAI,cAAc,UAAU,WAAW,GAAG;AACxC,uBAAiB,KAAK,OAAO;AAC7B;AAAA,IACF;AAEA,UAAM,UAAU,OAAO;AAAA,MACrB,uBAAuB,cAAc,OAAO;AAAA,MACvCC,QAAO,MAAW,QAAQ,QAAQ,OAAO,CAAC;AAAA,IACjD;AACA,QAAI,SAAS;AACX,uBAAiB,KAAK,EAAE,GAAG,SAAS,QAAQ,CAAC;AAAA,IAC/C,OAAO;AACL,uBAAiB,KAAK,OAAO;AAAA,IAC/B;AAAA,EACF;AAEA,SAAO;AACT,CAAC;;;ACvFM,SAAS,oBACd,0BACA,YACA,UAQA;AACA,SAAY,IAAI,aAAY;AAC1B,UAAM,UAAU,OAAY,QAAsB,iBAAiB;AACnE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,YAAY,QAAQ,YAAY,QAAQ;AAE9C,aAAS,4BAA4BC,SAAmB;AACtD,UAAIA,QAAO,kBAAkB;AAC3B,cAAMC,cAAa,QAAQ,oBAAoBD,QAAO,gBAAgB;AACtE,YAAIC,aAAY;AACd,gBAAM,cAAc,QAAQ,2CAA2CA,WAAU;AACjF,cAAI,eAAe,YAAY,SAAS,eAAe;AACrD,kBAAM,aAAa,YAAY,oBAAoBA,WAAU;AAC7D,mBAAO,cAAc,WAAW,WAAW,WAAW,QAAQ,IAAI,OAAc,KAC9E,WAAW,QAAQ,IAAI,MAAa,KACpC,WAAW,QAAQ,IAAI,mBAA0B;AAAA,UACrD;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,aAAS,kCAAkCD,SAAmB;AAC5D,UAAIA,QAAO,kBAAkB;AAC3B,cAAMC,cAAa,QAAQ,oBAAoBD,QAAO,gBAAgB;AACtE,YAAIC,aAAY;AACd,gBAAM,cAAc,QAAQ,2CAA2CA,WAAU;AACjF,cAAI,eAAe,YAAY,SAAS,eAAe;AACrD,kBAAM,aAAa,YAAY,oBAAoBA,WAAU;AAC7D,mBAAO,cAAc,WAAW,WAAW,WAAW,QAAQ,IAAI,WAAkB,KAClF,WAAW,QAAQ,IAAI,MAAa;AAAA,UACxC;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAGA,QAAI,UAAyB;AAC7B,QAAI,WAA2B;AAC/B,eAAW,QAAQ,QAAQ,wBAAwB,YAAY,SAAS,GAAG;AACzE,UACE,GAAG,2BAA2B,IAAI,KAClC,GAAG,aAAa,KAAK,IAAI,KACzB,QAAQ,cAAc,SAAS,EAAE,KAAK,IAAI,GAC1C;AACA,cAAM,OAAO,YAAY,kBAAkB,IAAI;AAC/C,mBAAW,WAAW,YAAY,oBAAoB,MAAM,GAAG,cAAc,IAAI,GAAG;AAElF,cAAI,QAAQ,WAAW,UAAU,KAAK,kCAAkC,QAAQ,WAAW,CAAC,CAAC,GAAG;AAC9F,sBAAU,GAAG,OAAO,KAAK,IAAI;AAC7B,uBAAW,KAAK;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,QAAI,YAAY,QAAQ,aAAa,KAAM,QAAO;AAGlD,UAAM,SAAsC,CAAC;AAC7C,UAAM,cAA8B,CAAC;AACrC,UAAM,oBAAoB,CAAC,SAAkB;AAC3C,kBAAY,KAAK,IAAI;AACrB,aAAO;AAAA,IACT;AAGA,UAAM,cAAoC,CAAC;AAC3C,eAAW,eAAe,QAAQ,eAAe,GAAG;AAClD,UAAI,YAAY,kBAAmB;AACnC,UAAI,YAAY,KAAK,QAAQ,MAAM,MAAM,MAAM,YAAY,KAAK,QAAQ,mBAAmB,MAAM,GAAI;AAErG,UAAI,YAAY,KAAK,QAAQ,OAAO,IAAI,IAAI;AAC1C,oBAAY,QAAQ,WAAW;AAAA,MACjC,OAAO;AACL,oBAAY,KAAK,WAAW;AAAA,MAC9B;AAAA,IACF;AAEA,eAAW,cAAc,aAAa;AAEpC,UAAI,OAAO,SAAS,EAAG;AAGvB,SAAG,aAAa,YAAY,iBAAiB;AAE7C,aAAO,OAAO,WAAW,KAAK,YAAY,SAAS,GAAG;AACpD,cAAM,OAAO,YAAY,MAAM;AAC/B,YACE,GAAG,iBAAiB,IAAI,KAAK,GAAG,2BAA2B,KAAK,UAAU,KAC1E,GAAG,aAAa,KAAK,WAAW,IAAI,MACnC,GAAG,OAAO,KAAK,WAAW,IAAI,MAAM,UAAU,GAAG,OAAO,KAAK,WAAW,IAAI,MAAM,sBACnF;AACA,gBAAMD,UAAS,YAAY,oBAAoB,KAAK,WAAW,IAAI;AACnE,cAAIA,WAAU,4BAA4BA,OAAM,GAAG;AACjD,kBAAM,OAAO,YAAY,kBAAkB,IAAI;AAC/C,kBAAM,OAAO,KAAK,YAAY,MAAM;AACpC,gBAAI,MAAM;AACR,oBAAM,WAAW,YAAY,0BAA0B,MAAM,IAAI;AACjE,kBAAI,WAAW,YAAY,SAAS,UAAU,QAAS,QAAO,KAAK,CAAC,MAAMA,OAAM,CAAC;AAAA,YACnF;AAAA,UACF;AAAA,QACF;AAEA,WAAG,aAAa,MAAM,iBAAiB;AAAA,MACzC;AAAA,IACF;AAGA,QAAI,OAAO,WAAW,EAAG,QAAO;AAGhC,UAAM,kBAAkB,OAAO,IAAI,CAAC,CAAC,IAAI,OAAO;AAAA,MAC9C,UAAU,KAAK,cAAc,EAAE;AAAA,MAC/B,UAAU,GAAG,eAAe,KAAK,SAAS,GAAG,KAAK,MAAM,KAAK,SAAS,CAAC;AAAA,MACvE,MAAM,GAAG,kBAAkB;AAAA,MAC3B,MAAM;AAAA,MACN,eAAe,GAAG,kBAAkB;AAAA,MACpC,eAAe;AAAA,IACjB,EAAE;AAEF,QAAI,0BAA0B;AAC5B,aAAO;AAAA,QACL,GAAG;AAAA,QACH,cAAc,yBAAyB,eAAe,CAAC,GAAG,OAAO,eAAe;AAAA,MAClF;AAAA,IACF;AAEA,WAAQ;AAAA,MACN,UAAU,GAAG,eAAe,SAAS,SAAS,GAAG,SAAS,MAAM,SAAS,SAAS,CAAC;AAAA,MACnF,aAAa;AAAA,IACf;AAAA,EACF,CAAC;AACH;;;ACnJO,SAAS,KACd,0BACA,YACA,UASA;AACA,SAAO,oBAAoB,0BAA0B,YAAY,QAAQ;AAC3E;;;ACfO,IAAM,oBAAyB,GAAG,mBAAmB,EAAE,WAC5D,YACA,OACA,aACA,YACA;AAEA,MAAI,CAAC,YAAa,QAAO;AACzB,MAAI,YAAY,4CAA4C,KAAM,QAAO;AACzE,MAAI,CAAC,WAAY,QAAO;AAExB,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,QAAM,SAA8B,CAAC;AAGrC,QAAM,YAAY,CAAC,SAAkB;AACnC,WAAO;AAAA,MACL,WAAW,UAAU,IAAI;AAAA,MACpBE,QAAO,MAAM,KAAK,WAAW,YAAY,IAAI,GAAQA,QAAO,MAAM,WAAW,oBAAoB,IAAI,CAAC,CAAC,CAAC;AAAA,IAC/G;AAAA,EACF;AAGA,aAAW,aAAa,YAAY;AAClC,QAAI,aAAa;AACjB,QAAI,UAAU,SAAS,GAAG,cAAc,MAAM;AAC5C,YAAM,OAAO,QAAQ,kCAAkC,YAAY,UAAU,WAAW,CAAC;AACzF,UAAI,QAAQ,KAAK,QAAQ;AACvB,cAAM,cAAc,KAAK;AACzB,eAAO;AAAA,UACL,UAAU,WAAW;AAAA,UAChBC,KAAI,CAAC,MAAM;AACd,kBAAM,iBAAiB,GAAG,gBAAgB,EAAE,mBAAmB,GAAG,WAAW,iBAAiB,UAAU;AACxG,gBACE,kBAAkB,EAAE,QAAQ,UAAU,YAAY,eAAe,OACjE,UAAU,YAAY,EAAE,KAAK,SAAS,UAAU,GAChD;AACA,2BAAa;AAAA,YACf;AAAA,UACF,CAAC;AAAA,UACI;AAAA,QACP;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,WAAY,QAAO,KAAK,SAAS;AAAA,EACxC;AAEA,SAAO;AACT,CAAC;;;ACpDD,IAAM,sBAAyB,KAA2B,CAAC,IAAI,OAAO,GAAG,SAAS,GAAG,QAAQ,GAAG,SAAS,GAAG,IAAI;AAEhH,IAAM,iBAAoB;AAAA,EAAsB,CAAC,IAAI,OACnD,GAAG,SAAS,GAAG,QAAQ,OAAO,GAAG,SAAS,OAAO,GAAG,SACnD,OAAO,GAAG,SAAS,cAAiB,MAAM,mBAAmB,EAAE,GAAG,MAAO,GAAG,IAAK,IAAI;AACxF;AAEO,SAAS,aAAaC,YAA0E;AACrG,MAAI,CAACA,WAAW,QAAY,QAAQA,UAAS;AAC7C,MAAIA,WAAU,MAAM;AAClB,WAAY,QAAQ;AAAA,MAClB,GAAGA;AAAA,MACH,MAAY,WAAWA,WAAU,MAAM,cAAc;AAAA,IACvD,CAAC;AAAA,EACH;AACA,SAAY,QAAQA,UAAS;AAC/B;;;ACbO,SAAS,eACd,YACA,UACAC,YACA;AACA,SAAO;AAAA,IACA,IAAI,aAAY;AACnB,YAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,YAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,YAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,YAAM,UAAU,OAAY,QAAqC,4BAA4B;AAG7F,UAAI,QAAQ,8BAA8B,QAAS,QAAOA;AAE1D,eAAS,uBAAuB,aAAsB,aAAqB;AACzE,YAAI,uBAAuB;AAC3B,YAAI,QAAQ,yBAAyB,GAAG;AACtC,gBAAM,WAAW,YAAY;AAAA,YAC3B;AAAA,YACA;AAAA,YACA,GAAG,iBAAiB;AAAA;AAAA,YAEpB;AAAA,YACA;AAAA,YACA,QAAQ;AAAA,UACV;AACA,gBAAM,UAAU,GAAG,cAAc,CAAC,CAAC;AACnC,iCAAuB,WAAW,QAAQ,UAAU,GAAG,SAAS,aAAa,UAAU,UAAU,IAAI;AAAA,QACvG,OAAO;AACL,iCAAuB,YAAY,aAAa,aAAa,QAAW,GAAG,gBAAgB,YAAY;AAAA,QACzG;AACA,eAAO,QAAQ,WAAW,MAAM,oBAAoB;AAAA,MACtD;AAEA,eAAS,uBAAuB,OAAe,GAAY,GAAY,GAAyC;AAC9G,eAAO,CAAC;AAAA,UACN,MAAM;AAAA,UACN,MACE,eACQ,QAAQ,UACf,uBAAuB,GAAG,SAAS,IACpC,OACC,uBAAuB,GAAG,SAAS,IACpC,OACC,uBAAuB,GAAG,cAAc,IACzC;AAAA,QAEJ,CAAC;AAAA,MACH;AAEA,eAAS,oBAAoBC,OAAwB;AACnD,YAAI,GAAG,gBAAgBA,MAAK,MAAM,KAAKA,MAAK,QAAQA,MAAK,OAAO,KAAK;AACnE,iBAAOA,MAAK,OAAO;AAAA,QACrB;AACA,YAAI,GAAG,mBAAmBA,MAAK,MAAM,KAAKA,MAAK,QAAQA,MAAK,OAAO,KAAK;AACtE,iBAAOA,MAAK;AAAA,QACd;AACA,YAAI,GAAG,oBAAoBA,MAAK,MAAM,GAAG;AACvC,iBAAOA,MAAK;AAAA,QACd;AACA,eAAOA;AAAA,MACT;AAEA,eAAS,sBAAsB;AAE7B,YAAI,EAAE,6BAA6B,MAAM,OAAO,GAAG,4BAA4B,YAAa;AAE5F,cAAM,eAAe,GAAG,wBAAwB,YAAY,QAAQ;AAEpE,YAAI,iBAAiB,WAAY;AACjC,cAAM,eAAe,oBAAoB,YAAY;AAErD,YAAI,GAAG,QAAQ,YAAY,KAAK,aAAa,SAAS,GAAG,WAAW,cAAc;AAChF,cACE,GAAG,kBAAkB,aAAa,MAAM,KAAK,aAAa,OAAO,iBACjE,aAAa,OAAO,YACpB;AAEA,mBAAO;AAAA,cACL,MAAM,YAAY,kBAAkB,aAAa,OAAO,UAAU;AAAA,cAClE,YAAY,aAAa,OAAO;AAAA,cAChC,MAAM,aAAa;AAAA,cACnB,WAAW;AAAA,YACb;AAAA,UACF;AAAA,QACF;AAEA,eAAO;AAAA,UACL,MAAM,YAAY,kBAAkB,YAAY;AAAA,UAChD,YAAY;AAAA,UACZ,MAAM;AAAA,UACN,WAAW,QAAQ,8BAA8B,YAAYD,aAAY,OAAOA,cAC9E,GAAG,qBAAqBA,WAAU,YAAY,EAAE,QAAQ,KAAK,IAAI;AAAA,QACrE;AAAA,MACF;AAGA,YAAM,OAAO,oBAAoB;AACjC,UAAI,EAAE,QAAQ,KAAK,WAAY,QAAOA;AACtC,YAAM,EAAE,YAAY,MAAM,KAAK,IAAI;AAGnC,YAAM,8BAA8B,OAAO;AAAA,QACzC,WAAW;AAAA,UACT;AAAA,UACA;AAAA,QACF;AAAA,QACKE,KAAI,CAAC,MAAM,uBAAuB,0BAA0B,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;AAAA,QAC1EC,QAAO,MAAM;AAEhB,gBAAM,gBAAgB,YAAY,oBAAoB,MAAM,GAAG,cAAc,IAAI;AACjF,cAAI,cAAc,WAAW,EAAG,QAAY,QAAQ,CAAC,CAAC;AACtD,gBAAM,aAAa,YAAY,yBAAyB,cAAc,CAAC,CAAC;AACxE,iBAAO;AAAA,YACL,WAAW;AAAA,cACT;AAAA,cACA;AAAA,YACF;AAAA,YACKD,KAAI,CAAC,MAAM,uBAAuB,mCAAmC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;AAAA,UAC1F;AAAA,QACF,CAAC;AAAA,MACH;AAGA,UAAI,CAACF,YAAW;AACd,cAAM,QAAQ,GAAG,kBAAkB,MAAM,UAAU;AACnD,cAAM,MAAM,KAAK;AACjB,eAAO;AAAA,UACL,MAAM,GAAG,kBAAkB;AAAA,UAC3B,eAAe;AAAA,UACf,UAAU,EAAE,OAAO,QAAQ,MAAM,MAAM;AAAA,UACvC,eAAe;AAAA,QACjB;AAAA,MACF;AAEA,UAAIA,WAAU,eAAe;AAC3B,eAAO;AAAA,UACL,GAAGA;AAAA,UACH,eAAe,4BAA4B,OAAOA,WAAU,aAAa;AAAA,QAC3E;AAAA,MACF;AAEA,aAAO;AAAA,QACL,GAAGA;AAAA,QACH,eAAe;AAAA,MACjB;AAAA,IACF,CAAC;AAAA,IACIG,QAAO,MAAW,QAAQH,UAAS,CAAC;AAAA,EAC3C;AACF;;;AChIA,IAAM,YAA0B;AAIhC,IAAM,WAAwB;AAC9B,IAAM,SAAwB;AAE9B,IAAM,cAA0B;AAKhC,SAAS,OAAO,KAAK;AAAE,MAAI,MAAM,IAAI;AAAQ,SAAO,EAAE,OAAO,GAAG;AAAE,QAAI,GAAG,IAAI;AAAA,EAAG;AAAE;AAIlF,IAAM,eAAe;AACrB,IAAM,eAAe;AACrB,IAAM,YAAe;AAGrB,IAAM,cAAiB;AACvB,IAAM,cAAiB;AAQvB,IAAM,iBAAkB;AAGxB,IAAM,aAAkB;AAGxB,IAAM,YAAkB,aAAa,IAAI;AAGzC,IAAM,YAAkB;AAGxB,IAAM,aAAkB;AAGxB,IAAM,cAAkB,IAAI,YAAY;AAGxC,IAAM,aAAkB;AAGxB,IAAM,WAAgB;AAQtB,IAAM,cAAc;AAGpB,IAAM,YAAc;AAGpB,IAAM,UAAc;AAGpB,IAAM,YAAc;AAGpB,IAAM,cAAc;AAIpB,IAAM;AAAA;AAAA,EACJ,IAAI,WAAW,CAAC,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,CAAC,CAAC;AAAA;AAE5E,IAAM;AAAA;AAAA,EACJ,IAAI,WAAW,CAAC,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,EAAE,CAAC;AAAA;AAEtF,IAAM;AAAA;AAAA,EACJ,IAAI,WAAW,CAAC,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,CAAC,CAAC;AAAA;AAExD,IAAM,WACJ,IAAI,WAAW,CAAC,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,EAAE,CAAC;AAajE,IAAM,gBAAgB;AAGtB,IAAM,eAAgB,IAAI,OAAO,YAAY,KAAK,CAAC;AACnD,OAAO,YAAY;AAOnB,IAAM,eAAgB,IAAI,MAAM,YAAY,CAAC;AAC7C,OAAO,YAAY;AAKnB,IAAM,aAAgB,IAAI,MAAM,aAAa;AAC7C,OAAO,UAAU;AAMjB,IAAM,eAAgB,IAAI,MAAM,cAAc,cAAc,CAAC;AAC7D,OAAO,YAAY;AAGnB,IAAM,cAAgB,IAAI,MAAM,cAAc;AAC9C,OAAO,WAAW;AAGlB,IAAM,YAAgB,IAAI,MAAM,SAAS;AACzC,OAAO,SAAS;AAIhB,SAAS,eAAe,aAAa,YAAY,YAAY,OAAO,YAAY;AAE9E,OAAK,cAAe;AACpB,OAAK,aAAe;AACpB,OAAK,aAAe;AACpB,OAAK,QAAe;AACpB,OAAK,aAAe;AAGpB,OAAK,YAAe,eAAe,YAAY;AACjD;AAGA,IAAI;AACJ,IAAI;AACJ,IAAI;AAGJ,SAAS,SAAS,UAAU,WAAW;AACrC,OAAK,WAAW;AAChB,OAAK,WAAW;AAChB,OAAK,YAAY;AACnB;AAIA,IAAM,SAAS,CAAC,SAAS;AAEvB,SAAO,OAAO,MAAM,WAAW,IAAI,IAAI,WAAW,OAAO,SAAS,EAAE;AACtE;AAOA,IAAM,YAAY,CAAC,GAAG,MAAM;AAG1B,IAAE,YAAY,EAAE,SAAS,IAAK,IAAK;AACnC,IAAE,YAAY,EAAE,SAAS,IAAK,MAAM,IAAK;AAC3C;AAOA,IAAM,YAAY,CAAC,GAAG,OAAO,WAAW;AAEtC,MAAI,EAAE,WAAY,WAAW,QAAS;AACpC,MAAE,UAAW,SAAS,EAAE,WAAY;AACpC,cAAU,GAAG,EAAE,MAAM;AACrB,MAAE,SAAS,SAAU,WAAW,EAAE;AAClC,MAAE,YAAY,SAAS;AAAA,EACzB,OAAO;AACL,MAAE,UAAW,SAAS,EAAE,WAAY;AACpC,MAAE,YAAY;AAAA,EAChB;AACF;AAGA,IAAM,YAAY,CAAC,GAAG,GAAG,SAAS;AAEhC;AAAA,IAAU;AAAA,IAAG,KAAK,IAAI,CAAC;AAAA,IAAY,KAAK,IAAI,IAAI,CAAC;AAAA;AAAA,EAAS;AAC5D;AAQA,IAAM,aAAa,CAAC,MAAM,QAAQ;AAEhC,MAAI,MAAM;AACV,KAAG;AACD,WAAO,OAAO;AACd,cAAU;AACV,YAAQ;AAAA,EACV,SAAS,EAAE,MAAM;AACjB,SAAO,QAAQ;AACjB;AAMA,IAAM,WAAW,CAAC,MAAM;AAEtB,MAAI,EAAE,aAAa,IAAI;AACrB,cAAU,GAAG,EAAE,MAAM;AACrB,MAAE,SAAS;AACX,MAAE,WAAW;AAAA,EAEf,WAAW,EAAE,YAAY,GAAG;AAC1B,MAAE,YAAY,EAAE,SAAS,IAAI,EAAE,SAAS;AACxC,MAAE,WAAW;AACb,MAAE,YAAY;AAAA,EAChB;AACF;AAaA,IAAM,aAAa,CAAC,GAAG,SAAS;AAI9B,QAAM,OAAkB,KAAK;AAC7B,QAAM,WAAkB,KAAK;AAC7B,QAAM,QAAkB,KAAK,UAAU;AACvC,QAAM,YAAkB,KAAK,UAAU;AACvC,QAAM,QAAkB,KAAK,UAAU;AACvC,QAAM,OAAkB,KAAK,UAAU;AACvC,QAAM,aAAkB,KAAK,UAAU;AACvC,MAAI;AACJ,MAAI,GAAG;AACP,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,WAAW;AAEf,OAAK,OAAO,GAAG,QAAQ,YAAY,QAAQ;AACzC,MAAE,SAAS,IAAI,IAAI;AAAA,EACrB;AAKA,OAAK,EAAE,KAAK,EAAE,QAAQ,IAAI,IAAI,CAAC,IAAY;AAE3C,OAAK,IAAI,EAAE,WAAW,GAAG,IAAI,aAAa,KAAK;AAC7C,QAAI,EAAE,KAAK,CAAC;AACZ,WAAO,KAAK,KAAK,IAAI,IAAI,CAAC,IAAY,IAAI,CAAC,IAAY;AACvD,QAAI,OAAO,YAAY;AACrB,aAAO;AACP;AAAA,IACF;AACA,SAAK,IAAI,IAAI,CAAC,IAAY;AAG1B,QAAI,IAAI,UAAU;AAAE;AAAA,IAAU;AAE9B,MAAE,SAAS,IAAI;AACf,YAAQ;AACR,QAAI,KAAK,MAAM;AACb,cAAQ,MAAM,IAAI,IAAI;AAAA,IACxB;AACA,QAAI,KAAK,IAAI,CAAC;AACd,MAAE,WAAW,KAAK,OAAO;AACzB,QAAI,WAAW;AACb,QAAE,cAAc,KAAK,MAAM,IAAI,IAAI,CAAC,IAAY;AAAA,IAClD;AAAA,EACF;AACA,MAAI,aAAa,GAAG;AAAE;AAAA,EAAQ;AAM9B,KAAG;AACD,WAAO,aAAa;AACpB,WAAO,EAAE,SAAS,IAAI,MAAM,GAAG;AAAE;AAAA,IAAQ;AACzC,MAAE,SAAS,IAAI;AACf,MAAE,SAAS,OAAO,CAAC,KAAK;AACxB,MAAE,SAAS,UAAU;AAIrB,gBAAY;AAAA,EACd,SAAS,WAAW;AAOpB,OAAK,OAAO,YAAY,SAAS,GAAG,QAAQ;AAC1C,QAAI,EAAE,SAAS,IAAI;AACnB,WAAO,MAAM,GAAG;AACd,UAAI,EAAE,KAAK,EAAE,CAAC;AACd,UAAI,IAAI,UAAU;AAAE;AAAA,MAAU;AAC9B,UAAI,KAAK,IAAI,IAAI,CAAC,MAAc,MAAM;AAEpC,UAAE,YAAY,OAAO,KAAK,IAAI,IAAI,CAAC,KAAa,KAAK,IAAI,CAAC;AAC1D,aAAK,IAAI,IAAI,CAAC,IAAY;AAAA,MAC5B;AACA;AAAA,IACF;AAAA,EACF;AACF;AAWA,IAAM,YAAY,CAAC,MAAM,UAAU,aAAa;AAK9C,QAAM,YAAY,IAAI,MAAM,aAAa,CAAC;AAC1C,MAAI,OAAO;AACX,MAAI;AACJ,MAAI;AAKJ,OAAK,OAAO,GAAG,QAAQ,YAAY,QAAQ;AACzC,WAAQ,OAAO,SAAS,OAAO,CAAC,KAAM;AACtC,cAAU,IAAI,IAAI;AAAA,EACpB;AAQA,OAAK,IAAI,GAAI,KAAK,UAAU,KAAK;AAC/B,QAAI,MAAM,KAAK,IAAI,IAAI,CAAC;AACxB,QAAI,QAAQ,GAAG;AAAE;AAAA,IAAU;AAE3B,SAAK,IAAI,CAAC,IAAa,WAAW,UAAU,GAAG,KAAK,GAAG;AAAA,EAIzD;AACF;AAMA,IAAM,iBAAiB,MAAM;AAE3B,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,QAAM,WAAW,IAAI,MAAM,aAAa,CAAC;AAgBzC,WAAS;AACT,OAAK,OAAO,GAAG,OAAO,iBAAiB,GAAG,QAAQ;AAChD,gBAAY,IAAI,IAAI;AACpB,SAAK,IAAI,GAAG,IAAK,KAAK,YAAY,IAAI,GAAI,KAAK;AAC7C,mBAAa,QAAQ,IAAI;AAAA,IAC3B;AAAA,EACF;AAMA,eAAa,SAAS,CAAC,IAAI;AAG3B,SAAO;AACP,OAAK,OAAO,GAAG,OAAO,IAAI,QAAQ;AAChC,cAAU,IAAI,IAAI;AAClB,SAAK,IAAI,GAAG,IAAK,KAAK,YAAY,IAAI,GAAI,KAAK;AAC7C,iBAAW,MAAM,IAAI;AAAA,IACvB;AAAA,EACF;AAEA,WAAS;AACT,SAAO,OAAO,WAAW,QAAQ;AAC/B,cAAU,IAAI,IAAI,QAAQ;AAC1B,SAAK,IAAI,GAAG,IAAK,KAAM,YAAY,IAAI,IAAI,GAAK,KAAK;AACnD,iBAAW,MAAM,MAAM,IAAI;AAAA,IAC7B;AAAA,EACF;AAIA,OAAK,OAAO,GAAG,QAAQ,YAAY,QAAQ;AACzC,aAAS,IAAI,IAAI;AAAA,EACnB;AAEA,MAAI;AACJ,SAAO,KAAK,KAAK;AACf,iBAAa,IAAI,IAAI,CAAC,IAAY;AAClC;AACA,aAAS,CAAC;AAAA,EACZ;AACA,SAAO,KAAK,KAAK;AACf,iBAAa,IAAI,IAAI,CAAC,IAAY;AAClC;AACA,aAAS,CAAC;AAAA,EACZ;AACA,SAAO,KAAK,KAAK;AACf,iBAAa,IAAI,IAAI,CAAC,IAAY;AAClC;AACA,aAAS,CAAC;AAAA,EACZ;AACA,SAAO,KAAK,KAAK;AACf,iBAAa,IAAI,IAAI,CAAC,IAAY;AAClC;AACA,aAAS,CAAC;AAAA,EACZ;AAKA,YAAU,cAAc,YAAY,GAAG,QAAQ;AAG/C,OAAK,IAAI,GAAG,IAAI,WAAW,KAAK;AAC9B,iBAAa,IAAI,IAAI,CAAC,IAAY;AAClC,iBAAa,IAAI,CAAC,IAAa,WAAW,GAAG,CAAC;AAAA,EAChD;AAGA,kBAAgB,IAAI,eAAe,cAAc,aAAa,aAAa,GAAG,WAAW,UAAU;AACnG,kBAAgB,IAAI,eAAe,cAAc,aAAa,GAAY,WAAW,UAAU;AAC/F,mBAAiB,IAAI,eAAe,IAAI,MAAM,CAAC,GAAG,cAAc,GAAW,YAAY,WAAW;AAGpG;AAMA,IAAM,aAAa,CAAC,MAAM;AAExB,MAAI;AAGJ,OAAK,IAAI,GAAG,IAAI,WAAY,KAAK;AAAE,MAAE,UAAU,IAAI,CAAC,IAAa;AAAA,EAAG;AACpE,OAAK,IAAI,GAAG,IAAI,WAAY,KAAK;AAAE,MAAE,UAAU,IAAI,CAAC,IAAa;AAAA,EAAG;AACpE,OAAK,IAAI,GAAG,IAAI,YAAY,KAAK;AAAE,MAAE,QAAQ,IAAI,CAAC,IAAa;AAAA,EAAG;AAElE,IAAE,UAAU,YAAY,CAAC,IAAa;AACtC,IAAE,UAAU,EAAE,aAAa;AAC3B,IAAE,WAAW,EAAE,UAAU;AAC3B;AAMA,IAAM,YAAY,CAAC,MACnB;AACE,MAAI,EAAE,WAAW,GAAG;AAClB,cAAU,GAAG,EAAE,MAAM;AAAA,EACvB,WAAW,EAAE,WAAW,GAAG;AAEzB,MAAE,YAAY,EAAE,SAAS,IAAI,EAAE;AAAA,EACjC;AACA,IAAE,SAAS;AACX,IAAE,WAAW;AACf;AAMA,IAAM,UAAU,CAAC,MAAM,GAAG,GAAG,UAAU;AAErC,QAAM,MAAM,IAAI;AAChB,QAAM,MAAM,IAAI;AAChB,SAAQ,KAAK,GAAG,IAAa,KAAK,GAAG,KAC7B,KAAK,GAAG,MAAe,KAAK,GAAG,KAAc,MAAM,CAAC,KAAK,MAAM,CAAC;AAC1E;AAQA,IAAM,aAAa,CAAC,GAAG,MAAM,MAAM;AAKjC,QAAM,IAAI,EAAE,KAAK,CAAC;AAClB,MAAI,IAAI,KAAK;AACb,SAAO,KAAK,EAAE,UAAU;AAEtB,QAAI,IAAI,EAAE,YACR,QAAQ,MAAM,EAAE,KAAK,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,EAAE,KAAK,GAAG;AAClD;AAAA,IACF;AAEA,QAAI,QAAQ,MAAM,GAAG,EAAE,KAAK,CAAC,GAAG,EAAE,KAAK,GAAG;AAAE;AAAA,IAAO;AAGnD,MAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC;AACpB,QAAI;AAGJ,UAAM;AAAA,EACR;AACA,IAAE,KAAK,CAAC,IAAI;AACd;AASA,IAAM,iBAAiB,CAAC,GAAG,OAAO,UAAU;AAK1C,MAAI;AACJ,MAAI;AACJ,MAAI,KAAK;AACT,MAAI;AACJ,MAAI;AAEJ,MAAI,EAAE,aAAa,GAAG;AACpB,OAAG;AACD,aAAO,EAAE,YAAY,EAAE,UAAU,IAAI,IAAI;AACzC,eAAS,EAAE,YAAY,EAAE,UAAU,IAAI,IAAI,QAAS;AACpD,WAAK,EAAE,YAAY,EAAE,UAAU,IAAI;AACnC,UAAI,SAAS,GAAG;AACd,kBAAU,GAAG,IAAI,KAAK;AAAA,MAExB,OAAO;AAEL,eAAO,aAAa,EAAE;AACtB,kBAAU,GAAG,OAAO,aAAa,GAAG,KAAK;AACzC,gBAAQ,YAAY,IAAI;AACxB,YAAI,UAAU,GAAG;AACf,gBAAM,YAAY,IAAI;AACtB,oBAAU,GAAG,IAAI,KAAK;AAAA,QACxB;AACA;AACA,eAAO,OAAO,IAAI;AAGlB,kBAAU,GAAG,MAAM,KAAK;AACxB,gBAAQ,YAAY,IAAI;AACxB,YAAI,UAAU,GAAG;AACf,kBAAQ,UAAU,IAAI;AACtB,oBAAU,GAAG,MAAM,KAAK;AAAA,QAC1B;AAAA,MACF;AAAA,IAKF,SAAS,KAAK,EAAE;AAAA,EAClB;AAEA,YAAU,GAAG,WAAW,KAAK;AAC/B;AAWA,IAAM,aAAa,CAAC,GAAG,SAAS;AAI9B,QAAM,OAAW,KAAK;AACtB,QAAM,QAAW,KAAK,UAAU;AAChC,QAAM,YAAY,KAAK,UAAU;AACjC,QAAM,QAAW,KAAK,UAAU;AAChC,MAAI,GAAG;AACP,MAAI,WAAW;AACf,MAAI;AAMJ,IAAE,WAAW;AACb,IAAE,WAAW;AAEb,OAAK,IAAI,GAAG,IAAI,OAAO,KAAK;AAC1B,QAAI,KAAK,IAAI,CAAC,MAAe,GAAG;AAC9B,QAAE,KAAK,EAAE,EAAE,QAAQ,IAAI,WAAW;AAClC,QAAE,MAAM,CAAC,IAAI;AAAA,IAEf,OAAO;AACL,WAAK,IAAI,IAAI,CAAC,IAAY;AAAA,IAC5B;AAAA,EACF;AAOA,SAAO,EAAE,WAAW,GAAG;AACrB,WAAO,EAAE,KAAK,EAAE,EAAE,QAAQ,IAAK,WAAW,IAAI,EAAE,WAAW;AAC3D,SAAK,OAAO,CAAC,IAAa;AAC1B,MAAE,MAAM,IAAI,IAAI;AAChB,MAAE;AAEF,QAAI,WAAW;AACb,QAAE,cAAc,MAAM,OAAO,IAAI,CAAC;AAAA,IACpC;AAAA,EAEF;AACA,OAAK,WAAW;AAKhB,OAAK,IAAK,EAAE,YAAY,GAAc,KAAK,GAAG,KAAK;AAAE,eAAW,GAAG,MAAM,CAAC;AAAA,EAAG;AAK7E,SAAO;AACP,KAAG;AAGD,QAAI,EAAE;AAAA,MAAK;AAAA;AAAA,IAAa;AACxB,MAAE;AAAA,MAAK;AAAA;AAAA,IAAa,IAAI,EAAE,KAAK,EAAE,UAAU;AAC3C;AAAA,MAAW;AAAA,MAAG;AAAA,MAAM;AAAA;AAAA,IAAa;AAGjC,QAAI,EAAE;AAAA,MAAK;AAAA;AAAA,IAAa;AAExB,MAAE,KAAK,EAAE,EAAE,QAAQ,IAAI;AACvB,MAAE,KAAK,EAAE,EAAE,QAAQ,IAAI;AAGvB,SAAK,OAAO,CAAC,IAAa,KAAK,IAAI,CAAC,IAAa,KAAK,IAAI,CAAC;AAC3D,MAAE,MAAM,IAAI,KAAK,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK;AACvE,SAAK,IAAI,IAAI,CAAC,IAAY,KAAK,IAAI,IAAI,CAAC,IAAY;AAGpD,MAAE;AAAA,MAAK;AAAA;AAAA,IAAa,IAAI;AACxB;AAAA,MAAW;AAAA,MAAG;AAAA,MAAM;AAAA;AAAA,IAAa;AAAA,EAEnC,SAAS,EAAE,YAAY;AAEvB,IAAE,KAAK,EAAE,EAAE,QAAQ,IAAI,EAAE;AAAA,IAAK;AAAA;AAAA,EAAa;AAK3C,aAAW,GAAG,IAAI;AAGlB,YAAU,MAAM,UAAU,EAAE,QAAQ;AACtC;AAOA,IAAM,YAAY,CAAC,GAAG,MAAM,aAAa;AAKvC,MAAI;AACJ,MAAI,UAAU;AACd,MAAI;AAEJ,MAAI,UAAU,KAAK,IAAI,IAAI,CAAC;AAE5B,MAAI,QAAQ;AACZ,MAAI,YAAY;AAChB,MAAI,YAAY;AAEhB,MAAI,YAAY,GAAG;AACjB,gBAAY;AACZ,gBAAY;AAAA,EACd;AACA,QAAM,WAAW,KAAK,IAAI,CAAC,IAAY;AAEvC,OAAK,IAAI,GAAG,KAAK,UAAU,KAAK;AAC9B,aAAS;AACT,cAAU,MAAM,IAAI,KAAK,IAAI,CAAC;AAE9B,QAAI,EAAE,QAAQ,aAAa,WAAW,SAAS;AAC7C;AAAA,IAEF,WAAW,QAAQ,WAAW;AAC5B,QAAE,QAAQ,SAAS,CAAC,KAAc;AAAA,IAEpC,WAAW,WAAW,GAAG;AAEvB,UAAI,WAAW,SAAS;AAAE,UAAE,QAAQ,SAAS,CAAC;AAAA,MAAc;AAC5D,QAAE,QAAQ,UAAU,CAAC;AAAA,IAEvB,WAAW,SAAS,IAAI;AACtB,QAAE,QAAQ,YAAY,CAAC;AAAA,IAEzB,OAAO;AACL,QAAE,QAAQ,cAAc,CAAC;AAAA,IAC3B;AAEA,YAAQ;AACR,cAAU;AAEV,QAAI,YAAY,GAAG;AACjB,kBAAY;AACZ,kBAAY;AAAA,IAEd,WAAW,WAAW,SAAS;AAC7B,kBAAY;AACZ,kBAAY;AAAA,IAEd,OAAO;AACL,kBAAY;AACZ,kBAAY;AAAA,IACd;AAAA,EACF;AACF;AAOA,IAAM,YAAY,CAAC,GAAG,MAAM,aAAa;AAKvC,MAAI;AACJ,MAAI,UAAU;AACd,MAAI;AAEJ,MAAI,UAAU,KAAK,IAAI,IAAI,CAAC;AAE5B,MAAI,QAAQ;AACZ,MAAI,YAAY;AAChB,MAAI,YAAY;AAGhB,MAAI,YAAY,GAAG;AACjB,gBAAY;AACZ,gBAAY;AAAA,EACd;AAEA,OAAK,IAAI,GAAG,KAAK,UAAU,KAAK;AAC9B,aAAS;AACT,cAAU,MAAM,IAAI,KAAK,IAAI,CAAC;AAE9B,QAAI,EAAE,QAAQ,aAAa,WAAW,SAAS;AAC7C;AAAA,IAEF,WAAW,QAAQ,WAAW;AAC5B,SAAG;AAAE,kBAAU,GAAG,QAAQ,EAAE,OAAO;AAAA,MAAG,SAAS,EAAE,UAAU;AAAA,IAE7D,WAAW,WAAW,GAAG;AACvB,UAAI,WAAW,SAAS;AACtB,kBAAU,GAAG,QAAQ,EAAE,OAAO;AAC9B;AAAA,MACF;AAEA,gBAAU,GAAG,SAAS,EAAE,OAAO;AAC/B,gBAAU,GAAG,QAAQ,GAAG,CAAC;AAAA,IAE3B,WAAW,SAAS,IAAI;AACtB,gBAAU,GAAG,WAAW,EAAE,OAAO;AACjC,gBAAU,GAAG,QAAQ,GAAG,CAAC;AAAA,IAE3B,OAAO;AACL,gBAAU,GAAG,aAAa,EAAE,OAAO;AACnC,gBAAU,GAAG,QAAQ,IAAI,CAAC;AAAA,IAC5B;AAEA,YAAQ;AACR,cAAU;AACV,QAAI,YAAY,GAAG;AACjB,kBAAY;AACZ,kBAAY;AAAA,IAEd,WAAW,WAAW,SAAS;AAC7B,kBAAY;AACZ,kBAAY;AAAA,IAEd,OAAO;AACL,kBAAY;AACZ,kBAAY;AAAA,IACd;AAAA,EACF;AACF;AAOA,IAAM,gBAAgB,CAAC,MAAM;AAE3B,MAAI;AAGJ,YAAU,GAAG,EAAE,WAAW,EAAE,OAAO,QAAQ;AAC3C,YAAU,GAAG,EAAE,WAAW,EAAE,OAAO,QAAQ;AAG3C,aAAW,GAAG,EAAE,OAAO;AASvB,OAAK,cAAc,aAAa,GAAG,eAAe,GAAG,eAAe;AAClE,QAAI,EAAE,QAAQ,SAAS,WAAW,IAAI,IAAI,CAAC,MAAc,GAAG;AAC1D;AAAA,IACF;AAAA,EACF;AAEA,IAAE,WAAW,KAAK,cAAc,KAAK,IAAI,IAAI;AAI7C,SAAO;AACT;AAQA,IAAM,iBAAiB,CAAC,GAAG,QAAQ,QAAQ,YAAY;AAIrD,MAAII;AAMJ,YAAU,GAAG,SAAS,KAAK,CAAC;AAC5B,YAAU,GAAG,SAAS,GAAK,CAAC;AAC5B,YAAU,GAAG,UAAU,GAAI,CAAC;AAC5B,OAAKA,QAAO,GAAGA,QAAO,SAASA,SAAQ;AAErC,cAAU,GAAG,EAAE,QAAQ,SAASA,KAAI,IAAI,IAAI,CAAC,GAAW,CAAC;AAAA,EAC3D;AAGA,YAAU,GAAG,EAAE,WAAW,SAAS,CAAC;AAGpC,YAAU,GAAG,EAAE,WAAW,SAAS,CAAC;AAEtC;AAgBA,IAAM,mBAAmB,CAAC,MAAM;AAK9B,MAAI,aAAa;AACjB,MAAI;AAGJ,OAAK,IAAI,GAAG,KAAK,IAAI,KAAK,gBAAgB,GAAG;AAC3C,QAAK,aAAa,KAAO,EAAE,UAAU,IAAI,CAAC,MAAe,GAAI;AAC3D,aAAO;AAAA,IACT;AAAA,EACF;AAGA,MAAI,EAAE,UAAU,IAAI,CAAC,MAAe,KAAK,EAAE,UAAU,KAAK,CAAC,MAAe,KACtE,EAAE,UAAU,KAAK,CAAC,MAAe,GAAG;AACtC,WAAO;AAAA,EACT;AACA,OAAK,IAAI,IAAI,IAAI,YAAY,KAAK;AAChC,QAAI,EAAE,UAAU,IAAI,CAAC,MAAe,GAAG;AACrC,aAAO;AAAA,IACT;AAAA,EACF;AAKA,SAAO;AACT;AAGA,IAAI,mBAAmB;AAKvB,IAAM,aAAa,CAAC,MACpB;AAEE,MAAI,CAAC,kBAAkB;AACrB,mBAAe;AACf,uBAAmB;AAAA,EACrB;AAEA,IAAE,SAAU,IAAI,SAAS,EAAE,WAAW,aAAa;AACnD,IAAE,SAAU,IAAI,SAAS,EAAE,WAAW,aAAa;AACnD,IAAE,UAAU,IAAI,SAAS,EAAE,SAAS,cAAc;AAElD,IAAE,SAAS;AACX,IAAE,WAAW;AAGb,aAAW,CAAC;AACd;AAMA,IAAM,qBAAqB,CAAC,GAAG,KAAK,YAAY,SAAS;AAMvD,YAAU,IAAI,gBAAgB,MAAM,OAAO,IAAI,IAAI,CAAC;AACpD,YAAU,CAAC;AACX,YAAU,GAAG,UAAU;AACvB,YAAU,GAAG,CAAC,UAAU;AACxB,MAAI,YAAY;AACd,MAAE,YAAY,IAAI,EAAE,OAAO,SAAS,KAAK,MAAM,UAAU,GAAG,EAAE,OAAO;AAAA,EACvE;AACA,IAAE,WAAW;AACf;AAOA,IAAM,cAAc,CAAC,MAAM;AACzB,YAAU,GAAG,gBAAgB,GAAG,CAAC;AACjC,YAAU,GAAG,WAAW,YAAY;AACpC,WAAS,CAAC;AACZ;AAOA,IAAM,oBAAoB,CAAC,GAAG,KAAK,YAAY,SAAS;AAMtD,MAAI,UAAU;AACd,MAAI,cAAc;AAGlB,MAAI,EAAE,QAAQ,GAAG;AAGf,QAAI,EAAE,KAAK,cAAc,aAAa;AACpC,QAAE,KAAK,YAAY,iBAAiB,CAAC;AAAA,IACvC;AAGA,eAAW,GAAG,EAAE,MAAM;AAItB,eAAW,GAAG,EAAE,MAAM;AAUtB,kBAAc,cAAc,CAAC;AAG7B,eAAY,EAAE,UAAU,IAAI,MAAO;AACnC,kBAAe,EAAE,aAAa,IAAI,MAAO;AAMzC,QAAI,eAAe,UAAU;AAAE,iBAAW;AAAA,IAAa;AAAA,EAEzD,OAAO;AAEL,eAAW,cAAc,aAAa;AAAA,EACxC;AAEA,MAAK,aAAa,KAAK,YAAc,QAAQ,IAAK;AAShD,uBAAmB,GAAG,KAAK,YAAY,IAAI;AAAA,EAE7C,WAAW,EAAE,aAAa,aAAa,gBAAgB,UAAU;AAE/D,cAAU,IAAI,gBAAgB,MAAM,OAAO,IAAI,IAAI,CAAC;AACpD,mBAAe,GAAG,cAAc,YAAY;AAAA,EAE9C,OAAO;AACL,cAAU,IAAI,aAAa,MAAM,OAAO,IAAI,IAAI,CAAC;AACjD,mBAAe,GAAG,EAAE,OAAO,WAAW,GAAG,EAAE,OAAO,WAAW,GAAG,cAAc,CAAC;AAC/E,mBAAe,GAAG,EAAE,WAAW,EAAE,SAAS;AAAA,EAC5C;AAKA,aAAW,CAAC;AAEZ,MAAI,MAAM;AACR,cAAU,CAAC;AAAA,EACb;AAGF;AAMA,IAAM,cAAc,CAAC,GAAG,MAAM,OAAO;AAKnC,IAAE,YAAY,EAAE,UAAU,EAAE,UAAU,IAAI;AAC1C,IAAE,YAAY,EAAE,UAAU,EAAE,UAAU,IAAI,QAAQ;AAClD,IAAE,YAAY,EAAE,UAAU,EAAE,UAAU,IAAI;AAC1C,MAAI,SAAS,GAAG;AAEd,MAAE,UAAU,KAAK,CAAC;AAAA,EACpB,OAAO;AACL,MAAE;AAEF;AAKA,MAAE,WAAW,aAAa,EAAE,IAAI,aAAa,KAAK,CAAC;AACnD,MAAE,UAAU,OAAO,IAAI,IAAI,CAAC;AAAA,EAC9B;AAEA,SAAQ,EAAE,aAAa,EAAE;AAC3B;AAEA,IAAI,aAAc;AAClB,IAAI,qBAAqB;AACzB,IAAI,oBAAqB;AACzB,IAAI,cAAc;AAClB,IAAI,cAAc;AAElB,IAAI,QAAQ;AAAA,EACX,UAAU;AAAA,EACV,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,WAAW;AAAA,EACX,WAAW;AACZ;AAyBA,IAAM,UAAU,CAAC,OAAO,KAAK,KAAK,QAAQ;AACxC,MAAI,KAAM,QAAQ,QAAS,GACvB,KAAO,UAAU,KAAM,QAAS,GAChC,IAAI;AAER,SAAO,QAAQ,GAAG;AAIhB,QAAI,MAAM,MAAO,MAAO;AACxB,WAAO;AAEP,OAAG;AACD,WAAM,KAAK,IAAI,KAAK,IAAI;AACxB,WAAM,KAAK,KAAK;AAAA,IAClB,SAAS,EAAE;AAEX,UAAM;AACN,UAAM;AAAA,EACR;AAEA,SAAQ,KAAM,MAAM,KAAM;AAC5B;AAGA,IAAI,YAAY;AA0BhB,IAAM,YAAY,MAAM;AACtB,MAAI,GAAG,QAAQ,CAAC;AAEhB,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,QAAI;AACJ,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,UAAM,IAAI,IAAM,aAAc,MAAM,IAAO,MAAM;AAAA,IACnD;AACA,UAAM,CAAC,IAAI;AAAA,EACb;AAEA,SAAO;AACT;AAGA,IAAM,WAAW,IAAI,YAAY,UAAU,CAAC;AAG5C,IAAM,QAAQ,CAAC,KAAK,KAAK,KAAK,QAAQ;AACpC,QAAM,IAAI;AACV,QAAM,MAAM,MAAM;AAElB,SAAO;AAEP,WAAS,IAAI,KAAK,IAAI,KAAK,KAAK;AAC9B,UAAO,QAAQ,IAAK,GAAG,MAAM,IAAI,CAAC,KAAK,GAAI;AAAA,EAC7C;AAEA,SAAQ,MAAO;AACjB;AAGA,IAAI,UAAU;AAqBd,IAAI,WAAW;AAAA,EACb,GAAQ;AAAA;AAAA,EACR,GAAQ;AAAA;AAAA,EACR,GAAQ;AAAA;AAAA,EACR,MAAQ;AAAA;AAAA,EACR,MAAQ;AAAA;AAAA,EACR,MAAQ;AAAA;AAAA,EACR,MAAQ;AAAA;AAAA,EACR,MAAQ;AAAA;AAAA,EACR,MAAQ;AAAA;AACV;AAqBA,IAAI,cAAc;AAAA;AAAA,EAGhB,YAAoB;AAAA,EACpB,iBAAoB;AAAA,EACpB,cAAoB;AAAA,EACpB,cAAoB;AAAA,EACpB,UAAoB;AAAA,EACpB,SAAoB;AAAA,EACpB,SAAoB;AAAA;AAAA;AAAA;AAAA,EAKpB,MAAoB;AAAA,EACpB,cAAoB;AAAA,EACpB,aAAoB;AAAA,EACpB,SAAmB;AAAA,EACnB,gBAAmB;AAAA,EACnB,cAAmB;AAAA,EACnB,aAAmB;AAAA,EACnB,aAAmB;AAAA;AAAA;AAAA,EAInB,kBAA0B;AAAA,EAC1B,cAA0B;AAAA,EAC1B,oBAA0B;AAAA,EAC1B,uBAAyB;AAAA,EAGzB,YAA0B;AAAA,EAC1B,gBAA0B;AAAA,EAC1B,OAA0B;AAAA,EAC1B,SAA0B;AAAA,EAC1B,oBAA0B;AAAA;AAAA,EAG1B,UAA0B;AAAA,EAC1B,QAA0B;AAAA;AAAA,EAE1B,WAA0B;AAAA;AAAA,EAG1B,YAA0B;AAAA;AAE5B;AAqBA,IAAM,EAAE,UAAU,kBAAkB,iBAAiB,WAAW,UAAU,IAAI;AAQ9E,IAAM;AAAA,EACJ,YAAY;AAAA,EAAc;AAAA,EAAiB,cAAc;AAAA,EAAgB,UAAU;AAAA,EAAY,SAAS;AAAA,EACxG,MAAM;AAAA,EAAQ,cAAc;AAAA,EAAgB,gBAAgB;AAAA,EAAkB,cAAc;AAAA,EAAgB,aAAa;AAAA,EACzH,uBAAuB;AAAA,EACvB;AAAA,EAAY;AAAA,EAAgB;AAAA,EAAO;AAAA,EAAS,oBAAoB;AAAA,EAChE;AAAA,EACA,YAAY;AACd,IAAI;AAKJ,IAAM,gBAAgB;AAEtB,IAAM,cAAc;AAEpB,IAAM,gBAAgB;AAGtB,IAAM,eAAgB;AAEtB,IAAM,WAAgB;AAEtB,IAAM,UAAgB,WAAW,IAAI;AAErC,IAAM,UAAgB;AAEtB,IAAM,WAAgB;AAEtB,IAAM,YAAgB,IAAI,UAAU;AAEpC,IAAM,WAAY;AAGlB,IAAM,YAAY;AAClB,IAAM,YAAY;AAClB,IAAM,gBAAiB,YAAY,YAAY;AAE/C,IAAM,cAAc;AAEpB,IAAM,aAAiB;AAEvB,IAAM,aAAiB;AAEvB,IAAM,cAAiB;AACvB,IAAM,aAAiB;AACvB,IAAM,gBAAiB;AACvB,IAAM,aAAgB;AACtB,IAAM,aAAgB;AACtB,IAAM,eAAgB;AAEtB,IAAM,eAAoB;AAC1B,IAAM,gBAAoB;AAC1B,IAAM,oBAAoB;AAC1B,IAAM,iBAAoB;AAE1B,IAAM,UAAU;AAEhB,IAAM,MAAM,CAAC,MAAM,cAAc;AAC/B,OAAK,MAAM,SAAS,SAAS;AAC7B,SAAO;AACT;AAEA,IAAM,OAAO,CAAC,MAAM;AAClB,SAAS,IAAK,KAAO,IAAK,IAAI,IAAI;AACpC;AAEA,IAAM,OAAO,CAAC,QAAQ;AACpB,MAAI,MAAM,IAAI;AAAQ,SAAO,EAAE,OAAO,GAAG;AAAE,QAAI,GAAG,IAAI;AAAA,EAAG;AAC3D;AAOA,IAAM,aAAa,CAAC,MAAM;AACxB,MAAI,GAAG;AACP,MAAI;AACJ,MAAI,QAAQ,EAAE;AAEd,MAAI,EAAE;AACN,MAAI;AACJ,KAAG;AACD,QAAI,EAAE,KAAK,EAAE,CAAC;AACd,MAAE,KAAK,CAAC,IAAK,KAAK,QAAQ,IAAI,QAAQ;AAAA,EACxC,SAAS,EAAE;AACX,MAAI;AAEJ,MAAI;AACJ,KAAG;AACD,QAAI,EAAE,KAAK,EAAE,CAAC;AACd,MAAE,KAAK,CAAC,IAAK,KAAK,QAAQ,IAAI,QAAQ;AAAA,EAIxC,SAAS,EAAE;AAEb;AAGA,IAAI,YAAY,CAAC,GAAG,MAAM,UAAW,QAAQ,EAAE,aAAc,QAAQ,EAAE;AAIvE,IAAI,OAAO;AASX,IAAM,gBAAgB,CAAC,SAAS;AAC9B,QAAM,IAAI,KAAK;AAGf,MAAI,MAAM,EAAE;AACZ,MAAI,MAAM,KAAK,WAAW;AACxB,UAAM,KAAK;AAAA,EACb;AACA,MAAI,QAAQ,GAAG;AAAE;AAAA,EAAQ;AAEzB,OAAK,OAAO,IAAI,EAAE,YAAY,SAAS,EAAE,aAAa,EAAE,cAAc,GAAG,GAAG,KAAK,QAAQ;AACzF,OAAK,YAAa;AAClB,IAAE,eAAgB;AAClB,OAAK,aAAa;AAClB,OAAK,aAAa;AAClB,IAAE,WAAgB;AAClB,MAAI,EAAE,YAAY,GAAG;AACnB,MAAE,cAAc;AAAA,EAClB;AACF;AAGA,IAAM,mBAAmB,CAAC,GAAG,SAAS;AACpC,kBAAgB,GAAI,EAAE,eAAe,IAAI,EAAE,cAAc,IAAK,EAAE,WAAW,EAAE,aAAa,IAAI;AAC9F,IAAE,cAAc,EAAE;AAClB,gBAAc,EAAE,IAAI;AACtB;AAGA,IAAM,WAAW,CAAC,GAAG,MAAM;AACzB,IAAE,YAAY,EAAE,SAAS,IAAI;AAC/B;AAQA,IAAM,cAAc,CAAC,GAAG,MAAM;AAI5B,IAAE,YAAY,EAAE,SAAS,IAAK,MAAM,IAAK;AACzC,IAAE,YAAY,EAAE,SAAS,IAAI,IAAI;AACnC;AAUA,IAAM,WAAW,CAAC,MAAM,KAAK,OAAOC,UAAS;AAE3C,MAAI,MAAM,KAAK;AAEf,MAAI,MAAMA,OAAM;AAAE,UAAMA;AAAA,EAAM;AAC9B,MAAI,QAAQ,GAAG;AAAE,WAAO;AAAA,EAAG;AAE3B,OAAK,YAAY;AAGjB,MAAI,IAAI,KAAK,MAAM,SAAS,KAAK,SAAS,KAAK,UAAU,GAAG,GAAG,KAAK;AACpE,MAAI,KAAK,MAAM,SAAS,GAAG;AACzB,SAAK,QAAQ,UAAU,KAAK,OAAO,KAAK,KAAK,KAAK;AAAA,EACpD,WAES,KAAK,MAAM,SAAS,GAAG;AAC9B,SAAK,QAAQ,QAAQ,KAAK,OAAO,KAAK,KAAK,KAAK;AAAA,EAClD;AAEA,OAAK,WAAW;AAChB,OAAK,YAAY;AAEjB,SAAO;AACT;AAYA,IAAM,gBAAgB,CAAC,GAAG,cAAc;AAEtC,MAAI,eAAe,EAAE;AACrB,MAAI,OAAO,EAAE;AACb,MAAIC;AACJ,MAAI;AACJ,MAAI,WAAW,EAAE;AACjB,MAAI,aAAa,EAAE;AACnB,QAAM,QAAS,EAAE,WAAY,EAAE,SAAS,gBACpC,EAAE,YAAY,EAAE,SAAS,iBAAiB;AAE9C,QAAM,OAAO,EAAE;AAEf,QAAM,QAAQ,EAAE;AAChB,QAAM,OAAQ,EAAE;AAMhB,QAAM,SAAS,EAAE,WAAW;AAC5B,MAAI,YAAa,KAAK,OAAO,WAAW,CAAC;AACzC,MAAI,WAAa,KAAK,OAAO,QAAQ;AAQrC,MAAI,EAAE,eAAe,EAAE,YAAY;AACjC,qBAAiB;AAAA,EACnB;AAIA,MAAI,aAAa,EAAE,WAAW;AAAE,iBAAa,EAAE;AAAA,EAAW;AAI1D,KAAG;AAED,IAAAA,SAAQ;AAWR,QAAI,KAAKA,SAAQ,QAAQ,MAAU,YAC/B,KAAKA,SAAQ,WAAW,CAAC,MAAM,aAC/B,KAAKA,MAAK,MAAqB,KAAK,IAAI,KACxC,KAAK,EAAEA,MAAK,MAAmB,KAAK,OAAO,CAAC,GAAG;AACjD;AAAA,IACF;AAQA,YAAQ;AACR,IAAAA;AAMA,OAAG;AAAA,IAEH,SAAS,KAAK,EAAE,IAAI,MAAM,KAAK,EAAEA,MAAK,KAAK,KAAK,EAAE,IAAI,MAAM,KAAK,EAAEA,MAAK,KAC/D,KAAK,EAAE,IAAI,MAAM,KAAK,EAAEA,MAAK,KAAK,KAAK,EAAE,IAAI,MAAM,KAAK,EAAEA,MAAK,KAC/D,KAAK,EAAE,IAAI,MAAM,KAAK,EAAEA,MAAK,KAAK,KAAK,EAAE,IAAI,MAAM,KAAK,EAAEA,MAAK,KAC/D,KAAK,EAAE,IAAI,MAAM,KAAK,EAAEA,MAAK,KAAK,KAAK,EAAE,IAAI,MAAM,KAAK,EAAEA,MAAK,KAC/D,OAAO;AAIhB,UAAM,aAAa,SAAS;AAC5B,WAAO,SAAS;AAEhB,QAAI,MAAM,UAAU;AAClB,QAAE,cAAc;AAChB,iBAAW;AACX,UAAI,OAAO,YAAY;AACrB;AAAA,MACF;AACA,kBAAa,KAAK,OAAO,WAAW,CAAC;AACrC,iBAAa,KAAK,OAAO,QAAQ;AAAA,IACnC;AAAA,EACF,UAAU,YAAY,KAAK,YAAY,KAAK,KAAK,SAAS,EAAE,iBAAiB;AAE7E,MAAI,YAAY,EAAE,WAAW;AAC3B,WAAO;AAAA,EACT;AACA,SAAO,EAAE;AACX;AAaA,IAAM,cAAc,CAAC,MAAM;AAEzB,QAAM,UAAU,EAAE;AAClB,MAAI,GAAG,MAAM;AAIb,KAAG;AACD,WAAO,EAAE,cAAc,EAAE,YAAY,EAAE;AAoBvC,QAAI,EAAE,YAAY,WAAW,UAAU,gBAAgB;AAErD,QAAE,OAAO,IAAI,EAAE,OAAO,SAAS,SAAS,UAAU,UAAU,IAAI,GAAG,CAAC;AACpE,QAAE,eAAe;AACjB,QAAE,YAAY;AAEd,QAAE,eAAe;AACjB,UAAI,EAAE,SAAS,EAAE,UAAU;AACzB,UAAE,SAAS,EAAE;AAAA,MACf;AACA,iBAAW,CAAC;AACZ,cAAQ;AAAA,IACV;AACA,QAAI,EAAE,KAAK,aAAa,GAAG;AACzB;AAAA,IACF;AAcA,QAAI,SAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,WAAW,IAAI;AAC7D,MAAE,aAAa;AAGf,QAAI,EAAE,YAAY,EAAE,UAAU,WAAW;AACvC,YAAM,EAAE,WAAW,EAAE;AACrB,QAAE,QAAQ,EAAE,OAAO,GAAG;AAGtB,QAAE,QAAQ,KAAK,GAAG,EAAE,OAAO,EAAE,OAAO,MAAM,CAAC,CAAC;AAI5C,aAAO,EAAE,QAAQ;AAEf,UAAE,QAAQ,KAAK,GAAG,EAAE,OAAO,EAAE,OAAO,MAAM,YAAY,CAAC,CAAC;AAExD,UAAE,KAAK,MAAM,EAAE,MAAM,IAAI,EAAE,KAAK,EAAE,KAAK;AACvC,UAAE,KAAK,EAAE,KAAK,IAAI;AAClB;AACA,UAAE;AACF,YAAI,EAAE,YAAY,EAAE,SAAS,WAAW;AACtC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EAKF,SAAS,EAAE,YAAY,iBAAiB,EAAE,KAAK,aAAa;AAsC9D;AAiBA,IAAM,iBAAiB,CAAC,GAAG,UAAU;AAMnC,MAAI,YAAY,EAAE,mBAAmB,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,mBAAmB;AAMpF,MAAI,KAAKC,OAAM,MAAM,OAAO;AAC5B,MAAI,OAAO,EAAE,KAAK;AAClB,KAAG;AAKD,UAAM;AACN,WAAQ,EAAE,WAAW,MAAO;AAC5B,QAAI,EAAE,KAAK,YAAY,MAAM;AAC3B;AAAA,IACF;AAEA,WAAO,EAAE,KAAK,YAAY;AAC1B,IAAAA,QAAO,EAAE,WAAW,EAAE;AACtB,QAAI,MAAMA,QAAO,EAAE,KAAK,UAAU;AAChC,YAAMA,QAAO,EAAE,KAAK;AAAA,IACtB;AACA,QAAI,MAAM,MAAM;AACd,YAAM;AAAA,IACR;AAOA,QAAI,MAAM,cAAe,QAAQ,KAAK,UAAU,cAC5B,UAAU,gBACV,QAAQA,QAAO,EAAE,KAAK,WAAW;AACnD;AAAA,IACF;AAKA,WAAO,UAAU,cAAc,QAAQA,QAAO,EAAE,KAAK,WAAW,IAAI;AACpE,qBAAiB,GAAG,GAAG,GAAG,IAAI;AAG9B,MAAE,YAAY,EAAE,UAAU,CAAC,IAAI;AAC/B,MAAE,YAAY,EAAE,UAAU,CAAC,IAAI,OAAO;AACtC,MAAE,YAAY,EAAE,UAAU,CAAC,IAAI,CAAC;AAChC,MAAE,YAAY,EAAE,UAAU,CAAC,IAAI,CAAC,OAAO;AAGvC,kBAAc,EAAE,IAAI;AASpB,QAAIA,OAAM;AACR,UAAIA,QAAO,KAAK;AACd,QAAAA,QAAO;AAAA,MACT;AAEA,QAAE,KAAK,OAAO,IAAI,EAAE,OAAO,SAAS,EAAE,aAAa,EAAE,cAAcA,KAAI,GAAG,EAAE,KAAK,QAAQ;AACzF,QAAE,KAAK,YAAYA;AACnB,QAAE,KAAK,aAAaA;AACpB,QAAE,KAAK,aAAaA;AACpB,QAAE,eAAeA;AACjB,aAAOA;AAAA,IACT;AAKA,QAAI,KAAK;AACP,eAAS,EAAE,MAAM,EAAE,KAAK,QAAQ,EAAE,KAAK,UAAU,GAAG;AACpD,QAAE,KAAK,YAAY;AACnB,QAAE,KAAK,aAAa;AACpB,QAAE,KAAK,aAAa;AAAA,IACtB;AAAA,EACF,SAAS,SAAS;AAQlB,UAAQ,EAAE,KAAK;AACf,MAAI,MAAM;AAIR,QAAI,QAAQ,EAAE,QAAQ;AACpB,QAAE,UAAU;AAEZ,QAAE,OAAO,IAAI,EAAE,KAAK,MAAM,SAAS,EAAE,KAAK,UAAU,EAAE,QAAQ,EAAE,KAAK,OAAO,GAAG,CAAC;AAChF,QAAE,WAAW,EAAE;AACf,QAAE,SAAS,EAAE;AAAA,IACf,OACK;AACH,UAAI,EAAE,cAAc,EAAE,YAAY,MAAM;AAEtC,UAAE,YAAY,EAAE;AAEhB,UAAE,OAAO,IAAI,EAAE,OAAO,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,GAAG,CAAC;AAClE,YAAI,EAAE,UAAU,GAAG;AACjB,YAAE;AAAA,QACJ;AACA,YAAI,EAAE,SAAS,EAAE,UAAU;AACzB,YAAE,SAAS,EAAE;AAAA,QACf;AAAA,MACF;AAEA,QAAE,OAAO,IAAI,EAAE,KAAK,MAAM,SAAS,EAAE,KAAK,UAAU,MAAM,EAAE,KAAK,OAAO,GAAG,EAAE,QAAQ;AACrF,QAAE,YAAY;AACd,QAAE,UAAU,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS;AAAA,IACjE;AACA,MAAE,cAAc,EAAE;AAAA,EACpB;AACA,MAAI,EAAE,aAAa,EAAE,UAAU;AAC7B,MAAE,aAAa,EAAE;AAAA,EACnB;AAGA,MAAI,MAAM;AACR,WAAO;AAAA,EACT;AAGA,MAAI,UAAU,gBAAgB,UAAU,cACtC,EAAE,KAAK,aAAa,KAAK,EAAE,aAAa,EAAE,aAAa;AACvD,WAAO;AAAA,EACT;AAGA,SAAO,EAAE,cAAc,EAAE;AACzB,MAAI,EAAE,KAAK,WAAW,QAAQ,EAAE,eAAe,EAAE,QAAQ;AAEvD,MAAE,eAAe,EAAE;AACnB,MAAE,YAAY,EAAE;AAEhB,MAAE,OAAO,IAAI,EAAE,OAAO,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,GAAG,CAAC;AAClE,QAAI,EAAE,UAAU,GAAG;AACjB,QAAE;AAAA,IACJ;AACA,YAAQ,EAAE;AACV,QAAI,EAAE,SAAS,EAAE,UAAU;AACzB,QAAE,SAAS,EAAE;AAAA,IACf;AAAA,EACF;AACA,MAAI,OAAO,EAAE,KAAK,UAAU;AAC1B,WAAO,EAAE,KAAK;AAAA,EAChB;AACA,MAAI,MAAM;AACR,aAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,UAAU,IAAI;AAC3C,MAAE,YAAY;AACd,MAAE,UAAU,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS;AAAA,EACjE;AACA,MAAI,EAAE,aAAa,EAAE,UAAU;AAC7B,MAAE,aAAa,EAAE;AAAA,EACnB;AAOA,SAAQ,EAAE,WAAW,MAAO;AAE5B,SAAO,EAAE,mBAAmB,OAAO,QAAwB,QAAwB,EAAE,mBAAmB;AACxG,cAAY,OAAO,EAAE,SAAS,EAAE,SAAS;AACzC,EAAAA,QAAO,EAAE,WAAW,EAAE;AACtB,MAAIA,SAAQ,cACPA,SAAQ,UAAU,eAAe,UAAU,gBAC7C,EAAE,KAAK,aAAa,KAAKA,SAAQ,MAAO;AACzC,UAAMA,QAAO,OAAO,OAAOA;AAC3B,WAAO,UAAU,cAAc,EAAE,KAAK,aAAa,KAC9C,QAAQA,QAAO,IAAI;AACxB,qBAAiB,GAAG,EAAE,aAAa,KAAK,IAAI;AAC5C,MAAE,eAAe;AACjB,kBAAc,EAAE,IAAI;AAAA,EACtB;AAGA,SAAO,OAAO,oBAAoB;AACpC;AAUA,IAAM,eAAe,CAAC,GAAG,UAAU;AAEjC,MAAI;AACJ,MAAI;AAEJ,aAAS;AAMP,QAAI,EAAE,YAAY,eAAe;AAC/B,kBAAY,CAAC;AACb,UAAI,EAAE,YAAY,iBAAiB,UAAU,cAAc;AACzD,eAAO;AAAA,MACT;AACA,UAAI,EAAE,cAAc,GAAG;AACrB;AAAA,MACF;AAAA,IACF;AAKA,gBAAY;AACZ,QAAI,EAAE,aAAa,WAAW;AAE5B,QAAE,QAAQ,KAAK,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,YAAY,CAAC,CAAC;AAC/D,kBAAY,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,IAAI,EAAE,KAAK,EAAE,KAAK;AAC1D,QAAE,KAAK,EAAE,KAAK,IAAI,EAAE;AAAA,IAEtB;AAKA,QAAI,cAAc,KAAc,EAAE,WAAW,aAAe,EAAE,SAAS,eAAiB;AAKtF,QAAE,eAAe,cAAc,GAAG,SAAS;AAAA,IAE7C;AACA,QAAI,EAAE,gBAAgB,WAAW;AAK/B,eAAS,UAAU,GAAG,EAAE,WAAW,EAAE,aAAa,EAAE,eAAe,SAAS;AAE5E,QAAE,aAAa,EAAE;AAKjB,UAAI,EAAE,gBAAgB,EAAE,kBAAuC,EAAE,aAAa,WAAW;AACvF,UAAE;AACF,WAAG;AACD,YAAE;AAEF,YAAE,QAAQ,KAAK,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,YAAY,CAAC,CAAC;AAC/D,sBAAY,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,IAAI,EAAE,KAAK,EAAE,KAAK;AAC1D,YAAE,KAAK,EAAE,KAAK,IAAI,EAAE;AAAA,QAKtB,SAAS,EAAE,EAAE,iBAAiB;AAC9B,UAAE;AAAA,MACJ,OACA;AACE,UAAE,YAAY,EAAE;AAChB,UAAE,eAAe;AACjB,UAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ;AAE7B,UAAE,QAAQ,KAAK,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;AAAA,MAQrD;AAAA,IACF,OAAO;AAIL,eAAS,UAAU,GAAG,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC;AAE7C,QAAE;AACF,QAAE;AAAA,IACJ;AACA,QAAI,QAAQ;AAEV,uBAAiB,GAAG,KAAK;AACzB,UAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,eAAO;AAAA,MACT;AAAA,IAEF;AAAA,EACF;AACA,IAAE,SAAW,EAAE,WAAY,YAAY,IAAM,EAAE,WAAW,YAAY;AACtE,MAAI,UAAU,YAAY;AAExB,qBAAiB,GAAG,IAAI;AACxB,QAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACA,MAAI,EAAE,UAAU;AAEd,qBAAiB,GAAG,KAAK;AACzB,QAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,aAAO;AAAA,IACT;AAAA,EAEF;AACA,SAAO;AACT;AAOA,IAAM,eAAe,CAAC,GAAG,UAAU;AAEjC,MAAI;AACJ,MAAI;AAEJ,MAAI;AAGJ,aAAS;AAMP,QAAI,EAAE,YAAY,eAAe;AAC/B,kBAAY,CAAC;AACb,UAAI,EAAE,YAAY,iBAAiB,UAAU,cAAc;AACzD,eAAO;AAAA,MACT;AACA,UAAI,EAAE,cAAc,GAAG;AAAE;AAAA,MAAO;AAAA,IAClC;AAKA,gBAAY;AACZ,QAAI,EAAE,aAAa,WAAW;AAE5B,QAAE,QAAQ,KAAK,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,YAAY,CAAC,CAAC;AAC/D,kBAAY,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,IAAI,EAAE,KAAK,EAAE,KAAK;AAC1D,QAAE,KAAK,EAAE,KAAK,IAAI,EAAE;AAAA,IAEtB;AAIA,MAAE,cAAc,EAAE;AAClB,MAAE,aAAa,EAAE;AACjB,MAAE,eAAe,YAAY;AAE7B,QAAI,cAAc,KAAY,EAAE,cAAc,EAAE,kBAC5C,EAAE,WAAW,aAAc,EAAE,SAAS,eAA+B;AAKvE,QAAE,eAAe,cAAc,GAAG,SAAS;AAG3C,UAAI,EAAE,gBAAgB,MAClB,EAAE,aAAa,cAAe,EAAE,iBAAiB,aAAa,EAAE,WAAW,EAAE,cAAc,OAAmB;AAKhH,UAAE,eAAe,YAAY;AAAA,MAC/B;AAAA,IACF;AAIA,QAAI,EAAE,eAAe,aAAa,EAAE,gBAAgB,EAAE,aAAa;AACjE,mBAAa,EAAE,WAAW,EAAE,YAAY;AAOxC,eAAS,UAAU,GAAG,EAAE,WAAW,IAAI,EAAE,YAAY,EAAE,cAAc,SAAS;AAM9E,QAAE,aAAa,EAAE,cAAc;AAC/B,QAAE,eAAe;AACjB,SAAG;AACD,YAAI,EAAE,EAAE,YAAY,YAAY;AAE9B,YAAE,QAAQ,KAAK,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,YAAY,CAAC,CAAC;AAC/D,sBAAY,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,IAAI,EAAE,KAAK,EAAE,KAAK;AAC1D,YAAE,KAAK,EAAE,KAAK,IAAI,EAAE;AAAA,QAEtB;AAAA,MACF,SAAS,EAAE,EAAE,gBAAgB;AAC7B,QAAE,kBAAkB;AACpB,QAAE,eAAe,YAAY;AAC7B,QAAE;AAEF,UAAI,QAAQ;AAEV,yBAAiB,GAAG,KAAK;AACzB,YAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,iBAAO;AAAA,QACT;AAAA,MAEF;AAAA,IAEF,WAAW,EAAE,iBAAiB;AAO5B,eAAS,UAAU,GAAG,GAAG,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;AAEjD,UAAI,QAAQ;AAEV,yBAAiB,GAAG,KAAK;AAAA,MAE3B;AACA,QAAE;AACF,QAAE;AACF,UAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,eAAO;AAAA,MACT;AAAA,IACF,OAAO;AAIL,QAAE,kBAAkB;AACpB,QAAE;AACF,QAAE;AAAA,IACJ;AAAA,EACF;AAEA,MAAI,EAAE,iBAAiB;AAGrB,aAAS,UAAU,GAAG,GAAG,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;AAEjD,MAAE,kBAAkB;AAAA,EACtB;AACA,IAAE,SAAS,EAAE,WAAW,YAAY,IAAI,EAAE,WAAW,YAAY;AACjE,MAAI,UAAU,YAAY;AAExB,qBAAiB,GAAG,IAAI;AACxB,QAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACA,MAAI,EAAE,UAAU;AAEd,qBAAiB,GAAG,KAAK;AACzB,QAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,aAAO;AAAA,IACT;AAAA,EAEF;AAEA,SAAO;AACT;AAQA,IAAM,cAAc,CAAC,GAAG,UAAU;AAEhC,MAAI;AACJ,MAAI;AACJ,MAAI,MAAM;AAEV,QAAM,OAAO,EAAE;AAEf,aAAS;AAKP,QAAI,EAAE,aAAa,WAAW;AAC5B,kBAAY,CAAC;AACb,UAAI,EAAE,aAAa,aAAa,UAAU,cAAc;AACtD,eAAO;AAAA,MACT;AACA,UAAI,EAAE,cAAc,GAAG;AAAE;AAAA,MAAO;AAAA,IAClC;AAGA,MAAE,eAAe;AACjB,QAAI,EAAE,aAAa,aAAa,EAAE,WAAW,GAAG;AAC9C,aAAO,EAAE,WAAW;AACpB,aAAO,KAAK,IAAI;AAChB,UAAI,SAAS,KAAK,EAAE,IAAI,KAAK,SAAS,KAAK,EAAE,IAAI,KAAK,SAAS,KAAK,EAAE,IAAI,GAAG;AAC3E,iBAAS,EAAE,WAAW;AACtB,WAAG;AAAA,QAEH,SAAS,SAAS,KAAK,EAAE,IAAI,KAAK,SAAS,KAAK,EAAE,IAAI,KAC7C,SAAS,KAAK,EAAE,IAAI,KAAK,SAAS,KAAK,EAAE,IAAI,KAC7C,SAAS,KAAK,EAAE,IAAI,KAAK,SAAS,KAAK,EAAE,IAAI,KAC7C,SAAS,KAAK,EAAE,IAAI,KAAK,SAAS,KAAK,EAAE,IAAI,KAC7C,OAAO;AAChB,UAAE,eAAe,aAAa,SAAS;AACvC,YAAI,EAAE,eAAe,EAAE,WAAW;AAChC,YAAE,eAAe,EAAE;AAAA,QACrB;AAAA,MACF;AAAA,IAEF;AAGA,QAAI,EAAE,gBAAgB,WAAW;AAI/B,eAAS,UAAU,GAAG,GAAG,EAAE,eAAe,SAAS;AAEnD,QAAE,aAAa,EAAE;AACjB,QAAE,YAAY,EAAE;AAChB,QAAE,eAAe;AAAA,IACnB,OAAO;AAIL,eAAS,UAAU,GAAG,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC;AAE7C,QAAE;AACF,QAAE;AAAA,IACJ;AACA,QAAI,QAAQ;AAEV,uBAAiB,GAAG,KAAK;AACzB,UAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,eAAO;AAAA,MACT;AAAA,IAEF;AAAA,EACF;AACA,IAAE,SAAS;AACX,MAAI,UAAU,YAAY;AAExB,qBAAiB,GAAG,IAAI;AACxB,QAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACA,MAAI,EAAE,UAAU;AAEd,qBAAiB,GAAG,KAAK;AACzB,QAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,aAAO;AAAA,IACT;AAAA,EAEF;AACA,SAAO;AACT;AAMA,IAAM,eAAe,CAAC,GAAG,UAAU;AAEjC,MAAI;AAEJ,aAAS;AAEP,QAAI,EAAE,cAAc,GAAG;AACrB,kBAAY,CAAC;AACb,UAAI,EAAE,cAAc,GAAG;AACrB,YAAI,UAAU,cAAc;AAC1B,iBAAO;AAAA,QACT;AACA;AAAA,MACF;AAAA,IACF;AAGA,MAAE,eAAe;AAGjB,aAAS,UAAU,GAAG,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC;AAC7C,MAAE;AACF,MAAE;AACF,QAAI,QAAQ;AAEV,uBAAiB,GAAG,KAAK;AACzB,UAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,eAAO;AAAA,MACT;AAAA,IAEF;AAAA,EACF;AACA,IAAE,SAAS;AACX,MAAI,UAAU,YAAY;AAExB,qBAAiB,GAAG,IAAI;AACxB,QAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACA,MAAI,EAAE,UAAU;AAEd,qBAAiB,GAAG,KAAK;AACzB,QAAI,EAAE,KAAK,cAAc,GAAG;AAC1B,aAAO;AAAA,IACT;AAAA,EAEF;AACA,SAAO;AACT;AAOA,SAAS,OAAO,aAAa,UAAU,aAAa,WAAW,MAAM;AAEnE,OAAK,cAAc;AACnB,OAAK,WAAW;AAChB,OAAK,cAAc;AACnB,OAAK,YAAY;AACjB,OAAK,OAAO;AACd;AAEA,IAAM,sBAAsB;AAAA;AAAA,EAE1B,IAAI,OAAO,GAAG,GAAG,GAAG,GAAG,cAAc;AAAA;AAAA,EACrC,IAAI,OAAO,GAAG,GAAG,GAAG,GAAG,YAAY;AAAA;AAAA,EACnC,IAAI,OAAO,GAAG,GAAG,IAAI,GAAG,YAAY;AAAA;AAAA,EACpC,IAAI,OAAO,GAAG,GAAG,IAAI,IAAI,YAAY;AAAA;AAAA,EAErC,IAAI,OAAO,GAAG,GAAG,IAAI,IAAI,YAAY;AAAA;AAAA,EACrC,IAAI,OAAO,GAAG,IAAI,IAAI,IAAI,YAAY;AAAA;AAAA,EACtC,IAAI,OAAO,GAAG,IAAI,KAAK,KAAK,YAAY;AAAA;AAAA,EACxC,IAAI,OAAO,GAAG,IAAI,KAAK,KAAK,YAAY;AAAA;AAAA,EACxC,IAAI,OAAO,IAAI,KAAK,KAAK,MAAM,YAAY;AAAA;AAAA,EAC3C,IAAI,OAAO,IAAI,KAAK,KAAK,MAAM,YAAY;AAAA;AAC7C;AAMA,IAAM,UAAU,CAAC,MAAM;AAErB,IAAE,cAAc,IAAI,EAAE;AAGtB,OAAK,EAAE,IAAI;AAIX,IAAE,iBAAiB,oBAAoB,EAAE,KAAK,EAAE;AAChD,IAAE,aAAa,oBAAoB,EAAE,KAAK,EAAE;AAC5C,IAAE,aAAa,oBAAoB,EAAE,KAAK,EAAE;AAC5C,IAAE,mBAAmB,oBAAoB,EAAE,KAAK,EAAE;AAElD,IAAE,WAAW;AACb,IAAE,cAAc;AAChB,IAAE,YAAY;AACd,IAAE,SAAS;AACX,IAAE,eAAe,EAAE,cAAc,YAAY;AAC7C,IAAE,kBAAkB;AACpB,IAAE,QAAQ;AACZ;AAGA,SAAS,eAAe;AACtB,OAAK,OAAO;AACZ,OAAK,SAAS;AACd,OAAK,cAAc;AACnB,OAAK,mBAAmB;AACxB,OAAK,cAAc;AACnB,OAAK,UAAU;AACf,OAAK,OAAO;AACZ,OAAK,SAAS;AACd,OAAK,UAAU;AACf,OAAK,SAAS;AACd,OAAK,aAAa;AAElB,OAAK,SAAS;AACd,OAAK,SAAS;AACd,OAAK,SAAS;AAEd,OAAK,SAAS;AAQd,OAAK,cAAc;AAKnB,OAAK,OAAO;AAMZ,OAAK,OAAO;AAEZ,OAAK,QAAQ;AACb,OAAK,YAAY;AACjB,OAAK,YAAY;AACjB,OAAK,YAAY;AAEjB,OAAK,aAAa;AAOlB,OAAK,cAAc;AAKnB,OAAK,eAAe;AACpB,OAAK,aAAa;AAClB,OAAK,kBAAkB;AACvB,OAAK,WAAW;AAChB,OAAK,cAAc;AACnB,OAAK,YAAY;AAEjB,OAAK,cAAc;AAKnB,OAAK,mBAAmB;AAMxB,OAAK,iBAAiB;AAYtB,OAAK,QAAQ;AACb,OAAK,WAAW;AAEhB,OAAK,aAAa;AAGlB,OAAK,aAAa;AAYlB,OAAK,YAAa,IAAI,YAAY,YAAY,CAAC;AAC/C,OAAK,YAAa,IAAI,aAAa,IAAI,UAAU,KAAK,CAAC;AACvD,OAAK,UAAa,IAAI,aAAa,IAAI,WAAW,KAAK,CAAC;AACxD,OAAK,KAAK,SAAS;AACnB,OAAK,KAAK,SAAS;AACnB,OAAK,KAAK,OAAO;AAEjB,OAAK,SAAW;AAChB,OAAK,SAAW;AAChB,OAAK,UAAW;AAGhB,OAAK,WAAW,IAAI,YAAY,WAAW,CAAC;AAI5C,OAAK,OAAO,IAAI,YAAY,IAAI,UAAU,CAAC;AAC3C,OAAK,KAAK,IAAI;AAEd,OAAK,WAAW;AAChB,OAAK,WAAW;AAKhB,OAAK,QAAQ,IAAI,YAAY,IAAI,UAAU,CAAC;AAC5C,OAAK,KAAK,KAAK;AAIf,OAAK,UAAU;AAEf,OAAK,cAAc;AAoBnB,OAAK,WAAW;AAChB,OAAK,UAAU;AAEf,OAAK,UAAU;AACf,OAAK,aAAa;AAClB,OAAK,UAAU;AACf,OAAK,SAAS;AAGd,OAAK,SAAS;AAId,OAAK,WAAW;AAalB;AAMA,IAAM,oBAAoB,CAAC,SAAS;AAElC,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,QAAM,IAAI,KAAK;AACf,MAAI,CAAC,KAAK,EAAE,SAAS,QAAS,EAAE,WAAW;AAAA,EAEb,EAAE,WAAW;AAAA,EAEb,EAAE,WAAW,eACb,EAAE,WAAW,cACb,EAAE,WAAW,iBACb,EAAE,WAAW,cACb,EAAE,WAAW,cACb,EAAE,WAAW,cAAe;AACxD,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,IAAM,mBAAmB,CAAC,SAAS;AAEjC,MAAI,kBAAkB,IAAI,GAAG;AAC3B,WAAO,IAAI,MAAM,gBAAgB;AAAA,EACnC;AAEA,OAAK,WAAW,KAAK,YAAY;AACjC,OAAK,YAAY;AAEjB,QAAM,IAAI,KAAK;AACf,IAAE,UAAU;AACZ,IAAE,cAAc;AAEhB,MAAI,EAAE,OAAO,GAAG;AACd,MAAE,OAAO,CAAC,EAAE;AAAA,EAEd;AACA,IAAE;AAAA,EAEA,EAAE,SAAS,IAAI;AAAA;AAAA,IAEf,EAAE,OAAO,aAAa;AAAA;AACxB,OAAK,QAAS,EAAE,SAAS,IACvB,IAEA;AACF,IAAE,aAAa;AACf,WAAS,CAAC;AACV,SAAO;AACT;AAGA,IAAM,eAAe,CAAC,SAAS;AAE7B,QAAM,MAAM,iBAAiB,IAAI;AACjC,MAAI,QAAQ,QAAQ;AAClB,YAAQ,KAAK,KAAK;AAAA,EACpB;AACA,SAAO;AACT;AAGA,IAAM,mBAAmB,CAAC,MAAMC,UAAS;AAEvC,MAAI,kBAAkB,IAAI,KAAK,KAAK,MAAM,SAAS,GAAG;AACpD,WAAO;AAAA,EACT;AACA,OAAK,MAAM,SAASA;AACpB,SAAO;AACT;AAGA,IAAM,eAAe,CAAC,MAAM,OAAO,QAAQ,YAAY,UAAU,aAAa;AAE5E,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,MAAI,OAAO;AAEX,MAAI,UAAU,yBAAyB;AACrC,YAAQ;AAAA,EACV;AAEA,MAAI,aAAa,GAAG;AAClB,WAAO;AACP,iBAAa,CAAC;AAAA,EAChB,WAES,aAAa,IAAI;AACxB,WAAO;AACP,kBAAc;AAAA,EAChB;AAGA,MAAI,WAAW,KAAK,WAAW,iBAAiB,WAAW,gBACzD,aAAa,KAAK,aAAa,MAAM,QAAQ,KAAK,QAAQ,KAC1D,WAAW,KAAK,WAAW,WAAY,eAAe,KAAK,SAAS,GAAI;AACxE,WAAO,IAAI,MAAM,gBAAgB;AAAA,EACnC;AAGA,MAAI,eAAe,GAAG;AACpB,iBAAa;AAAA,EACf;AAGA,QAAM,IAAI,IAAI,aAAa;AAE3B,OAAK,QAAQ;AACb,IAAE,OAAO;AACT,IAAE,SAAS;AAEX,IAAE,OAAO;AACT,IAAE,SAAS;AACX,IAAE,SAAS;AACX,IAAE,SAAS,KAAK,EAAE;AAClB,IAAE,SAAS,EAAE,SAAS;AAEtB,IAAE,YAAY,WAAW;AACzB,IAAE,YAAY,KAAK,EAAE;AACrB,IAAE,YAAY,EAAE,YAAY;AAC5B,IAAE,aAAa,CAAC,GAAG,EAAE,YAAY,YAAY,KAAK;AAElD,IAAE,SAAS,IAAI,WAAW,EAAE,SAAS,CAAC;AACtC,IAAE,OAAO,IAAI,YAAY,EAAE,SAAS;AACpC,IAAE,OAAO,IAAI,YAAY,EAAE,MAAM;AAKjC,IAAE,cAAc,KAAM,WAAW;AAyCjC,IAAE,mBAAmB,EAAE,cAAc;AACrC,IAAE,cAAc,IAAI,WAAW,EAAE,gBAAgB;AAIjD,IAAE,UAAU,EAAE;AAGd,IAAE,WAAW,EAAE,cAAc,KAAK;AAMlC,IAAE,QAAQ;AACV,IAAE,WAAW;AACb,IAAE,SAAS;AAEX,SAAO,aAAa,IAAI;AAC1B;AAEA,IAAM,cAAc,CAAC,MAAM,UAAU;AAEnC,SAAO,aAAa,MAAM,OAAO,cAAc,aAAa,eAAe,oBAAoB;AACjG;AAIA,IAAM,YAAY,CAAC,MAAM,UAAU;AAEjC,MAAI,kBAAkB,IAAI,KAAK,QAAQ,aAAa,QAAQ,GAAG;AAC7D,WAAO,OAAO,IAAI,MAAM,gBAAgB,IAAI;AAAA,EAC9C;AAEA,QAAM,IAAI,KAAK;AAEf,MAAI,CAAC,KAAK,UACL,KAAK,aAAa,KAAK,CAAC,KAAK,SAC7B,EAAE,WAAW,gBAAgB,UAAU,YAAa;AACvD,WAAO,IAAI,MAAO,KAAK,cAAc,IAAK,gBAAgB,gBAAgB;AAAA,EAC5E;AAEA,QAAM,YAAY,EAAE;AACpB,IAAE,aAAa;AAGf,MAAI,EAAE,YAAY,GAAG;AACnB,kBAAc,IAAI;AAClB,QAAI,KAAK,cAAc,GAAG;AAOxB,QAAE,aAAa;AACf,aAAO;AAAA,IACT;AAAA,EAMF,WAAW,KAAK,aAAa,KAAK,KAAK,KAAK,KAAK,KAAK,SAAS,KAC7D,UAAU,YAAY;AACtB,WAAO,IAAI,MAAM,aAAa;AAAA,EAChC;AAGA,MAAI,EAAE,WAAW,gBAAgB,KAAK,aAAa,GAAG;AACpD,WAAO,IAAI,MAAM,aAAa;AAAA,EAChC;AAGA,MAAI,EAAE,WAAW,cAAc,EAAE,SAAS,GAAG;AAC3C,MAAE,SAAS;AAAA,EACb;AACA,MAAI,EAAE,WAAW,YAAY;AAE3B,QAAI,SAAU,gBAAiB,EAAE,SAAS,KAAM,MAAO;AACvD,QAAI,cAAc;AAElB,QAAI,EAAE,YAAY,kBAAkB,EAAE,QAAQ,GAAG;AAC/C,oBAAc;AAAA,IAChB,WAAW,EAAE,QAAQ,GAAG;AACtB,oBAAc;AAAA,IAChB,WAAW,EAAE,UAAU,GAAG;AACxB,oBAAc;AAAA,IAChB,OAAO;AACL,oBAAc;AAAA,IAChB;AACA,cAAW,eAAe;AAC1B,QAAI,EAAE,aAAa,GAAG;AAAE,gBAAU;AAAA,IAAa;AAC/C,cAAU,KAAM,SAAS;AAEzB,gBAAY,GAAG,MAAM;AAGrB,QAAI,EAAE,aAAa,GAAG;AACpB,kBAAY,GAAG,KAAK,UAAU,EAAE;AAChC,kBAAY,GAAG,KAAK,QAAQ,KAAM;AAAA,IACpC;AACA,SAAK,QAAQ;AACb,MAAE,SAAS;AAGX,kBAAc,IAAI;AAClB,QAAI,EAAE,YAAY,GAAG;AACnB,QAAE,aAAa;AACf,aAAO;AAAA,IACT;AAAA,EACF;AAEA,MAAI,EAAE,WAAW,YAAY;AAE3B,SAAK,QAAQ;AACb,aAAS,GAAG,EAAE;AACd,aAAS,GAAG,GAAG;AACf,aAAS,GAAG,CAAC;AACb,QAAI,CAAC,EAAE,QAAQ;AACb,eAAS,GAAG,CAAC;AACb,eAAS,GAAG,CAAC;AACb,eAAS,GAAG,CAAC;AACb,eAAS,GAAG,CAAC;AACb,eAAS,GAAG,CAAC;AACb,eAAS,GAAG,EAAE,UAAU,IAAI,IACf,EAAE,YAAY,kBAAkB,EAAE,QAAQ,IAC1C,IAAI,CAAE;AACnB,eAAS,GAAG,OAAO;AACnB,QAAE,SAAS;AAGX,oBAAc,IAAI;AAClB,UAAI,EAAE,YAAY,GAAG;AACnB,UAAE,aAAa;AACf,eAAO;AAAA,MACT;AAAA,IACF,OACK;AACH;AAAA,QAAS;AAAA,SAAI,EAAE,OAAO,OAAO,IAAI,MACpB,EAAE,OAAO,OAAO,IAAI,MACpB,CAAC,EAAE,OAAO,QAAQ,IAAI,MACtB,CAAC,EAAE,OAAO,OAAO,IAAI,MACrB,CAAC,EAAE,OAAO,UAAU,IAAI;AAAA,MACrC;AACA,eAAS,GAAG,EAAE,OAAO,OAAO,GAAI;AAChC,eAAS,GAAI,EAAE,OAAO,QAAQ,IAAK,GAAI;AACvC,eAAS,GAAI,EAAE,OAAO,QAAQ,KAAM,GAAI;AACxC,eAAS,GAAI,EAAE,OAAO,QAAQ,KAAM,GAAI;AACxC,eAAS,GAAG,EAAE,UAAU,IAAI,IACf,EAAE,YAAY,kBAAkB,EAAE,QAAQ,IAC1C,IAAI,CAAE;AACnB,eAAS,GAAG,EAAE,OAAO,KAAK,GAAI;AAC9B,UAAI,EAAE,OAAO,SAAS,EAAE,OAAO,MAAM,QAAQ;AAC3C,iBAAS,GAAG,EAAE,OAAO,MAAM,SAAS,GAAI;AACxC,iBAAS,GAAI,EAAE,OAAO,MAAM,UAAU,IAAK,GAAI;AAAA,MACjD;AACA,UAAI,EAAE,OAAO,MAAM;AACjB,aAAK,QAAQ,QAAQ,KAAK,OAAO,EAAE,aAAa,EAAE,SAAS,CAAC;AAAA,MAC9D;AACA,QAAE,UAAU;AACZ,QAAE,SAAS;AAAA,IACb;AAAA,EACF;AACA,MAAI,EAAE,WAAW,aAAa;AAC5B,QAAI,EAAE,OAAO,OAAqB;AAChC,UAAI,MAAM,EAAE;AACZ,UAAID,SAAQ,EAAE,OAAO,MAAM,SAAS,SAAU,EAAE;AAChD,aAAO,EAAE,UAAUA,QAAO,EAAE,kBAAkB;AAC5C,YAAIE,QAAO,EAAE,mBAAmB,EAAE;AAGlC,UAAE,YAAY,IAAI,EAAE,OAAO,MAAM,SAAS,EAAE,SAAS,EAAE,UAAUA,KAAI,GAAG,EAAE,OAAO;AACjF,UAAE,UAAU,EAAE;AAEd,YAAI,EAAE,OAAO,QAAQ,EAAE,UAAU,KAAK;AACpC,eAAK,QAAQ,QAAQ,KAAK,OAAO,EAAE,aAAa,EAAE,UAAU,KAAK,GAAG;AAAA,QACtE;AAEA,UAAE,WAAWA;AACb,sBAAc,IAAI;AAClB,YAAI,EAAE,YAAY,GAAG;AACnB,YAAE,aAAa;AACf,iBAAO;AAAA,QACT;AACA,cAAM;AACN,QAAAF,SAAQE;AAAA,MACV;AAGA,UAAI,eAAe,IAAI,WAAW,EAAE,OAAO,KAAK;AAGhD,QAAE,YAAY,IAAI,aAAa,SAAS,EAAE,SAAS,EAAE,UAAUF,KAAI,GAAG,EAAE,OAAO;AAC/E,QAAE,WAAWA;AAEb,UAAI,EAAE,OAAO,QAAQ,EAAE,UAAU,KAAK;AACpC,aAAK,QAAQ,QAAQ,KAAK,OAAO,EAAE,aAAa,EAAE,UAAU,KAAK,GAAG;AAAA,MACtE;AAEA,QAAE,UAAU;AAAA,IACd;AACA,MAAE,SAAS;AAAA,EACb;AACA,MAAI,EAAE,WAAW,YAAY;AAC3B,QAAI,EAAE,OAAO,MAAoB;AAC/B,UAAI,MAAM,EAAE;AACZ,UAAI;AACJ,SAAG;AACD,YAAI,EAAE,YAAY,EAAE,kBAAkB;AAEpC,cAAI,EAAE,OAAO,QAAQ,EAAE,UAAU,KAAK;AACpC,iBAAK,QAAQ,QAAQ,KAAK,OAAO,EAAE,aAAa,EAAE,UAAU,KAAK,GAAG;AAAA,UACtE;AAEA,wBAAc,IAAI;AAClB,cAAI,EAAE,YAAY,GAAG;AACnB,cAAE,aAAa;AACf,mBAAO;AAAA,UACT;AACA,gBAAM;AAAA,QACR;AAEA,YAAI,EAAE,UAAU,EAAE,OAAO,KAAK,QAAQ;AACpC,gBAAM,EAAE,OAAO,KAAK,WAAW,EAAE,SAAS,IAAI;AAAA,QAChD,OAAO;AACL,gBAAM;AAAA,QACR;AACA,iBAAS,GAAG,GAAG;AAAA,MACjB,SAAS,QAAQ;AAEjB,UAAI,EAAE,OAAO,QAAQ,EAAE,UAAU,KAAK;AACpC,aAAK,QAAQ,QAAQ,KAAK,OAAO,EAAE,aAAa,EAAE,UAAU,KAAK,GAAG;AAAA,MACtE;AAEA,QAAE,UAAU;AAAA,IACd;AACA,MAAE,SAAS;AAAA,EACb;AACA,MAAI,EAAE,WAAW,eAAe;AAC9B,QAAI,EAAE,OAAO,SAAuB;AAClC,UAAI,MAAM,EAAE;AACZ,UAAI;AACJ,SAAG;AACD,YAAI,EAAE,YAAY,EAAE,kBAAkB;AAEpC,cAAI,EAAE,OAAO,QAAQ,EAAE,UAAU,KAAK;AACpC,iBAAK,QAAQ,QAAQ,KAAK,OAAO,EAAE,aAAa,EAAE,UAAU,KAAK,GAAG;AAAA,UACtE;AAEA,wBAAc,IAAI;AAClB,cAAI,EAAE,YAAY,GAAG;AACnB,cAAE,aAAa;AACf,mBAAO;AAAA,UACT;AACA,gBAAM;AAAA,QACR;AAEA,YAAI,EAAE,UAAU,EAAE,OAAO,QAAQ,QAAQ;AACvC,gBAAM,EAAE,OAAO,QAAQ,WAAW,EAAE,SAAS,IAAI;AAAA,QACnD,OAAO;AACL,gBAAM;AAAA,QACR;AACA,iBAAS,GAAG,GAAG;AAAA,MACjB,SAAS,QAAQ;AAEjB,UAAI,EAAE,OAAO,QAAQ,EAAE,UAAU,KAAK;AACpC,aAAK,QAAQ,QAAQ,KAAK,OAAO,EAAE,aAAa,EAAE,UAAU,KAAK,GAAG;AAAA,MACtE;AAAA,IAEF;AACA,MAAE,SAAS;AAAA,EACb;AACA,MAAI,EAAE,WAAW,YAAY;AAC3B,QAAI,EAAE,OAAO,MAAM;AACjB,UAAI,EAAE,UAAU,IAAI,EAAE,kBAAkB;AACtC,sBAAc,IAAI;AAClB,YAAI,EAAE,YAAY,GAAG;AACnB,YAAE,aAAa;AACf,iBAAO;AAAA,QACT;AAAA,MACF;AACA,eAAS,GAAG,KAAK,QAAQ,GAAI;AAC7B,eAAS,GAAI,KAAK,SAAS,IAAK,GAAI;AACpC,WAAK,QAAQ;AAAA,IACf;AACA,MAAE,SAAS;AAGX,kBAAc,IAAI;AAClB,QAAI,EAAE,YAAY,GAAG;AACnB,QAAE,aAAa;AACf,aAAO;AAAA,IACT;AAAA,EACF;AAKA,MAAI,KAAK,aAAa,KAAK,EAAE,cAAc,KACxC,UAAU,gBAAgB,EAAE,WAAW,cAAe;AACvD,QAAI,SAAS,EAAE,UAAU,IAAI,eAAe,GAAG,KAAK,IACvC,EAAE,aAAa,iBAAiB,aAAa,GAAG,KAAK,IACrD,EAAE,aAAa,QAAQ,YAAY,GAAG,KAAK,IAC3C,oBAAoB,EAAE,KAAK,EAAE,KAAK,GAAG,KAAK;AAEvD,QAAI,WAAW,qBAAqB,WAAW,gBAAgB;AAC7D,QAAE,SAAS;AAAA,IACb;AACA,QAAI,WAAW,gBAAgB,WAAW,mBAAmB;AAC3D,UAAI,KAAK,cAAc,GAAG;AACxB,UAAE,aAAa;AAAA,MAEjB;AACA,aAAO;AAAA,IAQT;AACA,QAAI,WAAW,eAAe;AAC5B,UAAI,UAAU,iBAAiB;AAC7B,kBAAU,CAAC;AAAA,MACb,WACS,UAAU,WAAW;AAE5B,yBAAiB,GAAG,GAAG,GAAG,KAAK;AAI/B,YAAI,UAAU,gBAAgB;AAE5B,eAAK,EAAE,IAAI;AAEX,cAAI,EAAE,cAAc,GAAG;AACrB,cAAE,WAAW;AACb,cAAE,cAAc;AAChB,cAAE,SAAS;AAAA,UACb;AAAA,QACF;AAAA,MACF;AACA,oBAAc,IAAI;AAClB,UAAI,KAAK,cAAc,GAAG;AACxB,UAAE,aAAa;AACf,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,MAAI,UAAU,YAAY;AAAE,WAAO;AAAA,EAAQ;AAC3C,MAAI,EAAE,QAAQ,GAAG;AAAE,WAAO;AAAA,EAAgB;AAG1C,MAAI,EAAE,SAAS,GAAG;AAChB,aAAS,GAAG,KAAK,QAAQ,GAAI;AAC7B,aAAS,GAAI,KAAK,SAAS,IAAK,GAAI;AACpC,aAAS,GAAI,KAAK,SAAS,KAAM,GAAI;AACrC,aAAS,GAAI,KAAK,SAAS,KAAM,GAAI;AACrC,aAAS,GAAG,KAAK,WAAW,GAAI;AAChC,aAAS,GAAI,KAAK,YAAY,IAAK,GAAI;AACvC,aAAS,GAAI,KAAK,YAAY,KAAM,GAAI;AACxC,aAAS,GAAI,KAAK,YAAY,KAAM,GAAI;AAAA,EAC1C,OAEA;AACE,gBAAY,GAAG,KAAK,UAAU,EAAE;AAChC,gBAAY,GAAG,KAAK,QAAQ,KAAM;AAAA,EACpC;AAEA,gBAAc,IAAI;AAIlB,MAAI,EAAE,OAAO,GAAG;AAAE,MAAE,OAAO,CAAC,EAAE;AAAA,EAAM;AAEpC,SAAO,EAAE,YAAY,IAAI,SAAS;AACpC;AAGA,IAAM,aAAa,CAAC,SAAS;AAE3B,MAAI,kBAAkB,IAAI,GAAG;AAC3B,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,KAAK,MAAM;AAE1B,OAAK,QAAQ;AAEb,SAAO,WAAW,aAAa,IAAI,MAAM,cAAc,IAAI;AAC7D;AAOA,IAAM,uBAAuB,CAAC,MAAM,eAAe;AAEjD,MAAI,aAAa,WAAW;AAE5B,MAAI,kBAAkB,IAAI,GAAG;AAC3B,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,KAAK;AACf,QAAM,OAAO,EAAE;AAEf,MAAI,SAAS,KAAM,SAAS,KAAK,EAAE,WAAW,cAAe,EAAE,WAAW;AACxE,WAAO;AAAA,EACT;AAGA,MAAI,SAAS,GAAG;AAEd,SAAK,QAAQ,UAAU,KAAK,OAAO,YAAY,YAAY,CAAC;AAAA,EAC9D;AAEA,IAAE,OAAO;AAGT,MAAI,cAAc,EAAE,QAAQ;AAC1B,QAAI,SAAS,GAAG;AAEd,WAAK,EAAE,IAAI;AACX,QAAE,WAAW;AACb,QAAE,cAAc;AAChB,QAAE,SAAS;AAAA,IACb;AAGA,QAAI,UAAU,IAAI,WAAW,EAAE,MAAM;AACrC,YAAQ,IAAI,WAAW,SAAS,aAAa,EAAE,QAAQ,UAAU,GAAG,CAAC;AACrE,iBAAa;AACb,iBAAa,EAAE;AAAA,EACjB;AAEA,QAAM,QAAQ,KAAK;AACnB,QAAM,OAAO,KAAK;AAClB,QAAM,QAAQ,KAAK;AACnB,OAAK,WAAW;AAChB,OAAK,UAAU;AACf,OAAK,QAAQ;AACb,cAAY,CAAC;AACb,SAAO,EAAE,aAAa,WAAW;AAC/B,QAAI,MAAM,EAAE;AACZ,QAAI,IAAI,EAAE,aAAa,YAAY;AACnC,OAAG;AAED,QAAE,QAAQ,KAAK,GAAG,EAAE,OAAO,EAAE,OAAO,MAAM,YAAY,CAAC,CAAC;AAExD,QAAE,KAAK,MAAM,EAAE,MAAM,IAAI,EAAE,KAAK,EAAE,KAAK;AAEvC,QAAE,KAAK,EAAE,KAAK,IAAI;AAClB;AAAA,IACF,SAAS,EAAE;AACX,MAAE,WAAW;AACb,MAAE,YAAY,YAAY;AAC1B,gBAAY,CAAC;AAAA,EACf;AACA,IAAE,YAAY,EAAE;AAChB,IAAE,cAAc,EAAE;AAClB,IAAE,SAAS,EAAE;AACb,IAAE,YAAY;AACd,IAAE,eAAe,EAAE,cAAc,YAAY;AAC7C,IAAE,kBAAkB;AACpB,OAAK,UAAU;AACf,OAAK,QAAQ;AACb,OAAK,WAAW;AAChB,IAAE,OAAO;AACT,SAAO;AACT;AAGA,IAAI,gBAAgB;AACpB,IAAI,iBAAiB;AACrB,IAAI,iBAAiB;AACrB,IAAI,qBAAqB;AACzB,IAAI,qBAAqB;AACzB,IAAI,cAAc;AAClB,IAAI,eAAe;AACnB,IAAI,yBAAyB;AAC7B,IAAI,cAAc;AAYlB,IAAI,cAAc;AAAA,EACjB,aAAa;AAAA,EACb,cAAc;AAAA,EACd,cAAc;AAAA,EACd,kBAAkB;AAAA,EAClB,kBAAkB;AAAA,EAClB,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,sBAAsB;AAAA,EACtB;AACD;AAEA,IAAM,OAAO,CAAC,KAAK,QAAQ;AACzB,SAAO,OAAO,UAAU,eAAe,KAAK,KAAK,GAAG;AACtD;AAEA,IAAI,SAAS,SAAU,KAAkC;AACvD,QAAM,UAAU,MAAM,UAAU,MAAM,KAAK,WAAW,CAAC;AACvD,SAAO,QAAQ,QAAQ;AACrB,UAAM,SAAS,QAAQ,MAAM;AAC7B,QAAI,CAAC,QAAQ;AAAE;AAAA,IAAU;AAEzB,QAAI,OAAO,WAAW,UAAU;AAC9B,YAAM,IAAI,UAAU,SAAS,oBAAoB;AAAA,IACnD;AAEA,eAAW,KAAK,QAAQ;AACtB,UAAI,KAAK,QAAQ,CAAC,GAAG;AACnB,YAAI,CAAC,IAAI,OAAO,CAAC;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAIA,IAAI,gBAAgB,CAAC,WAAW;AAE9B,MAAI,MAAM;AAEV,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,IAAI,GAAG,KAAK;AAC7C,WAAO,OAAO,CAAC,EAAE;AAAA,EACnB;AAGA,QAAM,SAAS,IAAI,WAAW,GAAG;AAEjC,WAAS,IAAI,GAAG,MAAM,GAAG,IAAI,OAAO,QAAQ,IAAI,GAAG,KAAK;AACtD,QAAI,QAAQ,OAAO,CAAC;AACpB,WAAO,IAAI,OAAO,GAAG;AACrB,WAAO,MAAM;AAAA,EACf;AAEA,SAAO;AACT;AAEA,IAAI,SAAS;AAAA,EACZ;AAAA,EACA;AACD;AAUA,IAAI,mBAAmB;AAEvB,IAAI;AAAE,SAAO,aAAa,MAAM,MAAM,IAAI,WAAW,CAAC,CAAC;AAAG,SAAS,IAAI;AAAE,qBAAmB;AAAO;AAMnG,IAAM,WAAW,IAAI,WAAW,GAAG;AACnC,SAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,WAAS,CAAC,IAAK,KAAK,MAAM,IAAI,KAAK,MAAM,IAAI,KAAK,MAAM,IAAI,KAAK,MAAM,IAAI,KAAK,MAAM,IAAI;AAC5F;AACA,SAAS,GAAG,IAAI,SAAS,GAAG,IAAI;AAIhC,IAAI,aAAa,CAAC,QAAQ;AACxB,MAAI,OAAO,gBAAgB,cAAc,YAAY,UAAU,QAAQ;AACrE,WAAO,IAAI,YAAY,EAAE,OAAO,GAAG;AAAA,EACrC;AAEA,MAAI,KAAK,GAAG,IAAI,OAAO,GAAG,UAAU,IAAI,QAAQ,UAAU;AAG1D,OAAK,QAAQ,GAAG,QAAQ,SAAS,SAAS;AACxC,QAAI,IAAI,WAAW,KAAK;AACxB,SAAK,IAAI,WAAY,SAAW,QAAQ,IAAI,SAAU;AACpD,WAAK,IAAI,WAAW,QAAQ,CAAC;AAC7B,WAAK,KAAK,WAAY,OAAQ;AAC5B,YAAI,SAAY,IAAI,SAAW,OAAO,KAAK;AAC3C;AAAA,MACF;AAAA,IACF;AACA,eAAW,IAAI,MAAO,IAAI,IAAI,OAAQ,IAAI,IAAI,QAAU,IAAI;AAAA,EAC9D;AAGA,QAAM,IAAI,WAAW,OAAO;AAG5B,OAAK,IAAI,GAAG,QAAQ,GAAG,IAAI,SAAS,SAAS;AAC3C,QAAI,IAAI,WAAW,KAAK;AACxB,SAAK,IAAI,WAAY,SAAW,QAAQ,IAAI,SAAU;AACpD,WAAK,IAAI,WAAW,QAAQ,CAAC;AAC7B,WAAK,KAAK,WAAY,OAAQ;AAC5B,YAAI,SAAY,IAAI,SAAW,OAAO,KAAK;AAC3C;AAAA,MACF;AAAA,IACF;AACA,QAAI,IAAI,KAAM;AAEZ,UAAI,GAAG,IAAI;AAAA,IACb,WAAW,IAAI,MAAO;AAEpB,UAAI,GAAG,IAAI,MAAQ,MAAM;AACzB,UAAI,GAAG,IAAI,MAAQ,IAAI;AAAA,IACzB,WAAW,IAAI,OAAS;AAEtB,UAAI,GAAG,IAAI,MAAQ,MAAM;AACzB,UAAI,GAAG,IAAI,MAAQ,MAAM,IAAI;AAC7B,UAAI,GAAG,IAAI,MAAQ,IAAI;AAAA,IACzB,OAAO;AAEL,UAAI,GAAG,IAAI,MAAQ,MAAM;AACzB,UAAI,GAAG,IAAI,MAAQ,MAAM,KAAK;AAC9B,UAAI,GAAG,IAAI,MAAQ,MAAM,IAAI;AAC7B,UAAI,GAAG,IAAI,MAAQ,IAAI;AAAA,IACzB;AAAA,EACF;AAEA,SAAO;AACT;AAGA,IAAM,gBAAgB,CAAC,KAAK,QAAQ;AAIlC,MAAI,MAAM,OAAO;AACf,QAAI,IAAI,YAAY,kBAAkB;AACpC,aAAO,OAAO,aAAa,MAAM,MAAM,IAAI,WAAW,MAAM,MAAM,IAAI,SAAS,GAAG,GAAG,CAAC;AAAA,IACxF;AAAA,EACF;AAEA,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,cAAU,OAAO,aAAa,IAAI,CAAC,CAAC;AAAA,EACtC;AACA,SAAO;AACT;AAIA,IAAI,aAAa,CAAC,KAAK,QAAQ;AAC7B,QAAM,MAAM,OAAO,IAAI;AAEvB,MAAI,OAAO,gBAAgB,cAAc,YAAY,UAAU,QAAQ;AACrE,WAAO,IAAI,YAAY,EAAE,OAAO,IAAI,SAAS,GAAG,GAAG,CAAC;AAAA,EACtD;AAEA,MAAI,GAAG;AAKP,QAAM,WAAW,IAAI,MAAM,MAAM,CAAC;AAElC,OAAK,MAAM,GAAG,IAAI,GAAG,IAAI,OAAM;AAC7B,QAAI,IAAI,IAAI,GAAG;AAEf,QAAI,IAAI,KAAM;AAAE,eAAS,KAAK,IAAI;AAAG;AAAA,IAAU;AAE/C,QAAI,QAAQ,SAAS,CAAC;AAEtB,QAAI,QAAQ,GAAG;AAAE,eAAS,KAAK,IAAI;AAAQ,WAAK,QAAQ;AAAG;AAAA,IAAU;AAGrE,SAAK,UAAU,IAAI,KAAO,UAAU,IAAI,KAAO;AAE/C,WAAO,QAAQ,KAAK,IAAI,KAAK;AAC3B,UAAK,KAAK,IAAM,IAAI,GAAG,IAAI;AAC3B;AAAA,IACF;AAGA,QAAI,QAAQ,GAAG;AAAE,eAAS,KAAK,IAAI;AAAQ;AAAA,IAAU;AAErD,QAAI,IAAI,OAAS;AACf,eAAS,KAAK,IAAI;AAAA,IACpB,OAAO;AACL,WAAK;AACL,eAAS,KAAK,IAAI,QAAW,KAAK,KAAM;AACxC,eAAS,KAAK,IAAI,QAAU,IAAI;AAAA,IAClC;AAAA,EACF;AAEA,SAAO,cAAc,UAAU,GAAG;AACpC;AASA,IAAI,aAAa,CAAC,KAAK,QAAQ;AAE7B,QAAM,OAAO,IAAI;AACjB,MAAI,MAAM,IAAI,QAAQ;AAAE,UAAM,IAAI;AAAA,EAAQ;AAG1C,MAAI,MAAM,MAAM;AAChB,SAAO,OAAO,MAAM,IAAI,GAAG,IAAI,SAAU,KAAM;AAAE;AAAA,EAAO;AAIxD,MAAI,MAAM,GAAG;AAAE,WAAO;AAAA,EAAK;AAI3B,MAAI,QAAQ,GAAG;AAAE,WAAO;AAAA,EAAK;AAE7B,SAAQ,MAAM,SAAS,IAAI,GAAG,CAAC,IAAI,MAAO,MAAM;AAClD;AAEA,IAAI,UAAU;AAAA,EACb;AAAA,EACA;AAAA,EACA;AACD;AAqBA,SAAS,UAAU;AAEjB,OAAK,QAAQ;AACb,OAAK,UAAU;AAEf,OAAK,WAAW;AAEhB,OAAK,WAAW;AAEhB,OAAK,SAAS;AACd,OAAK,WAAW;AAEhB,OAAK,YAAY;AAEjB,OAAK,YAAY;AAEjB,OAAK,MAAM;AAEX,OAAK,QAAQ;AAEb,OAAK,YAAY;AAEjB,OAAK,QAAQ;AACf;AAEA,IAAI,UAAU;AAEd,IAAM,aAAa,OAAO,UAAU;AAKpC,IAAM;AAAA,EACJ,YAAY;AAAA,EAAc;AAAA,EAAc;AAAA,EAAc,UAAU;AAAA,EAChE,MAAM;AAAA,EAAQ,cAAc;AAAA,EAC5B;AAAA,EACA;AAAA,EACA,YAAY;AACd,IAAI;AA0FJ,SAAS,UAAU,SAAS;AAC1B,OAAK,UAAU,OAAO,OAAO;AAAA,IAC3B,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,UAAU;AAAA,EACZ,GAAG,WAAW,CAAC,CAAC;AAEhB,MAAI,MAAM,KAAK;AAEf,MAAI,IAAI,OAAQ,IAAI,aAAa,GAAI;AACnC,QAAI,aAAa,CAAC,IAAI;AAAA,EACxB,WAES,IAAI,QAAS,IAAI,aAAa,KAAO,IAAI,aAAa,IAAK;AAClE,QAAI,cAAc;AAAA,EACpB;AAEA,OAAK,MAAS;AACd,OAAK,MAAS;AACd,OAAK,QAAS;AACd,OAAK,SAAS,CAAC;AAEf,OAAK,OAAO,IAAI,QAAQ;AACxB,OAAK,KAAK,YAAY;AAEtB,MAAI,SAAS,YAAY;AAAA,IACvB,KAAK;AAAA,IACL,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,EACN;AAEA,MAAI,WAAW,QAAQ;AACrB,UAAM,IAAI,MAAM,SAAS,MAAM,CAAC;AAAA,EAClC;AAEA,MAAI,IAAI,QAAQ;AACd,gBAAY,iBAAiB,KAAK,MAAM,IAAI,MAAM;AAAA,EACpD;AAEA,MAAI,IAAI,YAAY;AAClB,QAAI;AAEJ,QAAI,OAAO,IAAI,eAAe,UAAU;AAEtC,aAAO,QAAQ,WAAW,IAAI,UAAU;AAAA,IAC1C,WAAW,WAAW,KAAK,IAAI,UAAU,MAAM,wBAAwB;AACrE,aAAO,IAAI,WAAW,IAAI,UAAU;AAAA,IACtC,OAAO;AACL,aAAO,IAAI;AAAA,IACb;AAEA,aAAS,YAAY,qBAAqB,KAAK,MAAM,IAAI;AAEzD,QAAI,WAAW,QAAQ;AACrB,YAAM,IAAI,MAAM,SAAS,MAAM,CAAC;AAAA,IAClC;AAEA,SAAK,YAAY;AAAA,EACnB;AACF;AAwBA,UAAU,UAAU,OAAO,SAAU,MAAM,YAAY;AACrD,QAAM,OAAO,KAAK;AAClB,QAAM,YAAY,KAAK,QAAQ;AAC/B,MAAI,QAAQ;AAEZ,MAAI,KAAK,OAAO;AAAE,WAAO;AAAA,EAAO;AAEhC,MAAI,eAAe,CAAC,CAAC,WAAY,eAAc;AAAA,MAC1C,eAAc,eAAe,OAAO,aAAa;AAGtD,MAAI,OAAO,SAAS,UAAU;AAE5B,SAAK,QAAQ,QAAQ,WAAW,IAAI;AAAA,EACtC,WAAW,WAAW,KAAK,IAAI,MAAM,wBAAwB;AAC3D,SAAK,QAAQ,IAAI,WAAW,IAAI;AAAA,EAClC,OAAO;AACL,SAAK,QAAQ;AAAA,EACf;AAEA,OAAK,UAAU;AACf,OAAK,WAAW,KAAK,MAAM;AAE3B,aAAS;AACP,QAAI,KAAK,cAAc,GAAG;AACxB,WAAK,SAAS,IAAI,WAAW,SAAS;AACtC,WAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACnB;AAGA,SAAK,gBAAgB,gBAAgB,gBAAgB,iBAAiB,KAAK,aAAa,GAAG;AACzF,WAAK,OAAO,KAAK,OAAO,SAAS,GAAG,KAAK,QAAQ,CAAC;AAClD,WAAK,YAAY;AACjB;AAAA,IACF;AAEA,aAAS,YAAY,QAAQ,MAAM,WAAW;AAG9C,QAAI,WAAW,gBAAgB;AAC7B,UAAI,KAAK,WAAW,GAAG;AACrB,aAAK,OAAO,KAAK,OAAO,SAAS,GAAG,KAAK,QAAQ,CAAC;AAAA,MACpD;AACA,eAAS,YAAY,WAAW,KAAK,IAAI;AACzC,WAAK,MAAM,MAAM;AACjB,WAAK,QAAQ;AACb,aAAO,WAAW;AAAA,IACpB;AAGA,QAAI,KAAK,cAAc,GAAG;AACxB,WAAK,OAAO,KAAK,MAAM;AACvB;AAAA,IACF;AAGA,QAAI,cAAc,KAAK,KAAK,WAAW,GAAG;AACxC,WAAK,OAAO,KAAK,OAAO,SAAS,GAAG,KAAK,QAAQ,CAAC;AAClD,WAAK,YAAY;AACjB;AAAA,IACF;AAEA,QAAI,KAAK,aAAa,EAAG;AAAA,EAC3B;AAEA,SAAO;AACT;AAUA,UAAU,UAAU,SAAS,SAAU,OAAO;AAC5C,OAAK,OAAO,KAAK,KAAK;AACxB;AAYA,UAAU,UAAU,QAAQ,SAAU,QAAQ;AAE5C,MAAI,WAAW,QAAQ;AACrB,SAAK,SAAS,OAAO,cAAc,KAAK,MAAM;AAAA,EAChD;AACA,OAAK,SAAS,CAAC;AACf,OAAK,MAAM;AACX,OAAK,MAAM,KAAK,KAAK;AACvB;AAmCA,SAAS,UAAU,OAAO,SAAS;AACjC,QAAM,WAAW,IAAI,UAAU,OAAO;AAEtC,WAAS,KAAK,OAAO,IAAI;AAGzB,MAAI,SAAS,KAAK;AAAE,UAAM,SAAS,OAAO,SAAS,SAAS,GAAG;AAAA,EAAG;AAElE,SAAO,SAAS;AAClB;AAWA,SAAS,aAAa,OAAO,SAAS;AACpC,YAAU,WAAW,CAAC;AACtB,UAAQ,MAAM;AACd,SAAO,UAAU,OAAO,OAAO;AACjC;AAWA,SAAS,OAAO,OAAO,SAAS;AAC9B,YAAU,WAAW,CAAC;AACtB,UAAQ,OAAO;AACf,SAAO,UAAU,OAAO,OAAO;AACjC;AAGA,IAAI,cAAc;AAClB,IAAI,YAAY;AAChB,IAAI,iBAAiB;AACrB,IAAI,WAAW;AACf,IAAI,cAAc;AAElB,IAAI,cAAc;AAAA,EACjB,SAAS;AAAA,EACT,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,MAAM;AAAA,EACN,WAAW;AACZ;AAsBA,IAAM,QAAQ;AACd,IAAM,SAAS;AAqCf,IAAI,UAAU,SAAS,aAAa,MAAM,OAAO;AAC/C,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AAGJ,MAAI,OAAO;AAGX,QAAM,QAAQ,KAAK;AAEnB,QAAM,KAAK;AACX,UAAQ,KAAK;AACb,SAAO,OAAO,KAAK,WAAW;AAC9B,SAAO,KAAK;AACZ,WAAS,KAAK;AACd,QAAM,QAAQ,QAAQ,KAAK;AAC3B,QAAM,QAAQ,KAAK,YAAY;AAE/B,SAAO,MAAM;AAEb,UAAQ,MAAM;AACd,UAAQ,MAAM;AACd,UAAQ,MAAM;AACd,aAAW,MAAM;AACjB,SAAO,MAAM;AACb,SAAO,MAAM;AACb,UAAQ,MAAM;AACd,UAAQ,MAAM;AACd,WAAS,KAAK,MAAM,WAAW;AAC/B,WAAS,KAAK,MAAM,YAAY;AAMhC;AACA,OAAG;AACD,UAAI,OAAO,IAAI;AACb,gBAAQ,MAAM,KAAK,KAAK;AACxB,gBAAQ;AACR,gBAAQ,MAAM,KAAK,KAAK;AACxB,gBAAQ;AAAA,MACV;AAEA,aAAO,MAAM,OAAO,KAAK;AAEzB;AACA,mBAAS;AACP,eAAK,SAAS;AACd,oBAAU;AACV,kBAAQ;AACR,eAAM,SAAS,KAAM;AACrB,cAAI,OAAO,GAAG;AAIZ,mBAAO,MAAM,IAAI,OAAO;AAAA,UAC1B,WACS,KAAK,IAAI;AAChB,kBAAM,OAAO;AACb,kBAAM;AACN,gBAAI,IAAI;AACN,kBAAI,OAAO,IAAI;AACb,wBAAQ,MAAM,KAAK,KAAK;AACxB,wBAAQ;AAAA,cACV;AACA,qBAAO,QAAS,KAAK,MAAM;AAC3B,wBAAU;AACV,sBAAQ;AAAA,YACV;AAEA,gBAAI,OAAO,IAAI;AACb,sBAAQ,MAAM,KAAK,KAAK;AACxB,sBAAQ;AACR,sBAAQ,MAAM,KAAK,KAAK;AACxB,sBAAQ;AAAA,YACV;AACA,mBAAO,MAAM,OAAO,KAAK;AAEzB;AACA,yBAAS;AACP,qBAAK,SAAS;AACd,0BAAU;AACV,wBAAQ;AACR,qBAAM,SAAS,KAAM;AAErB,oBAAI,KAAK,IAAI;AACX,yBAAO,OAAO;AACd,wBAAM;AACN,sBAAI,OAAO,IAAI;AACb,4BAAQ,MAAM,KAAK,KAAK;AACxB,4BAAQ;AACR,wBAAI,OAAO,IAAI;AACb,8BAAQ,MAAM,KAAK,KAAK;AACxB,8BAAQ;AAAA,oBACV;AAAA,kBACF;AACA,0BAAQ,QAAS,KAAK,MAAM;AAE5B,sBAAI,OAAO,MAAM;AACf,yBAAK,MAAM;AACX,0BAAM,OAAO;AACb,0BAAM;AAAA,kBACR;AAEA,4BAAU;AACV,0BAAQ;AAER,uBAAK,OAAO;AACZ,sBAAI,OAAO,IAAI;AACb,yBAAK,OAAO;AACZ,wBAAI,KAAK,OAAO;AACd,0BAAI,MAAM,MAAM;AACd,6BAAK,MAAM;AACX,8BAAM,OAAO;AACb,8BAAM;AAAA,sBACR;AAAA,oBAuBF;AACA,2BAAO;AACP,kCAAc;AACd,wBAAI,UAAU,GAAG;AACf,8BAAQ,QAAQ;AAChB,0BAAI,KAAK,KAAK;AACZ,+BAAO;AACP,2BAAG;AACD,iCAAO,MAAM,IAAI,SAAS,MAAM;AAAA,wBAClC,SAAS,EAAE;AACX,+BAAO,OAAO;AACd,sCAAc;AAAA,sBAChB;AAAA,oBACF,WACS,QAAQ,IAAI;AACnB,8BAAQ,QAAQ,QAAQ;AACxB,4BAAM;AACN,0BAAI,KAAK,KAAK;AACZ,+BAAO;AACP,2BAAG;AACD,iCAAO,MAAM,IAAI,SAAS,MAAM;AAAA,wBAClC,SAAS,EAAE;AACX,+BAAO;AACP,4BAAI,QAAQ,KAAK;AACf,+BAAK;AACL,iCAAO;AACP,6BAAG;AACD,mCAAO,MAAM,IAAI,SAAS,MAAM;AAAA,0BAClC,SAAS,EAAE;AACX,iCAAO,OAAO;AACd,wCAAc;AAAA,wBAChB;AAAA,sBACF;AAAA,oBACF,OACK;AACH,8BAAQ,QAAQ;AAChB,0BAAI,KAAK,KAAK;AACZ,+BAAO;AACP,2BAAG;AACD,iCAAO,MAAM,IAAI,SAAS,MAAM;AAAA,wBAClC,SAAS,EAAE;AACX,+BAAO,OAAO;AACd,sCAAc;AAAA,sBAChB;AAAA,oBACF;AACA,2BAAO,MAAM,GAAG;AACd,6BAAO,MAAM,IAAI,YAAY,MAAM;AACnC,6BAAO,MAAM,IAAI,YAAY,MAAM;AACnC,6BAAO,MAAM,IAAI,YAAY,MAAM;AACnC,6BAAO;AAAA,oBACT;AACA,wBAAI,KAAK;AACP,6BAAO,MAAM,IAAI,YAAY,MAAM;AACnC,0BAAI,MAAM,GAAG;AACX,+BAAO,MAAM,IAAI,YAAY,MAAM;AAAA,sBACrC;AAAA,oBACF;AAAA,kBACF,OACK;AACH,2BAAO,OAAO;AACd,uBAAG;AACD,6BAAO,MAAM,IAAI,OAAO,MAAM;AAC9B,6BAAO,MAAM,IAAI,OAAO,MAAM;AAC9B,6BAAO,MAAM,IAAI,OAAO,MAAM;AAC9B,6BAAO;AAAA,oBACT,SAAS,MAAM;AACf,wBAAI,KAAK;AACP,6BAAO,MAAM,IAAI,OAAO,MAAM;AAC9B,0BAAI,MAAM,GAAG;AACX,+BAAO,MAAM,IAAI,OAAO,MAAM;AAAA,sBAChC;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF,YACU,KAAK,QAAQ,GAAG;AACxB,yBAAO,OAAO,OAAO,UAAuB,QAAS,KAAK,MAAM,EAAG;AACnE,2BAAS;AAAA,gBACX,OACK;AACH,uBAAK,MAAM;AACX,wBAAM,OAAO;AACb,wBAAM;AAAA,gBACR;AAEA;AAAA,cACF;AAAA,UACF,YACU,KAAK,QAAQ,GAAG;AACxB,mBAAO,OAAO,OAAO,UAAuB,QAAS,KAAK,MAAM,EAAG;AACnE,qBAAS;AAAA,UACX,WACS,KAAK,IAAI;AAEhB,kBAAM,OAAO;AACb,kBAAM;AAAA,UACR,OACK;AACH,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb,kBAAM;AAAA,UACR;AAEA;AAAA,QACF;AAAA,IACF,SAAS,MAAM,QAAQ,OAAO;AAG9B,QAAM,QAAQ;AACd,SAAO;AACP,UAAQ,OAAO;AACf,WAAS,KAAK,QAAQ;AAGtB,OAAK,UAAU;AACf,OAAK,WAAW;AAChB,OAAK,WAAY,MAAM,OAAO,KAAK,OAAO,OAAO,KAAK,MAAM;AAC5D,OAAK,YAAa,OAAO,MAAM,OAAO,MAAM,QAAQ,OAAO,OAAO;AAClE,QAAM,OAAO;AACb,QAAM,OAAO;AACb;AACF;AAqBA,IAAM,UAAU;AAChB,IAAM,gBAAgB;AACtB,IAAM,iBAAiB;AAGvB,IAAM,UAAU;AAChB,IAAM,SAAS;AACf,IAAM,UAAU;AAEhB,IAAM,QAAQ,IAAI,YAAY;AAAA;AAAA,EAC5B;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EACrD;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAG;AAC/D,CAAC;AAED,IAAM,OAAO,IAAI,WAAW;AAAA;AAAA,EAC1B;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAC5D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAC1D,CAAC;AAED,IAAM,QAAQ,IAAI,YAAY;AAAA;AAAA,EAC5B;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAK;AAAA,EACtD;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAClD;AAAA,EAAM;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAG;AAChC,CAAC;AAED,IAAM,OAAO,IAAI,WAAW;AAAA;AAAA,EAC1B;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAC5D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EACpC;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AACtB,CAAC;AAED,IAAM,gBAAgB,CAAC,MAAM,MAAM,YAAY,OAAO,OAAO,aAAa,MAAM,SAChF;AACE,QAAM,OAAO,KAAK;AAGlB,MAAI,MAAM;AACV,MAAI,MAAM;AACV,MAAI,MAAM,GAAG,MAAM;AACnB,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAIA,QAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,OAAO;AAEX,MAAID;AACJ,QAAM,QAAQ,IAAI,YAAY,UAAU,CAAC;AACzC,QAAM,OAAO,IAAI,YAAY,UAAU,CAAC;AACxC,MAAI,QAAQ;AAEZ,MAAI,WAAW,SAAS;AAkCxB,OAAK,MAAM,GAAG,OAAO,SAAS,OAAO;AACnC,UAAM,GAAG,IAAI;AAAA,EACf;AACA,OAAK,MAAM,GAAG,MAAM,OAAO,OAAO;AAChC,UAAM,KAAK,aAAa,GAAG,CAAC;AAAA,EAC9B;AAGA,SAAO;AACP,OAAK,MAAM,SAAS,OAAO,GAAG,OAAO;AACnC,QAAI,MAAM,GAAG,MAAM,GAAG;AAAE;AAAA,IAAO;AAAA,EACjC;AACA,MAAI,OAAO,KAAK;AACd,WAAO;AAAA,EACT;AACA,MAAI,QAAQ,GAAG;AAIb,UAAM,aAAa,IAAK,KAAK,KAAO,MAAM,KAAM;AAMhD,UAAM,aAAa,IAAK,KAAK,KAAO,MAAM,KAAM;AAEhD,SAAK,OAAO;AACZ,WAAO;AAAA,EACT;AACA,OAAK,MAAM,GAAG,MAAM,KAAK,OAAO;AAC9B,QAAI,MAAM,GAAG,MAAM,GAAG;AAAE;AAAA,IAAO;AAAA,EACjC;AACA,MAAI,OAAO,KAAK;AACd,WAAO;AAAA,EACT;AAGA,EAAAC,QAAO;AACP,OAAK,MAAM,GAAG,OAAO,SAAS,OAAO;AACnC,IAAAA,UAAS;AACT,IAAAA,SAAQ,MAAM,GAAG;AACjB,QAAIA,QAAO,GAAG;AACZ,aAAO;AAAA,IACT;AAAA,EACF;AACA,MAAIA,QAAO,MAAM,SAAS,WAAW,QAAQ,IAAI;AAC/C,WAAO;AAAA,EACT;AAGA,OAAK,CAAC,IAAI;AACV,OAAK,MAAM,GAAG,MAAM,SAAS,OAAO;AAClC,SAAK,MAAM,CAAC,IAAI,KAAK,GAAG,IAAI,MAAM,GAAG;AAAA,EACvC;AAGA,OAAK,MAAM,GAAG,MAAM,OAAO,OAAO;AAChC,QAAI,KAAK,aAAa,GAAG,MAAM,GAAG;AAChC,WAAK,KAAK,KAAK,aAAa,GAAG,CAAC,GAAG,IAAI;AAAA,IACzC;AAAA,EACF;AAoCA,MAAI,SAAS,SAAS;AACpB,WAAO,QAAQ;AACf,IAAAD,SAAQ;AAAA,EAEV,WAAW,SAAS,QAAQ;AAC1B,WAAO;AACP,YAAQ;AACR,IAAAA,SAAQ;AAAA,EAEV,OAAO;AACL,WAAO;AACP,YAAQ;AACR,IAAAA,SAAQ;AAAA,EACV;AAGA,SAAO;AACP,QAAM;AACN,QAAM;AACN,SAAO;AACP,SAAO;AACP,SAAO;AACP,QAAM;AACN,SAAO,KAAK;AACZ,SAAO,OAAO;AAGd,MAAK,SAAS,UAAU,OAAO,iBAC5B,SAAS,WAAW,OAAO,gBAAiB;AAC7C,WAAO;AAAA,EACT;AAGA,aAAS;AAEP,gBAAY,MAAM;AAClB,QAAI,KAAK,GAAG,IAAI,IAAIA,QAAO;AACzB,gBAAU;AACV,iBAAW,KAAK,GAAG;AAAA,IACrB,WACS,KAAK,GAAG,KAAKA,QAAO;AAC3B,gBAAU,MAAM,KAAK,GAAG,IAAIA,MAAK;AACjC,iBAAW,KAAK,KAAK,GAAG,IAAIA,MAAK;AAAA,IACnC,OACK;AACH,gBAAU,KAAK;AACf,iBAAW;AAAA,IACb;AAGA,WAAO,KAAM,MAAM;AACnB,WAAO,KAAK;AACZ,UAAM;AACN,OAAG;AACD,cAAQ;AACR,YAAM,QAAQ,QAAQ,QAAQ,IAAI,IAAK,aAAa,KAAO,WAAW,KAAM,WAAU;AAAA,IACxF,SAAS,SAAS;AAGlB,WAAO,KAAM,MAAM;AACnB,WAAO,OAAO,MAAM;AAClB,eAAS;AAAA,IACX;AACA,QAAI,SAAS,GAAG;AACd,cAAQ,OAAO;AACf,cAAQ;AAAA,IACV,OAAO;AACL,aAAO;AAAA,IACT;AAGA;AACA,QAAI,EAAE,MAAM,GAAG,MAAM,GAAG;AACtB,UAAI,QAAQ,KAAK;AAAE;AAAA,MAAO;AAC1B,YAAM,KAAK,aAAa,KAAK,GAAG,CAAC;AAAA,IACnC;AAGA,QAAI,MAAM,SAAS,OAAO,UAAU,KAAK;AAEvC,UAAI,SAAS,GAAG;AACd,eAAO;AAAA,MACT;AAGA,cAAQ;AAGR,aAAO,MAAM;AACb,MAAAC,QAAO,KAAK;AACZ,aAAO,OAAO,OAAO,KAAK;AACxB,QAAAA,SAAQ,MAAM,OAAO,IAAI;AACzB,YAAIA,SAAQ,GAAG;AAAE;AAAA,QAAO;AACxB;AACA,QAAAA,UAAS;AAAA,MACX;AAGA,cAAQ,KAAK;AACb,UAAK,SAAS,UAAU,OAAO,iBAC5B,SAAS,WAAW,OAAO,gBAAiB;AAC7C,eAAO;AAAA,MACT;AAGA,YAAM,OAAO;AAIb,YAAM,GAAG,IAAK,QAAQ,KAAO,QAAQ,KAAO,OAAO,cAAc;AAAA,IACnE;AAAA,EACF;AAKA,MAAI,SAAS,GAAG;AAId,UAAM,OAAO,IAAI,IAAM,MAAM,QAAS,KAAO,MAAM,KAAK;AAAA,EAC1D;AAIA,OAAK,OAAO;AACZ,SAAO;AACT;AAGA,IAAI,WAAW;AA0Bf,IAAM,QAAQ;AACd,IAAM,OAAO;AACb,IAAM,QAAQ;AAKd,IAAM;AAAA,EACJ,UAAU;AAAA,EAAY;AAAA,EAAS;AAAA,EAC/B,MAAM;AAAA,EAAQ,cAAc;AAAA,EAAgB,aAAa;AAAA,EAAe,gBAAgB;AAAA,EAAkB,cAAc;AAAA,EAAgB,aAAa;AAAA,EAAe;AAAA,EACpK;AACF,IAAI;AAOJ,IAAS,OAAO;AAChB,IAAS,QAAQ;AACjB,IAAS,OAAO;AAChB,IAAS,KAAK;AACd,IAAS,QAAQ;AACjB,IAAS,QAAQ;AACjB,IAAS,OAAO;AAChB,IAAS,UAAU;AACnB,IAAS,OAAO;AAChB,IAAS,SAAS;AAClB,IAAS,OAAO;AAChB,IAAa,OAAO;AACpB,IAAa,SAAS;AACtB,IAAa,SAAS;AACtB,IAAa,QAAQ;AACrB,IAAa,OAAO;AACpB,IAAa,QAAQ;AACrB,IAAa,UAAU;AACvB,IAAa,WAAW;AACxB,IAAiB,OAAO;AACxB,IAAiB,MAAM;AACvB,IAAiB,SAAS;AAC1B,IAAiB,OAAO;AACxB,IAAiB,UAAU;AAC3B,IAAiB,QAAQ;AACzB,IAAiB,MAAM;AACvB,IAAS,QAAQ;AACjB,IAAS,SAAS;AAClB,IAAS,OAAO;AAChB,IAAS,MAAM;AACf,IAAS,MAAM;AACf,IAAS,OAAO;AAMhB,IAAM,cAAc;AACpB,IAAM,eAAe;AAGrB,IAAM,YAAY;AAElB,IAAM,YAAY;AAGlB,IAAM,UAAU,CAAC,MAAM;AAErB,UAAW,MAAM,KAAM,QACb,MAAM,IAAK,WACX,IAAI,UAAW,OACf,IAAI,QAAS;AACzB;AAGA,SAAS,eAAe;AACtB,OAAK,OAAO;AACZ,OAAK,OAAO;AACZ,OAAK,OAAO;AACZ,OAAK,OAAO;AAEZ,OAAK,WAAW;AAChB,OAAK,QAAQ;AAEb,OAAK,OAAO;AACZ,OAAK,QAAQ;AACb,OAAK,QAAQ;AAEb,OAAK,OAAO;AAGZ,OAAK,QAAQ;AACb,OAAK,QAAQ;AACb,OAAK,QAAQ;AACb,OAAK,QAAQ;AACb,OAAK,SAAS;AAGd,OAAK,OAAO;AACZ,OAAK,OAAO;AAGZ,OAAK,SAAS;AACd,OAAK,SAAS;AAGd,OAAK,QAAQ;AAGb,OAAK,UAAU;AACf,OAAK,WAAW;AAChB,OAAK,UAAU;AACf,OAAK,WAAW;AAGhB,OAAK,QAAQ;AACb,OAAK,OAAO;AACZ,OAAK,QAAQ;AACb,OAAK,OAAO;AACZ,OAAK,OAAO;AAEZ,OAAK,OAAO,IAAI,YAAY,GAAG;AAC/B,OAAK,OAAO,IAAI,YAAY,GAAG;AAO/B,OAAK,SAAS;AACd,OAAK,UAAU;AACf,OAAK,OAAO;AACZ,OAAK,OAAO;AACZ,OAAK,MAAM;AACb;AAGA,IAAM,oBAAoB,CAAC,SAAS;AAElC,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,KAAK;AACnB,MAAI,CAAC,SAAS,MAAM,SAAS,QAC3B,MAAM,OAAO,QAAQ,MAAM,OAAO,MAAM;AACxC,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,IAAM,mBAAmB,CAAC,SAAS;AAEjC,MAAI,kBAAkB,IAAI,GAAG;AAAE,WAAO;AAAA,EAAkB;AACxD,QAAM,QAAQ,KAAK;AACnB,OAAK,WAAW,KAAK,YAAY,MAAM,QAAQ;AAC/C,OAAK,MAAM;AACX,MAAI,MAAM,MAAM;AACd,SAAK,QAAQ,MAAM,OAAO;AAAA,EAC5B;AACA,QAAM,OAAO;AACb,QAAM,OAAO;AACb,QAAM,WAAW;AACjB,QAAM,QAAQ;AACd,QAAM,OAAO;AACb,QAAM,OAAO;AACb,QAAM,OAAO;AACb,QAAM,OAAO;AAEb,QAAM,UAAU,MAAM,SAAS,IAAI,WAAW,WAAW;AACzD,QAAM,WAAW,MAAM,UAAU,IAAI,WAAW,YAAY;AAE5D,QAAM,OAAO;AACb,QAAM,OAAO;AAEb,SAAO;AACT;AAGA,IAAM,eAAe,CAAC,SAAS;AAE7B,MAAI,kBAAkB,IAAI,GAAG;AAAE,WAAO;AAAA,EAAkB;AACxD,QAAM,QAAQ,KAAK;AACnB,QAAM,QAAQ;AACd,QAAM,QAAQ;AACd,QAAM,QAAQ;AACd,SAAO,iBAAiB,IAAI;AAE9B;AAGA,IAAM,gBAAgB,CAAC,MAAM,eAAe;AAC1C,MAAI;AAGJ,MAAI,kBAAkB,IAAI,GAAG;AAAE,WAAO;AAAA,EAAkB;AACxD,QAAM,QAAQ,KAAK;AAGnB,MAAI,aAAa,GAAG;AAClB,WAAO;AACP,iBAAa,CAAC;AAAA,EAChB,OACK;AACH,YAAQ,cAAc,KAAK;AAC3B,QAAI,aAAa,IAAI;AACnB,oBAAc;AAAA,IAChB;AAAA,EACF;AAGA,MAAI,eAAe,aAAa,KAAK,aAAa,KAAK;AACrD,WAAO;AAAA,EACT;AACA,MAAI,MAAM,WAAW,QAAQ,MAAM,UAAU,YAAY;AACvD,UAAM,SAAS;AAAA,EACjB;AAGA,QAAM,OAAO;AACb,QAAM,QAAQ;AACd,SAAO,aAAa,IAAI;AAC1B;AAGA,IAAM,eAAe,CAAC,MAAM,eAAe;AAEzC,MAAI,CAAC,MAAM;AAAE,WAAO;AAAA,EAAkB;AAGtC,QAAM,QAAQ,IAAI,aAAa;AAI/B,OAAK,QAAQ;AACb,QAAM,OAAO;AACb,QAAM,SAAS;AACf,QAAM,OAAO;AACb,QAAM,MAAM,cAAc,MAAM,UAAU;AAC1C,MAAI,QAAQ,QAAQ;AAClB,SAAK,QAAQ;AAAA,EACf;AACA,SAAO;AACT;AAGA,IAAM,cAAc,CAAC,SAAS;AAE5B,SAAO,aAAa,MAAM,SAAS;AACrC;AAaA,IAAI,SAAS;AAEb,IAAI;AAAJ,IAAY;AAGZ,IAAM,cAAc,CAAC,UAAU;AAG7B,MAAI,QAAQ;AACV,aAAS,IAAI,WAAW,GAAG;AAC3B,cAAU,IAAI,WAAW,EAAE;AAG3B,QAAI,MAAM;AACV,WAAO,MAAM,KAAK;AAAE,YAAM,KAAK,KAAK,IAAI;AAAA,IAAG;AAC3C,WAAO,MAAM,KAAK;AAAE,YAAM,KAAK,KAAK,IAAI;AAAA,IAAG;AAC3C,WAAO,MAAM,KAAK;AAAE,YAAM,KAAK,KAAK,IAAI;AAAA,IAAG;AAC3C,WAAO,MAAM,KAAK;AAAE,YAAM,KAAK,KAAK,IAAI;AAAA,IAAG;AAE3C,aAAS,MAAO,MAAM,MAAM,GAAG,KAAK,QAAU,GAAG,MAAM,MAAM,EAAE,MAAM,EAAE,CAAC;AAGxE,UAAM;AACN,WAAO,MAAM,IAAI;AAAE,YAAM,KAAK,KAAK,IAAI;AAAA,IAAG;AAE1C,aAAS,OAAO,MAAM,MAAM,GAAG,IAAM,SAAS,GAAG,MAAM,MAAM,EAAE,MAAM,EAAE,CAAC;AAGxE,aAAS;AAAA,EACX;AAEA,QAAM,UAAU;AAChB,QAAM,UAAU;AAChB,QAAM,WAAW;AACjB,QAAM,WAAW;AACnB;AAiBA,IAAM,eAAe,CAAC,MAAM,KAAK,KAAKE,UAAS;AAE7C,MAAI;AACJ,QAAM,QAAQ,KAAK;AAGnB,MAAI,MAAM,WAAW,MAAM;AACzB,UAAM,QAAQ,KAAK,MAAM;AACzB,UAAM,QAAQ;AACd,UAAM,QAAQ;AAEd,UAAM,SAAS,IAAI,WAAW,MAAM,KAAK;AAAA,EAC3C;AAGA,MAAIA,SAAQ,MAAM,OAAO;AACvB,UAAM,OAAO,IAAI,IAAI,SAAS,MAAM,MAAM,OAAO,GAAG,GAAG,CAAC;AACxD,UAAM,QAAQ;AACd,UAAM,QAAQ,MAAM;AAAA,EACtB,OACK;AACH,WAAO,MAAM,QAAQ,MAAM;AAC3B,QAAI,OAAOA,OAAM;AACf,aAAOA;AAAA,IACT;AAEA,UAAM,OAAO,IAAI,IAAI,SAAS,MAAMA,OAAM,MAAMA,QAAO,IAAI,GAAG,MAAM,KAAK;AACzE,IAAAA,SAAQ;AACR,QAAIA,OAAM;AAER,YAAM,OAAO,IAAI,IAAI,SAAS,MAAMA,OAAM,GAAG,GAAG,CAAC;AACjD,YAAM,QAAQA;AACd,YAAM,QAAQ,MAAM;AAAA,IACtB,OACK;AACH,YAAM,SAAS;AACf,UAAI,MAAM,UAAU,MAAM,OAAO;AAAE,cAAM,QAAQ;AAAA,MAAG;AACpD,UAAI,MAAM,QAAQ,MAAM,OAAO;AAAE,cAAM,SAAS;AAAA,MAAM;AAAA,IACxD;AAAA,EACF;AACA,SAAO;AACT;AAGA,IAAM,YAAY,CAAC,MAAM,UAAU;AAEjC,MAAI;AACJ,MAAI,OAAO;AACX,MAAI;AACJ,MAAI;AACJ,MAAI,MAAMF;AACV,MAAI;AACJ,MAAI;AACJ,MAAI,KAAK;AACT,MAAIE;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,OAAO;AACX,MAAI,WAAW,SAAS;AAExB,MAAI,WAAW,SAAS;AACxB,MAAI;AACJ,MAAI;AACJ,QAAM,OAAO,IAAI,WAAW,CAAC;AAC7B,MAAI;AAEJ,MAAI;AAEJ,QAAM;AAAA;AAAA,IACJ,IAAI,WAAW,CAAE,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,EAAG,CAAC;AAAA;AAGrF,MAAI,kBAAkB,IAAI,KAAK,CAAC,KAAK,UAChC,CAAC,KAAK,SAAS,KAAK,aAAa,GAAI;AACxC,WAAO;AAAA,EACT;AAEA,UAAQ,KAAK;AACb,MAAI,MAAM,SAAS,MAAM;AAAE,UAAM,OAAO;AAAA,EAAQ;AAIhD,QAAM,KAAK;AACX,WAAS,KAAK;AACd,EAAAF,QAAO,KAAK;AACZ,SAAO,KAAK;AACZ,UAAQ,KAAK;AACb,SAAO,KAAK;AACZ,SAAO,MAAM;AACb,SAAO,MAAM;AAGb,QAAM;AACN,SAAOA;AACP,QAAM;AAEN;AACA,eAAS;AACP,cAAQ,MAAM,MAAM;AAAA,QAClB,KAAK;AACH,cAAI,MAAM,SAAS,GAAG;AACpB,kBAAM,OAAO;AACb;AAAA,UACF;AAEA,iBAAO,OAAO,IAAI;AAChB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACV;AAEA,cAAK,MAAM,OAAO,KAAM,SAAS,OAAQ;AACvC,gBAAI,MAAM,UAAU,GAAG;AACrB,oBAAM,QAAQ;AAAA,YAChB;AACA,kBAAM,QAAQ;AAEd,iBAAK,CAAC,IAAI,OAAO;AACjB,iBAAK,CAAC,IAAK,SAAS,IAAK;AACzB,kBAAM,QAAQ,QAAQ,MAAM,OAAO,MAAM,GAAG,CAAC;AAI7C,mBAAO;AACP,mBAAO;AAEP,kBAAM,OAAO;AACb;AAAA,UACF;AACA,cAAI,MAAM,MAAM;AACd,kBAAM,KAAK,OAAO;AAAA,UACpB;AACA,cAAI,EAAE,MAAM,OAAO;AAAA,aACd,OAAO,QAAoB,MAAM,QAAQ,MAAM,IAAI;AACtD,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AACA,eAAK,OAAO,QAAqB,YAAY;AAC3C,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AAEA,oBAAU;AACV,kBAAQ;AAER,iBAAO,OAAO,MAAmB;AACjC,cAAI,MAAM,UAAU,GAAG;AACrB,kBAAM,QAAQ;AAAA,UAChB;AACA,cAAI,MAAM,MAAM,MAAM,MAAM,OAAO;AACjC,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AAIA,gBAAM,OAAO,KAAK,MAAM;AAGxB,gBAAM,QAAQ;AAEd,eAAK,QAAQ,MAAM,QAAQ;AAC3B,gBAAM,OAAO,OAAO,MAAQ,SAAS;AAErC,iBAAO;AACP,iBAAO;AAEP;AAAA,QACF,KAAK;AAEH,iBAAO,OAAO,IAAI;AAChB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACV;AAEA,gBAAM,QAAQ;AACd,eAAK,MAAM,QAAQ,SAAU,YAAY;AACvC,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AACA,cAAI,MAAM,QAAQ,OAAQ;AACxB,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AACA,cAAI,MAAM,MAAM;AACd,kBAAM,KAAK,OAAS,QAAQ,IAAK;AAAA,UACnC;AACA,cAAK,MAAM,QAAQ,OAAY,MAAM,OAAO,GAAI;AAE9C,iBAAK,CAAC,IAAI,OAAO;AACjB,iBAAK,CAAC,IAAK,SAAS,IAAK;AACzB,kBAAM,QAAQ,QAAQ,MAAM,OAAO,MAAM,GAAG,CAAC;AAAA,UAE/C;AAEA,iBAAO;AACP,iBAAO;AAEP,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AAEH,iBAAO,OAAO,IAAI;AAChB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACV;AAEA,cAAI,MAAM,MAAM;AACd,kBAAM,KAAK,OAAO;AAAA,UACpB;AACA,cAAK,MAAM,QAAQ,OAAY,MAAM,OAAO,GAAI;AAE9C,iBAAK,CAAC,IAAI,OAAO;AACjB,iBAAK,CAAC,IAAK,SAAS,IAAK;AACzB,iBAAK,CAAC,IAAK,SAAS,KAAM;AAC1B,iBAAK,CAAC,IAAK,SAAS,KAAM;AAC1B,kBAAM,QAAQ,QAAQ,MAAM,OAAO,MAAM,GAAG,CAAC;AAAA,UAE/C;AAEA,iBAAO;AACP,iBAAO;AAEP,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AAEH,iBAAO,OAAO,IAAI;AAChB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACV;AAEA,cAAI,MAAM,MAAM;AACd,kBAAM,KAAK,SAAU,OAAO;AAC5B,kBAAM,KAAK,KAAM,QAAQ;AAAA,UAC3B;AACA,cAAK,MAAM,QAAQ,OAAY,MAAM,OAAO,GAAI;AAE9C,iBAAK,CAAC,IAAI,OAAO;AACjB,iBAAK,CAAC,IAAK,SAAS,IAAK;AACzB,kBAAM,QAAQ,QAAQ,MAAM,OAAO,MAAM,GAAG,CAAC;AAAA,UAE/C;AAEA,iBAAO;AACP,iBAAO;AAEP,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,QAAQ,MAAQ;AAExB,mBAAO,OAAO,IAAI;AAChB,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YACV;AAEA,kBAAM,SAAS;AACf,gBAAI,MAAM,MAAM;AACd,oBAAM,KAAK,YAAY;AAAA,YACzB;AACA,gBAAK,MAAM,QAAQ,OAAY,MAAM,OAAO,GAAI;AAE9C,mBAAK,CAAC,IAAI,OAAO;AACjB,mBAAK,CAAC,IAAK,SAAS,IAAK;AACzB,oBAAM,QAAQ,QAAQ,MAAM,OAAO,MAAM,GAAG,CAAC;AAAA,YAE/C;AAEA,mBAAO;AACP,mBAAO;AAAA,UAET,WACS,MAAM,MAAM;AACnB,kBAAM,KAAK,QAAQ;AAAA,UACrB;AACA,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,QAAQ,MAAQ;AACxB,YAAAE,QAAO,MAAM;AACb,gBAAIA,QAAO,MAAM;AAAE,cAAAA,QAAO;AAAA,YAAM;AAChC,gBAAIA,OAAM;AACR,kBAAI,MAAM,MAAM;AACd,sBAAM,MAAM,KAAK,YAAY,MAAM;AACnC,oBAAI,CAAC,MAAM,KAAK,OAAO;AAErB,wBAAM,KAAK,QAAQ,IAAI,WAAW,MAAM,KAAK,SAAS;AAAA,gBACxD;AACA,sBAAM,KAAK,MAAM;AAAA,kBACf,MAAM;AAAA,oBACJ;AAAA;AAAA;AAAA,oBAGA,OAAOA;AAAA,kBACT;AAAA;AAAA,kBAEA;AAAA,gBACF;AAAA,cAIF;AACA,kBAAK,MAAM,QAAQ,OAAY,MAAM,OAAO,GAAI;AAC9C,sBAAM,QAAQ,QAAQ,MAAM,OAAO,OAAOA,OAAM,IAAI;AAAA,cACtD;AACA,sBAAQA;AACR,sBAAQA;AACR,oBAAM,UAAUA;AAAA,YAClB;AACA,gBAAI,MAAM,QAAQ;AAAE,oBAAM;AAAA,YAAW;AAAA,UACvC;AACA,gBAAM,SAAS;AACf,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,QAAQ,MAAQ;AACxB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC,YAAAA,QAAO;AACP,eAAG;AAED,oBAAM,MAAM,OAAOA,OAAM;AAEzB,kBAAI,MAAM,QAAQ,OACb,MAAM,SAAS,OAAgC;AAClD,sBAAM,KAAK,QAAQ,OAAO,aAAa,GAAG;AAAA,cAC5C;AAAA,YACF,SAAS,OAAOA,QAAO;AAEvB,gBAAK,MAAM,QAAQ,OAAY,MAAM,OAAO,GAAI;AAC9C,oBAAM,QAAQ,QAAQ,MAAM,OAAO,OAAOA,OAAM,IAAI;AAAA,YACtD;AACA,oBAAQA;AACR,oBAAQA;AACR,gBAAI,KAAK;AAAE,oBAAM;AAAA,YAAW;AAAA,UAC9B,WACS,MAAM,MAAM;AACnB,kBAAM,KAAK,OAAO;AAAA,UACpB;AACA,gBAAM,SAAS;AACf,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,QAAQ,MAAQ;AACxB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC,YAAAA,QAAO;AACP,eAAG;AACD,oBAAM,MAAM,OAAOA,OAAM;AAEzB,kBAAI,MAAM,QAAQ,OACb,MAAM,SAAS,OAAgC;AAClD,sBAAM,KAAK,WAAW,OAAO,aAAa,GAAG;AAAA,cAC/C;AAAA,YACF,SAAS,OAAOA,QAAO;AACvB,gBAAK,MAAM,QAAQ,OAAY,MAAM,OAAO,GAAI;AAC9C,oBAAM,QAAQ,QAAQ,MAAM,OAAO,OAAOA,OAAM,IAAI;AAAA,YACtD;AACA,oBAAQA;AACR,oBAAQA;AACR,gBAAI,KAAK;AAAE,oBAAM;AAAA,YAAW;AAAA,UAC9B,WACS,MAAM,MAAM;AACnB,kBAAM,KAAK,UAAU;AAAA,UACvB;AACA,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,QAAQ,KAAQ;AAExB,mBAAO,OAAO,IAAI;AAChB,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YACV;AAEA,gBAAK,MAAM,OAAO,KAAM,UAAU,MAAM,QAAQ,QAAS;AACvD,mBAAK,MAAM;AACX,oBAAM,OAAO;AACb;AAAA,YACF;AAEA,mBAAO;AACP,mBAAO;AAAA,UAET;AACA,cAAI,MAAM,MAAM;AACd,kBAAM,KAAK,OAAS,MAAM,SAAS,IAAK;AACxC,kBAAM,KAAK,OAAO;AAAA,UACpB;AACA,eAAK,QAAQ,MAAM,QAAQ;AAC3B,gBAAM,OAAO;AACb;AAAA,QACF,KAAK;AAEH,iBAAO,OAAO,IAAI;AAChB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACV;AAEA,eAAK,QAAQ,MAAM,QAAQ,QAAQ,IAAI;AAEvC,iBAAO;AACP,iBAAO;AAEP,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,aAAa,GAAG;AAExB,iBAAK,WAAW;AAChB,iBAAK,YAAYF;AACjB,iBAAK,UAAU;AACf,iBAAK,WAAW;AAChB,kBAAM,OAAO;AACb,kBAAM,OAAO;AAEb,mBAAO;AAAA,UACT;AACA,eAAK,QAAQ,MAAM,QAAQ;AAC3B,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,UAAU,WAAW,UAAU,SAAS;AAAE,kBAAM;AAAA,UAAW;AAAA;AAAA,QAEjE,KAAK;AACH,cAAI,MAAM,MAAM;AAEd,sBAAU,OAAO;AACjB,oBAAQ,OAAO;AAEf,kBAAM,OAAO;AACb;AAAA,UACF;AAEA,iBAAO,OAAO,GAAG;AACf,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACV;AAEA,gBAAM,OAAQ,OAAO;AAErB,oBAAU;AACV,kBAAQ;AAGR,kBAAS,OAAO,GAAkB;AAAA,YAChC,KAAK;AAGH,oBAAM,OAAO;AACb;AAAA,YACF,KAAK;AACH,0BAAY,KAAK;AAGjB,oBAAM,OAAO;AACb,kBAAI,UAAU,SAAS;AAErB,0BAAU;AACV,wBAAQ;AAER,sBAAM;AAAA,cACR;AACA;AAAA,YACF,KAAK;AAGH,oBAAM,OAAO;AACb;AAAA,YACF,KAAK;AACH,mBAAK,MAAM;AACX,oBAAM,OAAO;AAAA,UACjB;AAEA,oBAAU;AACV,kBAAQ;AAER;AAAA,QACF,KAAK;AAEH,oBAAU,OAAO;AACjB,kBAAQ,OAAO;AAGf,iBAAO,OAAO,IAAI;AAChB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACV;AAEA,eAAK,OAAO,YAAc,SAAS,KAAM,QAAS;AAChD,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AACA,gBAAM,SAAS,OAAO;AAItB,iBAAO;AACP,iBAAO;AAEP,gBAAM,OAAO;AACb,cAAI,UAAU,SAAS;AAAE,kBAAM;AAAA,UAAW;AAAA;AAAA,QAE5C,KAAK;AACH,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,UAAAE,QAAO,MAAM;AACb,cAAIA,OAAM;AACR,gBAAIA,QAAO,MAAM;AAAE,cAAAA,QAAO;AAAA,YAAM;AAChC,gBAAIA,QAAOF,OAAM;AAAE,cAAAE,QAAOF;AAAA,YAAM;AAChC,gBAAIE,UAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AAEnC,mBAAO,IAAI,MAAM,SAAS,MAAM,OAAOA,KAAI,GAAG,GAAG;AAEjD,oBAAQA;AACR,oBAAQA;AACR,YAAAF,SAAQE;AACR,mBAAOA;AACP,kBAAM,UAAUA;AAChB;AAAA,UACF;AAEA,gBAAM,OAAO;AACb;AAAA,QACF,KAAK;AAEH,iBAAO,OAAO,IAAI;AAChB,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACV;AAEA,gBAAM,QAAQ,OAAO,MAAmB;AAExC,oBAAU;AACV,kBAAQ;AAER,gBAAM,SAAS,OAAO,MAAmB;AAEzC,oBAAU;AACV,kBAAQ;AAER,gBAAM,SAAS,OAAO,MAAmB;AAEzC,oBAAU;AACV,kBAAQ;AAGR,cAAI,MAAM,OAAO,OAAO,MAAM,QAAQ,IAAI;AACxC,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AAGA,gBAAM,OAAO;AACb,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,iBAAO,MAAM,OAAO,MAAM,OAAO;AAE/B,mBAAO,OAAO,GAAG;AACf,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YACV;AAEA,kBAAM,KAAK,MAAM,MAAM,MAAM,CAAC,IAAK,OAAO;AAE1C,sBAAU;AACV,oBAAQ;AAAA,UAEV;AACA,iBAAO,MAAM,OAAO,IAAI;AACtB,kBAAM,KAAK,MAAM,MAAM,MAAM,CAAC,IAAI;AAAA,UACpC;AAKA,gBAAM,UAAU,MAAM;AACtB,gBAAM,UAAU;AAEhB,iBAAO,EAAE,MAAM,MAAM,QAAQ;AAC7B,gBAAM,SAAS,OAAO,MAAM,MAAM,GAAG,IAAI,MAAM,SAAS,GAAG,MAAM,MAAM,IAAI;AAC3E,gBAAM,UAAU,KAAK;AAErB,cAAI,KAAK;AACP,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AAEA,gBAAM,OAAO;AACb,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,iBAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO;AAC5C,uBAAS;AACP,qBAAO,MAAM,QAAQ,QAAS,KAAK,MAAM,WAAW,CAAE;AACtD,0BAAY,SAAS;AACrB,wBAAW,SAAS,KAAM;AAC1B,yBAAW,OAAO;AAElB,kBAAK,aAAc,MAAM;AAAE;AAAA,cAAO;AAElC,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YAEV;AACA,gBAAI,WAAW,IAAI;AAEjB,wBAAU;AACV,sBAAQ;AAER,oBAAM,KAAK,MAAM,MAAM,IAAI;AAAA,YAC7B,OACK;AACH,kBAAI,aAAa,IAAI;AAEnB,oBAAI,YAAY;AAChB,uBAAO,OAAO,GAAG;AACf,sBAAI,SAAS,GAAG;AAAE,0BAAM;AAAA,kBAAW;AACnC;AACA,0BAAQ,MAAM,MAAM,KAAK;AACzB,0BAAQ;AAAA,gBACV;AAGA,0BAAU;AACV,wBAAQ;AAER,oBAAI,MAAM,SAAS,GAAG;AACpB,uBAAK,MAAM;AACX,wBAAM,OAAO;AACb;AAAA,gBACF;AACA,sBAAM,MAAM,KAAK,MAAM,OAAO,CAAC;AAC/B,gBAAAA,QAAO,KAAK,OAAO;AAEnB,0BAAU;AACV,wBAAQ;AAAA,cAEV,WACS,aAAa,IAAI;AAExB,oBAAI,YAAY;AAChB,uBAAO,OAAO,GAAG;AACf,sBAAI,SAAS,GAAG;AAAE,0BAAM;AAAA,kBAAW;AACnC;AACA,0BAAQ,MAAM,MAAM,KAAK;AACzB,0BAAQ;AAAA,gBACV;AAGA,0BAAU;AACV,wBAAQ;AAER,sBAAM;AACN,gBAAAA,QAAO,KAAK,OAAO;AAEnB,0BAAU;AACV,wBAAQ;AAAA,cAEV,OACK;AAEH,oBAAI,YAAY;AAChB,uBAAO,OAAO,GAAG;AACf,sBAAI,SAAS,GAAG;AAAE,0BAAM;AAAA,kBAAW;AACnC;AACA,0BAAQ,MAAM,MAAM,KAAK;AACzB,0BAAQ;AAAA,gBACV;AAGA,0BAAU;AACV,wBAAQ;AAER,sBAAM;AACN,gBAAAA,QAAO,MAAM,OAAO;AAEpB,0BAAU;AACV,wBAAQ;AAAA,cAEV;AACA,kBAAI,MAAM,OAAOA,QAAO,MAAM,OAAO,MAAM,OAAO;AAChD,qBAAK,MAAM;AACX,sBAAM,OAAO;AACb;AAAA,cACF;AACA,qBAAOA,SAAQ;AACb,sBAAM,KAAK,MAAM,MAAM,IAAI;AAAA,cAC7B;AAAA,YACF;AAAA,UACF;AAGA,cAAI,MAAM,SAAS,KAAK;AAAE;AAAA,UAAO;AAGjC,cAAI,MAAM,KAAK,GAAG,MAAM,GAAG;AACzB,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AAKA,gBAAM,UAAU;AAEhB,iBAAO,EAAE,MAAM,MAAM,QAAQ;AAC7B,gBAAM,SAAS,MAAM,MAAM,MAAM,GAAG,MAAM,MAAM,MAAM,SAAS,GAAG,MAAM,MAAM,IAAI;AAGlF,gBAAM,UAAU,KAAK;AAGrB,cAAI,KAAK;AACP,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AAEA,gBAAM,WAAW;AAGjB,gBAAM,WAAW,MAAM;AACvB,iBAAO,EAAE,MAAM,MAAM,SAAS;AAC9B,gBAAM,SAAS,OAAO,MAAM,MAAM,MAAM,MAAM,MAAM,OAAO,MAAM,UAAU,GAAG,MAAM,MAAM,IAAI;AAG9F,gBAAM,WAAW,KAAK;AAGtB,cAAI,KAAK;AACP,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AAEA,gBAAM,OAAO;AACb,cAAI,UAAU,SAAS;AAAE,kBAAM;AAAA,UAAW;AAAA;AAAA,QAE5C,KAAK;AACH,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,QAAQ,KAAKF,SAAQ,KAAK;AAE5B,iBAAK,WAAW;AAChB,iBAAK,YAAYA;AACjB,iBAAK,UAAU;AACf,iBAAK,WAAW;AAChB,kBAAM,OAAO;AACb,kBAAM,OAAO;AAEb,oBAAQ,MAAM,IAAI;AAElB,kBAAM,KAAK;AACX,qBAAS,KAAK;AACd,YAAAA,QAAO,KAAK;AACZ,mBAAO,KAAK;AACZ,oBAAQ,KAAK;AACb,mBAAO,KAAK;AACZ,mBAAO,MAAM;AACb,mBAAO,MAAM;AAGb,gBAAI,MAAM,SAAS,MAAM;AACvB,oBAAM,OAAO;AAAA,YACf;AACA;AAAA,UACF;AACA,gBAAM,OAAO;AACb,qBAAS;AACP,mBAAO,MAAM,QAAQ,QAAS,KAAK,MAAM,WAAW,CAAE;AACtD,wBAAY,SAAS;AACrB,sBAAW,SAAS,KAAM;AAC1B,uBAAW,OAAO;AAElB,gBAAI,aAAa,MAAM;AAAE;AAAA,YAAO;AAEhC,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UAEV;AACA,cAAI,YAAY,UAAU,SAAU,GAAG;AACrC,wBAAY;AACZ,sBAAU;AACV,uBAAW;AACX,uBAAS;AACP,qBAAO,MAAM,QAAQ,aACX,QAAS,KAAM,YAAY,WAAY,MAAoC,UAAU;AAC/F,0BAAY,SAAS;AACrB,wBAAW,SAAS,KAAM;AAC1B,yBAAW,OAAO;AAElB,kBAAK,YAAY,aAAc,MAAM;AAAE;AAAA,cAAO;AAE9C,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YAEV;AAEA,sBAAU;AACV,oBAAQ;AAER,kBAAM,QAAQ;AAAA,UAChB;AAEA,oBAAU;AACV,kBAAQ;AAER,gBAAM,QAAQ;AACd,gBAAM,SAAS;AACf,cAAI,YAAY,GAAG;AAIjB,kBAAM,OAAO;AACb;AAAA,UACF;AACA,cAAI,UAAU,IAAI;AAEhB,kBAAM,OAAO;AACb,kBAAM,OAAO;AACb;AAAA,UACF;AACA,cAAI,UAAU,IAAI;AAChB,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AACA,gBAAM,QAAQ,UAAU;AACxB,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,OAAO;AAEf,gBAAI,MAAM;AACV,mBAAO,OAAO,GAAG;AACf,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YACV;AAEA,kBAAM,UAAU,QAAS,KAAK,MAAM,SAAS;AAE7C,sBAAU,MAAM;AAChB,oBAAQ,MAAM;AAEd,kBAAM,QAAQ,MAAM;AAAA,UACtB;AAEA,gBAAM,MAAM,MAAM;AAClB,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,qBAAS;AACP,mBAAO,MAAM,SAAS,QAAS,KAAK,MAAM,YAAY,CAAE;AACxD,wBAAY,SAAS;AACrB,sBAAW,SAAS,KAAM;AAC1B,uBAAW,OAAO;AAElB,gBAAK,aAAc,MAAM;AAAE;AAAA,YAAO;AAElC,gBAAI,SAAS,GAAG;AAAE,oBAAM;AAAA,YAAW;AACnC;AACA,oBAAQ,MAAM,MAAM,KAAK;AACzB,oBAAQ;AAAA,UAEV;AACA,eAAK,UAAU,SAAU,GAAG;AAC1B,wBAAY;AACZ,sBAAU;AACV,uBAAW;AACX,uBAAS;AACP,qBAAO,MAAM,SAAS,aACZ,QAAS,KAAM,YAAY,WAAY,MAAoC,UAAU;AAC/F,0BAAY,SAAS;AACrB,wBAAW,SAAS,KAAM;AAC1B,yBAAW,OAAO;AAElB,kBAAK,YAAY,aAAc,MAAM;AAAE;AAAA,cAAO;AAE9C,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YAEV;AAEA,sBAAU;AACV,oBAAQ;AAER,kBAAM,QAAQ;AAAA,UAChB;AAEA,oBAAU;AACV,kBAAQ;AAER,gBAAM,QAAQ;AACd,cAAI,UAAU,IAAI;AAChB,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AACA,gBAAM,SAAS;AACf,gBAAM,QAAS,UAAW;AAC1B,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,OAAO;AAEf,gBAAI,MAAM;AACV,mBAAO,OAAO,GAAG;AACf,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YACV;AAEA,kBAAM,UAAU,QAAS,KAAK,MAAM,SAAS;AAE7C,sBAAU,MAAM;AAChB,oBAAQ,MAAM;AAEd,kBAAM,QAAQ,MAAM;AAAA,UACtB;AAEA,cAAI,MAAM,SAAS,MAAM,MAAM;AAC7B,iBAAK,MAAM;AACX,kBAAM,OAAO;AACb;AAAA,UACF;AAGA,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAIA,UAAS,GAAG;AAAE,kBAAM;AAAA,UAAW;AACnC,UAAAE,QAAO,OAAOF;AACd,cAAI,MAAM,SAASE,OAAM;AACvB,YAAAA,QAAO,MAAM,SAASA;AACtB,gBAAIA,QAAO,MAAM,OAAO;AACtB,kBAAI,MAAM,MAAM;AACd,qBAAK,MAAM;AACX,sBAAM,OAAO;AACb;AAAA,cACF;AAAA,YAgBF;AACA,gBAAIA,QAAO,MAAM,OAAO;AACtB,cAAAA,SAAQ,MAAM;AACd,qBAAO,MAAM,QAAQA;AAAA,YACvB,OACK;AACH,qBAAO,MAAM,QAAQA;AAAA,YACvB;AACA,gBAAIA,QAAO,MAAM,QAAQ;AAAE,cAAAA,QAAO,MAAM;AAAA,YAAQ;AAChD,0BAAc,MAAM;AAAA,UACtB,OACK;AACH,0BAAc;AACd,mBAAO,MAAM,MAAM;AACnB,YAAAA,QAAO,MAAM;AAAA,UACf;AACA,cAAIA,QAAOF,OAAM;AAAE,YAAAE,QAAOF;AAAA,UAAM;AAChC,UAAAA,SAAQE;AACR,gBAAM,UAAUA;AAChB,aAAG;AACD,mBAAO,KAAK,IAAI,YAAY,MAAM;AAAA,UACpC,SAAS,EAAEA;AACX,cAAI,MAAM,WAAW,GAAG;AAAE,kBAAM,OAAO;AAAA,UAAK;AAC5C;AAAA,QACF,KAAK;AACH,cAAIF,UAAS,GAAG;AAAE,kBAAM;AAAA,UAAW;AACnC,iBAAO,KAAK,IAAI,MAAM;AACtB,UAAAA;AACA,gBAAM,OAAO;AACb;AAAA,QACF,KAAK;AACH,cAAI,MAAM,MAAM;AAEd,mBAAO,OAAO,IAAI;AAChB,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AAEA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YACV;AAEA,oBAAQA;AACR,iBAAK,aAAa;AAClB,kBAAM,SAAS;AACf,gBAAK,MAAM,OAAO,KAAM,MAAM;AAC5B,mBAAK,QAAQ,MAAM;AAAA,cAEd,MAAM,QAAQ,QAAQ,MAAM,OAAO,QAAQ,MAAM,MAAM,IAAI,IAAI,UAAU,MAAM,OAAO,QAAQ,MAAM,MAAM,IAAI;AAAA,YAErH;AACA,mBAAOA;AAEP,gBAAK,MAAM,OAAO,MAAO,MAAM,QAAQ,OAAO,QAAQ,IAAI,OAAO,MAAM,OAAO;AAC5E,mBAAK,MAAM;AACX,oBAAM,OAAO;AACb;AAAA,YACF;AAEA,mBAAO;AACP,mBAAO;AAAA,UAGT;AACA,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,cAAI,MAAM,QAAQ,MAAM,OAAO;AAE7B,mBAAO,OAAO,IAAI;AAChB,kBAAI,SAAS,GAAG;AAAE,sBAAM;AAAA,cAAW;AACnC;AACA,sBAAQ,MAAM,MAAM,KAAK;AACzB,sBAAQ;AAAA,YACV;AAEA,gBAAK,MAAM,OAAO,KAAM,UAAU,MAAM,QAAQ,aAAa;AAC3D,mBAAK,MAAM;AACX,oBAAM,OAAO;AACb;AAAA,YACF;AAEA,mBAAO;AACP,mBAAO;AAAA,UAGT;AACA,gBAAM,OAAO;AAAA;AAAA,QAEf,KAAK;AACH,gBAAM;AACN,gBAAM;AAAA,QACR,KAAK;AACH,gBAAM;AACN,gBAAM;AAAA,QACR,KAAK;AACH,iBAAO;AAAA,QACT,KAAK;AAAA;AAAA,QAEL;AACE,iBAAO;AAAA,MACX;AAAA,IACF;AAYA,OAAK,WAAW;AAChB,OAAK,YAAYA;AACjB,OAAK,UAAU;AACf,OAAK,WAAW;AAChB,QAAM,OAAO;AACb,QAAM,OAAO;AAGb,MAAI,MAAM,SAAU,SAAS,KAAK,aAAa,MAAM,OAAO,QACvC,MAAM,OAAO,SAAS,UAAU,aAAc;AACjE,QAAI,aAAa,MAAM,KAAK,QAAQ,KAAK,UAAU,OAAO,KAAK,SAAS,EAAG;AAAA,EAC7E;AACA,SAAO,KAAK;AACZ,UAAQ,KAAK;AACb,OAAK,YAAY;AACjB,OAAK,aAAa;AAClB,QAAM,SAAS;AACf,MAAK,MAAM,OAAO,KAAM,MAAM;AAC5B,SAAK,QAAQ,MAAM;AAAA,IAChB,MAAM,QAAQ,QAAQ,MAAM,OAAO,QAAQ,MAAM,KAAK,WAAW,IAAI,IAAI,UAAU,MAAM,OAAO,QAAQ,MAAM,KAAK,WAAW,IAAI;AAAA,EACvI;AACA,OAAK,YAAY,MAAM,QAAQ,MAAM,OAAO,KAAK,MAC9B,MAAM,SAAS,OAAO,MAAM,MAC5B,MAAM,SAAS,QAAQ,MAAM,SAAS,QAAQ,MAAM;AACvE,OAAM,QAAQ,KAAK,SAAS,KAAM,UAAU,eAAe,QAAQ,QAAQ;AACzE,UAAM;AAAA,EACR;AACA,SAAO;AACT;AAGA,IAAM,aAAa,CAAC,SAAS;AAE3B,MAAI,kBAAkB,IAAI,GAAG;AAC3B,WAAO;AAAA,EACT;AAEA,MAAI,QAAQ,KAAK;AACjB,MAAI,MAAM,QAAQ;AAChB,UAAM,SAAS;AAAA,EACjB;AACA,OAAK,QAAQ;AACb,SAAO;AACT;AAGA,IAAM,mBAAmB,CAAC,MAAMC,UAAS;AAGvC,MAAI,kBAAkB,IAAI,GAAG;AAAE,WAAO;AAAA,EAAkB;AACxD,QAAM,QAAQ,KAAK;AACnB,OAAK,MAAM,OAAO,OAAO,GAAG;AAAE,WAAO;AAAA,EAAkB;AAGvD,QAAM,OAAOA;AACb,EAAAA,MAAK,OAAO;AACZ,SAAO;AACT;AAGA,IAAM,uBAAuB,CAAC,MAAM,eAAe;AACjD,QAAM,aAAa,WAAW;AAE9B,MAAI;AACJ,MAAI;AACJ,MAAI;AAGJ,MAAI,kBAAkB,IAAI,GAAG;AAAE,WAAO;AAAA,EAAkB;AACxD,UAAQ,KAAK;AAEb,MAAI,MAAM,SAAS,KAAK,MAAM,SAAS,MAAM;AAC3C,WAAO;AAAA,EACT;AAGA,MAAI,MAAM,SAAS,MAAM;AACvB,aAAS;AAET,aAAS,UAAU,QAAQ,YAAY,YAAY,CAAC;AACpD,QAAI,WAAW,MAAM,OAAO;AAC1B,aAAO;AAAA,IACT;AAAA,EACF;AAGA,QAAM,aAAa,MAAM,YAAY,YAAY,UAAU;AAC3D,MAAI,KAAK;AACP,UAAM,OAAO;AACb,WAAO;AAAA,EACT;AACA,QAAM,WAAW;AAEjB,SAAO;AACT;AAGA,IAAI,iBAAiB;AACrB,IAAI,kBAAkB;AACtB,IAAI,qBAAqB;AACzB,IAAI,gBAAgB;AACpB,IAAI,iBAAiB;AACrB,IAAI,cAAc;AAClB,IAAI,eAAe;AACnB,IAAI,qBAAqB;AACzB,IAAI,yBAAyB;AAC7B,IAAI,cAAc;AAclB,IAAI,cAAc;AAAA,EACjB,cAAc;AAAA,EACd,eAAe;AAAA,EACf,kBAAkB;AAAA,EAClB,aAAa;AAAA,EACb,cAAc;AAAA,EACd,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,kBAAkB;AAAA,EAClB,sBAAsB;AAAA,EACtB;AACD;AAqBA,SAAS,WAAW;AAElB,OAAK,OAAa;AAElB,OAAK,OAAa;AAElB,OAAK,SAAa;AAElB,OAAK,KAAa;AAElB,OAAK,QAAa;AAElB,OAAK,YAAa;AAWlB,OAAK,OAAa;AAIlB,OAAK,UAAa;AAIlB,OAAK,OAAa;AAElB,OAAK,OAAa;AACpB;AAEA,IAAI,WAAW;AAEf,IAAM,WAAW,OAAO,UAAU;AAKlC,IAAM;AAAA,EACJ;AAAA,EAAY;AAAA,EACZ;AAAA,EAAM;AAAA,EAAc;AAAA,EAAa;AAAA,EAAgB;AAAA,EAAc;AACjE,IAAI;AAkFJ,SAAS,UAAU,SAAS;AAC1B,OAAK,UAAU,OAAO,OAAO;AAAA,IAC3B,WAAW,OAAO;AAAA,IAClB,YAAY;AAAA,IACZ,IAAI;AAAA,EACN,GAAG,WAAW,CAAC,CAAC;AAEhB,QAAM,MAAM,KAAK;AAIjB,MAAI,IAAI,OAAQ,IAAI,cAAc,KAAO,IAAI,aAAa,IAAK;AAC7D,QAAI,aAAa,CAAC,IAAI;AACtB,QAAI,IAAI,eAAe,GAAG;AAAE,UAAI,aAAa;AAAA,IAAK;AAAA,EACpD;AAGA,MAAK,IAAI,cAAc,KAAO,IAAI,aAAa,MAC3C,EAAE,WAAW,QAAQ,aAAa;AACpC,QAAI,cAAc;AAAA,EACpB;AAIA,MAAK,IAAI,aAAa,MAAQ,IAAI,aAAa,IAAK;AAGlD,SAAK,IAAI,aAAa,QAAQ,GAAG;AAC/B,UAAI,cAAc;AAAA,IACpB;AAAA,EACF;AAEA,OAAK,MAAS;AACd,OAAK,MAAS;AACd,OAAK,QAAS;AACd,OAAK,SAAS,CAAC;AAEf,OAAK,OAAS,IAAI,QAAQ;AAC1B,OAAK,KAAK,YAAY;AAEtB,MAAI,SAAU,YAAY;AAAA,IACxB,KAAK;AAAA,IACL,IAAI;AAAA,EACN;AAEA,MAAI,WAAW,MAAM;AACnB,UAAM,IAAI,MAAM,SAAS,MAAM,CAAC;AAAA,EAClC;AAEA,OAAK,SAAS,IAAI,SAAS;AAE3B,cAAY,iBAAiB,KAAK,MAAM,KAAK,MAAM;AAGnD,MAAI,IAAI,YAAY;AAElB,QAAI,OAAO,IAAI,eAAe,UAAU;AACtC,UAAI,aAAa,QAAQ,WAAW,IAAI,UAAU;AAAA,IACpD,WAAW,SAAS,KAAK,IAAI,UAAU,MAAM,wBAAwB;AACnE,UAAI,aAAa,IAAI,WAAW,IAAI,UAAU;AAAA,IAChD;AACA,QAAI,IAAI,KAAK;AACX,eAAS,YAAY,qBAAqB,KAAK,MAAM,IAAI,UAAU;AACnE,UAAI,WAAW,MAAM;AACnB,cAAM,IAAI,MAAM,SAAS,MAAM,CAAC;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AACF;AA2BA,UAAU,UAAU,OAAO,SAAU,MAAM,YAAY;AACrD,QAAM,OAAO,KAAK;AAClB,QAAM,YAAY,KAAK,QAAQ;AAC/B,QAAM,aAAa,KAAK,QAAQ;AAChC,MAAI,QAAQ,aAAa;AAEzB,MAAI,KAAK,MAAO,QAAO;AAEvB,MAAI,eAAe,CAAC,CAAC,WAAY,eAAc;AAAA,MAC1C,eAAc,eAAe,OAAO,WAAW;AAGpD,MAAI,SAAS,KAAK,IAAI,MAAM,wBAAwB;AAClD,SAAK,QAAQ,IAAI,WAAW,IAAI;AAAA,EAClC,OAAO;AACL,SAAK,QAAQ;AAAA,EACf;AAEA,OAAK,UAAU;AACf,OAAK,WAAW,KAAK,MAAM;AAE3B,aAAS;AACP,QAAI,KAAK,cAAc,GAAG;AACxB,WAAK,SAAS,IAAI,WAAW,SAAS;AACtC,WAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACnB;AAEA,aAAS,YAAY,QAAQ,MAAM,WAAW;AAE9C,QAAI,WAAW,eAAe,YAAY;AACxC,eAAS,YAAY,qBAAqB,MAAM,UAAU;AAE1D,UAAI,WAAW,MAAM;AACnB,iBAAS,YAAY,QAAQ,MAAM,WAAW;AAAA,MAChD,WAAW,WAAW,cAAc;AAElC,iBAAS;AAAA,MACX;AAAA,IACF;AAGA,WAAO,KAAK,WAAW,KAChB,WAAW,gBACX,KAAK,MAAM,OAAO,KAClB,KAAK,KAAK,OAAO,MAAM,GAC9B;AACE,kBAAY,aAAa,IAAI;AAC7B,eAAS,YAAY,QAAQ,MAAM,WAAW;AAAA,IAChD;AAEA,YAAQ,QAAQ;AAAA,MACd,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,aAAK,MAAM,MAAM;AACjB,aAAK,QAAQ;AACb,eAAO;AAAA,IACX;AAIA,qBAAiB,KAAK;AAEtB,QAAI,KAAK,UAAU;AACjB,UAAI,KAAK,cAAc,KAAK,WAAW,cAAc;AAEnD,YAAI,KAAK,QAAQ,OAAO,UAAU;AAEhC,cAAI,gBAAgB,QAAQ,WAAW,KAAK,QAAQ,KAAK,QAAQ;AAEjE,cAAI,OAAO,KAAK,WAAW;AAC3B,cAAI,UAAU,QAAQ,WAAW,KAAK,QAAQ,aAAa;AAG3D,eAAK,WAAW;AAChB,eAAK,YAAY,YAAY;AAC7B,cAAI,KAAM,MAAK,OAAO,IAAI,KAAK,OAAO,SAAS,eAAe,gBAAgB,IAAI,GAAG,CAAC;AAEtF,eAAK,OAAO,OAAO;AAAA,QAErB,OAAO;AACL,eAAK,OAAO,KAAK,OAAO,WAAW,KAAK,WAAW,KAAK,SAAS,KAAK,OAAO,SAAS,GAAG,KAAK,QAAQ,CAAC;AAAA,QACzG;AAAA,MACF;AAAA,IACF;AAGA,QAAI,WAAW,QAAQ,mBAAmB,EAAG;AAG7C,QAAI,WAAW,cAAc;AAC3B,eAAS,YAAY,WAAW,KAAK,IAAI;AACzC,WAAK,MAAM,MAAM;AACjB,WAAK,QAAQ;AACb,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,aAAa,EAAG;AAAA,EAC3B;AAEA,SAAO;AACT;AAWA,UAAU,UAAU,SAAS,SAAU,OAAO;AAC5C,OAAK,OAAO,KAAK,KAAK;AACxB;AAYA,UAAU,UAAU,QAAQ,SAAU,QAAQ;AAE5C,MAAI,WAAW,MAAM;AACnB,QAAI,KAAK,QAAQ,OAAO,UAAU;AAChC,WAAK,SAAS,KAAK,OAAO,KAAK,EAAE;AAAA,IACnC,OAAO;AACL,WAAK,SAAS,OAAO,cAAc,KAAK,MAAM;AAAA,IAChD;AAAA,EACF;AACA,OAAK,SAAS,CAAC;AACf,OAAK,MAAM;AACX,OAAK,MAAM,KAAK,KAAK;AACvB;AA0CA,SAAS,UAAU,OAAO,SAAS;AACjC,QAAM,WAAW,IAAI,UAAU,OAAO;AAEtC,WAAS,KAAK,KAAK;AAGnB,MAAI,SAAS,IAAK,OAAM,SAAS,OAAO,SAAS,SAAS,GAAG;AAE7D,SAAO,SAAS;AAClB;AAWA,SAAS,aAAa,OAAO,SAAS;AACpC,YAAU,WAAW,CAAC;AACtB,UAAQ,MAAM;AACd,SAAO,UAAU,OAAO,OAAO;AACjC;AAaA,IAAI,cAAc;AAClB,IAAI,YAAY;AAChB,IAAI,iBAAiB;AACrB,IAAI,WAAW;AACf,IAAI,YAAY;AAEhB,IAAI,cAAc;AAAA,EACjB,SAAS;AAAA,EACT,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR;AACD;AAEA,IAAM,EAAE,SAAS,SAAS,YAAY,KAAK,IAAI;AAE/C,IAAM,EAAE,SAAS,SAAS,YAAY,OAAO,IAAI;AAKjD,IAAI,YAAY;;;AC1rNT,IAAM,iCAAN,MAAqC;AAAA,EAE1C,YACW,SACA,MACT;AAFS;AACA;AAAA,EACR;AAAA,EAJM,OAAO;AAKlB;AA6BO,IAAM,oBAAyB,GAAG,mBAAmB,EAAE,WAAU,MAAe,MAGpF;AACD,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,QAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,QAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,QAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,QAAM,aAAa,QAAQ,oBAAoB,IAAI;AACnD,QAAM,kBAAkB,QAAQ,qDAAqD,YAAY,UAAU,OAAO,KAChH;AAGF,QAAM,eAAe,oBAAI,QAAiB;AAC1C,QAAM,oBAAoB,oBAAI,QAAiB;AAC/C,QAAM,cAAc,oBAAI,QAAkC;AAG1D,QAAM,cAA8B,CAAC,IAAI;AACzC,QAAM,oBAAoB,CAACE,UAAkB;AAC3C,gBAAY,KAAKA,KAAI;AACrB,WAAO;AAAA,EACT;AAEA,QAAM,eAAqBC,eAAoB,SAAiD,CAAC;AAEjG,QAAM,kBAAuB,GAAG,iBAAiB,EAAE,WAAUD,OAAe;AAC1E,QAAI,WAA2B,CAAC;AAChC,QAAI,WAA2B,CAAC;AAChC,QAAI,YAAiC;AACrC,QAAI,aAA2D;AAC/D,QAAI,kBAAkB,IAAIA,KAAI,GAAG;AAC/B,UAAI,GAAG,aAAaA,KAAI,GAAG;AACzB,cAAM,iBAAiB,YAAY,kBAAkBA,KAAI;AACzD,YAAI,gBAAgB;AAClB,gBAAM,iBAAiB,YAAY,oBAAoB,gBAAgB,GAAG,cAAc,IAAI;AAC5F,cAAI,eAAe,WAAW,GAAG;AAC/B,wBAAY,YAAY,yBAAyB,eAAe,CAAC,CAAC;AAAA,UACpE;AAAA,QACF;AAAA,MACF;AAAA,IACF,OAAO;AACL,kBAAY,YAAY,kBAAkBA,KAAI;AAAA,IAChD;AACA,QAAI,WAAW;AACb,mBAAa,OAAO,KAAK,WAAW,UAAU,WAAWA,KAAI,GAAQE,QAAO,MAAW,KAAK,CAAC;AAAA,IAC/F;AACA,QAAI,CAAC,WAAY,aAAY;AAE7B,QAAI,YAAY;AAEd,iBAAW,iBAAiB,mBAAmB,WAAW,IAAI,EAAE,OAAO,CAAC,MAAM,EAAE,EAAE,QAAQ,GAAG,UAAU,MAAM;AAC7G,iBAAW,iBAAiB,mBAAmB,WAAW,GAAG,EAAE,OAAO,CAAC,MAAM,EAAE,EAAE,QAAQ,GAAG,UAAU,MAAM;AAAA,IAC9G;AAEA,WAAO,EAAE,MAAAF,OAAM,WAAW,YAAY,UAAU,SAAS;AAAA,EAC3D,CAAC;AAED,QAAMG,WAAe,GAAG,SAAS,EAAE,WAAUH,OAAe,UAA+B;AACzF,UAAM,YAAkB,QAAQ,cAAc,WAAW,WAAW,OAAO,gBAAgBA,KAAI,CAAC;AAChG,gBAAY,IAAIA,OAAM,SAAS;AAC/B,WAAO;AAAA,EACT,CAAC;AAED,SAAO,YAAY,SAAS,GAAG;AAC7B,UAAMA,QAAO,YAAY,IAAI;AAG7B,UAAM,WAAW,OAAO,KAAK,WAAW,SAASA,KAAI,GAAQE,QAAO,MAAW,KAAK,CAAC;AACrF,QAAI,UAAU;AACZ,UAAI,CAAC,aAAa,IAAIF,KAAI,GAAG;AAE3B,0BAAkBA,KAAI;AACtB,0BAAkB,SAAS,OAAO;AAClC,iBAAS,KAAK,QAAQ,iBAAiB;AACvC,iBAAS,KAAK,QAAQ,CAAC,MAAM,kBAAkB,IAAI,CAAC,CAAC;AACrD,qBAAa,IAAIA,KAAI;AAAA,MACvB,OAAO;AAEL,cAAM,aAAa,CAAC,SAAS,SAAS,GAAG,SAAS,IAAI,EAAE,IAAI,CAAC,MAAM,YAAY,IAAI,CAAC,CAAC,EAAE;AAAA,UAC3E;AAAA,QACZ,EAAE;AAAA,UACA,CAAC,MAAY,QAAQ,cAAc,CAAC;AAAA,QACtC;AACA,YAAI,WAAW,WAAW,SAAS,KAAK,SAAS,GAAG;AAElD,cAAI,WAA0B;AAC9B,qBAAW,aAAa,YAAY;AAClC,gBAAI,aAAa,KAAM,CAAM,QAAQ,cAAc,WAAW,UAAU,EAAE,cAAc,OAAO,CAAC;AAChG,uBAAW;AAAA,UACb;AACA,cAAI,aAAa,MAAM;AAErB,kBAAM,YAAY,OAAOG,SAAQH,KAAI;AACrC,YAAM,QAAQ,cAAc,WAAW,UAAU,EAAE,cAAc,OAAO,CAAC;AAAA,UAC3E;AAAA,QACF,OAAO;AAEL,qBAAW,QAAQ,CAAC,MAAY,WAAW,cAAc,CAAC,CAAC;AAE3D,gBAAM,WAAW,OAAO,gBAAgBA,KAAI;AAC5C,cAAI,SAAS,WAAY,QAAOG,SAAQH,OAAM,QAAQ;AAAA,QACxD;AAAA,MACF;AACA;AAAA,IACF;AAGA,QAAI,GAAG,iBAAiBA,KAAI,GAAG;AAE7B,UAAI,gBAAgB,CAAC,KAAK;AAC1B,UAAI,KAAK,uBAAuB;AAC9B,cAAM,cAAc,GAAG,2BAA2BA,MAAK,UAAU,KAC/D,GAAG,aAAaA,MAAK,WAAW,UAAU,KAC1C,GAAG,OAAOA,MAAK,WAAW,UAAU,MAAM;AAC5C,YAAI,YAAa,iBAAgB;AAAA,MACnC;AAEA,UAAI,eAAe;AACjB,YAAI,CAAC,aAAa,IAAIA,KAAI,GAAG;AAE3B,4BAAkBA,KAAI;AACtB,UAAAA,MAAK,UAAU,QAAQ,iBAAiB;AACxC,uBAAa,IAAIA,KAAI;AAAA,QACvB,OAAO;AACL,gBAAM,aAAaA,MAAK,UAAU,IAAI,CAAC,MAAM,YAAY,IAAI,CAAC,CAAC,EAAE,OAAiB,QAAQ,EAAE;AAAA,YAAO,CAAC,MAC5F,QAAQ,cAAc,CAAC;AAAA,UAC/B;AAEA,cAAI,WAAW,WAAWA,MAAK,UAAU,QAAQ;AAE/C,kBAAM,YAAY,OAAOG,SAAQH,KAAI;AACrC,uBAAW;AAAA,cAAQ,CAAC,GAAG,kBACf,QAAQ,cAAc,WAAW,GAAG,EAAE,cAAc,QAAQ,cAAc,CAAC;AAAA,YACnF;AAAA,UACF,OAAO;AAEL,uBAAW,QAAQ,CAAC,MAAY,WAAW,cAAc,CAAC,CAAC;AAC3D,kBAAM,WAAW,OAAO,gBAAgBA,KAAI;AAC5C,gBAAI,SAAS,WAAY,QAAOG,SAAQH,OAAM,QAAQ;AAAA,UACxD;AAAA,QACF;AACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI,KAAK,uBAAuB,GAAG,yBAAyBA,KAAI,GAAG;AACjE,UAAI,CAAC,aAAa,IAAIA,KAAI,GAAG;AAC3B,0BAAkBA,KAAI;AACtB,QAAAA,MAAK,SAAS,QAAQ,iBAAiB;AACvC,qBAAa,IAAIA,KAAI;AAAA,MACvB,OAAO;AACL,cAAM,aAAaA,MAAK,SAAS,IAAI,CAAC,MAAM,YAAY,IAAI,CAAC,CAAC,EAAE,OAAiB,QAAQ,EAAE;AAAA,UAAO,CAAC,MAC3F,QAAQ,cAAc,CAAC;AAAA,QAC/B;AACA,YAAI,WAAW,SAAS,GAAG;AACzB,gBAAM,YAAY,OAAOG,SAAQH,KAAI;AACrC,qBAAW;AAAA,YAAQ,CAAC,GAAG,UACf,QAAQ,cAAc,WAAW,GAAG,EAAE,cAAc,gBAAgB,MAAM,CAAC;AAAA,UACnF;AAAA,QACF;AAAA,MACF;AACA;AAAA,IACF;AAGA,QAAI,GAAG,aAAaA,KAAI,GAAG;AACzB,YAAM,WAAW,OAAO,gBAAgBA,KAAI;AAC5C,UAAI,SAAS,YAAY;AACvB,eAAOG,SAAQH,OAAM,QAAQ;AAC7B;AAAA,MACF;AAAA,IACF;AAGA,WAAO,OAAY,KAAK,IAAI,+BAA+B,0CAA0CA,KAAI,CAAC;AAAA,EAC5G;AAEA,SAAaI,aAAY,YAAY;AACvC,CAAC;AAEM,IAAM,mBAAwB,GAAG,kBAAkB,EAAE,WAAU,YAAwB;AAC5F,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,QAAM,KAAK,OAAY,QAAsB,aAAa;AAE1D,SAAa,UAAU,YAAY;AAAA,IACjC,WAAW,CAAC,SAAS,KAAK,UAAU,IAAI;AAAA,IACxC,WAAW,CAAC,cAAc;AACxB,YAAM,aAAa,QAAQ,oBAAoB,UAAU,IAAI;AAC7D,UAAI,OAAO,WAAW,KAAK,UAAU,UAAU,KAAK,KAAK,UAAU,KAAK,GAAG,EAAE,KAAK;AAClF,cAAQ,iBACL,UAAU,SAAS,IAAI,CAAC,MAAM,YAAY,aAAa,GAAG,QAAW,GAAG,gBAAgB,YAAY,CAAC,EAAE;AAAA,QACtG;AAAA,MACF;AACF,cAAQ,iBACN,UAAU,SAAS,IAAI,CAAC,MAAM,YAAY,aAAa,GAAG,QAAW,GAAG,gBAAgB,YAAY,CAAC,EAAE;AAAA,QACrG;AAAA,MACF;AACF,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACH,CAAC;AAEM,IAAM,yBAA8B,GAAG,wBAAwB,EAAE,WAAU,YAAwB;AACxG,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,QAAM,KAAK,OAAY,QAAsB,aAAa;AAE1D,QAAM,cAAc,CAAC,UACnB,MAAM,QAAQ,OAAO,GAAG,EAAE;AAAA,IACxB;AAAA,IACA;AAAA,EACF,EAAE,UAAU,GAAG,EAAE,EAAE,QAAQ,MAAM,QAAQ,EAAE,QAAQ,OAAO,MAAM,EAAE,QAAQ,OAAO,MAAM,EAAE,KAAK;AAEhG,QAAM,gBAAgB,oBAAI,IAAqB;AAC/C,QAAM,WAAW,CAAC,SAAkB;AAClC,QAAI,cAAc,IAAI,IAAI,EAAG,QAAO,cAAc,IAAI,IAAI;AAC1D,UAAM,OAAO,YAAY,aAAa,MAAM,QAAW,GAAG,gBAAgB,YAAY;AACtF,kBAAc,IAAI,MAAM,IAAI;AAC5B,WAAO;AAAA,EACT;AAEA,MAAI,SAAwB,CAAC;AAG7B,aAAW,CAAC,gBAAgB,SAAS,KAAW,QAAc,MAAM,UAAU,CAAC,GAAG;AAChF,QAAI,eAA8B,CAAC;AACnC,eAAW,QAAQ,CAAC,YAAY,UAAU,GAAY;AACpD,YAAM,oBAAmC,CAAC;AAC1C,eAAS,IAAI,GAAG,IAAI,UAAU,IAAI,EAAE,QAAQ,KAAK;AAC/C,0BAAkB,KAAK,GAAG,cAAc,IAAI,IAAI,IAAI,CAAC,KAAK,YAAY,SAAS,UAAU,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI;AAAA,MACzG;AACA,UAAI,kBAAkB,SAAS,GAAG;AAChC,uBAAe;AAAA,UACb,GAAG;AAAA,UACH,YAAY,cAAc,IAAI,IAAI,KAAK,SAAS,aAAa,aAAa,UAAU;AAAA,UACpF,GAAG,kBAAkB,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;AAAA,UACxC;AAAA,UACA,SAAS,cAAc,IAAI,IAAI;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AACA,mBAAe;AAAA,MACb,YAAY,cAAc;AAAA,MAC1B,GAAG,aAAa,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;AAAA,MACnC;AAAA,MACA,SAAS,cAAc;AAAA,MACvB,SAAS,cAAc;AAAA,IACzB;AACA,UAAM,aAAa,QAAQ,oBAAoB,UAAU,IAAI;AAC7D,UAAM,eAAe,UAAU,KAAK,SAAS,YAAY,KAAK;AAC9D,UAAM,EAAE,WAAW,KAAK,IAAI,GAAG,8BAA8B,YAAY,YAAY;AACrF,UAAM,WAAW,WAAW,KAAK,UAAU,UAAU,KAAK,KAAK,UAAU,KAAK,GAAG,EAAE,KAAK;AACxF,aAAS;AAAA,MACP,GAAG;AAAA,MACH,YAAY,cAAc,QAAQ,YAAY,QAAQ,CAAC,eAAe,OAAO,CAAC,QAAQ,SAAS;AAAA,MAC/F,GAAG,aAAa,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;AAAA,MACnC;AAAA,MACA,SAAS,cAAc;AAAA,IACzB;AAAA,EACF;AAGA,aAAW,YAAkBC,QAAa,MAAM,UAAU,CAAC,GAAG;AAC5D,UAAM,aAAa,WAAW,MAAM,IAAI,SAAS,MAAM;AACvD,UAAM,aAAa,WAAW,MAAM,IAAI,SAAS,MAAM;AACvD,QAAI,YAAqB;AACzB,eAAW,QAAQ,CAAC,YAAY,UAAU,GAAY;AACpD,eAAS,IAAI,GAAG,IAAI,WAAW,IAAI,EAAE,QAAQ,KAAK;AAChD,cAAM,YAAY,WAAW,IAAI,EAAE,QAAQ,WAAW,IAAI,EAAE,CAAC,CAAC;AAC9D,YAAI,YAAY,IAAI;AAClB,iBAAO,KAAK,GAAG,SAAS,MAAM,IAAI,IAAI,IAAI,CAAC,SAAS,SAAS,MAAM,IAAI,IAAI,IAAI,SAAS,EAAE;AAC1F,sBAAY;AAAA,QACd;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,WAAW;AACd,aAAO,KAAK,GAAG,SAAS,MAAM,SAAS,SAAS,MAAM,EAAE;AAAA,IAC1D;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA,GAAG,OAAO,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;AAAA,EAC/B,EAAE,KAAK,IAAI;AACb,CAAC;AAWM,IAAM,sBAA2B,GAAG,qBAAqB,EAAE,WAAU,YAAwB;AAClG,QAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,QAAM,eAAqBJ,eAAoB,SAAwC,CAAC;AAExF,QAAM,YAAY,oBAAI,IAAqC;AAC3D,QAAM,eAAe,oBAAI,QAAmB;AAE5C,QAAM,YAAkBI,QAAa,UAAU,YAAY,EAAE,WAAW,WAAW,CAAC,CAAC;AACrF,QAAM,mBAA8C,CAAC;AAErD,aAAW,YAAY,WAAW;AAChC,UAAMC,UAAS,YAAY,oBAAoB,SAAS,IAAI;AAC5D,QAAI,CAACA,SAAQ;AACX,uBAAiB,KAAK,QAAQ;AAAA,IAChC,WAAWA,WAAU,CAAC,aAAa,IAAIA,OAAM,GAAG;AAC9C,uBAAiB,KAAK,QAAQ;AAC9B,mBAAa,IAAIA,OAAM;AAAA,IACzB;AAAA,EACF;AAGA,aAAW,YAAY,kBAAkB;AACvC,UAAM,YAAkB,QAAQ,cAAc;AAAA,MAC5C,MAAM,SAAS;AAAA,MACf,UAAU,SAAS;AAAA,MACnB,UAAU,SAAS;AAAA,IACrB,CAAC;AACD,eAAW,gBAAgB,SAAS,UAAU;AAE5C,UAAI,SAAS,SAAS,QAAQ,YAAY,IAAI,GAAI;AAElD,YAAM,oBAAoB,UAAU,IAAI,YAAY,KAAK,CAAC;AAC1D,gBAAU,IAAI,cAAc,CAAC,GAAG,mBAAmB,SAAS,CAAC;AAAA,IAC/D;AAAA,EACF;AAGA,aAAW,CAAC,WAAW,QAAQ,KAAW,QAAc,MAAM,YAAY,CAAC,GAAG;AAC5E,eAAW,gBAAgB,SAAS,UAAU;AAC5C,iBAAW,CAAC,cAAc,mBAAmB,KAAK,UAAU,QAAQ,GAAG;AACrE,YAAI,iBAAiB,gBAAgB,YAAY,mBAAmB,cAAc,YAAY,GAAG;AAC/F,qBAAW,qBAAqB,qBAAqB;AACnD,YAAM,QAAQ,cAAc,WAAW,mBAAmB,CAAC,CAAC;AAAA,UAC9D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAaF,aAAY,YAAY;AACvC,CAAC;AAEM,IAAM,0BAA+B,GAAG,yBAAyB;AAAA,EACtE,WAAU,mBAAsC;AAC9C,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,WAAa,UAAU,mBAAmB;AAAA,MACxC,WAAW,MAAM;AAAA,MACjB,WAAW,CAAC,cAAc;AACxB,cAAM,aAAa,QAAQ,oBAAoB,UAAU,IAAI;AAC7D,eAAO,WAAW,KAAK,UAAU,UAAU,KAAK,KAAK,UAAU,KAAK,GAAG,EAAE,KAAK;AAAA,MAChF;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAcO,IAAM,kCAAuC,GAAG,iCAAiC;AAAA,EACtF,WAAU,cAAiC,cAAuB;AAChE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAE1D,UAAM,SAAgC,CAAC;AAEvC,UAAM,qBAAqB,IAAI,IAAI,iBAAiB,mBAAmB,YAAY,CAAC;AACpF,UAAM,uBAAuB,oBAAI,IAAa;AAG9C,UAAM,gBAAsBG,QAAO,cAAoBC,QAAO;AAC9D,UAAM,cAAoB,aAAmB,QAAc,UAAU,eAAe,EAAE,WAAW,WAAW,CAAC,CAAC,CAAC;AAC/G,UAAM,WAAiB,aAAmBH,QAAa,aAAa,eAAe,EAAE,OAAO,YAAY,CAAC,CAAC,CAAC;AAC3G,eAAW,YAAY,UAAU;AAC/B,UAAI,CAAC,GAAG,aAAa,SAAS,IAAI,EAAG;AACrC,YAAM,sBAAsB,SAAS,SAAS,OAAO,CAAC,MAAM,SAAS,SAAS,QAAQ,CAAC,MAAM,EAAE;AAC/F,YAAM,cAAc,oBAAoB,KAAK,CAAC,MAAM,mBAAmB,IAAI,CAAC,CAAC;AAC7E,UAAI,aAAa;AACf,4BAAoB,QAAQ,CAAC,MAAM,mBAAmB,OAAO,CAAC,CAAC;AAAA,MACjE;AACA,eAAS,SAAS,QAAQ,CAAC,MAAM,qBAAqB,OAAO,CAAC,CAAC;AAC/D,eAAS,SAAS,QAAQ,CAAC,MAAM,qBAAqB,IAAI,CAAC,CAAC;AAC5D,aAAO,KAAK;AAAA,QACV,QAAQ;AAAA,QACR,UAAU;AAAA,QACV,iBAAiB,SAAS;AAAA,MAC5B,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,MACL,iBAAiB;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AACF;AAGO,IAAM,qBAAqB,CAChC,OACA,WACA,SAA6B,CAAC,MACN;AACxB,QAAM,QAAQ,OAAO,SAAS,CAAC;AAC/B,QAAM,YAAY,OAAO,aAAa;AAEtC,SAAO,IAAU,OAAO,CAAC,OAAO;AAAA,IAC9B,CAAC,OAAO,QAAQ,GAAG,MAAM;AACvB,UAAI,QAAQ,CAAC,GAAG,KAAK;AACrB,YAAM,aAAa,oBAAI,IAAqB;AAE5C,YAAM,aAAa,MAAM;AACvB,eAAO,MAAM,SAAS,GAAG;AACvB,gBAAM,UAAU,MAAM,MAAM;AAE5B,cAAI,WAAW,IAAI,OAAO,EAAG;AAC7B,qBAAW,IAAI,OAAO;AAEtB,gBAAM,YAAkB,kBAAkB,OAAO,SAAS,SAAS;AACnE,gBAAM,oBAA4C,CAAC;AACnD,qBAAW,YAAY,WAAW;AAChC,kBAAM,eAAqB,QAAQ,OAAO,QAAQ;AAClD,gBAAWI,QAAO,YAAY,KAAK,UAAU,aAAa,KAAK,GAAG;AAChE,gCAAkB,KAAK,QAAQ;AAAA,YACjC;AAAA,UACF;AAEA,cAAI,kBAAkB,SAAS,GAAG;AAChC,oBAAQ,CAAC,GAAG,OAAO,GAAG,iBAAiB;AAAA,UACzC,OAAO;AACL,kBAAM,WAAiB,QAAQ,OAAO,OAAO;AAC7C,gBAAWA,QAAO,QAAQ,KAAK,UAAU,SAAS,KAAK,GAAG;AACxD,qBAAO,EAAE,MAAM,OAAO,OAAO,EAAE,SAAS,SAAS,KAAK,EAAE;AAAA,YAC1D;AAAA,UACF;AAAA,QACF;AAEA,eAAO,EAAE,MAAM,MAAM,OAAO,OAAU;AAAA,MACxC;AAEA,aAAO,EAAE,MAAM,WAAW;AAAA,IAC5B;AAAA,EACF,EAAE;AACJ;AAWO,IAAM,+BAAoC,GAAG,8BAA8B;AAAA,EAChF,WAAU,YAAwB;AAChC,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAC9E,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,aAAmB,UAAU,YAAY,EAAE,WAAW,WAAW,CAAC;AACxE,UAAM,YAAkB,aAAmBJ,QAAO,UAAU,CAAC;AAC7D,UAAM,kBAAwB,aAAmB,QAAQ,UAAU,CAAC;AACpE,UAAM,SAAyC,CAAC;AAEhD,UAAM,YAAY,CAAC,WAAyB,SAAkC;AAC5E,YAAM,cAAc,KAAW,aAAa,SAAS,GAAS,KAAK,iBAAiB,sBAAsB,CAAC;AAC3G,iBAAW,aAAa,aAAa;AACnC,cAAM,UAA0B,CAAC;AACjC,mBACQ,aAAmBA;AAAA,UACvB;AAAA,YACE;AAAA,YACA,CAAC,OACE,SAAS,aAAa,EAAE,WAAW,EAAE,UAAU;AAAA,cAAK,CAACK,OACpDA,OAAM,aAAa,YAAY,mBAAmBA,IAAG,SAAS;AAAA,YAChE;AAAA,YACF,EAAE,OAAO,gBAAgB;AAAA,UAC3B;AAAA,QACF,GACA;AACA,kBAAQ,KAAK,UAAU,IAAI;AAAA,QAC7B;AACA,eAAO,KAAK;AAAA,UACV;AAAA,UACA,MAAM;AAAA,UACN,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAAA,IACF;AAEA,cAAU,IAAI,IAAI,UAAU,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,GAAG,UAAU;AACnE,cAAU,IAAI,IAAI,UAAU,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,GAAG,UAAU;AACnE,WAAO;AAAA,EACT;AACF;AAEO,IAAM,uCAA4C,GAAG,sCAAsC;AAAA,EAChG,WAAU,MAAsC;AAC9C,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,QAAI,KAAK,WAAW,EAAG,QAAO;AAE9B,UAAM,qBAAoC,CAAC;AAE3C,UAAM,aAAa,CAAC,aAAiD;AACnE,YAAM,aAAa,YAAY;AAAA,QAC7B,SAAS;AAAA,QACT;AAAA,QACA,GAAG,gBAAgB;AAAA,MACrB;AAEA,YAAM,YAAY,SAAS,MAAM,IAAI,CAAC,MAAM;AAC1C,cAAM,aAAa,QAAQ,oBAAoB,CAAC;AAChD,cAAM,eAAe,GAAG,kBAAkB,GAAG,UAAU;AACvD,cAAM,EAAE,WAAW,KAAK,IAAI,GAAG,8BAA8B,YAAY,YAAY;AACrF,cAAM,WAAW,WAAW,KAAK,UAAU,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,OAAO,GAAG,EAAE,OAAO,GAAG,EAAE;AAChG,eAAO,MAAM,OAAO,CAAC,QAAQ,SAAS,SAAS,QAAQ;AAAA,MACzD,CAAC;AAED,yBAAmB,KAAK,KAAK,UAAU,IAAI,SAAS,IAAI,OAAO,UAAU,KAAK,IAAI,CAAC,EAAE;AAAA,IACvF;AAEA,UAAM,gBAAgB,KAAK,OAAO,CAAC,MAAM,EAAE,SAAS,UAAU;AAC9D,UAAM,gBAAgB,KAAK,OAAO,CAAC,MAAM,EAAE,SAAS,UAAU;AAC9D,QAAI,cAAc,SAAS,GAAG;AAC5B,iBAAW,QAAQ,eAAe;AAChC,mBAAW,IAAI;AAAA,MACjB;AACA,UAAI,mBAAmB,SAAS,KAAK,cAAc,SAAS,EAAG,oBAAmB,KAAK,EAAE;AAAA,IAC3F;AACA,QAAI,cAAc,SAAS,GAAG;AAC5B,iBAAW,QAAQ,eAAe;AAChC,mBAAW,IAAI;AAAA,MACjB;AAAA,IACF;AACA,WAAO,UAAU,mBAAmB,IAAI,CAAC,MAAM,QAAQ,CAAC,EAAE,KAAK,IAAI,IACjE;AAAA,EACJ;AACF;;;AChlBA,SAAS,mBACP,MACuF;AACvF,SAAY,IAAI,aAAY;AAC1B,UAAM,QAAQ,KAAK,UAAU,EAAE,KAAK,CAAC;AACrC,UAAM,OAAO,IAAI,YAAY,EAAE,OAAO,KAAK;AAC3C,UAAM,aAAkB,UAAQ,MAAM,EAAE,OAAO,EAAE,CAAC;AAClD,UAAM,aAAa,UAAmB,gBAAgB,UAAU;AAChE,WAAO,uCAAuC;AAAA,EAChD,CAAC;AACH;AAEA,SAAS,gBACP,YACA,UACA;AACA,SAAY,IAAI,aAAY;AAC1B,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAG5D,UAAM,QAAQ,QAAQ,YAAY,QAAQ;AAC1C,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,KAAK;AAAA,MAC3C,OAAO,CAAC,MAAM,GAAG,sBAAsB,CAAC,KAAK,GAAG,sBAAsB,CAAC,CAAC;AAAA,MACxE,OAAO,CAAC,MAAM,QAAQ,cAAc,KAAK,EAAE,EAAE,IAAI,CAAC;AAAA,MAClD;AAAA,IACR;AACA,QAAWC,QAAO,SAAS,EAAG,QAAO;AACrC,UAAM,OAAO,UAAU;AACvB,UAAM,YAAY,KAAK,cACnB,KAAK,cACL;AAEJ,UAAM,YAAY,YAAY,kBAAkB,SAAS;AACzD,UAAM,aAAa,OAAY,OAAO,WAAW,UAAU,WAAW,SAAS,CAAC;AAEhF,QAAWA,QAAO,UAAU,EAAG,QAAO;AAEtC,WAAO,EAAE,MAAM,UAAU;AAAA,EAC3B,CAAC;AACH;AAEA,SAAS,gBACP,WACA;AACA,SAAY,IAAI,aAAY;AAC1B,UAAM,aAAa,OAAkB,kBAAkB,WAAW;AAAA,MAChE,qBAAqB;AAAA,MACrB,uBAAuB;AAAA,IACzB,CAAC;AACD,UAAM,qBAAqB,OAAkB,uBAAuB,UAAU;AAE9E,UAAM,eAAe,OAAkB,oBAAoB,UAAU;AACrE,UAAM,sBAAsB,OAAkB,wBAAwB,YAAY;AAClF,UAAM,wBAAwB,OAAkB,6BAA6B,UAAU;AACvF,UAAM,0CAA0C,OAAkB;AAAA,MAChE;AAAA,IACF;AACA,WAAO,EAAE,oBAAoB,qBAAqB,wCAAwC;AAAA,EAC5F,CAAC;AACH;AAEO,SAAS,uBACd,YACA,MACA,WACA;AACA,SAAY,IAAI,aAAY;AAC1B,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,WAAW,GAAG,8BAA8B,YAAY,MAAM,SAAS;AAC7E,UAAM,aAAa,OAAO,gBAAgB,YAAY,QAAQ;AAC9D,QAAI,CAAC,WAAY,QAAO,OAAY,KAAK,IAAe,+BAA+B,eAAe,CAAC;AACvG,UAAM,EAAE,WAAW,KAAK,IAAI;AAC5B,UAAM,EAAE,mBAAmB,IAAI,OAAO,gBAAgB,SAAS;AAC/D,WAAO,EAAE,OAAO,KAAK,KAAK,KAAK,KAAK,KAAK,aAAa,mBAAmB;AAAA,EAC3E,CAAC;AACH;AAEO,SAAS,UACd,YACA,UACAC,YACA;AACA,SAAO;AAAA,IACA,IAAI,aAAY;AACnB,YAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,YAAM,UAAU,OAAY,QAAqC,4BAA4B;AAE7F,YAAM,aAAa,OAAO,gBAAgB,YAAY,QAAQ;AAC9D,UAAI,CAAC,WAAY,QAAOA;AACxB,YAAM,EAAE,WAAW,KAAK,IAAI;AAE5B,YAAM,wBAAwB,OAAO;AAAA,QACnC,gBAAgB,SAAS;AAAA,QACpBC;AAAA,UAAQ,CAAC,EAAE,oBAAoB,qBAAqB,wCAAwC,MAC1F,IAAI,aAAY;AACnB,kBAAM,YAAyC,CAAC;AAChD,gBAAI,CAAC,QAAQ,YAAY;AACvB,oBAAM,aAAa,OAAO,mBAAmB,kBAAkB;AAC/D,oBAAM,oBAAoB,OAAO,mBAAmB,mBAAmB;AACvE,wBAAU,KAAK,EAAE,MAAM,SAAS,MAAM,KAAK,CAAC;AAC5C,wBAAU,KAAK,EAAE,MAAM,QAAQ,MAAM,UAAU,CAAC;AAChD,wBAAU,KAAK,EAAE,MAAM,YAAY,MAAM,aAAa,yBAAyB,CAAC;AAChF,wBAAU,KAAK,EAAE,MAAM,QAAQ,MAAM,IAAI,CAAC;AAC1C,wBAAU,KAAK,EAAE,MAAM,QAAQ,MAAM,MAAM,CAAC;AAC5C,wBAAU,KAAK,EAAE,MAAM,QAAQ,MAAM,UAAU,CAAC;AAChD,wBAAU,KAAK,EAAE,MAAM,YAAY,MAAM,oBAAoB,sBAAsB,CAAC;AACpF,wBAAU,KAAK,EAAE,MAAM,QAAQ,MAAM,IAAI,CAAC;AAC1C,wBAAU,KAAK,EAAE,MAAM,SAAS,MAAM,KAAK,CAAC;AAAA,YAC9C;AACA,gBAAI,wCAAwC,WAAW,EAAG,QAAO;AACjE,mBAAO;AAAA,cACL;AAAA,gBACE,MAAM;AAAA,gBACN,MACE,UACA,0CACA;AAAA,cAEJ;AAAA,cACA,GAAG;AAAA,YACL;AAAA,UACF,CAAC;AAAA,QACH;AAAA,QACKC,QAAO,MAAW,QAAQ,CAAC,CAAgC,CAAC;AAAA,MACnE;AAGA,UAAI,sBAAsB,WAAW,EAAG,QAAOF;AAG/C,UAAI,CAACA,YAAW;AACd,cAAM,QAAQ,GAAG,kBAAkB,MAAM,UAAU;AACnD,cAAM,MAAM,KAAK;AACjB,eAAO;AAAA,UACL,MAAM,GAAG,kBAAkB;AAAA,UAC3B,eAAe;AAAA,UACf,UAAU,EAAE,OAAO,QAAQ,MAAM,MAAM;AAAA,UACvC,eAAe;AAAA,QACjB;AAAA,MACF;AAGA,UAAIA,WAAU,eAAe;AAC3B,eAAO;AAAA,UACL,GAAGA;AAAA,UACH,eAAeA,WAAU,cAAc,OAAO,CAAC,EAAE,MAAM,SAAS,MAAM,KAAK,CAAC,CAAC,EAAE,OAAO,qBAAqB;AAAA,QAC7G;AAAA,MACF;AAEA,aAAO;AAAA,QACL,GAAGA;AAAA,QACH,eAAe;AAAA,MACjB;AAAA,IACF,CAAC;AAAA,IACIE,QAAO,MAAW,QAAQF,UAAS,CAAC;AAAA,EAC3C;AACF;;;AClKO,SAAS,UACd,YACA,UACAG,YAUA;AACA,SAAY,IAAI,aAAY;AAC1B,UAAM,UAAU,OAAO,aAAaA,UAAS;AAC7C,UAAM,qBAAqB,OAAO,eAAe,YAAY,UAAU,OAAO;AAC9E,UAAM,gBAAgB,OAAO,UAAU,YAAY,UAAU,kBAAkB;AAC/E,WAAO;AAAA,EACT,CAAC;AACH;;;ACvBO,IAAM,iBAAqB,eAAe;AAAA,EAC/C,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,sBAAsB,EAAE,WAAU,YAAY,WAAW;AACtE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C;AAAA,QAAO,CAACC,UACZ,GAAG,sBAAsBA,KAAI,KAAK,GAAG,gBAAgBA,KAAI,KACzD,GAAG,qBAAqBA,KAAI;AAAA,MAC9B;AAAA,MACM,OAAO,CAACA,UAAS,CAAC,CAACA,MAAK,IAAI;AAAA,MAC5B,OAAO,CAACA,UAAS,CAAC,EAAE,GAAG,yBAAyBA,KAAI,IAAI,GAAG,cAAc,MAAM;AAAA,MAC/E;AAAA,IACR;AAEA,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,gBAAM,6BAA6B,QAAQ;AAAA,YACzC;AAAA,YACA;AAAA,YACA;AAAA,UACF,KAAK;AAEL,gBAAM,iBAAiB,QAAQ;AAAA,YAC7B;AAAA,YACA;AAAA,YACA,CAAC,eACC,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ;AAAA,gBACT,GAAG,QAAQ,iBAAiB,0BAA0B;AAAA,gBACtD;AAAA,cACF;AAAA,cACA;AAAA,cACA;AAAA,gBACE,GAAG,QAAQ;AAAA,kBACT;AAAA,kBACA;AAAA,kBACA,CAAC;AAAA,kBACD;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACJ;AAEA,wBAAc,YAAY,YAAY,MAAM,cAAc;AAAA,QAC5D,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,QAC9C,eAA8B,gBAAgB,WAAW;AAAA,MAChE;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AChEM,IAAM,2BAA+B,eAAe;AAAA,EACzD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,gCAAgC,EAAE,WAAU,YAAY,WAAW;AAChF,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C;AAAA,QACJ,CAACC,UACC,GAAG,sBAAsBA,KAAI,KAAK,GAAG,gBAAgBA,KAAI,KACzD,GAAG,qBAAqBA,KAAI;AAAA,MAChC;AAAA,MACM,OAAO,CAACA,UAAS,CAAC,CAACA,MAAK,IAAI;AAAA,MAC5B,OAAO,CAACA,UAAS,CAAC,EAAE,GAAG,yBAAyBA,KAAI,IAAI,GAAG,cAAc,MAAM;AAAA,MAC/E;AAAA,IACR;AAEA,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,gBAAM,6BAA6B,QAAQ;AAAA,YACzC;AAAA,YACA;AAAA,YACA;AAAA,UACF,KAAK;AAEL,gBAAM,2BAA2B,QAAQ;AAAA,YACvC;AAAA,YACA;AAAA,YACA;AAAA,UACF,KAAK;AAEL,cAAI,aAAa;AACjB,gBAAM,SAAqC,CAAC;AAE5C,mBAAS,iBAAiB;AACxB;AACA,kBAAM,YAAY,UAAU;AAC5B,mBAAO,KAAK,QAAQ,iCAAiC,0BAA0B,WAAW;AAAA,cACxF,GAAG,QAAQ;AAAA,gBACT;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,GAAG,QAAQ,sBAAsB,GAAG,WAAW,cAAc;AAAA,cAC/D;AAAA,YACF,CAAC,CAAC;AACF,mBAAO,GAAG,QAAQ;AAAA,cAChB,GAAG,QAAQ,iBAAiB,SAAS;AAAA,cACrC;AAAA,cACA,CAAC,GAAG,QAAQ,8BAA8B;AAAA,gBACxC,GAAG,QAAQ,kCAAkC,OAAO;AAAA,cACtD,CAAC,CAAC;AAAA,YACJ;AAAA,UACF;AAEA,gBAAM,iBAAiB,QAAQ;AAAA,YAC7B;AAAA,YACA;AAAA,YACA,CAAC,eACC,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ;AAAA,gBACT,GAAG,QAAQ,iBAAiB,0BAA0B;AAAA,gBACtD;AAAA,cACF;AAAA,cACA;AAAA,cACA;AAAA,gBACE,GAAG,QAAQ,8BAA8B;AAAA,kBACvC,GAAG,QAAQ;AAAA,oBACT,GAAG,QAAQ,iBAAiB,KAAK;AAAA,oBACjC,GAAG,QAAQ;AAAA,sBACT;AAAA,sBACA;AAAA,sBACA,CAAC;AAAA,sBACD;AAAA,sBACA;AAAA,sBACA;AAAA,oBACF;AAAA,kBACF;AAAA,kBACA,GAAG,QAAQ;AAAA,oBACT,GAAG,QAAQ,iBAAiB,OAAO;AAAA,oBACnC,GAAG,QAAQ;AAAA,sBACT;AAAA,sBACA;AAAA,sBACA,CAAC,GAAG,QAAQ,2BAA2B,QAAW,QAAW,OAAO,CAAC;AAAA,sBACrE;AAAA,sBACA;AAAA,sBACA,eAAe;AAAA,oBACjB;AAAA,kBACF;AAAA,gBACF,CAAC;AAAA,cACH;AAAA,YACF;AAAA,UACJ;AAEA,cAAI,aAAsB;AAC1B,iBAAO,WAAW,UAAU,CAAC,GAAG,aAAa,WAAW,MAAM,GAAG;AAC/D,yBAAa,WAAW;AAAA,UAC1B;AAEA,qBAAW,SAAS,QAAQ;AAC1B,0BAAc,iBAAiB,YAAY,YAAY,OAAO,IAAI;AAAA,UACpE;AAEA,wBAAc,YAAY,YAAY,MAAM,cAAc;AAAA,QAC5D,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,QAC9C,eAA8B,gBAAgB,WAAW;AAAA,MAChE;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACzHM,IAAM,kBAAsB,eAAe;AAAA,EAChD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,uBAAuB,EAAE,WAAU,YAAY,WAAW;AACvE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C;AAAA,QAAO,CAACC,UACZ,GAAG,sBAAsBA,KAAI,KAAK,GAAG,gBAAgBA,KAAI,KACzD,GAAG,qBAAqBA,KAAI;AAAA,MAC9B;AAAA,MACM,OAAO,CAACA,UAAS,CAAC,CAACA,MAAK,IAAI;AAAA,MAC5B,OAAO,CAACA,UAAS,CAAC,EAAE,GAAG,yBAAyBA,KAAI,IAAI,GAAG,cAAc,MAAM;AAAA,MAC/E;AAAA,IACR;AAEA,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,gBAAM,6BAA6B,QAAQ;AAAA,YACzC;AAAA,YACA;AAAA,YACA;AAAA,UACF,KAAK;AAEL,gBAAM,iBAAiB,QAAQ;AAAA,YAC7B;AAAA,YACA;AAAA,YACA,CAAC,eACC,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ;AAAA,gBACT,GAAG,QAAQ,iBAAiB,0BAA0B;AAAA,gBACtD;AAAA,cACF;AAAA,cACA;AAAA,cACA;AAAA,gBACE,GAAG,QAAQ;AAAA,kBACT;AAAA,kBACA;AAAA,kBACA,CAAC;AAAA,kBACD;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACJ;AAEA,wBAAc,YAAY,YAAY,MAAM,cAAc;AAAA,QAC5D,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,QAC9C,eAA8B,gBAAgB,WAAW;AAAA,MAChE;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AChEM,IAAM,4BAAgC,eAAe;AAAA,EAC1D,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,iCAAiC,EAAE,WAAU,YAAY,WAAW;AACjF,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AAErE,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C;AAAA,QACJ,CAACC,UACC,GAAG,sBAAsBA,KAAI,KAAK,GAAG,gBAAgBA,KAAI,KACzD,GAAG,qBAAqBA,KAAI;AAAA,MAChC;AAAA,MACM,OAAO,CAACA,UAAS,CAAC,CAACA,MAAK,IAAI;AAAA,MAC5B,OAAO,CAACA,UAAS,CAAC,EAAE,GAAG,yBAAyBA,KAAI,IAAI,GAAG,cAAc,MAAM;AAAA,MAC/E;AAAA,IACR;AAEA,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,gBAAM,6BAA6B,QAAQ;AAAA,YACzC;AAAA,YACA;AAAA,YACA;AAAA,UACF,KAAK;AAEL,gBAAM,2BAA2B,QAAQ;AAAA,YACvC;AAAA,YACA;AAAA,YACA;AAAA,UACF,KAAK;AAEL,cAAI,aAAa;AACjB,gBAAM,SAAqC,CAAC;AAE5C,mBAAS,iBAAiB;AACxB;AACA,kBAAM,YAAY,UAAU;AAC5B,mBAAO,KAAK,QAAQ,iCAAiC,0BAA0B,WAAW;AAAA,cACxF,GAAG,QAAQ;AAAA,gBACT;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,GAAG,QAAQ,sBAAsB,GAAG,WAAW,cAAc;AAAA,cAC/D;AAAA,YACF,CAAC,CAAC;AACF,mBAAO,GAAG,QAAQ;AAAA,cAChB,GAAG,QAAQ,iBAAiB,SAAS;AAAA,cACrC;AAAA,cACA,CAAC,GAAG,QAAQ,8BAA8B;AAAA,gBACxC,GAAG,QAAQ,kCAAkC,OAAO;AAAA,cACtD,CAAC,CAAC;AAAA,YACJ;AAAA,UACF;AAEA,gBAAM,iBAAiB,QAAQ;AAAA,YAC7B;AAAA,YACA;AAAA,YACA,CAAC,eACC,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ;AAAA,gBACT,GAAG,QAAQ,iBAAiB,0BAA0B;AAAA,gBACtD;AAAA,cACF;AAAA,cACA;AAAA,cACA;AAAA,gBACE,GAAG,QAAQ,8BAA8B;AAAA,kBACvC,GAAG,QAAQ;AAAA,oBACT,GAAG,QAAQ,iBAAiB,KAAK;AAAA,oBACjC,GAAG,QAAQ;AAAA,sBACT;AAAA,sBACA;AAAA,sBACA,CAAC;AAAA,sBACD;AAAA,sBACA;AAAA,sBACA;AAAA,oBACF;AAAA,kBACF;AAAA,kBACA,GAAG,QAAQ;AAAA,oBACT,GAAG,QAAQ,iBAAiB,OAAO;AAAA,oBACnC,GAAG,QAAQ;AAAA,sBACT;AAAA,sBACA;AAAA,sBACA,CAAC,GAAG,QAAQ,2BAA2B,QAAW,QAAW,OAAO,CAAC;AAAA,sBACrE;AAAA,sBACA;AAAA,sBACA,eAAe;AAAA,oBACjB;AAAA,kBACF;AAAA,gBACF,CAAC;AAAA,cACH;AAAA,YACF;AAAA,UACJ;AAEA,cAAI,aAAsB;AAC1B,iBAAO,WAAW,UAAU,CAAC,GAAG,aAAa,WAAW,MAAM,GAAG;AAC/D,yBAAa,WAAW;AAAA,UAC1B;AAEA,qBAAW,SAAS,QAAQ;AAC1B,0BAAc,iBAAiB,YAAY,YAAY,OAAO,IAAI;AAAA,UACpE;AAEA,wBAAc,YAAY,YAAY,MAAM,cAAc;AAAA,QAC5D,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,QAC9C,eAA8B,gBAAgB,WAAW;AAAA,MAChE;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACxHM,IAAM,gBAAoB,eAAe;AAAA,EAC9C,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,qBAAqB,EAAE,WAAU,YAAY,WAAW;AACrE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,kBAAkB,CAAC,SACvB,GAAG,QAAQ,IAAI,KAAK,KAAK,WAAW,WAAW,KAAK,GAAG,kBAAkB,KAAK,WAAW,CAAC,CAAC,KACzF,KAAK,WAAW,CAAC,EAAE,aACjB,KAAK,WAAW,CAAC,EAAE,aACnB;AAEN,UAAM,mCAAwC,GAAG,qCAAqC,EAAE,WAAU,MAAe;AAC/G,WAAK,GAAG,gBAAgB,IAAI,KAAK,GAAG,oBAAoB,IAAI,KAAK,GAAG,sBAAsB,IAAI,MAAM,KAAK,MAAM;AAC7G,YAAI,UAAU,gBAAgB,KAAK,IAAI;AACvC,YAAIC,YAAiC,CAAC;AACtC,eAAO,MAAM;AAEX,gBAAM,YAAY,OAAY,OAAO,WAAW,SAAS,OAAO,CAAC;AACjE,cAAWC,QAAO,SAAS,EAAG;AAC9B,oBAAU,UAAU,MAAM;AAC1B,UAAAD,YAAW,UAAU,MAAM,KAAK,OAAOA,SAAQ;AAAA,QACjD;AACA,cAAME,gBAAe,KAAK,QAAQ,GAAG,aAAa,KAAK,IAAI,IACvD,KAAK,OACL,GAAG,sBAAsB,KAAK,MAAM,KAAK,KAAK,OAAO,QAAQ,GAAG,aAAa,KAAK,OAAO,IAAI,IAC7F,KAAK,OAAO,OACZ;AACJ,cAAM,YAAY,OAAO,WAAW,UAAU,OAAO;AACrD,eAAQ,EAAE,GAAG,WAAW,eAAe,MAAM,UAAAF,WAAU,cAAAE,cAAa;AAAA,MACtE;AACA,aAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAAA,IAC9D,CAAC;AAED,UAAM,cAAc,QAAQ,wBAAwB,YAAY,SAAS;AACzE,QAAI,YAAY,WAAW,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAE1F,UAAM,wBAAwC;AAAA,MAC5C;AAAA,MACM,OAAO,CAAC,MAAmC,GAAG,sBAAsB,CAAC,KAAK,EAAE,cAAc,OAAO,KAAK;AAAA,MACtG,OAAO,CAAC,MAAM,QAAQ,cAAc,SAAS,EAAE,EAAE,IAAI,CAAC;AAAA,MACtDC,KAAI,CAAC,MAAM,EAAE,WAAY;AAAA,IACjC;AAEA,UAAM,YAAY,OAAO;AAAA,MACvB,sBAAsB,OAAO,WAAW;AAAA,MAClCA,KAAI,gCAAgC;AAAA,MACrC;AAAA,MACA;AAAA,IACP;AAEA,QAAWF,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,EAAE,cAAc,cAAc,mBAAmB,eAAe,SAAS,IAAI,UAAU;AAE7F,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa,eAAe,yBAAyB,GAAG,OAAO,YAAY,CAAC,OAAO;AAAA,MACnF,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAIrE,gBAAM,WAAW,eACf,GAAG,QAAQ;AAAA,YACT,GAAG,QAAQ;AAAA,cACT;AAAA,cACA;AAAA,YACF;AAAA,YACA;AAAA,YACA,CAAC,GAAG,QAAQ,oBAAoB,GAAG,OAAO,YAAY,CAAC,CAAC;AAAA,UAC1D,IACA,GAAG,QAAQ;AAAA,YACT;AAAA,YACA;AAAA,UACF;AAEF,gBAAM,4BAA4B,GAAG,QAAQ;AAAA,YAC3C;AAAA,YACA;AAAA,YACA,CAAC,GAAG,QAAQ;AAAA,cACV;AAAA,cACA,GAAG,QAAQ,YAAY,GAAG,WAAW,aAAa;AAAA,cAClD;AAAA,cACA,cAAc;AAAA,cACd,cAAc;AAAA,cACd,cAAc;AAAA,cACd,kBAAkB;AAAA,YACpB,CAAkB,EAAE,OAAO,QAAQ;AAAA,UACrC;AACA,wBAAc;AAAA,YACZ;AAAA,YACA;AAAA,YACA,QAAQ,gCAAgC,eAAe,2BAA2B,KAAK;AAAA,UACzF;AAAA,QACF,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,MACrD;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACvGM,IAAM,kBAAsB,eAAe;AAAA,EAChD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,uBAAuB,EAAE,WAAU,YAAY,WAAW;AACvE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C,OAAO,CAAC,MAAM,GAAG,sBAAsB,CAAC,KAAK,GAAG,oBAAoB,CAAC,CAAC;AAAA,MACtE,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI;AAAA,MACtB,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,QAAQ,cAAc,SAAS,EAAE,EAAE,IAAI,CAAC;AAAA,MAClE;AAAA,IACR;AAEA,QAAWG,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,gBAAM,OAAO,KAAK;AAClB,cAAI,UAA0B,GAAG,QAAQ,YAAY,KAAK,UAAU;AACpE,cAAI,KAAK,WAAW,WAAW,GAAG;AAChC,kBAAM,YAAY,KAAK,WAAW,CAAC;AACnC,gBAAI,aAAa,GAAG,kBAAkB,SAAS,KAAK,UAAU,YAAY;AACxE,wBAAU,UAAU;AAAA,YACtB;AAAA,UACF;AAEA,cAAI,aAAa,GAAG,yBAAyB,IAAI;AACjD,wBAAc,CAAC,GAAG,cAAc;AAChC,wBAAc,CAAC,GAAG,cAAc;AAChC,gBAAM,iBAAiB,GAAG,QAAQ,iCAAiC,UAAU;AAE7E,gBAAM,gBAAgB,GAAG,QAAQ;AAAA,YAC/B;AAAA,YACA,KAAK;AAAA,YACL,KAAK;AAAA,YACL;AAAA,YACA,GAAG,QAAQ,YAAY,GAAG,WAAW,sBAAsB;AAAA,YAC3D;AAAA,UACF;AAEA,gBAAM,iBAA0B,QAAQ;AAAA,YACtC;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,wBAAc,YAAY,YAAY,MAAM,gBAAgB;AAAA,YAC1D,qBAAqB,GAAG,YAAY,oBAAoB;AAAA,YACxD,sBAAsB,GAAG,YAAY,qBAAqB;AAAA,UAC5D,CAAC;AAAA,QACH,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,MACrD;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACxDM,IAAM,aAAiB,eAAe;AAAA,EAC3C,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,kBAAkB,EAAE,WAAU,YAAY,WAAW;AAClE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,UAAM,kBAAkB,QAAQ;AAAA,MAC9B;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAEL,UAAM,eAAe,CAAC,SAA2B;AAC/C,UACE,KAAK,WACJ,GAAG,sBAAsB,KAAK,MAAM,KAAK,GAAG,sBAAsB,KAAK,MAAM,MAC9E,GAAG,aAAa,IAAI,KACpB,KAAK,OAAO,eACZ,KAAK,OAAO,SAAS,MACrB;AACA,eAAO,KAAK,OAAO;AAAA,MACrB;AACA,aAAO;AAAA,IACT;AAEA,UAAM,8BAA8B,CAAC,SAAkB;AACrD,YAAM,aAAa,aAAa,IAAI;AACpC,aAAO;AAAA,QACM,kBAAkB,YAAY;AAAA,UACvC,qBAAqB;AAAA,UACrB,uBAAuB;AAAA,QACzB,CAAC;AAAA,QACIC,SAAmB,mBAAmB;AAAA,QACtCA;AAAA,UAAQ,CAAC,mBACN,UAAU,cAAc,KAAK,IAAe,gBAAgB,QAAa,QAAQ,cAAc;AAAA,QACvG;AAAA,QACKC,KAAI,CAAC,qBAAqB;AAAA,UAC7B,MAAM;AAAA,UACN,aAAa;AAAA,UACb,OAAO;AAAA,YACA,IAAI,aAAY;AACnB,oBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,oBAAM,mBAAmB,oBAAI,IAAa;AAC1C,yBAAW,SAAeC,QAAa,MAAM,eAAe,CAAC,GAAG;AAC9D,sBAAM,SAAS,QAAQ,CAAC,MAAM,iBAAiB,IAAI,CAAC,CAAC;AAAA,cACvD;AACA,oBAAM,aAAa;AAAA,gBACXA,QAAa,MAAM,eAAe,CAAC;AAAA,gBACnC;AAAA,gBACAD,KAAI,CAAC,MAAM,EAAE,IAAI;AAAA,gBACjB,OAAO,GAAG,YAAY;AAAA,gBACtB,KAAW;AAAA,kBACTE;AAAA,kBACN,CAAC,MAAe,EAAE;AAAA,gBACpB,CAAC;AAAA,cACH;AAEA,oBAAM,qBAAqB,OAAO;AAAA,gBAChC,WAAW,UAAU,YAAY,kBAAkB,UAAU,GAAG,UAAU;AAAA,gBACrEF,KAAI,CAAC,MAAM,EAAE,IAAI;AAAA,gBACjB;AAAA,cACP;AAEA,oBAAM,CAAC,gBAAgB,eAAe,IAAI;AAAA,gBAClC,aAAa,gBAAgB;AAAA,gBAC7B,KAAK,iBAAiB,sBAAsB;AAAA,gBAC5C;AAAA,kBAAU,CAAC,MACRG,QAAO,kBAAkB,KAAK,YAAY,mBAAmB,GAAG,mBAAmB,KAAK;AAAA,gBACjG;AAAA,cACF;AAEA,oBAAM,iBAAiB;AAAA,gBACrB;AAAA,gBACMH,KAAI,CAAC,MAAM,YAAY,eAAe,GAAG,QAAW,GAAG,iBAAiB,YAAY,CAAC;AAAA,gBACrF,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAAA,cACzB;AAEA,oBAAM,gBAAgB,eAAe,WAAW,IAC5C,GAAG,QAAQ,wBAAwB,OAAO,IAC1C,GAAG,QAAQ,oBAAoB,cAAc;AAEjD,oBAAM,cAAc;AAAA,gBAClB;AAAA,gBACMA,KAAI,CAAC,MAAM,YAAY,aAAa,GAAG,QAAW,GAAG,gBAAgB,YAAY,CAAC;AAAA,gBAClF,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAAA,cACzB;AAEA,oBAAM,mBAAmB,YAAY,WAAW,IAC5C,gBACA,GAAG;AAAA,gBACH;AAAA,gBACA,GAAG,WAAW;AAAA,gBACd,MAAM,YAAY,KAAK,KAAK,IAAI;AAAA,gBAChC;AAAA,cACF;AAEF,oBAAM,iBAAiB,GAAG,QAAQ;AAAA,gBAChC,GAAG,QAAQ;AAAA,kBACT,GAAG,QAAQ,6BAA6B,UAAU;AAAA,kBAClD,GAAG,QAAQ,wBAAwB,KAAK;AAAA,gBAC1C;AAAA,gBACA,GAAG,QAAQ;AAAA,kBACT,GAAG,QAAQ,oBAAoB,GAAG,QAAQ,iBAAiB,eAAe,GAAG,OAAO;AAAA,kBACpF,CAAC,gBAAgB;AAAA,gBACnB;AAAA,cACF;AAEA,4BAAc,YAAY,YAAY,YAAY,gBAAgB;AAAA,gBAChE,qBAAqB,GAAG,YAAY,oBAAoB;AAAA,gBACxD,sBAAsB,GAAG,YAAY,qBAAqB;AAAA,cAC5D,CAAC;AAAA,YACH,CAAC;AAAA,YACI,eAA6B,eAAe,EAAE;AAAA,UACrD;AAAA,QACF,EAAE;AAAA,MACJ;AAAA,IACF;AAEA,UAAM,oBAMF,CAAC,SAAkB;AACrB,UAAI,GAAG,eAAe,IAAI,KAAK,GAAG,oBAAoB,KAAK,IAAI,GAAG;AAChE,cAAM,aAAa,KAAK;AACxB,YACE,GAAG,eAAe,UAAU,KAAK,WAAW,KAAK,SAAS,GAAG,WAAW,YACxE;AACA,gBAAM,OAAO,YAAY,kBAAkB,KAAK,IAAI;AACpD,iBAAO;AAAA,YACL,WAAW,UAAU,MAAM,KAAK,IAAI;AAAA,YAC/BA,KAAI,CAAC,OAAO,EAAE,MAAM,GAAG,GAAG,iBAAiB,WAAW,WAAW,EAAE;AAAA,UAC1E;AAAA,QACF;AAAA,MACF;AACA,aAAkB,gBAAgB;AAAA,IACpC;AAEA,UAAM,uBAAuB,CAAC,SAAkB;AAC9C,YAAM,aAAa,aAAa,IAAI;AACpC,aAAO;AAAA,QACL,kBAAkB,UAAU;AAAA,QACvBD;AAAA,UAAQ,CAAC,iBACZ;AAAA,YACa,kBAAkB,aAAa,iBAAiB;AAAA,cACzD,qBAAqB;AAAA,cACrB,uBAAuB;AAAA,YACzB,CAAC;AAAA,YACIA,SAAmB,mBAAmB;AAAA,YACtCA;AAAA,cAAQ,CAAC,mBACN,UAAU,cAAc,KAAK,IAAe,gBAAgB,QAAa,QAAQ,cAAc;AAAA,YACvG;AAAA,YACKC,KAAI,CAAC,qBAAqB;AAAA,cAC7B,MAAM;AAAA,cACN,aAAa;AAAA,cACb,OAAY,IAAI,aAAY;AAC1B,sBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,sBAAM,EAAE,iBAAiB,mBAAmB,IAAI,OAAO;AAAA,kBAC1C;AAAA,oBACT;AAAA,oBACA,aAAa;AAAA,kBACf;AAAA,kBACK,eAA8B,gBAAgB,WAAW;AAAA,kBACzD,eAAgC,kBAAkB,gBAAgB;AAAA,kBAClE,eAA6B,eAAe,EAAE;AAAA,gBACrD;AAGA,sBAAM,iBAAiB,GAAG,QAAQ;AAAA,kBAChC,GAAG,QAAQ;AAAA,oBACT,gBAAgB,CAAC,EAAG;AAAA,oBACpB;AAAA,kBACF;AAAA,kBACA,CAAC;AAAA,kBACD,gBAAgB,MAAM,CAAC,EAAE;AAAA,oBAAI,CAAC,MAC5B,GAAG,QAAQ;AAAA,sBACT,GAAG,QAAQ;AAAA,wBACT,GAAG,QAAQ,iBAAiB,eAAe;AAAA,wBAC3C,EAAE,UAAU,EAAE,WAAW,iBAAiB,EAAE,SAAS,UAAU;AAAA,sBACjE;AAAA,sBACA,CAAC;AAAA,sBACD,CAAC,EAAE,eAAe;AAAA,oBACpB;AAAA,kBACF;AAAA,gBACF;AAEA,sBAAM,4BAA4B,mBAAmB,OAAO,IACxD,GAAG;AAAA,kBACH;AAAA,kBACA,GAAG,WAAW;AAAA,kBACd,qBAA2B,aAAa,mBAAmB,OAAO,CAAC,EAAE;AAAA,oBAAI,CAAC,MACxE,YAAY,aAAa,GAAG,QAAW,GAAG,gBAAgB,YAAY;AAAA,kBACxE,EAAE,KAAK,IAAI,IAAI;AAAA,kBACf;AAAA,gBACF,IACA;AAEF,8BAAc,YAAY,YAAY,YAAY,2BAA2B;AAAA,kBAC3E,qBAAqB,GAAG,YAAY,oBAAoB;AAAA,kBACxD,sBAAsB,GAAG,YAAY,qBAAqB;AAAA,gBAC5D,CAAC;AAAA,cACH,CAAC;AAAA,YACH,EAAE;AAAA,UACJ;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,cAAc,QAAQ,wBAAwB,YAAY,SAAS;AACzE,QAAI,YAAY,WAAW,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAE1F,WAAO,OAAO;AAAA,MACP,eAAe,YAAY,IAAI,oBAAoB,CAAC;AAAA,MACpDI,QAAO,MAAW,eAAe,YAAY,IAAI,2BAA2B,CAAC,CAAC;AAAA,MAC9EA,QAAO,MAAW,KAAK,IAAQ,2BAA2B,CAAC,CAAC;AAAA,IACnE;AAAA,EACF,CAAC;AACH,CAAC;;;ACrOM,IAAM,iCAAsC;AAAA,EACjD;AACF;AAAA,EACE,WAAU,YAA2B,WAAyB;AAC5D,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,aAAkB,GAAG,mCAAmC;AAAA,MAC5D,WAAU,MAAe;AACvB,YAAI,CAAC,GAAG,sBAAsB,IAAI,GAAG;AACnC,iBAAO,OAAY,KAAK,uCAAuC;AAAA,QACjE;AACA,cAAM,aAAa,KAAK;AACxB,YAAI,CAAC,GAAG,aAAa,UAAU,EAAG,QAAO,OAAY,KAAK,8BAA8B;AACxF,cAAM,cAAc,KAAK;AACzB,YAAI,CAAC,YAAa,QAAO,OAAY,KAAK,4BAA4B;AAEtE,cAAM,0BAA0B,KAAK;AACrC,YAAI,CAAC,2BAA2B,CAAC,GAAG,0BAA0B,uBAAuB,GAAG;AACtF,iBAAO,OAAY,KAAK,2CAA2C;AAAA,QACrE;AAEA,cAAM,oBAAoB,wBAAwB;AAClD,YAAI,CAAC,qBAAqB,CAAC,GAAG,oBAAoB,iBAAiB,GAAG;AACpE,iBAAO,OAAY,KAAK,2CAA2C;AAAA,QACrE;AAEA,cAAM,OAAO,YAAY,kBAAkB,WAAW;AACtD,cAAM,QAAQ,OAAO,WAAW,iBAAiB,MAAM,WAAW;AAElE,eAAO,EAAE,YAAY,mBAAmB,yBAAyB,MAAM;AAAA,MACzE;AAAA,IACF;AAEA,WAAO,OAAO;AAAA,MACZ,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/CC,KAAI,UAAU;AAAA,MACf;AAAA,MACA;AAAA,IACP;AAAA,EACF;AACF;AAEO,IAAM,qBAA0B,GAAG,oBAAoB,EAAE,WAC9D,kBACA,eACA,OACA,gBACA,OACA,mBACA,mBACA;AACA,QAAM,KAAK,OAAY,QAAsB,aAAa;AAE1D,QAAM,iBAAiB,GAAG,QAAQ;AAAA,IAChC,GAAG,QAAQ;AAAA,MACT,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,QAC5C,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,MACtC;AAAA,MACA,GAAG,QAAQ,iBAAiB,MAAM;AAAA,IACpC;AAAA,IACA,CAAC,GAAG,QAAQ;AAAA,MACV,GAAG,QAAQ,iBAAiB,aAAa;AAAA,IAC3C,CAAC;AAAA,EACH;AACA,QAAM,aAAa,EAAE,MAAM,QAAQ,GAAG,UAAU,UAC9C,GAAG,QAAQ;AAAA,IACT,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,IACvD;AAAA,IACA,CAAC;AAAA,IACD;AAAA,EACF,IACA,GAAG,QAAQ;AAAA,IACT,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,IACvD;AAAA,IACA;AAAA,IACA,CAAC,GAAG,QAAQ;AAAA,MACV,GAAG,WAAW;AAAA,MACd,CAAC,cAAc;AAAA,IACjB,CAAC;AAAA,IACD,CAAC;AAAA,EACH;AAEF,QAAM,kBAAkB,GAAG,QAAQ;AAAA,IACjC,GAAG,QAAQ;AAAA,MACT,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,QAC5C,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,MACtC;AAAA,MACA,GAAG,QAAQ,iBAAiB,SAAS;AAAA,IACvC;AAAA,IACA,CAAC,GAAG,QAAQ;AAAA,MACV,GAAG,QAAQ,iBAAiB,aAAa;AAAA,IAC3C,CAAC;AAAA,EACH;AACA,QAAM,cAAc,EAAE,MAAM,QAAQ,GAAG,UAAU,UAC/C,GAAG,QAAQ;AAAA,IACT,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,IACvD;AAAA,IACA,CAAC;AAAA,IACD;AAAA,EACF,IACA,GAAG,QAAQ;AAAA,IACT,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,IACvD;AAAA,IACA;AAAA,IACA,CAAC,GAAG,QAAQ;AAAA,MACV,GAAG,WAAW;AAAA,MACd,CAAC,eAAe;AAAA,IAClB,CAAC;AAAA,IACD,CAAC;AAAA,EACH;AAGF,QAAM,kBAAkB,GAAG,QAAQ;AAAA,IACjC,GAAG,QAAQ;AAAA,MACT,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,QAC5C,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,MACtC;AAAA,MACA,GAAG,QAAQ,iBAAiB,SAAS;AAAA,IACvC;AAAA,IACA,CAAC,GAAG,QAAQ;AAAA,MACV,GAAG,QAAQ,iBAAiB,aAAa;AAAA,IAC3C,CAAC;AAAA,EACH;AACA,QAAM,cAAc,GAAG,QAAQ;AAAA,IAC7B,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,IACvD;AAAA,IACA,CAAC;AAAA,IACD;AAAA,EACF;AAEA,SAAO,EAAE,aAAa,aAAa,WAAW;AAChD,CAAC;AAEM,IAAM,mBAAuB,eAAe;AAAA,EACjD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,wBAAwB,EAAE,WAAU,YAAY,WAAW;AACxE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,YAAY,OAAO,+BAA+B,YAAY,SAAS;AAC7E,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAE1F,UAAM,EAAE,YAAY,OAAO,yBAAyB,kBAAkB,IAAI,UAAU;AAEpF,WAAO;AAAA,MACL,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,gBAAM,mBAAmB,QAAQ;AAAA,YAC/B;AAAA,YACA;AAAA,YACA;AAAA,UACF,KAAK;AAEL,gBAAM,gBAAgB,GAAG,QAAQ,iBAAiB,GAAG,OAAO,UAAU,IAAI,GAAG;AAC7E,gBAAM,EAAE,aAAa,aAAa,WAAW,IAAI,OAAO;AAAA,YACtD;AAAA,YACA,GAAG,OAAO,aAAa;AAAA,YACvB,MAAM;AAAA,YACN,GAAG,OAAO,UAAU;AAAA,YACpB,MAAM;AAAA,YACN,GAAG,OAAO,UAAU,IAAI;AAAA,YACxB,GAAG,OAAO,UAAU,IAAI;AAAA,UAC1B;AAEA,wBAAc;AAAA,YACZ;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,wBAAc,gBAAgB,YAAY,mBAAmB,UAAU;AACvE,wBAAc,gBAAgB,YAAY,mBAAmB,WAAW;AACxE,wBAAc,gBAAgB,YAAY,mBAAmB,WAAW;AAGxE,gBAAM,gBAAgB,GAAG,QAAQ;AAAA,YAC/B,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,cAC5C,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,YACtC;AAAA,YACA;AAAA,cACE,GAAG,QAAQ,wBAAwB,WAAW,IAAI;AAAA,cAClD,GAAG,QAAQ,wBAAwB,YAAY,IAAI;AAAA,cACnD,GAAG,QAAQ,wBAAwB,YAAY,IAAI;AAAA,YACrD;AAAA,UACF;AACA,gBAAM,sBAAsB,GAAG,QAAQ;AAAA,YACrC,kBAAkB;AAAA,YAClB,GAAG,QAAQ;AAAA,cACT,CAAC,GAAG,QAAQ;AAAA,gBACV,GAAG,OAAO,UAAU;AAAA,gBACpB;AAAA,gBACA;AAAA,gBACA,GAAG,QAAQ,iBAAiB,GAAG,OAAO,aAAa,CAAC;AAAA,cACtD,CAAC;AAAA,cACD,wBAAwB;AAAA,YAC1B;AAAA,UACF;AAEA,wBAAc,gBAAgB,YAAY,mBAAmB,mBAAmB;AAChF,wBAAc,WAAW,YAAY,kBAAkB,KAAK,IAAI;AAAA,QAClE,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,MACrD;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC1NM,IAAM,yBAA6B,eAAe;AAAA,EACvD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,8BAA8B,EAAE,WAAU,YAAY,WAAW;AAC9E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,YAAY,OAAO,+BAA+B,YAAY,SAAS;AAC7E,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAE1F,UAAM,EAAE,YAAY,OAAO,yBAAyB,kBAAkB,IAAI,UAAU;AAEpF,WAAO;AAAA,MACL,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,gBAAM,mBAAmB,QAAQ;AAAA,YAC/B;AAAA,YACA;AAAA,YACA;AAAA,UACF,KAAK;AAEL,gBAAM,gBAAgB,GAAG,QAAQ,iBAAiB,GAAG,OAAO,UAAU,IAAI,GAAG;AAC7E,gBAAM,EAAE,aAAa,aAAa,WAAW,IAAI,OAAO;AAAA,YACtD;AAAA,YACA,GAAG,OAAO,aAAa;AAAA,YACvB,MAAM;AAAA,YACN,GAAG,OAAO,UAAU;AAAA,YACpB,MAAM;AAAA,YACN;AAAA,YACA;AAAA,UACF;AAEA,gBAAM,YAAY,GAAG,QAAQ;AAAA,YAC3B,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,YACvD,GAAG,QAAQ,iBAAiB,GAAG,OAAO,UAAU,CAAC;AAAA,YACjD,GAAG,QAAQ,kBAAkB;AAAA,cAC3B;AAAA,cACA;AAAA,YACF,CAAC;AAAA,YACD,GAAG,UAAU;AAAA,UACf;AAEA,wBAAc;AAAA,YACZ;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,wBAAc,gBAAgB,YAAY,mBAAmB,UAAU;AACvE,wBAAc,gBAAgB,YAAY,mBAAmB,SAAS;AAEtE,gBAAM,gBAAgB,GAAG,gBAAgB,UAAU,IAAI,IAAI,UAAU,KAAK,OAAO,GAAG,OAAO,UAAU,IAAI;AAGzG,gBAAM,gBAAgB,GAAG,QAAQ;AAAA,YAC/B,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ,iBAAiB,gBAAgB;AAAA,cAC5C,GAAG,QAAQ,iBAAiB,QAAQ;AAAA,YACtC;AAAA,YACA;AAAA,cACE,GAAG,QAAQ,wBAAwB,WAAW,IAAI;AAAA,cAClD,GAAG,QAAQ;AAAA,gBACT,GAAG,QAAQ;AAAA,kBACT,GAAG,QAAQ;AAAA,oBACT;AAAA,kBACF;AAAA,kBACA,GAAG,OAAO,YAAY,IAAI;AAAA,gBAC5B;AAAA,cACF;AAAA,cACA,GAAG,QAAQ,wBAAwB,GAAG,QAAQ;AAAA,gBAC5C,GAAG,QAAQ,iBAAiB,aAAa;AAAA,gBACzC,GAAG,OAAO,YAAY,IAAI;AAAA,cAC5B,CAAC;AAAA,YACH;AAAA,UACF;AACA,gBAAM,sBAAsB,GAAG,QAAQ;AAAA,YACrC,kBAAkB;AAAA,YAClB,GAAG,QAAQ;AAAA,cACT,CAAC,GAAG,QAAQ;AAAA,gBACV,GAAG,OAAO,UAAU;AAAA,gBACpB;AAAA,gBACA;AAAA,gBACA,GAAG,QAAQ,iBAAiB,GAAG,OAAO,aAAa,CAAC;AAAA,cACtD,CAAC;AAAA,cACD,wBAAwB;AAAA,YAC1B;AAAA,UACF;AAEA,wBAAc,gBAAgB,YAAY,mBAAmB,mBAAmB;AAChF,wBAAc,WAAW,YAAY,kBAAkB,KAAK,IAAI;AAAA,QAClE,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,MACrD;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC9FM,IAAM,sBAA0B,eAAe;AAAA,EACpD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,2BAA2B,EAAE,WAAU,YAAY,WAAW;AAC3E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,aAAS,WAAWC,OAA0C;AAC5D,UAAI,CAAC,GAAG,iBAAiBA,KAAI,EAAG,QAAO;AACvC,YAAM,aAAaA,MAAK;AACxB,UAAI,CAAC,GAAG,aAAa,UAAU,EAAG,QAAO;AACzC,UAAI,GAAG,OAAO,UAAU,MAAM,OAAQ,QAAO;AAC7C,aAAO;AAAA,IACT;AAEA,aAAS,sBACPA,OACA,MACkC;AAClC,UAAI,CAAC,GAAG,iBAAiBA,KAAI,EAAG,QAAcC,MAAK;AACnD,YAAM,YAAY,YAAY,qBAAqBD,KAAI;AACvD,UAAI,CAAC,UAAW,QAAcC,MAAK;AACnC,YAAM,iBAAiB,YAAY;AAAA,QACjC,YAAY,kBAAkBD,MAAK,UAAU;AAAA,QAC7C,GAAG,cAAc;AAAA,MACnB;AACA,eAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC9C,cAAM,gBAAgB,eAAe,CAAC;AACtC,YAAI,cAAc,WAAW,WAAWA,MAAK,UAAU,SAAS,GAAG;AACjE,iBAAcE;AAAA,YACZ,GAAG,QAAQ;AAAA,cACTF,MAAK;AAAA,cACL,CAAC;AAAA,cACD,CAAC,IAAI,EAAE,OAAOA,MAAK,SAAS;AAAA,YAC9B;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAcC,MAAK;AAAA,IACrB;AAEA,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C,OAAO,UAAU;AAAA,MACjB,OAAO,CAACD,UAAS,QAAQ,cAAc,SAAS,EAAEA,MAAK,UAAU,CAAC;AAAA,MAClE;AAAA,QACJ,CAACA,UAASA,MAAK,UAAU,SAAS;AAAA,MACpC;AAAA,MACMG,KAAI,CAACH,UAAS;AAClB,YAAII,WAAUJ,MAAK,UAAU,CAAC;AAC9B,YAAI,eAAe;AACnB,iBAAS,IAAI,GAAG,IAAIA,MAAK,UAAU,QAAQ,KAAK;AAC9C,gBAAM,MAAMA,MAAK,UAAU,CAAC;AAC5B,gBAAM,IAAI,sBAAsB,KAAKI,QAAO;AAC5C,cAAWC,QAAO,CAAC,GAAG;AAEpB,YAAAD,WAAU,EAAE;AACZ,2BAAe;AAAA,UACjB,OAAO;AACL,gBAAI,WAAWA,QAAO,GAAG;AAEvB,cAAAA,WAAU,GAAG,QAAQ;AAAA,gBACnB,GAAG,QAAQ,iBAAiB,MAAM;AAAA,gBAClC,CAAC;AAAA,gBACDA,SAAQ,UAAU,OAAO,CAAC,GAAG,CAAC;AAAA,cAChC;AAAA,YACF,OAAO;AAEL,cAAAA,WAAU,GAAG,QAAQ,qBAAqB,GAAG,QAAQ,iBAAiB,MAAM,GAAG,CAAC,GAAG;AAAA,gBACjFA;AAAA,gBACA;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AACA,eAAO,eAAsBF,MAAK,CAACF,OAAMI,QAAO,CAAU,IAAWH,MAAK;AAAA,MAC5E,CAAC;AAAA,MACK,OAAcI,OAAM;AAAA,MACpBF,KAAI,CAAC,MAAM,EAAE,KAAK;AAAA,MAClB;AAAA,IACR;AAEA,QAAWG,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,CAAC,MAAM,OAAO,IAAI,UAAU;AAElC,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAY,IAAI,aAAY;AAC1B,cAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,sBAAc,YAAY,YAAY,MAAM,OAAO;AAAA,MACrD,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH,CAAC;;;ACrEM,IAAM,6BAAiC,eAAe;AAAA,EAC3D,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,kCAAkC,EAAE,WAAU,YAAY,WAAW;AAClF,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,eACQ,iBAAiB,QAAQ,wBAAwB,YAAY,SAAS,GAC5E;AACA,YAAM,YAAY,OAAY,OAAO,WAAW,qBAAqB,aAAa,CAAC;AAEnF,UAAWC,QAAO,SAAS,EAAG;AAC9B,YAAM,kBAAkB,UAAU,MAAM;AAExC,aAAQ;AAAA,QACN,MAAM;AAAA,QACN,aAAa;AAAA,QACb,OAAY,IAAI,aAAY;AAC1B,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,wBAAc,YAAY,YAAY,eAAe,OAAO,eAAe;AAAA,QAC7E,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAAA,EAC9D,CAAC;AACH,CAAC;;;ACvDM,IAAM,kBAAsB,eAAe;AAAA,EAChD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,uBAAuB,EAAE,WAAU,YAAY,WAAW;AACvE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C,OAAO,GAAG,qBAAqB;AAAA,MAC/B,OAAO,CAACC,UAAS,QAAQ,cAAc,SAAS,EAAEA,MAAK,IAAI,CAAC;AAAA,MAC5D;AAAA,QAAO,CAACA,UACZ,CAAC,CAACA,MAAK,eACP,EAAE,GAAG,gBAAgBA,MAAK,WAAW,KAAK,GAAG,QAAQA,MAAK,YAAY,IAAI;AAAA,MAC5E;AAAA,MACM;AAAA,IACR;AAEA,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAY,IAAI,aAAY;AAC1B,cAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,cAAM,cAAc,KAAK;AAEzB,YAAI,GAAG,gBAAgB,WAAW,KAAK,YAAY,WAAW,WAAW,GAAG;AAE1E,wBAAc,YAAY,YAAY;AAAA,YACpC,KAAK,YAAY,KAAK;AAAA,YACtB,KAAK,YAAY;AAAA,UACnB,CAAC;AAED,wBAAc,YAAY,YAAY;AAAA,YACpC,KAAK,YAAY;AAAA,YACjB,KAAK,YAAY,KAAK;AAAA,UACxB,CAAC;AACD;AAAA,QACF;AAGA,sBAAc,WAAW,YAAY,YAAY,KAAK,QAAQ;AAAA,MAChE,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH,CAAC;;;AC9CM,IAAM,kBAAsB,eAAe;AAAA,EAChD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,uBAAuB,EAAE,WAAU,YAAY,WAAW;AACvE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,UAAMC,mBAAkB,CAAC,SAClB,IAAI,aAAY;AACnB,YAAM,WAAW,OAAO,WAAW,SAAS,IAAI;AAChD,cAAQ,SAAS,MAAM;AAAA,QACrB,KAAK,QAAQ;AACX,iBAAO,WAAW,aAAa,YAAY,kBAAkB,SAAS,OAAO,GAAG,SAAS,OAAO;AAChG,iBAAQ;AAAA,YACN,MAAM;AAAA,YACN,aAAa;AAAA,YACb,OAAY,IAAI,aAAY;AAC1B,oBAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,4BAAc;AAAA,gBACZ;AAAA,gBACA;AAAA,gBACA,GAAG,QAAQ;AAAA,kBACT,GAAG,QAAQ;AAAA,oBACT,SAAS;AAAA,oBACT;AAAA,kBACF;AAAA,kBACA;AAAA,kBACA,SAAS;AAAA,gBACX;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,QACA,KAAK;AACH,iBAAQ;AAAA,YACN,MAAM;AAAA,YACN,aAAa;AAAA,YACb,OAAY,IAAI,aAAY;AAC1B,oBAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,4BAAc;AAAA,gBACZ;AAAA,gBACA;AAAA,gBACA,GAAG,QAAQ;AAAA,kBACT,GAAG,QAAQ,iBAAiB,MAAM;AAAA,kBAClC;AAAA,kBACA,CAAC,SAAS,OAAO,EAAE,OAAO,SAAS,IAAI;AAAA,gBACzC;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,MACJ;AAAA,IACF,CAAC;AAEH,UAAM,gBAAgB,QAAQ,wBAAwB,YAAY,SAAS;AAE3E,WAAO,OAAO;AAAA,MACP,eAAe,cAAc,IAAIA,gBAAe,CAAC;AAAA,MACjDC,QAAO,MAAW,KAAK,IAAQ,2BAA2B,CAAC,CAAC;AAAA,IACnE;AAAA,EACF,CAAC;AACH,CAAC;;;AC7DM,IAAM,6BAAiC,eAAe;AAAA,EAC3D,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,kCAAkC,EAAE,WAAU,YAAY,WAAW;AAClF,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,aAAS,wBACPC,aACA,eACA,aAKA,UACA;AACA,YAAM,aAAa,GAAG,gBAAgB,aAAa,GAAG,WAAW,iBAAiBA,WAAU;AAC5F,YAAM,aAAa,GAAG,gBAAgB,WAAW,KAAK,eAAe;AACrE,YAAM,UAAU,aAAa,YAAY,WAAW,CAAC,IAAI;AACzD,UAAI,SAAS;AACX,YAAI,YAAY;AACd,wBAAc;AAAA,YACZA;AAAA,YACA;AAAA,YACA,GAAG,QAAQ,YAAY,GAAG,WAAW,cAAc;AAAA,UACrD;AACA,wBAAc;AAAA,YACZA;AAAA,YACA;AAAA,YACA,GAAG,QAAQ,YAAY,GAAG,WAAW,eAAe;AAAA,UACtD;AAAA,QACF;AACA,sBAAc,aAAaA,aAAY,QAAQ,KAAK,UAAU,EAAE,QAAQ,KAAK,CAAC;AAAA,MAChF;AAAA,IACF;AAEA,aAAS,2BACPA,aACA,eACA,aAKA;AACA,YAAM,aAAa,GAAG,gBAAgB,aAAa,GAAG,WAAW,iBAAiBA,WAAU;AAC5F,YAAM,aAAa,GAAG,gBAAgB,WAAW,KAAK,eAAe;AACrE,YAAM,UAAU,aAAa,YAAY,WAAW,CAAC,IAAI;AACzD,UAAI,WAAW,YAAY,MAAM;AAC/B,sBAAc,YAAYA,aAAY,EAAE,KAAK,QAAQ,KAAK,KAAK,YAAY,KAAK,IAAI,CAAC;AAAA,MACvF;AAAA,IACF;AAEA,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MACvC;AAAA,QAAO,CAACC,UACpB,GAAG,sBAAsBA,KAAI,KAAK,GAAG,qBAAqBA,KAAI,KAC9D,GAAG,gBAAgBA,KAAI,KAAK,GAAG,oBAAoBA,KAAI;AAAA,MACzD;AAAA,MACc;AAAA,IAChB;AAEA,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,QAAI,KAAK,MAAM;AACb,aAAQ;AAAA,QACN,MAAM;AAAA,QACN,aAAa;AAAA,QACb,OAAO;AAAA,UACA,QAAsB,aAAa;AAAA,UACnCC,KAAI,CAAC,kBAAkB,2BAA2B,YAAY,eAAe,IAAI,CAAC;AAAA,QACzF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,aAAa,iBAAiB,sBAAsB,IAAI;AAC9D,QAAI,CAAC,WAAY,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAE7E,UAAM,iBAAiB,iBAAiB;AAAA,MACtC;AAAA,MACA;AAAA,MACA,GAAG,iBAAiB;AAAA,IACtB;AAEA,QAAI,CAAC,eAAgB,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAEjF,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,QAAsB,aAAa;AAAA,QACnCA,KAAI,CAAC,kBAAkB,wBAAwB,YAAY,eAAe,MAAM,cAAc,CAAC;AAAA,MACtG;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AClGM,IAAM,uBAA2B,eAAe;AAAA,EACrD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,4BAA4B,EAAE,WAAU,YAAY,WAAW;AAC5E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,UAAM,YAAY;AAAA,MAChB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C,OAAO,CAACC,UAAS,GAAG,sBAAsBA,KAAI,KAAK,GAAG,sBAAsBA,KAAI,CAAC;AAAA,MACjF,OAAO,CAACA,UAAS,QAAQ,cAAc,SAAS,EAAEA,MAAK,IAAI,CAAC;AAAA,MAC5D,OAAO,CAACA,UAAS,CAAC,CAACA,MAAK,WAAW;AAAA,MACnC;AAAA,IACR;AAEA,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,cAAI,KAAK,MAAM;AACb,0BAAc,YAAY,YAAY,EAAE,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,IAAI,CAAC;AAChF;AAAA,UACF;AAEA,gBAAM,cAAc,KAAK;AACzB,gBAAM,kBAAkB,YAAY,kBAAkB,WAAW;AACjE,gBAAM,sBAA6B,aAAa,iBAAiB;AAAA,YAC/D;AAAA,YACA;AAAA,YACA,GAAG,iBAAiB;AAAA,UACtB,CAAC,EAAE;AAAA,YACM;AAAA,cAAO,MACL,aAAa,iBAAiB;AAAA,gBACnC;AAAA,gBACA;AAAA,gBACA,GAAG,iBAAiB;AAAA,cACtB,CAAC;AAAA,YACH;AAAA,YACO;AAAA,UACT;AACA,cAAI,qBAAqB;AACvB,0BAAc;AAAA,cACZ;AAAA,cACA,KAAK,KAAK;AAAA,cACV;AAAA,cACA;AAAA,gBACE,QAAQ;AAAA,cACV;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,MACrD;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC/DM,IAAM,kCAAN,MAAsC;AAAA,EAE3C,YACW,MACT;AADS;AAAA,EAEX;AAAA,EAJS,OAAO;AAAA,EAMhB,WAAW;AACT,WAAO;AAAA,EACT;AACF;AAEO,IAAM,sCAAN,MAA0C;AAAA,EAE/C,YACW,MACT;AADS;AAAA,EAEX;AAAA,EAJS,OAAO;AAAA,EAMhB,WAAW;AACT,WAAO,qBAAqB,KAAK,KAAK,QAAQ,CAAC;AAAA,EACjD;AACF;AAEO,IAAM,6BAAN,MAAiC;AAAA,EAEtC,YACW,MACT;AADS;AAAA,EAEX;AAAA,EAJS,OAAO;AAAA,EAKhB,WAAW;AACT,WAAO,qBAAqB,KAAK,KAAK,QAAQ,CAAC;AAAA,EACjD;AACF;AAEO,IAAM,8CAAN,MAAkD;AAAA,EAEvD,YACW,MACT;AADS;AAAA,EAEX;AAAA,EAJS,OAAO;AAAA,EAKhB,WAAW;AACT,WAAO,qBAAqB,KAAK,KAAK,QAAQ,CAAC;AAAA,EACjD;AACF;AASA,IAAM,mBAAwB,IAAsB,kBAAkB;AAE/D,IAAM,uBAA4B,GAAG,gCAAgC,EAAE,WAC5E,YACA;AACA,QAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,QAAM,yBAAyB,QAAQ;AAAA,IACrC;AAAA,IACA;AAAA,IACA;AAAA,EACF,KAAK;AAEL,QAAM,uBAA+C,CAAC;AACtD,aAAW,cAAc,CAAC,UAAU,UAAU,SAAS,UAAU,GAAG;AAClE,UAAM,eAAe,QAAQ,qDAAqD,YAAY,UAAU,UAAU;AAClH,QAAI,aAAc,sBAAqB,UAAU,IAAI;AAAA,EACvD;AAEA,QAAM,KAAK,OAAY,QAAsB,aAAa;AAE1D,SAAO;AAAA,IACL;AAAA,IACA,yBAAyB,CAAC,YACxB,GAAG,QAAQ;AAAA,MACT,GAAG,QAAQ,iBAAiB,sBAAsB;AAAA,MAClD;AAAA,IACF;AAAA,IACF,eAAe,CAAC,SAASC,UACvB,GAAG,QAAQ;AAAA,MACT,GAAG,QAAQ;AAAA,QACT,GAAG,QAAQ,iBAAiB,sBAAsB;AAAA,QAClD;AAAA,MACF;AAAA,MACA,CAAC;AAAA,MACDA;AAAA,IACF;AAAA,IACF,0BAA0B,CAAC,SAAS;AAClC,UAAI,GAAG,aAAa,IAAI,GAAG;AACzB,gBAAQ,GAAG,OAAO,IAAI,GAAG;AAAA,UACvB,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH,mBAAcC,MAAK,GAAG,OAAO,IAAI,CAAC;AAAA,UACpC,KAAK;AAAA,UACL,KAAK;AACH,mBAAcA,MAAK,OAAO;AAAA,QAC9B;AACA,eAAcC,MAAK;AAAA,MACrB;AACA,UAAI,CAAC,GAAG,aAAa,KAAK,IAAI,EAAG,QAAcA,MAAK;AACpD,iBAAW,cAAc,sBAAsB;AAC7C,YAAI,GAAG,OAAO,KAAK,IAAI,MAAM,qBAAqB,UAAU,KAAK,GAAG,OAAO,KAAK,KAAK,MAAM,YAAY;AACrG,iBAAcD,MAAK,UAAU;AAAA,QAC/B;AAAA,MACF;AACA,aAAcC,MAAK;AAAA,IACrB;AAAA,IACA;AAAA,EACF;AACF,CAAC;AAED,IAAM,uBAEsF;AAAA,EAC1F;AACF;AAAA,EACE,WAAU,YAA2B;AACnC,UAAM,EAAE,GAAG,IAAI,OAAY,QAAQ,gBAAgB;AACnD,QAAI,GAAG,aAAa,UAAU,EAAG,QAAO,GAAG,QAAQ,iBAAiB,GAAG,OAAO,UAAU,CAAC;AACzF,UAAMC,QAAO,OAAO,qBAAqB,WAAW,IAAI;AACxD,WAAO,GAAG,QAAQ;AAAA,MAChBA;AAAA,MACA,GAAG,QAAQ,iBAAiB,GAAG,OAAO,WAAW,KAAK,CAAC;AAAA,IACzD;AAAA,EACF;AACF;AAEA,IAAM,mBAOH;AAAA,EACC;AACF;AAAA,EACE,WAAU,MAAmB;AAC3B,UAAM,EAAE,GAAG,IAAI,OAAY,QAAQ,gBAAgB;AACnD,QAAI,GAAG,kBAAkB,IAAI,GAAG;AAC9B,cAAQ,KAAK,QAAQ,MAAM;AAAA,QACzB,KAAK,GAAG,WAAW;AACjB,iBAAO,CAAC,GAAG,QAAQ,oBAAoB,KAAK,QAAQ,IAAI,CAAC;AAAA,QAC3D,KAAK,GAAG,WAAW;AACjB,iBAAO,CAAC,GAAG,QAAQ,qBAAqB,KAAK,QAAQ,IAAI,CAAC;AAAA,QAC5D,KAAK,GAAG,WAAW;AACjB,iBAAO,CAAC,GAAG,QAAQ,WAAW,CAAC;AAAA,QACjC,KAAK,GAAG,WAAW;AACjB,iBAAO,CAAC,GAAG,QAAQ,YAAY,CAAC;AAAA,MACpC;AAAA,IACF;AACA,QAAI,GAAG,gBAAgB,IAAI,GAAG;AAC5B,aAAa,QAAQ,OAAY,IAAI,GAAG,KAAK,MAAM,IAAI,CAAC,MAAM,iBAAiB,CAAC,CAAC,CAAC,CAAC;AAAA,IACrF;AACA,QAAI,GAAG,wBAAwB,IAAI,GAAG;AACpC,aAAO,OAAO,iBAAiB,KAAK,IAAI;AAAA,IAC1C;AACA,WAAO,OAAY,KAAK,IAAI;AAAA,EAC9B;AACF;AAEF,IAAM,+BAA+B,CACnC,IACA,YACA,SAEA,GAAG;AAAA,EACD,GAAG,QAAQ,iBAAiB,EAAE;AAAA,EAC9B,GAAG,WAAW;AAAA,EACd,gCAAgC,KAAK,QAAQ,UAAU,IAAI;AAC7D;AAEK,IAAM,cAAc,CACzB,MACA,sBASK,IAAI,aAAY;AACnB,QAAM,EAAE,eAAe,yBAAyB,0BAA0B,YAAY,GAAG,IAAI,OAAY;AAAA,IACvG;AAAA,EACF;AAEA,UAAQ,KAAK,MAAM;AAAA,IACjB,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,KAAK;AAAA,IACtC,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,OAAO;AAAA,IACxC,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,SAAS;AAAA,IAC1C,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,MAAM;AAAA,IACvC,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,MAAM;AAAA,IACvC,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,WAAW;AAAA,IAC5C,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,QAAQ;AAAA,IACzC,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,QAAQ;AAAA,IACzC,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,SAAS;AAAA,IAC1C,KAAK,GAAG,WAAW;AACjB,aAAO,wBAAwB,QAAQ;AAAA,EAC3C;AAEA,MAAI,GAAG,kBAAkB,IAAI,GAAG;AAC9B,QAAI,KAAK,QAAQ,SAAS,GAAG,WAAW,YAAa,QAAO,wBAAwB,MAAM;AAC1F,UAAM,iBAAiB,OAAY,OAAO,iBAAiB,IAAI,CAAC;AAChE,QAAWC,QAAO,cAAc,EAAG,QAAO,cAAc,WAAW,eAAe,KAAK;AAAA,EACzF;AAEA,MAAI,GAAG,gBAAgB,IAAI,GAAG;AAE5B,UAAM,cAAc,OAAY,OAAO,iBAAiB,IAAI,CAAC;AAC7D,QAAWA,QAAO,WAAW,EAAG,QAAO,cAAc,WAAW,YAAY,KAAK;AAEjF,UAAM,UAAU,OAAY,IAAI,GAAG,KAAK,MAAM,IAAI,CAAC,MAAM,YAAY,GAAG,iBAAiB,CAAC,CAAC;AAC3F,WAAO,cAAc,SAAS,OAAO;AAAA,EACvC;AAEA,MAAI,GAAG,uBAAuB,IAAI,GAAG;AACnC,UAAM,CAAC,aAAa,GAAG,YAAY,IAAI,OAAY;AAAA,MACjD,GAAG,KAAK,MAAM,IAAI,CAAC,MAAM,YAAY,GAAG,iBAAiB,CAAC;AAAA,IAC5D;AACA,QAAI,aAAa,WAAW,EAAG,QAAO;AACtC,WAAO,GAAG,QAAQ;AAAA,MAChB,GAAG,QAAQ;AAAA,QACT;AAAA,QACA;AAAA,MACF;AAAA,MACA,CAAC;AAAA,MACD,aAAa,IAAI,CAAC,MAAM,cAAc,UAAU,CAAC,CAAC,CAAC,CAAC;AAAA,IACtD;AAAA,EACF;AAEA,MAAI,GAAG,mBAAmB,IAAI,GAAG;AAC/B,QAAI,KAAK,aAAa,GAAG,WAAW,cAAc;AAChD,aAAO,cAAc,SAAS,CAAC,OAAO,YAAY,KAAK,MAAM,iBAAiB,CAAC,CAAC;AAAA,IAClF,WAAW,KAAK,aAAa,GAAG,WAAW,iBAAiB;AAC1D,aAAO,OAAO,YAAY,KAAK,MAAM,iBAAiB;AAAA,IACxD;AAAA,EACF;AAEA,MAAI,GAAG,gBAAgB,IAAI,GAAG;AAC5B,UAAM,aAAa,OAAO,YAAY,KAAK,aAAa,iBAAiB;AACzE,WAAO,cAAc,SAAS,CAAC,UAAU,CAAC;AAAA,EAC5C;AAEA,MAAI,GAAG,kBAAkB,IAAI,GAAG;AAC9B,UAAM,EAAE,YAAY,QAAQ,IAAI,OAAO,eAAe,KAAK,SAAS,iBAAiB;AAErF,WAAO;AAAA,MACL;AAAA,MACA,CAAC,GAAG,QAAQ,8BAA8B,YAAY,IAAI,CAAC,EAAE,OAAO,OAAO;AAAA,IAC7E;AAAA,EACF;AAEA,MAAI,GAAG,wBAAwB,IAAI,GAAG;AACpC,WAAO,OAAO,YAAY,KAAK,MAAM,iBAAiB;AAAA,EACxD;AAEA,MAAI,GAAG,gBAAgB,IAAI,GAAG;AAC5B,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,OAAO,YAAY,kBAAkB,KAAK,QAAQ;AACxD,UAAM,WAAW,YAAY,eAAe,MAAM,QAAW,GAAG,iBAAiB,YAAY;AAC7F,QAAI,SAAU,QAAO,OAAO,YAAY,UAAU,IAAI;AAAA,EACxD;AAEA,MACE,CAAC,qBACD,GAAG,wBAAwB,IAAI,KAAK,GAAG,wBAAwB,KAAK,UAAU,KAC9E,GAAG,gBAAgB,KAAK,WAAW,IAAI,KAAK,GAAG,mBAAmB,KAAK,SAAS,KAChF,KAAK,UAAU,aAAa,GAAG,WAAW,gBAAgB,GAAG,gBAAgB,KAAK,UAAU,IAAI,KAChG,KAAK,UAAU,KAAK,SAAS,QAAQ,EAAE,KAAK,MAAM,KAAK,WAAW,KAAK,SAAS,QAAQ,EAAE,KAAK,GAC/F;AACA,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,OAAO,YAAY,kBAAkB,IAAI;AAC/C,UAAM,WAAW,YAAY,eAAe,MAAM,QAAW,GAAG,iBAAiB,YAAY;AAC7F,QAAI,SAAU,QAAO,OAAO,YAAY,UAAU,IAAI;AAAA,EACxD;AAEA,MAAI,GAAG,oBAAoB,IAAI,GAAG;AAChC,UAAM,aAAa,yBAAyB,KAAK,QAAQ;AACzD,QAAWA,QAAO,UAAU,GAAG;AAC7B,cAAQ,WAAW,OAAO;AAAA,QACxB,KAAK;AAAA,QACL,KAAK;AACH,iBAAO,wBAAwB,WAAW,KAAK;AAAA,QACjD,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK,SAAS;AACZ,gBAAM,WAAW,OAAY;AAAA,YAC3B,GAAI,KAAK,gBACL,KAAK,cAAc,IAAI,CAAC,MAAM,YAAY,GAAG,iBAAiB,CAAC,IAC/D,CAAC;AAAA,UACP;AACA,iBAAO,cAAc,WAAW,OAAO,QAAQ;AAAA,QACjD;AAAA,QACA,KAAK,UAAU;AACb,gBAAM,WAAW,OAAY;AAAA,YAC3B,GAAI,KAAK,gBACL,KAAK,cAAc,IAAI,CAAC,MAAM,YAAY,GAAG,iBAAiB,CAAC,IAC/D,CAAC;AAAA,UACP;AACA,cAAI,SAAS,UAAU,GAAG;AACxB,mBAAO,cAAc,WAAW,OAAO;AAAA,cACrC,GAAG,QAAQ,8BAA8B;AAAA,gBACvC,GAAG,QAAQ,yBAAyB,OAAO,SAAS,CAAC,CAAC;AAAA,gBACtD,GAAG,QAAQ,yBAAyB,SAAS,SAAS,CAAC,CAAC;AAAA,cAC1D,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AACA,iBAAO,6BAA6B,IAAI,YAAY,IAAI;AAAA,QAC1D;AAAA,QACA,KAAK,UAAU;AACb,gBAAM,WAAW,OAAY;AAAA,YAC3B,GAAI,KAAK,gBACL,KAAK,cAAc,IAAI,CAAC,MAAM,YAAY,GAAG,iBAAiB,CAAC,IAC/D,CAAC;AAAA,UACP;AACA,cAAI,SAAS,UAAU,GAAG;AACxB,mBAAO,cAAc,WAAW,OAAO;AAAA,cACrC,GAAG,QAAQ,8BAA8B;AAAA,gBACvC,GAAG,QAAQ,yBAAyB,SAAS,SAAS,CAAC,CAAC;AAAA,gBACxD,GAAG,QAAQ,yBAAyB,QAAQ,SAAS,CAAC,CAAC;AAAA,cACzD,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AACA,iBAAO,6BAA6B,IAAI,YAAY,IAAI;AAAA,QAC1D;AAAA,QACA,KAAK;AAAA,QACL,KAAK,QAAQ;AACX,gBAAM,gBAAsB,aAAa,KAAK,iBAAiB,CAAC,CAAC;AACjE,cAAI,cAAc,WAAW,GAAG;AAC9B,mBAAO,6BAA6B,IAAI,YAAY,IAAI;AAAA,UAC1D;AACA,gBAAM,WAAW,OAAO,YAAY,cAAc,CAAC,GAAG,iBAAiB;AACvE,gBAAM,yBAAyB,OAAY,OAAO,iBAAiB,cAAc,CAAC,CAAC,CAAC;AAEpF,cAAWC,QAAO,sBAAsB,GAAG;AACzC,mBAAO,6BAA6B,IAAI,YAAY,IAAI;AAAA,UAC1D;AACA,iBAAO,GAAG,QAAQ;AAAA,YAChB,GAAG,QAAQ;AAAA,cACT;AAAA,cACA;AAAA,YACF;AAAA,YACA,CAAC;AAAA,YACD,CAAC,cAAc,WAAW,MAAM,YAAY,GAAG,uBAAuB,KAAK,CAAC;AAAA,UAC9E;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,GAAG,oBAAoB,IAAI,GAAG;AAChC,QAAI,EAAE,KAAK,iBAAiB,KAAK,cAAc,SAAS,IAAI;AAC1D,aAAO,OAAO,qBAAqB,KAAK,QAAQ;AAAA,IAClD;AAAA,EACF;AAGA,SAAO,6BAA6B,IAAI,YAAY,IAAI;AAC1D,CAAC;AAEH,IAAM,iBAAsB;AAAA,EAC1B;AACF;AAAA,EACE,WAAU,SAAuC,mBAA4B;AAC3E,UAAM,EAAE,eAAe,GAAG,IAAI,OAAY;AAAA,MACxC;AAAA,IACF;AAEA,UAAM,aAA2C,CAAC;AAClD,eAAW,qBAAqB,QAAQ,OAAO,GAAG,mBAAmB,GAAG;AACtE,YAAM,OAAO,kBAAkB;AAC/B,UAAI,EAAE,GAAG,aAAa,IAAI,KAAK,GAAG,gBAAgB,IAAI,IAAI;AACxD,eAAO,OAAY,KAAK,IAAI,oCAAoC,iBAAiB,CAAC;AAAA,MACpF;AACA,UAAI,CAAC,kBAAkB,MAAM;AAC3B,eAAO,OAAY,KAAK,IAAI,2BAA2B,iBAAiB,CAAC;AAAA,MAC3E;AACA,YAAM,qBAAqB;AAAA,QACzB,OAAO,YAAY,kBAAkB,MAAM,iBAAiB;AAAA,QAC5D,kBAAkB,gBAAgB,CAAC,MAAM,cAAc,YAAY,CAAC,CAAC,CAAC,IAAI;AAAA,QAC1E,CAAC,MAAM,GAAG,QAAQ,yBAAyB,MAAM,CAAC;AAAA,MACpD;AAEA,iBAAW,KAAK,kBAAkB;AAAA,IACpC;AAEA,UAAM,UAA6C,CAAC;AACpD,eAAW,kBAAkB,QAAQ,OAAO,GAAG,2BAA2B,GAAG;AAC3E,UAAI,eAAe,WAAW,WAAW,GAAG;AAC1C,eAAO,OAAY,KAAK,IAAI,4CAA4C,cAAc,CAAC;AAAA,MACzF;AACA,YAAM,YAAY,eAAe,WAAW,CAAC;AAC7C,UAAI,CAAC,UAAU,KAAM,QAAO,OAAY,KAAK,IAAI,2BAA2B,SAAS,CAAC;AACtF,YAAM,gBAAgB,UAAU;AAChC,YAAM,MAAM,OAAO,YAAY,eAAe,iBAAiB;AAC/D,YAAM,QAAQ,OAAO,YAAY,eAAe,MAAM,iBAAiB;AACvE,cAAQ;AAAA,QACN,GAAG,QAAQ,8BAA8B;AAAA,UACvC,GAAG,QAAQ,yBAAyB,OAAO,GAAG;AAAA,UAC9C,GAAG,QAAQ,yBAAyB,SAAS,KAAK;AAAA,QACpD,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,EAAE,YAAY,QAAQ;AAAA,EAC/B;AACF;AAEA,IAAM,8BAAmC,GAAG,uCAAuC;AAAA,EACjF,WAAU,MAA+B,aAAsB;AAC7D,QAAI,KAAK,kBAAkB,KAAK,eAAe,SAAS,GAAG;AACzD,aAAO,OAAY,KAAK,IAAI,gCAAgC,IAAI,CAAC;AAAA,IACnE;AACA,UAAM,EAAE,eAAe,GAAG,IAAI,OAAY;AAAA,MACxC;AAAA,IACF;AAEA,UAAM,EAAE,YAAY,QAAQ,IAAI,OAAO,eAAe,KAAK,SAAS,KAAK;AAEzE,QAAI,eAAe,QAAQ,WAAW,GAAG;AACvC,aAAO,OAAO,mCAAmC,GAAG,OAAO,KAAK,IAAI,GAAG,UAAU;AAAA,IACnF;AAEA,UAAM,eAAe;AAAA,MACnB;AAAA,MACA,CAAC,GAAG,QAAQ,8BAA8B,YAAY,IAAI,CAAC,EAAE,OAAO,OAAO;AAAA,IAC7E;AAEA,WAAO,OAAO,gCAAgC,GAAG,OAAO,KAAK,IAAI,GAAG,YAAY;AAAA,EAClF;AACF;AAEA,IAAM,8BAAmC,GAAG,uCAAuC;AAAA,EACjF,WAAU,MAA+B,aAAsB;AAC7D,UAAM,EAAE,GAAG,IAAI,OAAY,QAAQ,gBAAgB;AAEnD,QAAI,KAAK,kBAAkB,KAAK,eAAe,SAAS,GAAG;AACzD,aAAO,OAAY,KAAK,IAAI,gCAAgC,IAAI,CAAC;AAAA,IACnE;AAEA,QAAI,eAAe,GAAG,kBAAkB,KAAK,IAAI,GAAG;AAClD,YAAM,EAAE,YAAY,QAAQ,IAAI,OAAO,eAAe,KAAK,KAAK,SAAS,KAAK;AAC9E,UAAI,QAAQ,WAAW,GAAG;AACxB,eAAO,OAAO,mCAAmC,GAAG,OAAO,KAAK,IAAI,GAAG,UAAU;AAAA,MACnF;AAAA,IACF;AAEA,UAAM,eAAe,OAAO,YAAY,KAAK,MAAM,KAAK;AAExD,WAAO,OAAO,gCAAgC,GAAG,OAAO,KAAK,IAAI,GAAG,YAAY;AAAA,EAClF;AACF;AAEA,IAAM,kCAAuC,GAAG,2CAA2C;AAAA,EACzF,WACE,MACA,aACA;AACA,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,WAAO,GAAG,QAAQ;AAAA,MAChB,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,MACvD,GAAG,QAAQ,8BAA8B;AAAA,QACvC,GAAG,QAAQ;AAAA,UACT,GAAG,QAAQ,iBAAiB,IAAI;AAAA,UAChC;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF,GAAG,GAAG,UAAU,KAAK;AAAA,IACvB;AAAA,EACF;AACF;AAEA,IAAM,qCAA0C,GAAG,8CAA8C;AAAA,EAC/F,WACE,MACA,SACA;AACA,UAAM,EAAE,wBAAwB,IAAI,OAAY,QAAQ,gBAAgB;AACxE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,WAAO,GAAG,QAAQ;AAAA,MAChB,CAAC,GAAG,QAAQ,eAAe,GAAG,WAAW,aAAa,CAAC;AAAA,MACvD,GAAG,QAAQ,iBAAiB,IAAI;AAAA,MAChC,CAAC;AAAA,MACD,CAAC,GAAG,QAAQ;AAAA,QACV,GAAG,WAAW;AAAA,QACd;AAAA,UACE,GAAG,QAAQ;AAAA,YACT,GAAG,QAAQ;AAAA,cACT,GAAG,QAAQ;AAAA,gBACT,wBAAwB,OAAO;AAAA,gBAC/B,CAAC,GAAG,QAAQ;AAAA,kBACV;AAAA,gBACF,CAAC;AAAA,gBACD,CAAC,GAAG,QAAQ,oBAAoB,IAAI,CAAC;AAAA,cACvC;AAAA,cACA,CAAC;AAAA,cACD,CAAC,GAAG,QAAQ;AAAA,gBACV;AAAA,gBACA;AAAA,cACF,CAAC;AAAA,YACH;AAAA,YACA,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF,CAAC;AAAA,MACD,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAEO,IAAM,UAAe,GAAG,mBAAmB;AAAA,EAChD,WACE,YACA,MACA,aACA;AACA,UAAM,MAAM,OAAO,qBAAqB,UAAU;AAClD,UAAM,KAAK,OAAY,QAAsB,aAAa;AAE1D,WAAO,OAAO;AAAA,MACZ,GAAG,uBAAuB,IAAI,IAC1B,4BAA4B,MAAM,WAAW,IAC7C,4BAA4B,MAAM,WAAW;AAAA,MAC5C,eAAe,kBAAkB,GAAG;AAAA,IAC3C;AAAA,EACF;AACF;AAEO,IAAM,oBAAyB,GAAG,6BAA6B;AAAA,EACpE,WAAU,YAA2B,WAAyB;AAC5D,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AAEnE,WAAO;AAAA,MACL,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MAC/C,OAAO,CAAC,SAAS,GAAG,uBAAuB,IAAI,KAAK,GAAG,uBAAuB,IAAI,CAAC;AAAA,MACnF,OAAO,CAAC,SAAS,QAAQ,cAAc,SAAS,EAAE,KAAK,IAAI,CAAC;AAAA,MAC5D,OAAO,CAAC,UAAU,KAAK,kBAAkB,CAAC,GAAG,WAAW,CAAC;AAAA,MACzD;AAAA,IACR;AAAA,EACF;AACF;AAEO,IAAM,cAAmB,GAAG,uBAAuB;AAAA,EACxD,WACE,YACA,MACA,aACA;AACA,UAAM,KAAK,OAAY,QAAsB,aAAa;AAE1D,UAAM,gBAAgB,OAAY,QAAsB,aAAa;AACrE,UAAM,UAAU,OAAO;AAAA,MACrB,QAAQ,YAAY,MAAM,WAAW;AAAA,MAChCC;AAAA,QAAO,CAAC,UACN,QAAQ,GAAG;AAAA,UACd,GAAG,QAAQ,iBAAiB,EAAE;AAAA,UAC9B,GAAG,WAAW;AAAA,UACd,MAAM,OAAO,KAAK,IAAI;AAAA,UACtB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,kBAAc,iBAAiB,YAAY,MAAM,SAAS,MAAM;AAAA,MAC9D,qBAAqB,GAAG,YAAY,oBAAoB;AAAA,IAC1D,CAAC;AAAA,EACH;AACF;;;ACxkBO,IAAM,qBAAyB,eAAe;AAAA,EACnD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,0BAA0B,EAAE,WAAU,YAAY,WAAW;AAC1E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,UAAM,YAAY,OAAiB,kBAAkB,YAAY,SAAS;AAE1E,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACK,YAAY,YAAY,MAAM,KAAK;AAAA,QACxC,eAA8B,gBAAgB,WAAW;AAAA,QACzD,eAA+B,iBAAiB,OAAO;AAAA,QACvD,eAA6B,eAAe,EAAE;AAAA,QAC9C,eAAgC,kBAAkB,gBAAgB;AAAA,MACzE;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AC1BM,IAAM,0BAA8B,eAAe;AAAA,EACxD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,+BAA+B,EAAE,WAAU,YAAY,WAAW;AAC/E,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,mBAAmB,OAAY,QAAyB,gBAAgB;AAE9E,UAAM,YAAY,OAAiB,kBAAkB,YAAY,SAAS;AAE1E,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAC1F,UAAM,OAAO,UAAU;AAEvB,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACK,YAAY,YAAY,MAAM,IAAI;AAAA,QACvC,eAA8B,gBAAgB,WAAW;AAAA,QACzD,eAA+B,iBAAiB,OAAO;AAAA,QACvD,eAA6B,eAAe,EAAE;AAAA,QAC9C,eAAgC,kBAAkB,gBAAgB;AAAA,MACzE;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;ACzBM,IAAM,oBAAwB,eAAe;AAAA,EAClD,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,yBAAyB,EAAE,WAAU,YAAY,WAAW;AACzE,UAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,UAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,UAAM,cAAc,OAAY,QAAuB,cAAc;AACrE,UAAM,aAAa,OAAY,QAAmB,UAAU;AAE5D,UAAM,mBAAwB,GAAG,0CAA0C;AAAA,MACzE,WAAU,MAAe;AACvB,YAAI,CAAC,GAAG,aAAa,IAAI,EAAG,QAAO,OAAY,KAAK,sBAAsB;AAC1E,YAAI,KAAK,UAAU,GAAG,iBAAiB,KAAK,MAAM,EAAG,QAAO,OAAY,KAAK,yBAAyB;AAEtG,cAAM,SAAS,KAAK;AACpB,YACE,UAAU,QAAQ,GAAG,sBAAsB,MAAM,KAAK,OAAO,gBAAgB,KAC7E,QAAO,OAAY,KAAK,gCAAgC;AAE1D,cAAM,OAAO,YAAY,kBAAkB,IAAI;AAC/C,eAAO,WAAW,iBAAiB,MAAM,IAAI;AAE7C,eAAO;AAAA,MACT;AAAA,IACF;AAEA,UAAM,YAAY,OAAO;AAAA,MACvB,QAAQ,wBAAwB,YAAY,SAAS;AAAA,MACvCC,KAAI,gBAAgB;AAAA,MAC7B;AAAA,MACA;AAAA,IACP;AACA,QAAWC,QAAO,SAAS,EAAG,QAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAE1F,UAAM,yBAAyB,QAAQ;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAEL,WAAO;AAAA,MACL,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAO;AAAA,QACA,IAAI,aAAY;AACnB,gBAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,gBAAM,YAAY,QAAQ;AAAA,YACxB;AAAA,YACA,QAAQ,+BAA+B,UAAU,KAAK;AAAA,UACxD;AAEA,wBAAc,YAAY,YAAY,UAAU,OAAO,SAAS;AAAA,QAClE,CAAC;AAAA,QACI,eAA6B,eAAe,EAAE;AAAA,QAC9C,eAA8B,gBAAgB,WAAW;AAAA,MAChE;AAAA,IACF;AAAA,EACF,CAAC;AACH,CAAC;;;AClEM,IAAM,eAAmB,eAAe;AAAA,EAC7C,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAY,GAAG,oBAAoB,EAAE,WAAU,YAAY,WAAW;AACpE,QAAI,UAAU,MAAM,UAAU,QAAQ,GAAG;AACvC,aAAO,OAAY,KAAK,IAAQ,2BAA2B,CAAC;AAAA,IAC9D;AAEA,WAAQ;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,OAAY,IAAI,aAAY;AAC1B,cAAM,gBAAgB,OAAY,QAAsB,aAAa;AAErE,sBAAc,WAAW,YAAY,UAAU,KAAK,OAAO;AAC3D,sBAAc,WAAW,YAAY,UAAU,KAAK,GAAG;AAAA,MACzD,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH,CAAC;;;ACFM,IAAM,YAAY;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;AClCO,IAAM,mBAAmB,CAC9B,YACA,UACA,gBACA,iBACA,cACA,oBAEK,IAAI,aAAY;AACnB,QAAM,KAAK,OAAY,QAAsB,aAAa;AAC1D,QAAM,UAAU,OAAY,QAAwB,eAAe;AACnE,QAAM,aAAa,OAAY,QAAmB,UAAU;AAC5D,QAAM,sBAAgD,CAAC;AAEvD,QAAM,OAAO,QAAQ,kCAAkC,YAAY,QAAQ;AAC3E,MAAI,QAAQ,GAAG,aAAa,IAAI,GAAG;AACjC,UAAM,gBAAgB,GAAG,OAAO,IAAI;AACpC,UAAM,cAAc,KAAK;AACzB,QAAI,GAAG,mBAAmB,WAAW,KAAK,YAAY,SAAS,MAAM;AACnE,YAAM,iBAAiB,OAAO;AAAA,QACvBC,KAAI,WAAW,kBAAkB,WAAW,GAAG,CAAC,MAAM,CAAC,EAAE,gBAAgB,CAAC;AAAA,QAC1EC,QAAO,MAAWD,KAAI,WAAW,qBAAqB,WAAW,GAAG,CAAC,MAAM,CAAC,EAAE,gBAAgB,CAAC,CAAC;AAAA,QAChGC,QAAO,MAAWD,KAAI,WAAW,iBAAiB,WAAW,GAAG,CAAC,MAAM,CAAC,EAAE,gBAAgB,CAAC,CAAC;AAAA,QAC5FC;AAAA,UAAO,MACLD,KAAI,WAAW,yBAAyB,WAAW,GAAG,CAAC,MAAM,CAAC,EAAE,kBAAkB,EAAE,gBAAgB,CAAC;AAAA,QAC5G;AAAA,QACKC;AAAA,UAAO,MACLD,KAAI,WAAW,yBAAyB,WAAW,GAAG,CAAC,MAAM,CAAC,EAAE,kBAAkB,EAAE,gBAAgB,CAAC;AAAA,QAC5G;AAAA,QACKC,QAAO,MAAWD,KAAI,WAAW,uBAAuB,WAAW,GAAG,CAAC,MAAM,CAAC,EAAE,gBAAgB,CAAC,CAAC;AAAA,QAClGC,QAAO,MAAWD,KAAI,WAAW,uBAAuB,WAAW,GAAG,CAAC,MAAM,CAAC,EAAE,gBAAgB,CAAC,CAAC;AAAA,QAClGC;AAAA,UAAO,MACLD;AAAA,YACH,WAAW,2BAA2B,WAAW;AAAA,YACjD,CAAC,MAAM,CAAC,EAAE,kBAAkB,EAAE,gBAAgB;AAAA,UAChD;AAAA,QACF;AAAA,QACK;AAAA,MACP;AACA,UAAWE,QAAO,cAAc,GAAG;AACjC,mBAAW,oBAAoB,eAAe,OAAO;AACnD,cAAI,CAAC,iBAAkB;AACvB,gBAAM,WAAW,WAAW,KAAK,MAAM,iBAAiB,KAAK,iBAAiB,GAAG;AACjF,gBAAM,YAAY,SAAS,YAAY,aAAa;AACpD,cAAI,cAAc,IAAI;AACpB,gCAAoB,KAAK;AAAA,cACvB,UAAU,WAAW;AAAA,cACrB,UAAU;AAAA,gBACR,OAAO,iBAAiB,MAAM;AAAA,gBAC9B,QAAQ,cAAc;AAAA,cACxB;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO,oBAAoB,WAAW,IAAI,kBAAkB,oBAAoB,OAAO,mBAAmB,CAAC,CAAC;AAC9G,CAAC;;;ACzCH,IAAM,mBAAmB;AAEzB,IAAM,OAAO,CACX,YAGG;AAKH,QAAM,wBAAwB,YAAY,IAAI,CAAC,eAAe,WAAW,IAAI;AAC7E,MAAI;AACF;AAAC,IAAC,QAAQ,WAAmB,QAAQ,gBAAgB;AAAA,MACnD,YAAY;AAAA,MACZ,gBAAgB,MAAM;AAAA,IACxB,CAAC;AAAA,EAEH,SAAS,GAAG;AAAA,EAAC;AAEb,MAAI,+BAC2B,MAAM,CAAC,CAAC;AAEvC,WAAS,uBAAuB,QAAa;AAC3C,mCAA4D,MAAM,MAAM;AAAA,EAC1E;AAEA,WAAS,OAAO,MAAkC;AAChD,UAAM,kBAAkB,KAAK;AAC7B,mCAA4D,MAAM,KAAK,MAAM;AAG7E,QAAK,gBAAwB,gBAAgB,EAAG,QAAO;AAEvD,SAAK,QAAQ,IAAI,qCAAqC;AAGtD,UAAM,QAA4B,uBAAO,OAAO,IAAI;AACnD,IAAC,MAAc,gBAAgB,IAAI;AACpC,eAAW,KAAK,OAAO,KAAK,eAAe,GAAsC;AAE/E,YAAM,CAAC,IAAI,IAAIC,UAAoB,gBAAgB,CAAC,EAAG,MAAM,iBAAiBA,KAAI;AAAA,IACpF;AAIA,aAAS,QAAQ,SAAqB;AACpC,aAAO,CACL,OAYA;AAAA,QACE;AAAA,QACWC;AAAA,QACMA;AAAA,QACD;AAAA,QACX,eAA8B,gBAAgB,QAAQ,eAAe,CAAC;AAAA,QACtE,eAA6B,mBAAmB,OAAO;AAAA,QACvD,eAA6B,eAAe,QAAQ,UAAU;AAAA,QAC9D;AAAA,UAC0B;AAAA,UAC7B;AAAA,QACF;AAAA,QACK;AAAA,MACP;AAAA,IACJ;AAEA,UAAM,yBAAyB,oBAAI,IAGjC;AACF,UAAM,kCAAkC,CAAC,aAAqB;AAC5D,YAAM,UAAU,gBAAgB,WAAW;AAC3C,aAAO,uBAAuB,OAAO,GAAG;AACtC,cAAM,SAAS,uBAAuB,KAAK,EAAE,KAAK,EAAE;AACpD,YAAI,OAAQ,wBAAuB,OAAO,MAAM;AAAA,MAClD;AACA,UAAI,6BAA6B,eAAe,SAAS;AACvD,+BAAuB,OAAO,QAAQ;AACtC,cAAM,aAAa,QAAQ,cAAc,QAAQ;AAEjD,YAAI,YAAY;AACd,iBAAO;AAAA,YACD,oCAAoC,aAAa,UAAU;AAAA,YAC/D,QAAQ,OAAO;AAAA,YACR,IAAI,CAAC,EAAE,WAAW,aAAAC,aAAY,MAAM;AACzC,qCAAuB,IAAI,UAAU,SAAS;AAC9C,qBAAOA;AAAA,YACT,CAAC;AAAA,YACM,UAAU,MAAM,CAAC,CAAC;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AACA,aAAO,CAAC;AAAA,IACV;AAEA,UAAM,yBAAyB,CAAC,aAAaF,UAAS;AACpD,YAAM,wBAAwB,gBAAgB,uBAAuB,UAAU,GAAGA,KAAI;AACtF,aAAW,kBAAkB,gCAAgC,QAAQ,GAAG,qBAAqB;AAAA,IAC/F;AAEA,UAAM,wBAAwB,IAAIA,UAChC,gBAAgB,sBAAsB,GAAGA,KAAI,EAAE;AAAA,MAC7C,sBAAsB,IAAI,CAAC,MAAM,KAAK,CAAC;AAAA,IACzC;AAEF,UAAM,yBAAyB,CAC7B,UACA,OACA,KACA,YACA,eACA,gBACGA,UACA;AACH,YAAM,sBAAsB,gBAAgB;AAAA,QAC1C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAGA;AAAA,MACL;AACA,YAAM,UAAU,gBAAgB,WAAW;AAE3C,UAAI,6BAA6B,eAAe,SAAS;AACvD,cAAM,aAAa,QAAQ,cAAc,QAAQ;AAEjD,YAAI,YAAY;AACd,iBAAO;AAAA,YACA,KAAK,MAAM;AACd,oBAAM,kBAA2C,CAAC;AAGlD,kBAAI,CAAC,uBAAuB,IAAI,QAAQ,GAAG;AACzC,gDAAgC,QAAQ;AAAA,cAC1C;AACA,oBAAM,mBAAmB,uBAAuB,IAAI,QAAQ,KAAK,CAAC,GAAG;AAAA,gBAAO,CAAC,MAC3E,EAAE,UAAU,SAAS,EAAE,QAAQ,OAAO,WAAW,QAAQ,EAAE,IAAI,IAAI;AAAA,cACrE;AAEA,oBAAM,gBAAgB,QAAQ,WAAW,WAAW;AAAA,gBAClD;AAAA,gBACA,KAAK;AAAA,cACP;AAEA,yBAAW,iBAAiB,iBAAiB;AAC3C,sBAAM,UAAU,QAAQ,WAAW,YAAY,cAAc;AAAA,kBAC3D;AAAA,oBACE;AAAA,oBACA,MAAM,KAAK;AAAA,oBACX,aAAa,eAAe,CAAC;AAAA,kBAC/B;AAAA,kBACA,CAAC,kBACC;AAAA,oBACE,cAAc;AAAA,oBACT,eAA6B,eAAe,aAAa;AAAA,oBACzD;AAAA,kBACP;AAAA,gBACJ;AACA,gCAAgB,KAAK;AAAA,kBACnB,SAAS,cAAc;AAAA,kBACvB,aAAa,cAAc;AAAA,kBAC3B;AAAA,gBACF,CAAC;AAAA,cACH;AAEA,qBAAO;AAAA,YACT,CAAC;AAAA,YACIG;AAAA,cAAQ,CAAC,oBACZ;AAAA,gBACE;AAAA,kBACE;AAAA,kBACA,KAAK;AAAA,kBACL;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF;AAAA,gBACKC,KAAI,CAAC,sBAAsB,gBAAgB,OAAO,iBAAiB,CAAC;AAAA,cAC3E;AAAA,YACF;AAAA,YACA,QAAQ,OAAO;AAAA,YACR,UAAU,MAAM,mBAAmB;AAAA,UAC5C;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,yBAAyB,IAAIJ,UAAS;AAC1C,YAAM,sBAAsB,gBAAgB,uBAAuB,GAAGA,KAAI;AAC1E,YAAM,CAAC,UAAU,eAAe,IAAIA;AACpC,YAAM,UAAU,gBAAgB,WAAW;AAE3C,UAAI,SAAS;AACX,cAAM,aAAa,QAAQ,cAAc,QAAQ;AACjD,YAAI,YAAY;AACd,iBAAO;AAAA,YACD,uBAAuB,WAAW,YAAY,eAAe;AAAA,YACjE,QAAQ,OAAO;AAAA,YACR,IAAI,CAAC,oBAAoB,oBAAoB,OAAO,eAAe,CAAC;AAAA,YACpE,UAAU,MAAM,mBAAmB;AAAA,UAC5C;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,UAAM,sBAAsB,CAC1B,UACA,eACA,iBACA,cACA,YACA,gBACGA,UACA;AACH,YAAM,UAAU,gBAAgB,WAAW;AAC3C,UAAI,SAAS;AACX,cAAM,aAAa,QAAQ,cAAc,QAAQ;AACjD,YAAI,YAAY;AACd,gBAAM,SAAS;AAAA,YACR,IAAI,aAAY;AACnB,oBAAM,qBAAqB,OAAW;AAAA,gBACpC;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,cACF;AAEA,oBAAM,gBAAgB,QAAQ,WAAW,WAAW;AAAA,gBAClD;AAAA,gBACA,KAAK;AAAA,cACP;AAEA,oBAAM,QAAQ,QAAQ,WAAW,YAAY,cAAc;AAAA,gBACzD;AAAA,kBACE;AAAA,kBACA,MAAM,KAAK;AAAA,kBACX,aAAa,eAAe,CAAC;AAAA,gBAC/B;AAAA,gBACA,CAAC,kBACC;AAAA,kBACE,mBAAmB;AAAA,kBACd,eAA6B,eAAe,aAAa;AAAA,kBACzD;AAAA,gBACP;AAAA,cACJ;AAEA,qBAAO,EAAE,MAAM;AAAA,YACjB,CAAC;AAAA,YACD,QAAQ,OAAO;AAAA,UACjB;AAEA,cAAWK,SAAQ,MAAM,EAAG,QAAO,OAAO;AAAA,QAC5C;AAAA,MACF;AAEA,aAAO,gBAAgB;AAAA,QACrB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAGL;AAAA,MACL;AAAA,IACF;AAEA,UAAM,yBAAyB,CAAC,UAAU,aAAaA,UAAS;AAC9D,YAAM,sBAAsB,gBAAgB,uBAAuB,UAAU,UAAU,GAAGA,KAAI;AAE9F,UAAI,6BAA6B,WAAW;AAC1C,cAAM,UAAU,gBAAgB,WAAW;AAC3C,YAAI,SAAS;AACX,gBAAM,aAAa,QAAQ,cAAc,QAAQ;AACjD,cAAI,YAAY;AACd,mBAAO;AAAA,cACL;AAAA,gBACE;AAAA,gBACA;AAAA,gBACA;AAAA,cACF;AAAA,cACA,QAAQ,OAAO;AAAA,cACR,UAAU,MAAM,mBAAmB;AAAA,YAC5C;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,2BAA2B,CAAC,UAAU,UAAU,SAAS,uBAAuBA,UAAS;AAC7F,YAAM,wBAAwB,gBAAgB;AAAA,QAC5C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAGA;AAAA,MACL;AAEA,UAAI,6BAA6B,aAAa;AAC5C,cAAM,UAAU,gBAAgB,WAAW;AAC3C,YAAI,SAAS;AACX,gBAAM,aAAa,QAAQ,cAAc,QAAQ;AACjD,cAAI,YAAY;AACd,mBAAO;AAAA,cACL,gCAAgC,YAAY,qBAAqB;AAAA,cAC5DG;AAAA,gBAAQ,CAAC,yBACZ;AAAA,kBACM;AAAA,oBACF;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA;AAAA,kBACF;AAAA,kBACKC;AAAA,oBAAI,CAAC,sBAAuB,uBAC7B;AAAA,sBACA,GAAG;AAAA,sBACH,SAAS,kBAAkB,OAAO,qBAAqB,OAAO;AAAA,oBAChE,IACG,kBAAkB,SAAS,IAC3B;AAAA,sBACC,SAAS;AAAA,sBACT,oBAAoB;AAAA,sBACpB,oBAAoB;AAAA,sBACpB,yBAAyB;AAAA,oBAC3B,IACA;AAAA,kBACJ;AAAA,gBACF;AAAA,cACF;AAAA,cACA,QAAQ,OAAO;AAAA,cACR,UAAU,MAAM,qBAAqB;AAAA,YAC9C;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,4BAA4B,CAChC,UACA,UACA,WACA,eACA,QACA,aACA,UACGJ,UACA;AACH,YAAM,mCAAmC,gBAAgB;AAAA,QACvD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAGA;AAAA,MACL;AAEA,UAAI,6BAA6B,aAAa;AAC5C,cAAM,UAAU,gBAAgB,WAAW;AAC3C,YAAI,SAAS;AACX,gBAAM,aAAa,QAAQ,cAAc,QAAQ;AACjD,cAAI,YAAY;AACd,mBAAO;AAAA,cACL;AAAA,gBACE;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,KAAK;AAAA,cACP;AAAA,cACA,QAAQ,OAAO;AAAA,cACR,UAAU,MAAM,gCAAgC;AAAA,YACzD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,4BAA4B,CAAC,UAAU,aAAaA,UAAS;AACjE,YAAM,uBAAuB,gBAAgB,0BAA0B,UAAU,UAAU,GAAGA,KAAI;AAElG,UAAI,6BAA6B,MAAM;AACrC,cAAM,UAAU,gBAAgB,WAAW;AAC3C,YAAI,SAAS;AACX,gBAAM,aAAa,QAAQ,cAAc,QAAQ;AACjD,cAAI,YAAY;AACd,mBAAO;AAAA,cACL,KAAK,sBAAsB,YAAY,QAAQ;AAAA,cAC/C,QAAQ,OAAO;AAAA,cACR,UAAU,MAAM,oBAAoB;AAAA,YAC7C;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,oBAAoB,CAAC,UAAU,MAAM,gBAAgBA,UAAS;AAClE,YAAM,uBAAuB,gBAAgB,kBAAkB,UAAU,MAAM,aAAa,GAAGA,KAAI;AAEnG,UAAI,6BAA6B,QAAQ;AACvC,cAAM,UAAU,gBAAgB,WAAW;AAC3C,YAAI,SAAS;AACX,gBAAM,aAAa,QAAQ,cAAc,QAAQ;AACjD,cAAI,YAAY;AACd,mBAAO;AAAA,cACL,kBAAkB,YAAY,MAAM,aAAa,oBAAoB;AAAA,cACrE,QAAQ,OAAO;AAAA,cACR,UAAU,MAAM,oBAAoB;AAAA,YAC7C;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,sBAAsB,CAAC,UAAU,UAAU,eAAe,gBAAgB,oBAAoBA,UAAS;AAC3G,YAAM,uBAAuB,gBAAgB;AAAA,QAC3C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAGA;AAAA,MACL;AAEA,UAAI,6BAA6B,SAAS;AACxC,cAAM,UAAU,gBAAgB,WAAW;AAC3C,YAAI,SAAS;AACX,gBAAM,aAAa,QAAQ,cAAc,QAAQ;AACjD,cAAI,YAAY;AACd,mBAAO;AAAA,cACL;AAAA,gBACE;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,cACF;AAAA,cACA,QAAQ,OAAO;AAAA,cACR,UAAU,MAAM,oBAAoB;AAAA,YAC7C;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,6BAGF;AAAA,MACF,0BAA0B,CAAC,QAAQ;AACjC,cAAM,EAAE,WAAW,MAAM,KAAK,IAAI,IAAI;AACtC,cAAM,iBAAiB,QAAQ,WAAW,OAAO,iBAAiB,IAAI;AAEtE,cAAM,iBAAiB,KAAK,QAAQ;AACpC,cAAM,aAAa,eAAe,+BAA+B,cAAc;AAC/E,YAAI,YAAY;AACd,gBAAM,gBAAgB,WAAW,kBAAkB;AACnD,cAAI,eAAe;AACjB,kBAAM,UAAU,cAAc,mBAAmB,EAAE,WAAW;AAC9D,gBAAI,SAAS;AACX,oBAAM,aAAa,cAAc,cAAc,WAAW,IAAI;AAC9D,kBAAI,YAAY;AACd,uBAAO;AAAA,kBACL,uBAAuB,YAAY,MAAM,SAAS;AAAA,kBAC7CI,KAAI,CAAC,cAAc;AAAA,oBACtB,UAAU;AAAA,sBACR,SAAS;AAAA,sBACT,GAAG;AAAA,oBACL;AAAA,kBACF,EAAE;AAAA,kBACF,QAAQ,OAAO;AAAA,kBACR,UAAU,CAAC,OAAO;AAAA,oBACvB,UAAU;AAAA,sBACR,SAAS;AAAA,sBACT,OAAO,EAAE;AAAA,oBACX;AAAA,kBACF,EAAE;AAAA,gBACJ;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,eAAO;AAAA,UACL,UAAU;AAAA,YACR,SAAS;AAAA,YACT,OAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,SAAS;AAChB,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,0BAA0B,GAAG;AACrE,YAAI;AACF,eAAK,QAAQ,mBAAmB,KAAK,KAAK;AAAA,QAC5C,SAAS,GAAG;AACV,eAAK,QAAQ,IAAI,+CAA+C,MAAM,qCAAqC,CAAC;AAAA,QAC9G;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,SAAO,EAAE,QAAQ,uBAAuB;AAC1C;AAEA,OAAO,UAAU;","names":["isFunction","input","dual","arity","body","arguments","apply","self","RangeError","a","b","length","c","d","e","args","identity","a","constant","value","constTrue","constFalse","constUndefined","constant","undefined","pipe","a","ab","bc","cd","de","ef","fg","gh","hi","arguments","length","ret","i","make","isEquivalent","self","that","array","item","make","self","that","length","i","isEq","globalStoreId","globalStore","globalValue","id","compute","globalThis","Map","has","set","get","isString","input","isNumber","isBoolean","isFunction","isFunction_","isRecordOrArray","input","isObject","isFunction","hasProperty","dual","self","property","isTagged","tag","isRecord","input","isRecordOrArray","Array","isArray","getBugErrorMessage","message","GenKindTypeId","Symbol","for","GenKindImpl","value","constructor","_F","identity","_R","_","_O","_E","GenKindTypeId","Symbol","iterator","SingleShotGen","self","called","next","a","done","return","throw","e","MUL_HI","MUL_LO","YieldWrapTypeId","Symbol","for","YieldWrap","constructor","value","structuralRegionState","globalValue","enabled","tester","undefined","standard","effect_internal_function","body","forced","isNotOptimizedAway","Error","stack","includes","internalCall","genConstructor","constructor","randomHashCache","globalValue","Symbol","for","WeakMap","symbol","hash","self","structuralRegionState","enabled","number","string","toString","String","Date","toISOString","URL","href","isHash","random","Error","has","set","Math","floor","Number","MAX_SAFE_INTEGER","get","combine","b","optimize","n","u","hasProperty","Infinity","h","str","i","length","charCodeAt","structureKeys","o","keys","pipe","structure","Object","array","arr","cached","arguments","defineProperty","value","enumerable","symbol","Symbol","for","equals","arguments","length","self","compareBoth","that","selfType","isEqual","hash","structuralRegionState","enabled","tester","Date","toISOString","URL","href","Array","isArray","every","v","i","Object","getPrototypeOf","prototype","keysSelf","keys","keysThat","key","u","hasProperty","equivalence","NodeInspectSymbol","Symbol","for","toJSON","x","hasProperty","isFunction","length","Array","isArray","map","redact","format","JSON","stringify","BaseProto","toString","Class","stringifyCircular","obj","whitespace","cache","retVal","JSON","stringify","_key","value","includes","undefined","push","redactableState","fiberRefs","isRedactable","symbolRedactable","Symbol","for","u","globalValue","redact","u","isRedactable","redactableState","fiberRefs","undefined","symbolRedactable","pipeArguments","self","args","length","ret","i","len","OP_COMMIT","OP_FAILURE","OP_WITH_RUNTIME","moduleVersion","getCurrentVersion","EffectTypeId","Symbol","for","StreamTypeId","SinkTypeId","ChannelTypeId","effectVariance","_R","_","_E","_A","_V","version","getCurrentVersion","sinkVariance","_In","_L","channelVariance","_Env","_InErr","_InElem","_InDone","_OutErr","_OutElem","_OutDone","EffectPrototype","symbol","that","cached","random","iterator","SingleShotGen","YieldWrap","pipe","pipeArguments","arguments","StructuralPrototype","structure","selfKeys","Object","keys","thatKeys","length","key","equals","CommitPrototype","_op","OP_COMMIT","StructuralCommitPrototype","TypeId","Symbol","for","CommonProto","EffectPrototype","_A","_","NodeInspectSymbol","toJSON","toString","format","SomeProto","Object","assign","create","_tag","_op","symbol","that","isOption","isSome","equals","value","cached","combine","hash","_id","NoneHash","Hash","NoneProto","isNone","input","hasProperty","fa","none","some","a","TypeId","Symbol","for","CommonProto","EffectPrototype","_R","_","NodeInspectSymbol","toJSON","toString","format","RightProto","Object","assign","create","_tag","_op","symbol","that","isEither","isRight","equals","right","combine","hash","_id","LeftProto","isLeft","left","input","hasProperty","ma","a","right","left","isLeft","isRight","map","dual","self","f","isRight","right","left","getOrElse","dual","self","onLeft","isLeft","left","right","isNonEmptyArray","self","length","make","compare","self","that","string","number","mapInput","dual","self","f","make","b1","b2","none","some","isNone","isSome","getOrElse","dual","self","onNone","isNone","value","orElse","that","fromNullable","nullableValue","none","some","getOrUndefined","getOrElse","constUndefined","map","dual","self","f","isNone","none","some","value","map","dual","self","f","out","key","keys","keys","self","Object","fromIterable","collection","Array","isArray","from","append","dual","self","last","appendAll","that","fromIterable","concat","isArray","Array","isEmptyArray","self","length","isEmptyReadonlyArray","isNonEmptyReadonlyArray","isNonEmptyArray","isOutOfBounds","i","as","length","get","dual","self","index","i","Math","floor","isOutOfBounds","none","some","unsafeGet","Error","head","get","headNonEmpty","unsafeGet","tailNonEmpty","self","slice","reverse","self","Array","from","sort","dual","O","out","containsWith","isEquivalent","dual","self","a","i","_equivalence","Equal","equivalence","intersectionWith","isEquivalent","has","containsWith","dual","self","that","fromIterable","filter","a","intersection","_equivalence","empty","map","dual","self","f","flatMap","isEmptyReadonlyArray","out","i","length","inner","j","push","flatten","identity","filter","dual","self","predicate","as","fromIterable","out","i","length","push","partition","left","right","reduce","dual","self","b","f","fromIterable","a","i","every","dual","self","refinement","dedupeWith","dual","self","isEquivalent","input","fromIterable","isNonEmptyReadonlyArray","out","headNonEmpty","rest","tailNonEmpty","r","every","a","push","dedupe","equivalence","SingleShotGen","fn","symbol","right","left","flatMap","map","args","orElse","arr","cont","cached","some","none","args","map","isFunction","flatMap","map","none","some","isNone","isSome","typeNode","diagnostics","refactors","map","refactor","completions","node","match","flatMap","codegens","codegen","createString","map","nanoLayer","flatMap","type","make","cached","symbol","standard","nanoLayer","make","symbol","flatMap","map","orElse","isSome","unnecessaryEffectGen","args","type","accessors","service","className","atLocation","flatMap","orElse","type","map","symbol","parse","accessors","hash","parse","map","orElse","match","string","isSome","args","TypeId","Symbol","for","copy","src","srcPos","dest","destPos","len","i","Math","min","length","emptyArray","getEquivalence","isEquivalent","make","self","that","toReadonlyArray","every","value","unsafeGet","_equivalence","equals","ChunkProto","_A","_","toString","format","toJSON","_id","values","map","NodeInspectSymbol","symbol","isChunk","cached","array","iterator","backing","_tag","pipe","pipeArguments","arguments","makeChunk","chunk","Object","create","depth","left","right","max","_empty","u","hasProperty","empty","as","unsafeFromNonEmptyArray","of","a","fromIterable","unsafeFromArray","copyToArray","initial","j","toReadonlyArray_","self","backing","_tag","emptyArray","array","arr","Array","length","copyToArray","left","_empty","right","depth","toReadonlyArray","reverseChunk","makeChunk","reverse","unsafeFromArray","unsafeFromArray","self","length","empty","of","makeChunk","_tag","array","unsafeFromNonEmptyArray","unsafeGet","dual","index","backing","Error","a","left","right","chunk","offset","prepend","dual","self","elem","appendAll","of","appendAll","dual","self","that","backing","_tag","diff","depth","Math","abs","makeChunk","left","right","nr","nrr","nl","nll","isEmpty","self","length","isNonEmpty","unsafeHead","self","unsafeGet","headNonEmpty","SIZE","BUCKET_SIZE","Math","pow","MASK","MAX_INDEX_NODE","MIN_ARRAY_NODE","popcount","x","hashFragment","shift","h","MASK","toBitmap","fromBitmap","bitmap","bit","make","value","previous","arrayUpdate","mutate","at","v","arr","out","len","length","Array","i","arraySpliceOut","newLen","g","arraySpliceIn","EmptyNode","_tag","modify","edit","_shift","f","hash","key","size","v","none","isNone","value","LeafNode","isEmptyNode","a","isTagged","isLeafNode","node","canEditNode","constructor","shift","equals","mergeLeaves","CollisionNode","children","canEdit","list","updateCollisionList","length","mutate","len","i","child","newValue","arraySpliceOut","arrayUpdate","IndexedNode","mask","frag","hashFragment","bit","toBitmap","indx","fromBitmap","exists","_newChild","SIZE","MAX_INDEX_NODE","expand","arraySpliceIn","current","bitmap","newChildren","ArrayNode","count","newChild","MIN_ARRAY_NODE","pack","removed","elements","Array","g","elem","subNodes","arr","mergeLeavesInner","h1","n1","h2","n2","subH1","subH2","stack","undefined","currentShift","res","make","final","previous","HashMapSymbolKey","HashMapTypeId","Symbol","for","HashMapProto","iterator","HashMapIterator","k","v","symbol","hash","item","pipe","combine","cached","that","isHashMap","_size","elem","getHash","isNone","equals","value","toString","format","toJSON","_id","values","Array","from","map","NodeInspectSymbol","pipeArguments","arguments","makeImpl","editable","edit","root","size","Object","create","_editable","_edit","_root","f","constructor","visitLazy","undefined","next","done","v0","applyCont","cont","visitLazyChildren","none","node","_tag","isSome","some","key","children","length","len","i","child","isEmptyNode","_empty","EmptyNode","empty","isHashMap","u","hasProperty","HashMapTypeId","getHash","Dual","dual","self","key","hash","node","_root","shift","_tag","equals","value","none","children","i","len","length","child","frag","hashFragment","bit","toBitmap","mask","fromBitmap","SIZE","set","Dual","dual","self","key","value","modifyAt","some","setTree","newRoot","newSize","_editable","_root","_size","makeImpl","_edit","keys","HashMapIterator","size","self","_size","beginMutation","self","makeImpl","_edit","_root","_size","modifyAt","Dual","dual","self","key","f","modifyHash","hash","size","value","_size","newRoot","_root","modify","_editable","_edit","NaN","pipe","setTree","forEach","Dual","dual","self","f","reduce","_","value","key","zero","root","_root","_tag","isSome","toVisit","children","pop","i","len","length","child","isEmptyNode","push","HashSetSymbolKey","HashSetTypeId","Symbol","for","HashSetProto","iterator","keys","_keyMap","symbol","cached","combine","hash","that","isHashSet","size","equals","toString","format","toJSON","_id","values","Array","from","map","NodeInspectSymbol","pipe","pipeArguments","arguments","makeImpl","keyMap","set","Object","create","u","hasProperty","_empty","HM","empty","size","self","_keyMap","beginMutation","makeImpl","endMutation","_editable","mutate","dual","f","transient","add","value","set","union","dual","self","that","mutate","empty","set","forEach","value","add","forEach","dual","self","f","_keyMap","_","k","empty","size","add","union","ArrayProto","Object","assign","create","Array","prototype","symbol","cached","array","that","isArray","length","every","v","i","equals","Structural","args","StructuralPrototype","OP_DIE","OP_EMPTY","OP_FAIL","OP_INTERRUPT","OP_PARALLEL","OP_SEQUENTIAL","CauseSymbolKey","CauseTypeId","Symbol","for","variance","_E","_","proto","symbol","pipe","hash","combine","flattenCause","cached","that","isCause","causeEquals","pipeArguments","arguments","toJSON","_tag","_id","defect","fiberId","failure","error","left","right","toString","pretty","NodeInspectSymbol","fail","error","o","Object","create","proto","_tag","OP_FAIL","parallel","left","right","o","Object","create","proto","_tag","OP_PARALLEL","sequential","OP_SEQUENTIAL","isCause","u","hasProperty","CauseTypeId","isInterruptedOnly","self","reduceWithContext","undefined","IsInterruptedOnlyCauseReducer","causeEquals","left","right","leftStack","of","rightStack","isNonEmpty","leftParallel","leftSequential","pipe","headNonEmpty","reduce","empty","parallel","sequential","cause","par","seq","evaluateCause","some","union","appendAll","rightParallel","rightSequential","equals","flattenCause","flattenCauseLoop","causes","flattened","updated","size","prepend","isEmpty","reverse","Error","getBugErrorMessage","evaluateCause","self","cause","stack","_parallel","empty","_sequential","undefined","_tag","OP_EMPTY","length","pop","OP_FAIL","add","make","error","OP_DIE","defect","OP_INTERRUPT","fiberId","OP_SEQUENTIAL","left","right","sequential","OP_PARALLEL","parallel","prepend","push","Error","getBugErrorMessage","IsInterruptedOnlyCauseReducer","emptyCase","constTrue","failCase","constFalse","dieCase","interruptCase","sequentialCase","_","left","right","parallelCase","OP_SEQUENTIAL_CASE","OP_PARALLEL_CASE","reduce","dual","self","zero","pf","accumulator","cause","causes","undefined","option","isSome","value","_tag","OP_SEQUENTIAL","push","right","left","OP_PARALLEL","length","pop","reduceWithContext","context","reducer","input","output","OP_EMPTY","emptyCase","OP_FAIL","failCase","error","OP_DIE","dieCase","defect","OP_INTERRUPT","interruptCase","fiberId","OP_SEQUENTIAL_CASE","OP_PARALLEL_CASE","either","sequentialCase","parallelCase","Error","pretty","options","isInterruptedOnly","prettyErrors","map","e","renderErrorCause","stack","join","prefix","lines","split","i","len","PrettyError","globalThis","span","constructor","originalError","originalErrorIsObject","prevLimit","stackTraceLimit","prettyErrorMessage","message","name","spanSymbol","Object","keys","forEach","key","prettyErrorStack","u","hasProperty","isFunction","prototype","toString","Array","stringifyCircular","locationRegex","spanToTrace","globalValue","WeakMap","out","startsWith","slice","includes","replace","current","stackFn","get","locationMatchAll","matchAll","match","location","getOrUndefined","parent","Symbol","for","_","unknownError","l","r","SingleShotGen","self","called","constructor","next","a","value","done","return","throw","e","Symbol","iterator","EffectTypeId","Symbol","for","EffectPrimitive","_op","effect_instruction_i0","undefined","effect_instruction_i1","effect_instruction_i2","trace","EffectTypeId","effectVariance","constructor","symbol","that","cached","random","pipe","pipeArguments","arguments","toJSON","_id","toString","format","NodeInspectSymbol","Symbol","iterator","SingleShotGen","YieldWrap","EffectPrimitiveFailure","_tag","exitIsExit","equals","string","combine","hash","cause","EffectPrimitiveSuccess","value","isEffect","u","hasProperty","withFiberRuntime","withRuntime","effect","OP_WITH_RUNTIME","originalSymbol","Symbol","for","capture","obj","span","isSome","Proxy","has","target","p","spanSymbol","originalSymbol","get","value","fail","error","isObject","spanSymbol","withFiberRuntime","fiber","failCause","capture","currentSpanFromFiber","failCause","cause","effect","EffectPrimitiveFailure","OP_FAILURE","effect_instruction_i0","logLevelAll","_tag","syslog","label","ordinal","Number","MIN_SAFE_INTEGER","pipe","pipeArguments","arguments","logLevelNone","_tag","syslog","label","ordinal","Number","MAX_SAFE_INTEGER","pipe","pipeArguments","arguments","RequestResolverSymbolKey","RequestResolverTypeId","Symbol","for","requestResolverVariance","_A","_","_R","RequestResolverImpl","runAll","target","constructor","symbol","cached","hash","random","that","isRequestResolver","equals","identified","ids","fromIterable","pipe","pipeArguments","arguments","u","hasProperty","YieldableError","globalThis","Error","commit","fail","toJSON","obj","message","cause","NodeInspectSymbol","toString","prototype","stack","split","slice","join","pretty","renderErrorCause","Object","assign","StructuralCommitPrototype","makeException","proto","tag","Base","_tag","name","RuntimeExceptionTypeId","Symbol","for","RuntimeException","InterruptedExceptionTypeId","Symbol","for","InterruptedException","makeException","IllegalArgumentExceptionTypeId","Symbol","for","IllegalArgumentException","makeException","NoSuchElementExceptionTypeId","Symbol","for","NoSuchElementException","makeException","InvalidPubSubCapacityExceptionTypeId","Symbol","for","InvalidPubSubCapacityException","makeException","ExceededCapacityExceptionTypeId","ExceededCapacityException","TimeoutExceptionTypeId","Symbol","for","TimeoutException","makeException","exitIsExit","u","isEffect","_tag","currentSpanFromFiber","fiber","span","currentSpan","undefined","_tag","some","none","Class","Structural","Error","plainArgsSymbol","Symbol","for","O","BaseEffectError","YieldableError","constructor","args","message","cause","undefined","Object","assign","defineProperty","value","enumerable","toJSON","TaggedError","tag","_tag","prototype","name","encoder","TextEncoder","encode","bytes","length","result","i","base64abc","base64abc","encode","data","replace","encodeBase64Url","input","encode","encoder","TypeId","Edge","Class","ProtoGraph","Symbol","iterator","nodes","NodeInspectSymbol","toJSON","symbol","that","isGraph","size","edges","type","nodeIndex","nodeData","has","otherNodeData","get","equals","edgeIndex","edgeData","otherEdge","hash","string","number","_id","nodeCount","edgeCount","toString","format","pipe","pipeArguments","arguments","GraphError","Data","TaggedError","missingNode","node","message","u","directed","mutate","graph","Object","create","Map","adjacency","reverseAdjacency","nextNodeIndex","nextEdgeIndex","isAcyclic","some","mutable","beginMutation","endMutation","beginMutation","graph","adjacency","Map","reverseAdjacency","nodeIndex","edges","set","mutable","Object","create","ProtoGraph","type","nodes","nextNodeIndex","nextEdgeIndex","isAcyclic","endMutation","mutate","dual","f","addNode","data","getNode","has","some","get","none","hasNode","nodeCount","size","reverse","mutable","index","edgeData","edges","set","source","target","data","adjacency","clear","reverseAdjacency","edgeIndex","sourceEdges","get","push","targetEdges","isAcyclic","none","invalidateCycleFlagOnRemoval","mutable","isSome","isAcyclic","value","none","invalidateCycleFlagOnAddition","addEdge","source","target","data","nodes","has","missingNode","edgeIndex","nextEdgeIndex","edgeData","Edge","edges","set","sourceAdjacency","adjacency","get","undefined","push","targetReverseAdjacency","reverseAdjacency","type","targetAdjacency","sourceReverseAdjacency","removeNode","nodeIndex","edgesToRemove","outgoingEdges","edge","incomingEdges","removeEdgeInternal","delete","removeEdgeInternal","mutable","edgeIndex","edge","edges","get","undefined","source","target","sourceAdjacency","adjacency","index","indexOf","splice","targetReverseAdjacency","reverseAdjacency","type","targetAdjacency","sourceReverseAdjacency","delete","neighborsDirected","graph","nodeIndex","direction","adjacencyMap","reverseAdjacency","adjacency","adjacencyList","get","undefined","result","edgeIndex","edge","edges","neighborNode","source","target","push","escapeMermaidLabel","label","replace","formatMermaidNode","nodeId","shape","toMermaid","graph","options","diagramType","direction","edgeLabel","data","String","nodeLabel","nodeShape","finalDiagramType","type","lines","push","nodeIndex","nodeData","nodes","formattedNode","edgeOperator","edgeData","edges","sourceId","source","targetId","target","join","Walker","Symbol","iterator","visit","constructor","index","data","indices","walker","_","values","entries","dfsPostOrder","graph","config","start","direction","nodeIndex","hasNode","missingNode","Walker","f","Symbol","iterator","stack","discovered","Set","finished","i","length","push","node","visitedChildren","nextMapped","current","has","add","neighbors","neighborsDirected","neighbor","nodeToEmit","pop","nodeData","getNode","isSome","done","value","undefined","next","nodes","nodeMap","entries","result","edges","edgeMap","edgeIndex","edgeData","externals","adjacencyMap","reverseAdjacency","adjacency","nodeIterator","adjacencyList","get","orElse","nodeToVisit","appendNodeToVisit","orElse","map","map","map","entries","isSome","orElse","isNone","map","orElse","sourceFile","service","map","orElse","symbol","flatMap","orElse","map","node","map","entries","map","entries","string","orElse","isSome","orElse","orElse","map","flatMap","map","orElse","args","type","orElse","hash","map","orElse","map","orElse","node","isSome","orElse","map","entries","type","map","flatMap","nodes","isSome","orElse","map","map","map","args","flatMap","map","parse","orElse","match","string","match","isNone","map","getOrElse","map","getOrElse","introducedAlias","orElse","symbol","sourceFile","orElse","map","quickInfo","quickInfo","node","map","orElse","rank","size","match","left","head","copy","node","beginMutation","orElse","addNode","endMutation","values","symbol","mutate","reverse","isSome","_","isNone","quickInfo","flatMap","orElse","quickInfo","node","isNone","node","isNone","node","isNone","node","isNone","pipeArgs","isNone","fnIdentifier","map","isNone","flatMap","map","values","number","isNone","orElse","map","isNone","isNone","node","none","some","map","newNode","isSome","isNone","isNone","node","isNone","togglePipeStyle","orElse","sourceFile","node","isNone","map","node","isNone","args","some","none","left","isSome","isNone","orElse","isNone","isNone","map","isNone","map","orElse","isSome","args","nanoLayer","diagnostics","flatMap","map","isRight"]}