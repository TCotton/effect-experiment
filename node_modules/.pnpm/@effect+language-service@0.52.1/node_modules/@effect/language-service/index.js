"use strict";

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value) => () => value;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constUndefined = /* @__PURE__ */ constant(void 0);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isFunction2 = isFunction;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && property in self);
var isTagged = /* @__PURE__ */ dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var GenKindImpl = class {
  value;
  constructor(value) {
    this.value = value;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys3) => {
  let h = 12289;
  for (let i = 0; i < keys3.length; i++) {
    h ^= pipe(string(keys3[i]), combine(hash(o[keys3[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? void 0 : cache.push(value) && (redactableState.fiberRefs !== void 0 && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = void 0;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_WITH_RUNTIME = "WithRuntime";

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.18.4";
var getCurrentVersion = () => moduleVersion;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var isLeft2 = isLeft;
var isRight2 = isRight;
var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var getOrElse = /* @__PURE__ */ dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self, that) => self === that ? 0 : compare(self, that);
var string2 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var number2 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var mapInput = /* @__PURE__ */ dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isNone2 = isNone;
var isSome2 = isSome;
var getOrElse2 = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrUndefined = /* @__PURE__ */ getOrElse2(constUndefined);
var map2 = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Record.js
var map3 = /* @__PURE__ */ dual(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
});
var keys = (self) => Object.keys(self);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Array.js
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var append = /* @__PURE__ */ dual(2, (self, last) => [...self, last]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
var get = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var tailNonEmpty = (self) => self.slice(1);
var reverse = (self) => Array.from(self).reverse();
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var containsWith = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence = /* @__PURE__ */ equivalence();
var intersectionWith = (isEquivalent) => {
  const has3 = containsWith(isEquivalent);
  return dual(2, (self, that) => fromIterable(self).filter((a) => has3(that, a)));
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence);
var empty = () => [];
var map4 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap(identity);
var filter = /* @__PURE__ */ dual(2, (self, predicate) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
});
var partition = /* @__PURE__ */ dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  const as = fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      right3.push(as[i]);
    } else {
      left3.push(as[i]);
    }
  }
  return [left3, right3];
});
var reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduce((b2, a, i) => f(b2, a, i), b));
var every = /* @__PURE__ */ dual(2, (self, refinement) => self.every(refinement));
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());

// src/core/Nano.ts
var NanoTag = class {
  constructor(key) {
    this.key = key;
  }
};
var Tag = (identifier) => new NanoTag(identifier);
var SingleShotGen2 = class _SingleShotGen {
  called = false;
  self;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var evaluate = Symbol.for("Nano.evaluate");
var contA = Symbol.for("Nano.contA");
var contE = Symbol.for("Nano.contE");
var contAll = Symbol.for("Nano.contAll");
var NanoYield = Symbol.for("Nano.yield");
var args = Symbol.for("Nano.args");
var NanoDefectException = class {
  constructor(message) {
    this.message = message;
  }
  _tag = "@effect/language-service/NanoDefectException";
};
var PrimitiveProto = {
  [Symbol.iterator]() {
    return new SingleShotGen2(this);
  }
};
var SucceedProto = {
  ...PrimitiveProto,
  _tag: "Success",
  get value() {
    return this[args];
  },
  [evaluate](fiber) {
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](this[args], fiber) : fiber.yieldWith(this);
  }
};
var succeed = (value) => {
  const nano = Object.create(SucceedProto);
  nano[args] = value;
  return nano;
};
var FailureProto = {
  ...PrimitiveProto,
  _tag: "Failure",
  get value() {
    return this[args];
  },
  [evaluate](fiber) {
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](this[args], fiber) : fiber.yieldWith(this);
  }
};
var fail = (error) => {
  const nano = Object.create(FailureProto);
  nano[args] = error;
  return nano;
};
var SuspendProto = {
  ...PrimitiveProto,
  [evaluate]() {
    return this[args]();
  }
};
var suspend = (fn2) => {
  const nano = Object.create(SuspendProto);
  nano[args] = fn2;
  return nano;
};
var NanoFiber = class {
  _stack = [];
  _yielded = void 0;
  _services = {};
  _cache = {};
  _perf = false;
  runLoop(nano) {
    let current = nano;
    while (true) {
      current = current[evaluate](this);
      if (current === NanoYield) {
        return this._yielded;
      }
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[contAll] && op[contAll](this);
      if (cont) return { [symbol3]: cont };
      if (op[symbol3]) return op;
    }
  }
  yieldWith(value) {
    this._yielded = value;
    return NanoYield;
  }
};
var timings = {};
var timingsCount = {};
var WithSpanProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const [fa, name] = this[args];
    if (!fiber._perf) return fa;
    const start = performance.now();
    timingsCount[name] = (timingsCount[name] || 0) + 1;
    return match(fa, {
      onSuccess: (_) => {
        const end = performance.now();
        timings[name] = (timings[name] || 0) + (end - start);
        return succeed(_);
      },
      onFailure: (_) => {
        const end = performance.now();
        timings[name] = (timings[name] || 0) + (end - start);
        return fail(_);
      }
    });
  }
};
var withSpan = (name) => (fa) => {
  const nano = Object.create(WithSpanProto);
  nano[args] = [fa, name];
  return nano;
};
var unsafeRun = (nano) => {
  const fiber = new NanoFiber();
  const result = fiber.runLoop(nano);
  if (result._tag === "Success") {
    return right2(result.value);
  }
  return left2(result.value);
};
var run = (nano) => {
  try {
    return unsafeRun(nano);
  } catch (e) {
    return left2(new NanoDefectException(e));
  }
};
var OnSuccessProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    fiber._stack.push(this);
    return this[args];
  }
};
var flatMap2 = dual(2, (fa, f) => {
  const nano = Object.create(OnSuccessProto);
  nano[args] = fa;
  nano[contA] = f;
  return nano;
});
var map5 = dual(2, (fa, f) => flatMap2(fa, (_) => succeed(f(_))));
var SyncProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const value = this[args]();
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](value, fiber) : fiber.yieldWith(succeed(value));
  }
};
var sync = (f) => {
  const nano = Object.create(SyncProto);
  nano[args] = f;
  return nano;
};
var void_ = succeed(void 0);
var FromIteratorProto = {
  ...PrimitiveProto,
  [contA](value, fiber) {
    const state = this[args][0].next(value);
    if (state.done) return succeed(state.value);
    fiber._stack.push(this);
    return state.value;
  },
  [evaluate](fiber) {
    return this[contA](this[args][1], fiber);
  }
};
var unsafeFromIterator = (iterator, initial) => {
  const nano = Object.create(FromIteratorProto);
  nano[args] = [iterator, initial];
  return nano;
};
var gen = (...args2) => suspend(() => unsafeFromIterator(args2[0]()));
var fn = (_) => (body) => (...args2) => withSpan(_)(suspend(() => unsafeFromIterator(body(...args2))));
var MatchProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    fiber._stack.push(this);
    return this[args];
  }
};
var match = (fa, opts) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = opts.onSuccess;
  nano[contE] = opts.onFailure;
  return nano;
};
var orElse2 = (f) => (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : f(_);
  return nano;
};
var firstSuccessOf = (arr) => arr.slice(1).reduce((arr2, fa) => orElse2(() => fa)(arr2), arr[0]);
var ProvideServiceProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const prevServices = fiber._services;
    const [fa, tag, value] = this[args];
    fiber._services = {
      ...fiber._services,
      [tag.key]: value
    };
    return match(fa, {
      onSuccess: (_) => {
        fiber._services = prevServices;
        return succeed(_);
      },
      onFailure: (_) => {
        fiber._services = prevServices;
        return fail(_);
      }
    });
  }
};
var provideService = (tag, value) => (fa) => {
  const nano = Object.create(ProvideServiceProto);
  nano[args] = [fa, tag, value];
  return nano;
};
var ServiceProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const tag = this[args];
    if (tag.key in fiber._services) {
      const value = fiber._services[tag.key];
      const cont2 = fiber.getCont(contA);
      return cont2 ? cont2[contA](value, fiber) : fiber.yieldWith(succeed(value));
    }
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](tag, fiber) : fiber.yieldWith(fail(new NanoDefectException(`Service ${tag.key} not found`)));
  }
};
var service = (tag) => {
  const nano = Object.create(ServiceProto);
  nano[args] = tag;
  return nano;
};
var CachedProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const [fa, type, key] = this[args];
    const cache = fiber._cache[type] || /* @__PURE__ */ new WeakMap();
    fiber._cache[type] = cache;
    const cached2 = cache.get(key);
    if (cached2) return cached2;
    return match(fa, {
      onSuccess: (_) => {
        cache.set(key, succeed(_));
        return succeed(_);
      },
      onFailure: (_) => {
        cache.set(key, fail(_));
        return fail(_);
      }
    });
  }
};
function cachedBy(fa, type, lookupKey) {
  return (...p) => {
    const nano = Object.create(CachedProto);
    nano[args] = [fa(...p), type, lookupKey(...p)];
    return nano;
  };
}
var option = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = (_) => succeed(some2(_));
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : succeed(none2());
  return nano;
};
var ignore = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = (_) => void_;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : void_;
  return nano;
};
var all = fn("all")(
  function* (...args2) {
    const results = [];
    for (const fa of args2) {
      const result = yield* fa;
      results.push(result);
    }
    return results;
  }
);

// src/core/LanguageServicePluginOptions.ts
var LanguageServicePluginOptions = Tag("PluginOptions");
function isValidSeverityLevel(value) {
  return value === "off" || value === "error" || value === "warning" || value === "message" || value === "suggestion";
}
function parseDiagnosticSeverity(config) {
  if (!isRecord(config)) return {};
  return Object.fromEntries(
    pipe(
      Object.entries(config),
      filter(([key, value]) => isString(key) && isString(value)),
      map4(([key, value]) => [String(key).toLowerCase(), String(value).toLowerCase()]),
      filter(([_, value]) => isValidSeverityLevel(value))
    )
  );
}
var defaults = {
  refactors: true,
  diagnostics: true,
  diagnosticSeverity: {},
  diagnosticsName: true,
  missingDiagnosticNextLine: "warning",
  quickinfo: true,
  quickinfoEffectParameters: "whentruncated",
  quickinfoMaximumLength: -1,
  completions: true,
  goto: true,
  inlays: true,
  allowedDuplicatedPackages: [],
  namespaceImportPackages: [],
  topLevelNamedReexports: "ignore",
  barrelImportPackages: [],
  importAliases: {},
  renames: true,
  noExternal: false,
  keyPatterns: [{
    target: "service",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }, {
    target: "custom",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }],
  extendedKeyDetection: false,
  pipeableMinArgCount: 1
};
function parseKeyPatterns(patterns) {
  const result = [];
  for (const entry of patterns) {
    if (!isObject(entry)) continue;
    result.push({
      target: hasProperty(entry, "target") && isString(entry.target) && ["service", "error", "custom"].includes(entry.target.toLowerCase()) ? entry.target.toLowerCase() : "service",
      pattern: hasProperty(entry, "pattern") && isString(entry.pattern) && ["package-identifier", "default", "default-hashed"].includes(entry.pattern.toLowerCase()) ? entry.pattern.toLowerCase() : "default",
      skipLeadingPath: hasProperty(entry, "skipLeadingPath") && isArray(entry.skipLeadingPath) && entry.skipLeadingPath.every(isString) ? entry.skipLeadingPath : ["src/"]
    });
  }
  return result;
}
function parse(config) {
  return {
    refactors: isObject(config) && hasProperty(config, "refactors") && isBoolean(config.refactors) ? config.refactors : defaults.refactors,
    diagnostics: isObject(config) && hasProperty(config, "diagnostics") && isBoolean(config.diagnostics) ? config.diagnostics : defaults.diagnostics,
    diagnosticSeverity: isObject(config) && hasProperty(config, "diagnosticSeverity") && isRecord(config.diagnosticSeverity) ? parseDiagnosticSeverity(config.diagnosticSeverity) : defaults.diagnosticSeverity,
    diagnosticsName: isObject(config) && hasProperty(config, "diagnosticsName") && isBoolean(config.diagnosticsName) ? config.diagnosticsName : defaults.diagnosticsName,
    missingDiagnosticNextLine: isObject(config) && hasProperty(config, "missingDiagnosticNextLine") && isString(config.missingDiagnosticNextLine) && isValidSeverityLevel(config.missingDiagnosticNextLine) ? config.missingDiagnosticNextLine : defaults.missingDiagnosticNextLine,
    quickinfo: isObject(config) && hasProperty(config, "quickinfo") && isBoolean(config.quickinfo) ? config.quickinfo : defaults.quickinfo,
    quickinfoEffectParameters: isObject(config) && hasProperty(config, "quickinfoEffectParameters") && isString(config.quickinfoEffectParameters) && ["always", "never", "whentruncated"].includes(config.quickinfoEffectParameters.toLowerCase()) ? config.quickinfoEffectParameters.toLowerCase() : defaults.quickinfoEffectParameters,
    quickinfoMaximumLength: isObject(config) && hasProperty(config, "quickinfoMaximumLength") && isNumber(config.quickinfoMaximumLength) ? config.quickinfoMaximumLength : defaults.quickinfoMaximumLength,
    completions: isObject(config) && hasProperty(config, "completions") && isBoolean(config.completions) ? config.completions : defaults.completions,
    goto: isObject(config) && hasProperty(config, "goto") && isBoolean(config.goto) ? config.goto : defaults.goto,
    inlays: isObject(config) && hasProperty(config, "inlays") && isBoolean(config.inlays) ? config.inlays : defaults.inlays,
    allowedDuplicatedPackages: isObject(config) && hasProperty(config, "allowedDuplicatedPackages") && isArray(config.allowedDuplicatedPackages) && config.allowedDuplicatedPackages.every(isString) ? config.allowedDuplicatedPackages.map((_) => _.toLowerCase()) : defaults.allowedDuplicatedPackages,
    namespaceImportPackages: isObject(config) && hasProperty(config, "namespaceImportPackages") && isArray(config.namespaceImportPackages) && config.namespaceImportPackages.every(isString) ? config.namespaceImportPackages.map((_) => _.toLowerCase()) : defaults.namespaceImportPackages,
    barrelImportPackages: isObject(config) && hasProperty(config, "barrelImportPackages") && isArray(config.barrelImportPackages) && config.barrelImportPackages.every(isString) ? config.barrelImportPackages.map((_) => _.toLowerCase()) : defaults.barrelImportPackages,
    importAliases: isObject(config) && hasProperty(config, "importAliases") && isRecord(config.importAliases) ? map3(config.importAliases, (value) => String(value)) : defaults.importAliases,
    topLevelNamedReexports: isObject(config) && hasProperty(config, "topLevelNamedReexports") && isString(config.topLevelNamedReexports) && ["ignore", "follow"].includes(config.topLevelNamedReexports.toLowerCase()) ? config.topLevelNamedReexports.toLowerCase() : defaults.topLevelNamedReexports,
    renames: isObject(config) && hasProperty(config, "renames") && isBoolean(config.renames) ? config.renames : defaults.renames,
    noExternal: isObject(config) && hasProperty(config, "noExternal") && isBoolean(config.noExternal) ? config.noExternal : defaults.noExternal,
    keyPatterns: isObject(config) && hasProperty(config, "keyPatterns") && isArray(config.keyPatterns) ? parseKeyPatterns(config.keyPatterns) : defaults.keyPatterns,
    extendedKeyDetection: isObject(config) && hasProperty(config, "extendedKeyDetection") && isBoolean(config.extendedKeyDetection) ? config.extendedKeyDetection : defaults.extendedKeyDetection,
    pipeableMinArgCount: isObject(config) && hasProperty(config, "pipeableMinArgCount") && isNumber(config.pipeableMinArgCount) ? config.pipeableMinArgCount : defaults.pipeableMinArgCount
  };
}

// src/core/TypeScriptApi.ts
var TypeScriptApi = Tag("TypeScriptApi");
var TypeScriptProgram = Tag("TypeScriptProgram");
var ChangeTracker = Tag("ChangeTracker");
function getPackageJsonInfoCache(program) {
  try {
    if (hasProperty(program, "getModuleResolutionCache") && isFunction2(program.getModuleResolutionCache)) {
      const moduleResolutionCache = program.getModuleResolutionCache();
      if (hasProperty(moduleResolutionCache, "getPackageJsonInfoCache") && isFunction2(moduleResolutionCache.getPackageJsonInfoCache)) {
        return moduleResolutionCache.getPackageJsonInfoCache();
      }
    }
  } catch (_) {
    return void 0;
  }
  return void 0;
}
function getDirectoryPath(ts, path) {
  try {
    if (hasProperty(ts, "getDirectoryPath") && isFunction2(ts.getDirectoryPath)) {
      return ts.getDirectoryPath(path);
    }
    return path;
  } catch (_) {
    return path;
  }
}
function makeGetModuleSpecifier(ts) {
  if (!(hasProperty(ts, "moduleSpecifiers") && hasProperty(ts.moduleSpecifiers, "getModuleSpecifier") && isFunction2(ts.moduleSpecifiers.getModuleSpecifier))) return;
  const _internal = ts.moduleSpecifiers.getModuleSpecifier;
  return (compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, options) => {
    return _internal(
      compilerOptions,
      importingSourceFile,
      importingSourceFileName,
      toFileName,
      host,
      options
    );
  };
}
function makeGetTemporaryModuleResolutionState(ts) {
  if (hasProperty(ts, "getTemporaryModuleResolutionState") && isFunction2(ts.getTemporaryModuleResolutionState)) {
    const _internal = ts.getTemporaryModuleResolutionState;
    return (cache, program, compilerOptions) => _internal(cache, program, compilerOptions);
  }
  return void 0;
}
function makeGetPackageScopeForPath(ts) {
  if (hasProperty(ts, "getPackageScopeForPath") && isFunction2(ts.getPackageScopeForPath)) {
    const _internal = ts.getPackageScopeForPath;
    return (path, state) => _internal(path, state);
  }
}
function makeResolvePackageNameToPackageJson(ts) {
  if (hasProperty(ts, "resolvePackageNameToPackageJson") && isFunction2(ts.resolvePackageNameToPackageJson)) {
    const _internal = ts.resolvePackageNameToPackageJson;
    return (packageName, fromFileName, compilerOptions, host) => _internal(packageName, fromFileName, compilerOptions, host);
  }
}
function makeGetEntrypointsFromPackageJsonInfo(ts) {
  if (hasProperty(ts, "getEntrypointsFromPackageJsonInfo") && isFunction2(ts.getEntrypointsFromPackageJsonInfo)) {
    const _internal = ts.getEntrypointsFromPackageJsonInfo;
    return (packageJsonInfo, compilerOptions, host) => _internal(packageJsonInfo, compilerOptions, host);
  }
}

// src/core/TypeScriptUtils.ts
var TypeScriptUtils = Tag("TypeScriptUtils");
var nanoLayer = (fa) => pipe(
  service(TypeScriptApi),
  flatMap2((ts) => pipe(fa, provideService(TypeScriptUtils, makeTypeScriptUtils(ts))))
);
function makeTypeScriptUtils(ts) {
  const getTemporaryModuleResolutionState = makeGetTemporaryModuleResolutionState(ts);
  const getPackageScopeForPath = makeGetPackageScopeForPath(ts);
  function parsePackageContentNameAndVersionFromScope(v) {
    if (!isObject(v)) return;
    if (!hasProperty(v, "packageJsonScope")) return;
    if (!v.packageJsonScope) return;
    const packageJsonScope = v.packageJsonScope;
    if (!hasProperty(packageJsonScope, "contents")) return;
    if (!hasProperty(packageJsonScope.contents, "packageJsonContent")) return;
    const packageJsonContent = packageJsonScope.contents.packageJsonContent;
    if (!hasProperty(packageJsonContent, "name")) return;
    if (!hasProperty(packageJsonScope, "packageDirectory")) return;
    if (!isString(packageJsonScope.packageDirectory)) return;
    const { name } = packageJsonContent;
    const version = hasProperty(packageJsonScope, "version") ? packageJsonScope.version : "";
    if (!isString(name)) return;
    if (!isString(version)) return;
    const hasEffectInPeerDependencies = hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) && hasProperty(packageJsonContent.peerDependencies, "effect");
    const referencedPackages = Object.keys({
      ...hasProperty(packageJsonContent, "dependencies") && isObject(packageJsonContent.dependencies) ? packageJsonContent.dependencies : {},
      ...hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) ? packageJsonContent.peerDependencies : {},
      ...hasProperty(packageJsonContent, "devDependencies") && isObject(packageJsonContent.devDependencies) ? packageJsonContent.devDependencies : {}
    });
    const exportsKeys = Object.keys(
      hasProperty(packageJsonContent, "exports") && isObject(packageJsonContent.exports) ? packageJsonContent.exports : {}
    );
    return {
      name: name.toLowerCase(),
      version: version.toLowerCase(),
      hasEffectInPeerDependencies,
      contents: packageJsonContent,
      packageDirectory: packageJsonScope.packageDirectory,
      referencedPackages,
      exportsKeys
    };
  }
  function resolveModuleWithPackageInfoFromSourceFile(program, sourceFile) {
    let packageJsonScope = parsePackageContentNameAndVersionFromScope(sourceFile);
    if (!packageJsonScope && getPackageScopeForPath && getTemporaryModuleResolutionState) {
      const packageJsonInfoCache = getPackageJsonInfoCache(program);
      const temporaryModuleResolutionState = getTemporaryModuleResolutionState(
        packageJsonInfoCache,
        program,
        program.getCompilerOptions()
      );
      const directoryPath = getDirectoryPath(ts, sourceFile.fileName);
      packageJsonScope = parsePackageContentNameAndVersionFromScope({
        ...sourceFile,
        packageJsonScope: getPackageScopeForPath(directoryPath, temporaryModuleResolutionState)
      });
    }
    return packageJsonScope;
  }
  function resolveModulePattern(program, sourceFile, pattern) {
    if (pattern.indexOf("*") === -1) return [pattern.toLowerCase()];
    const packageJsonScope = resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    const referencedPackages = [];
    for (const statement of sourceFile.statements) {
      if (ts.isImportDeclaration(statement) && ts.isStringLiteral(statement.moduleSpecifier)) {
        const moduleSpecifier = statement.moduleSpecifier.text.toLowerCase();
        const packageName = moduleSpecifier.startsWith("@") ? moduleSpecifier.split("/", 2).join("/") : moduleSpecifier.split("/", 1).join("/");
        referencedPackages.push(packageName);
      }
    }
    return pipe(
      referencedPackages.concat(packageJsonScope?.referencedPackages || []),
      dedupe,
      map4((packageName) => packageName.toLowerCase()),
      filter(
        (packageName) => pattern.endsWith("*") && packageName.startsWith(pattern.toLowerCase().substring(0, pattern.length - 1))
      )
    );
  }
  function findNodeWithLeadingCommentAtPosition(sourceFile, position) {
    const sourceText = sourceFile.text;
    let result;
    function find(node) {
      const leading = ts.getLeadingCommentRanges(sourceText, node.pos);
      if (leading) {
        for (const commentRange of leading) {
          if (commentRange.pos <= position && position < commentRange.end) {
            result = { node, commentRange };
            return;
          }
        }
      }
      if (node.pos <= position && position < node.end) {
        ts.forEachChild(node, find);
      }
    }
    find(sourceFile);
    return result;
  }
  function collectSelfAndAncestorNodesInRange(node, textRange) {
    let result = empty();
    let parent = node;
    while (parent) {
      if (parent.end >= textRange.end) {
        result = pipe(result, append(parent));
      }
      parent = parent.parent;
    }
    return result;
  }
  function findNodeAtPosition(sourceFile, position) {
    function find(node) {
      if (position >= ts.getTokenPosOfNode(node, sourceFile) && position < node.end) {
        return ts.forEachChild(node, find) || node;
      }
      return void 0;
    }
    return find(sourceFile);
  }
  function findNodeAtPositionIncludingTrivia(sourceFile, position) {
    function find(node) {
      if (position >= node.pos && position < node.end) {
        return ts.forEachChild(node, find) || node;
      }
      return void 0;
    }
    return find(sourceFile);
  }
  function getAncestorNodesInRange(sourceFile, textRange) {
    const nodeAtPosition = findNodeAtPosition(sourceFile, textRange.pos);
    if (!nodeAtPosition) return empty();
    return collectSelfAndAncestorNodesInRange(nodeAtPosition, textRange);
  }
  function getCommentAtPosition(sourceFile, pos) {
    const token = findNodeAtPositionIncludingTrivia(sourceFile, pos);
    if (token === void 0 || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || "").length) {
      return;
    }
    const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || "").length : token.pos;
    const result = ts.forEachTrailingCommentRange(sourceFile.text, startPos, isCommentInRange, pos) || ts.forEachLeadingCommentRange(sourceFile.text, startPos, isCommentInRange, pos);
    return result;
  }
  function isCommentInRange(pos, end, kind, _nl, at) {
    return at >= pos && at < end ? { pos, end, kind } : void 0;
  }
  function toTextRange(positionOrRange) {
    return typeof positionOrRange === "number" ? { end: positionOrRange, pos: positionOrRange } : positionOrRange;
  }
  function isNodeInRange(textRange) {
    return (node) => node.pos <= textRange.pos && node.end >= textRange.end;
  }
  function transformAsyncAwaitToEffectGeneratorBody(body, onAwait) {
    function visitor(_) {
      if (ts.isAwaitExpression(_)) {
        const expression = ts.visitEachChild(_.expression, visitor, ts.nullTransformationContext);
        return ts.factory.createYieldExpression(
          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
          onAwait(expression)
        );
      }
      return ts.visitEachChild(_, visitor, ts.nullTransformationContext);
    }
    return visitor(body);
  }
  function transformAsyncAwaitToEffectFn(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const fnName = node.name && ts.isIdentifier(node.name) ? node.name : ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name) && node.parent.initializer === node ? node.parent.name : void 0;
    let fnCall = ts.factory.createPropertyAccessExpression(
      ts.factory.createIdentifier(effectModuleName),
      "fn"
    );
    if (fnName) {
      fnCall = ts.factory.createCallExpression(
        fnCall,
        void 0,
        [ts.factory.createStringLiteral(ts.idText(fnName))]
      );
    }
    return tryPreserveDeclarationSemantics(
      node,
      ts.factory.createCallExpression(
        fnCall,
        void 0,
        [
          ts.factory.createFunctionExpression(
            void 0,
            ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
            void 0,
            node.typeParameters,
            node.parameters,
            void 0,
            ts.isBlock(generatorBody) ? generatorBody : ts.factory.createBlock([ts.factory.createReturnStatement(generatorBody)])
          )
        ]
      ),
      true
    );
  }
  function transformAsyncAwaitToEffectGen(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const effectGenCallExp = createEffectGenCallExpression(effectModuleName, generatorBody);
    let currentFlags = ts.getCombinedModifierFlags(node);
    currentFlags &= ~ts.ModifierFlags.Async;
    const newModifiers = ts.factory.createModifiersFromModifierFlags(currentFlags);
    if (ts.isArrowFunction(node)) {
      return ts.factory.createArrowFunction(
        newModifiers,
        node.typeParameters,
        node.parameters,
        void 0,
        node.equalsGreaterThanToken,
        effectGenCallExp
      );
    }
    const newBody = ts.factory.createBlock([
      ts.factory.createReturnStatement(effectGenCallExp)
    ]);
    if (ts.isFunctionDeclaration(node)) {
      return ts.factory.createFunctionDeclaration(
        newModifiers,
        node.asteriskToken,
        node.name,
        node.typeParameters,
        node.parameters,
        void 0,
        newBody
      );
    }
    return ts.factory.createFunctionExpression(
      newModifiers,
      node.asteriskToken,
      node.name,
      node.typeParameters,
      node.parameters,
      void 0,
      newBody
    );
  }
  function findImportedModuleIdentifier(sourceFile, test) {
    for (const statement of sourceFile.statements) {
      if (!ts.isImportDeclaration(statement)) continue;
      const importClause = statement.importClause;
      if (!importClause) continue;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) continue;
      if (ts.isNamespaceImport(namedBindings)) {
        if (test(namedBindings.name, statement.moduleSpecifier, none2())) {
          return ts.idText(namedBindings.name);
        }
      } else if (ts.isNamedImports(namedBindings)) {
        for (const importSpecifier of namedBindings.elements) {
          const importProperty = fromNullable(importSpecifier.propertyName).pipe(
            orElse(() => some2(importSpecifier.name))
          );
          if (test(importSpecifier.name, statement.moduleSpecifier, importProperty)) {
            return ts.idText(importSpecifier.name);
          }
        }
      }
    }
  }
  function findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, packageName, moduleName) {
    return findImportedModuleIdentifier(
      sourceFile,
      (_, fromModule, importProperty) => {
        if (isNone2(importProperty) && ts.isStringLiteral(fromModule) && fromModule.text === packageName + "/" + moduleName) {
          return true;
        }
        if (isSome2(importProperty) && ts.isIdentifier(importProperty.value) && ts.idText(importProperty.value) === moduleName && ts.isStringLiteral(fromModule) && fromModule.text === packageName) {
          return true;
        }
        return false;
      }
    );
  }
  function simplifyTypeNode(typeNode) {
    function collectCallable(typeNode2) {
      if (ts.isParenthesizedTypeNode(typeNode2)) return collectCallable(typeNode2.type);
      if (ts.isFunctionTypeNode(typeNode2)) {
        return some2([
          ts.factory.createCallSignature(typeNode2.typeParameters, typeNode2.parameters, typeNode2.type)
        ]);
      }
      if (ts.isTypeLiteralNode(typeNode2)) {
        const allCallSignatures = typeNode2.members.every(ts.isCallSignatureDeclaration);
        if (allCallSignatures) {
          return some2(typeNode2.members);
        }
      }
      if (ts.isIntersectionTypeNode(typeNode2)) {
        const members = typeNode2.types.map((node) => collectCallable(node));
        if (members.every(isSome2)) {
          return some2(members.map((_) => isSome2(_) ? _.value : []).flat());
        }
      }
      return none2();
    }
    const callSignatures = collectCallable(typeNode);
    if (isSome2(callSignatures) && callSignatures.value.length > 1) {
      return ts.factory.createTypeLiteralNode(callSignatures.value);
    }
    return typeNode;
  }
  function tryPreserveDeclarationSemantics(nodeToReplace, node, dropAsync) {
    if (!ts.isExpression(node)) return node;
    if (ts.isFunctionDeclaration(nodeToReplace)) {
      if (!nodeToReplace.name) return node;
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createVariableStatement(
        newModifiers,
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
            nodeToReplace.name,
            void 0,
            void 0,
            node
          )],
          ts.NodeFlags.Const
        )
      );
    } else if (ts.isMethodDeclaration(nodeToReplace)) {
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createPropertyDeclaration(
        newModifiers,
        nodeToReplace.name,
        void 0,
        void 0,
        node
      );
    }
    return node;
  }
  function parseAccessedExpressionForCompletion(sourceFile, position) {
    const precedingToken = ts.findPrecedingToken(position, sourceFile, void 0, true);
    if (!precedingToken) return;
    let accessedObject = precedingToken;
    let replacementSpan = ts.createTextSpan(position, 0);
    let outerNode = precedingToken;
    if (ts.isIdentifier(precedingToken) && precedingToken.parent && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const spanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        spanStart,
        precedingToken.end - spanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isToken(precedingToken) && precedingToken.kind === ts.SyntaxKind.DotToken && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isIdentifier(precedingToken) && precedingToken.parent) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken;
      outerNode = precedingToken;
    } else {
      return;
    }
    return { accessedObject, outerNode, replacementSpan };
  }
  function parseDataForExtendsClassCompletion(sourceFile, position) {
    const maybeInfos = parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return;
    const { accessedObject, outerNode, replacementSpan } = maybeInfos;
    if (!ts.isIdentifier(accessedObject)) return;
    let classDeclaration = outerNode.parent;
    while (ts.isExpressionWithTypeArguments(classDeclaration) || ts.isHeritageClause(classDeclaration)) {
      if (!classDeclaration.parent) break;
      classDeclaration = classDeclaration.parent;
    }
    if (!ts.isClassDeclaration(classDeclaration)) return;
    if (!classDeclaration.name) return;
    return {
      accessedObject,
      classDeclaration,
      className: classDeclaration.name,
      replacementSpan
    };
  }
  function createEffectGenCallExpression(effectModuleIdentifierName, node) {
    const generator = ts.factory.createFunctionExpression(
      void 0,
      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
      void 0,
      [],
      [],
      void 0,
      node
      // NOTE(mattia): intended, to use same routine for both ConciseBody and Body
    );
    return ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifierName),
        "gen"
      ),
      void 0,
      [generator]
    );
  }
  function createEffectGenCallExpressionWithBlock(effectModuleIdentifierName, statement) {
    return createEffectGenCallExpression(
      effectModuleIdentifierName,
      ts.factory.createBlock(isArray(statement) ? statement : [statement], false)
    );
  }
  function createReturnYieldStarStatement(expr) {
    return ts.factory.createReturnStatement(
      ts.factory.createYieldExpression(
        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
        expr
      )
    );
  }
  function createDataTaggedErrorDeclaration(dataModuleIdentifier, name, fields) {
    const invokeTaggedError = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(dataModuleIdentifier),
        "TaggedError"
      ),
      void 0,
      [
        ts.factory.createStringLiteral(name)
      ]
    );
    const withTypeFields = ts.factory.createExpressionWithTypeArguments(
      invokeTaggedError,
      [
        ts.factory.createTypeLiteralNode(fields)
      ]
    );
    return ts.factory.createClassDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      name,
      void 0,
      [
        ts.factory.createHeritageClause(
          ts.SyntaxKind.ExtendsKeyword,
          [
            withTypeFields
          ]
        )
      ],
      []
    );
  }
  function getSourceFileOfNode(current) {
    let node = current;
    while (node && node.kind !== ts.SyntaxKind.SourceFile) {
      node = node.parent;
    }
    return node;
  }
  return {
    findNodeAtPositionIncludingTrivia,
    parsePackageContentNameAndVersionFromScope,
    resolveModulePattern,
    resolveModuleWithPackageInfoFromSourceFile,
    findNodeWithLeadingCommentAtPosition,
    getCommentAtPosition,
    getAncestorNodesInRange,
    toTextRange,
    isNodeInRange,
    transformAsyncAwaitToEffectFn,
    transformAsyncAwaitToEffectGen,
    createDataTaggedErrorDeclaration,
    findImportedModuleIdentifierByPackageAndNameOrBarrel,
    simplifyTypeNode,
    tryPreserveDeclarationSemantics,
    parseDataForExtendsClassCompletion,
    createEffectGenCallExpressionWithBlock,
    createReturnYieldStarStatement,
    parseAccessedExpressionForCompletion,
    getSourceFileOfNode
  };
}

// src/core/LSP.ts
var RefactorNotApplicableError = class {
  _tag = "@effect/language-service/RefactorNotApplicableError";
};
function createRefactor(definition) {
  return definition;
}
function createDiagnostic(definition) {
  return definition;
}
function concatDiagnostics(fa, fb) {
  const result = fa.slice(0);
  for (const b of fb) {
    const existing = result.find(
      (a) => a.file === b.file && a.code === b.code && a.source === b.source && a.start === b.start && a.length === b.length && a.messageText === b.messageText
    );
    if (!existing) {
      result.push(b);
    }
  }
  return result;
}
function createCompletion(definition) {
  return definition;
}
var getSemanticDiagnosticsWithCodeFixes = fn(
  "LSP.getSemanticDiagnosticsWithCodeFixes"
)(function* (rules, sourceFile) {
  let effectDiagnostics = [];
  let effectCodeFixes = [];
  const executor = yield* createDiagnosticExecutor(sourceFile);
  for (const rule of rules) {
    const { codeFixes, diagnostics: diagnostics2 } = yield* executor.execute(rule);
    effectDiagnostics = effectDiagnostics.concat(diagnostics2);
    effectCodeFixes = effectCodeFixes.concat(codeFixes);
  }
  return {
    diagnostics: effectDiagnostics,
    codeFixes: effectCodeFixes
  };
});
function refactorNameToFullyQualifiedName(name) {
  return `@effect/language-service/refactors/${name}`;
}
var getApplicableRefactors = fn("LSP.getApplicableRefactors")(function* (refactors2, sourceFile, positionOrRange) {
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  const effectRefactors = [];
  for (const refactor of refactors2) {
    yield* pipe(
      refactor.apply(sourceFile, textRange),
      map5(
        (result) => effectRefactors.push({
          name: refactorNameToFullyQualifiedName(refactor.name),
          description: refactor.description,
          actions: [{
            name: refactorNameToFullyQualifiedName(refactor.name),
            description: result.description,
            kind: result.kind
          }]
        })
      ),
      ignore
    );
  }
  return effectRefactors;
});
var getEditsForRefactor = fn("LSP.getEditsForRefactor")(function* (refactors2, sourceFile, positionOrRange, refactorName) {
  const refactor = refactors2.find((refactor2) => refactorNameToFullyQualifiedName(refactor2.name) === refactorName);
  if (!refactor) {
    return yield* fail(new RefactorNotApplicableError());
  }
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  return yield* refactor.apply(sourceFile, textRange);
});
var getCompletionsAtPosition = fn("LSP.getCompletionsAtPosition")(function* (completions2, sourceFile, position, options, formatCodeSettings) {
  let effectCompletions = [];
  for (const completion of completions2) {
    const result = yield* completion.apply(sourceFile, position, options, formatCodeSettings);
    effectCompletions = effectCompletions.concat(
      result.map((_) => ({ sortText: "11", ..._ }))
    );
  }
  return effectCompletions;
});
var createDiagnosticExecutor = fn("LSP.createCommentDirectivesProcessor")(
  function* (sourceFile) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const pluginOptions = yield* service(LanguageServicePluginOptions);
    function findParentStatementForDisableNextLine(node) {
      let result;
      function find(node2) {
        if (ts.isStatement(node2)) {
          result = node2;
          return;
        }
        if (result) return;
        if (node2.parent) find(node2.parent);
      }
      find(node);
      return result || node;
    }
    const lineOverrides = {};
    const sectionOverrides = {};
    const skippedRules = [];
    const regex = /@effect-diagnostics(-next-line)?((?:\s[a-zA-Z0-9/]+:(?:off|warning|error|message|suggestion|skip-file))+)?/gm;
    let match3;
    while ((match3 = regex.exec(sourceFile.text)) !== null) {
      const nextLineCaptureGroup = match3[1];
      const rulesCaptureGroup = match3[2];
      if (rulesCaptureGroup) {
        const trimmedRuleString = rulesCaptureGroup.trim();
        if (trimmedRuleString) {
          const individualRules = trimmedRuleString.split(/\s+/);
          for (const rulePair of individualRules) {
            const [rawRuleName, ruleLevel] = rulePair.toLowerCase().split(":");
            const ruleName = rawRuleName.startsWith("effect/") ? rawRuleName.substring("effect/".length) : rawRuleName;
            if (ruleName && ruleLevel) {
              if (ruleLevel === "skip-file") skippedRules.push(ruleName);
              const isOverrideNextLine = nextLineCaptureGroup && nextLineCaptureGroup.trim().toLowerCase() === "-next-line";
              if (isOverrideNextLine) {
                const foundNode = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, match3.index);
                if (foundNode) {
                  lineOverrides[ruleName] = lineOverrides[ruleName] || [];
                  lineOverrides[ruleName].unshift({
                    pos: foundNode.node.pos,
                    end: foundNode.node.end,
                    level: ruleLevel,
                    commentRange: foundNode.commentRange
                  });
                }
              } else {
                sectionOverrides[ruleName] = sectionOverrides[ruleName] || [];
                sectionOverrides[ruleName].unshift({
                  pos: match3.index,
                  level: ruleLevel
                });
              }
            }
          }
        }
      }
    }
    const levelToDiagnosticCategory = {
      error: ts.DiagnosticCategory.Error,
      warning: ts.DiagnosticCategory.Warning,
      message: ts.DiagnosticCategory.Message,
      suggestion: ts.DiagnosticCategory.Suggestion
    };
    const execute = (rule) => gen(function* () {
      const diagnostics2 = [];
      const codeFixes = [];
      const ruleNameLowered = rule.name.toLowerCase();
      const defaultLevel = pluginOptions.diagnosticSeverity[ruleNameLowered] || rule.severity;
      if (skippedRules.indexOf(ruleNameLowered) > -1) return { diagnostics: diagnostics2, codeFixes };
      if (defaultLevel === "off" && (lineOverrides[ruleNameLowered] || sectionOverrides[ruleNameLowered] || []).length === 0) {
        return { diagnostics: diagnostics2, codeFixes };
      }
      const fixByDisableNextLine = (node) => ({
        fixName: rule.name + "_skipNextLine",
        description: "Disable " + rule.name + " for this line",
        apply: flatMap2(
          service(ChangeTracker),
          (changeTracker) => gen(function* () {
            const disableAtNode = findParentStatementForDisableNextLine(node);
            const start = ts.getTokenPosOfNode(disableAtNode, sourceFile);
            const { line } = ts.getLineAndCharacterOfPosition(sourceFile, start);
            changeTracker.insertCommentBeforeLine(
              sourceFile,
              line,
              start,
              ` @effect-diagnostics-next-line ${rule.name}:off`
            );
          })
        )
      });
      const fixByDisableEntireFile = {
        fixName: rule.name + "_skipFile",
        description: "Disable " + rule.name + " for this entire file",
        apply: flatMap2(
          service(ChangeTracker),
          (changeTracker) => sync(
            () => changeTracker.insertText(
              sourceFile,
              0,
              `/** @effect-diagnostics ${rule.name}:skip-file */
`
            )
          )
        )
      };
      const applicableDiagnostics = [];
      yield* rule.apply(sourceFile, (entry) => {
        const range = "kind" in entry.location ? { pos: ts.getTokenPosOfNode(entry.location, sourceFile), end: entry.location.end } : entry.location;
        const node = "kind" in entry.location ? entry.location : tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, entry.location.pos);
        applicableDiagnostics.push({
          range,
          messageText: pluginOptions.diagnosticsName ? `${entry.messageText}    effect(${rule.name})` : entry.messageText,
          fixes: entry.fixes.concat(node ? [fixByDisableNextLine(node)] : []).concat([fixByDisableEntireFile])
        });
      });
      const unusedLineOverrides = new Set(lineOverrides[ruleNameLowered] || []);
      for (const emitted of applicableDiagnostics.slice(0)) {
        let newLevel = defaultLevel;
        const lineOverride = (lineOverrides[ruleNameLowered] || []).find(
          (_) => _.pos < emitted.range.pos && _.end >= emitted.range.end
        );
        if (lineOverride) {
          newLevel = lineOverride.level;
          unusedLineOverrides.delete(lineOverride);
        } else {
          const sectionOverride = (sectionOverrides[ruleNameLowered] || []).find((_) => _.pos < emitted.range.pos);
          if (sectionOverride) newLevel = sectionOverride.level;
        }
        if (!(newLevel in levelToDiagnosticCategory)) continue;
        diagnostics2.push({
          file: sourceFile,
          start: emitted.range.pos,
          length: emitted.range.end - emitted.range.pos,
          messageText: emitted.messageText,
          category: levelToDiagnosticCategory[newLevel],
          code: rule.code,
          source: "effect"
        });
        for (const fix of emitted.fixes) {
          codeFixes.push({
            ...fix,
            code: rule.code,
            start: emitted.range.pos,
            end: emitted.range.end
          });
        }
      }
      if (pluginOptions.missingDiagnosticNextLine !== "off" && unusedLineOverrides.size > 0) {
        for (const unusedLineOverride of unusedLineOverrides) {
          diagnostics2.push({
            file: sourceFile,
            start: unusedLineOverride.commentRange.pos,
            length: unusedLineOverride.commentRange.end - unusedLineOverride.commentRange.pos,
            messageText: `@effect-diagnostics-next-line ${rule.name}:${unusedLineOverride.level} has no effect, make sure you are suppressing the right rule.`,
            category: levelToDiagnosticCategory[pluginOptions.missingDiagnosticNextLine],
            code: -1,
            source: "effect"
          });
        }
      }
      return { diagnostics: diagnostics2, codeFixes };
    });
    return { execute };
  }
);
var cyrb53 = (str, seed = 0) => {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (h2 >>> 0).toString(16).padStart(8, "0") + (h1 >>> 0).toString(16).padStart(8, "0");
};
var CodegenNotApplicableError = class {
  constructor(cause) {
    this.cause = cause;
  }
  _tag = "@effect/language-service/CodegenNotApplicableError";
};
function createCodegen(definition) {
  return definition;
}
var getCodegensForSourceFile = fn("LSP.getApplicableCodegens")(function* (codegens2, sourceFile) {
  const tsUtils = yield* service(TypeScriptUtils);
  const result = [];
  const regex = /@effect-codegens((?:\s[a-zA-Z0-9]+(?::(?:[a-zA-Z0-9]+))?)+)+/gmid;
  let match3;
  while ((match3 = regex.exec(sourceFile.text)) !== null) {
    const pos = match3.indices?.[0]?.[0];
    if (!pos) continue;
    const commentRange = tsUtils.getCommentAtPosition(sourceFile, pos);
    if (!commentRange) continue;
    const commentText = sourceFile.text.slice(pos, commentRange.end);
    const codegenRegex = /(\s+)(\w+)(?::(\w+))?/gmi;
    let codegenMatch;
    while ((codegenMatch = codegenRegex.exec(commentText)) !== null) {
      const whitespace = codegenMatch[1] || "";
      const codegenName = codegenMatch[2] || "";
      const codegenHash = codegenMatch[3] || "";
      const range = {
        pos: codegenMatch.index + pos + whitespace.length,
        end: codegenMatch.index + pos + codegenMatch[0].length
      };
      const codegen = codegens2.find((codegen2) => codegen2.name === codegenName);
      if (!codegen) continue;
      result.push({ codegen, hash: codegenHash, range });
    }
  }
  return result;
});
var getEditsForCodegen = fn("LSP.getEditsForCodegen")(function* (codegens2, sourceFile, textRange) {
  const applicableCodegens = yield* getCodegensForSourceFile(codegens2, sourceFile);
  const inRangeCodegens = applicableCodegens.filter(
    (codegen2) => codegen2.range.pos <= textRange.pos && codegen2.range.end >= textRange.end
  );
  if (inRangeCodegens.length !== 1) {
    return yield* fail(new CodegenNotApplicableError("zero or multiple codegens in range"));
  }
  const { codegen, range } = inRangeCodegens[0];
  const edit = yield* codegen.apply(sourceFile, range);
  const updateHashComment = pipe(
    service(ChangeTracker),
    map5((changeTracker) => {
      changeTracker.deleteRange(sourceFile, range);
      changeTracker.insertText(sourceFile, range.pos, `${codegen.name}:${edit.hash}`);
    })
  );
  return {
    ...edit,
    apply: pipe(
      edit.apply,
      flatMap2(() => updateHashComment)
    ),
    ignore: updateHashComment
  };
});
var getEffectLspPatchSourceFileMetadata = (sourceFile) => {
  return sourceFile["@effect-lsp-patch/metadata"];
};

// src/core/KeyBuilder.ts
var makeKeyBuilder = fn("KeyBuilder")(
  function* (sourceFile) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const program = yield* service(TypeScriptProgram);
    const options = yield* service(LanguageServicePluginOptions);
    const packageInfo = tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    function createString2(classNameText, kind) {
      if (!packageInfo) return;
      for (const keyPattern of options.keyPatterns) {
        if (keyPattern.target !== kind) continue;
        const lastIndex = sourceFile.fileName.lastIndexOf("/");
        let onlyFileName = lastIndex === -1 ? "" : sourceFile.fileName.slice(lastIndex + 1);
        const lastExtensionIndex = onlyFileName.lastIndexOf(".");
        if (lastExtensionIndex !== -1) onlyFileName = onlyFileName.slice(0, lastExtensionIndex);
        if (onlyFileName.toLowerCase().endsWith("/index")) onlyFileName = onlyFileName.slice(0, -6);
        if (onlyFileName.startsWith("/")) onlyFileName = onlyFileName.slice(1);
        let subDirectory = getDirectoryPath(ts, sourceFile.fileName);
        if (!subDirectory.startsWith(packageInfo.packageDirectory)) continue;
        subDirectory = subDirectory.slice(packageInfo.packageDirectory.length);
        if (!subDirectory.endsWith("/")) subDirectory = subDirectory + "/";
        if (subDirectory.startsWith("/")) subDirectory = subDirectory.slice(1);
        for (const prefix of keyPattern.skipLeadingPath) {
          if (subDirectory.startsWith(prefix)) {
            subDirectory = subDirectory.slice(prefix.length);
            break;
          }
        }
        let parts = [packageInfo.name, subDirectory, onlyFileName].concat(
          onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
        );
        if (keyPattern.pattern === "package-identifier") {
          parts = [packageInfo.name, onlyFileName].concat(
            onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
          );
        }
        parts = parts.map((part) => part.startsWith("/") ? part.slice(1) : part).map(
          (part) => part.endsWith("/") ? part.slice(0, -1) : part
        );
        const fullKey = parts.filter((_) => String(_).trim().length > 0).join("/");
        return keyPattern.pattern === "default-hashed" ? cyrb53(fullKey) : fullKey;
      }
    }
    return {
      createString: createString2
    };
  }
);
var keyBuilderCache = /* @__PURE__ */ new Map();
var getOrMakeKeyBuilder = fn("getOrMakeKeyBuilder")(function* (sourceFile) {
  while (keyBuilderCache.size > 5) {
    const oldest = keyBuilderCache.keys().next().value;
    if (oldest) keyBuilderCache.delete(oldest);
  }
  const keyBuilder = keyBuilderCache.get(sourceFile.fileName) || (yield* makeKeyBuilder(sourceFile));
  keyBuilderCache.set(sourceFile.fileName, keyBuilder);
  return keyBuilder;
});
function createString(sourceFile, identifier, kind) {
  return map5(
    getOrMakeKeyBuilder(sourceFile),
    (identifierBuilder) => identifierBuilder.createString(identifier, kind)
  );
}

// src/completions/contextSelfInClasses.ts
var contextSelfInClasses = createCompletion({
  name: "contextSelfInClasses",
  apply: fn("contextSelfInClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const contextIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Context"
    ) || "Context";
    if (contextIdentifier !== ts.idText(accessedObject)) return [];
    const name = ts.idText(className);
    const tagKey = (yield* createString(sourceFile, name, "service")) || name;
    return [{
      name: `Tag("${name}")`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${contextIdentifier}.Tag("${tagKey}")<${name}, ${"${0}"}>(){}`,
      replacementSpan,
      isSnippet: true
    }];
  })
});

// src/core/TypeCheckerApi.ts
var TypeCheckerApi = Tag("TypeChecker");
function makeResolveExternalModuleName(typeChecker) {
  if (!(hasProperty(typeChecker, "resolveExternalModuleName") && isFunction(typeChecker.resolveExternalModuleName))) {
    return;
  }
  const _internal = typeChecker.resolveExternalModuleName;
  return (moduleSpecifier) => {
    return _internal(moduleSpecifier);
  };
}

// src/core/TypeCheckerUtils.ts
var TypeCheckerUtils = Tag("TypeCheckerUtils");
var nanoLayer2 = (fa) => pipe(
  service(TypeScriptApi),
  flatMap2(
    (ts) => flatMap2(service(TypeCheckerApi), (typeChecker) => flatMap2(service(TypeScriptUtils), (typeScriptUtils) => pipe(fa, provideService(TypeCheckerUtils, makeTypeCheckerUtils(ts, typeChecker, typeScriptUtils)))))
  )
);
function makeTypeCheckerUtils(ts, typeChecker, tsUtils) {
  function isUnion(type) {
    return !!(type.flags & ts.TypeFlags.Union);
  }
  function isIndexType(type) {
    return !!(type.flags & ts.TypeFlags.Index);
  }
  function isThisTypeParameter(type) {
    return !!(type.flags & ts.TypeFlags.TypeParameter && type.isThisType);
  }
  function getTypeParameterAtPosition(signature, pos) {
    const type = typeChecker.getParameterType(signature, pos);
    if (isIndexType(type) && isThisTypeParameter(type.type)) {
      const constraint = typeChecker.getBaseConstraintOfType(type.type);
      if (constraint) {
        return typeChecker.getIndexType(constraint);
      }
    }
    return type;
  }
  const unrollUnionMembers = (type) => {
    const result = [];
    let toTest = [type];
    while (toTest.length > 0) {
      const type2 = toTest.pop();
      if (isUnion(type2)) {
        toTest = toTest.concat(type2.types);
      } else {
        result.push(type2);
      }
    }
    return result;
  };
  const getMissingTypeEntriesInTargetType = function(realType, expectedType) {
    if (realType === expectedType) return [];
    const result = [];
    let toTest = [realType];
    while (toTest.length > 0) {
      const type = toTest.pop();
      if (!type) return result;
      if (isUnion(type)) {
        toTest = toTest.concat(type.types);
      } else {
        const assignable = typeChecker.isTypeAssignableTo(type, expectedType);
        if (!assignable) {
          result.push(type);
        }
      }
    }
    return result;
  };
  const appendToUniqueTypesMap = fn(
    "TypeCheckerUtils.appendToUniqueTypesMap"
  )(
    function* (memory, initialType, shouldExclude) {
      const newIndexes = /* @__PURE__ */ new Set();
      const knownIndexes = /* @__PURE__ */ new Set();
      let toTest = [initialType];
      while (toTest.length > 0) {
        const type = toTest.pop();
        if (!type) break;
        if (yield* shouldExclude(type)) {
          continue;
        }
        if (isUnion(type)) {
          toTest = toTest.concat(type.types);
        } else {
          const foundMatch = [];
          for (const [typeId, knownType] of memory.entries()) {
            const areSame = typeChecker.isTypeAssignableTo(knownType, type) && typeChecker.isTypeAssignableTo(type, knownType);
            if (areSame) {
              foundMatch.push(typeId);
              break;
            }
          }
          if (foundMatch.length === 0) {
            const newId = "t" + (memory.size + 1);
            memory.set(newId, type);
            newIndexes.add(newId);
          } else {
            knownIndexes.add(foundMatch[0]);
          }
        }
      }
      return {
        newIndexes,
        knownIndexes,
        allIndexes: pipe(
          fromIterable(newIndexes),
          appendAll(fromIterable(knownIndexes))
        )
      };
    }
  );
  const deterministicTypeOrder = make2((a, b) => {
    const aName = typeChecker.typeToString(a);
    const bName = typeChecker.typeToString(b);
    if (aName < bName) return -1;
    if (aName > bName) return 1;
    return 0;
  });
  const getAncestorConvertibleDeclaration = (node) => {
    let current = node;
    while (current) {
      if (ts.isFunctionDeclaration(current) || ts.isFunctionExpression(current) || ts.isArrowFunction(current) || ts.isMethodDeclaration(current)) {
        return current;
      }
      current = current.parent;
    }
  };
  const getInferredReturnType = (declaration) => {
    if (!declaration.body) {
      return;
    }
    let returnType;
    if (typeChecker.isImplementationOfOverload(declaration)) {
      const signatures = typeChecker.getSignaturesOfType(
        typeChecker.getTypeAtLocation(declaration),
        ts.SignatureKind.Call
      );
      if (signatures.length > 1) {
        returnType = typeChecker.getUnionType(
          signatures.map((s) => typeChecker.getReturnTypeOfSignature(s)).filter((_) => !!_)
        );
      }
    }
    if (!returnType) {
      const signature = typeChecker.getSignatureFromDeclaration(declaration);
      if (signature) {
        const typePredicate = typeChecker.getTypePredicateOfSignature(signature);
        if (typePredicate && typePredicate.type) {
          return typePredicate.type;
        } else {
          returnType = typeChecker.getReturnTypeOfSignature(signature);
        }
      }
    }
    return returnType;
  };
  const expectedAndRealTypeCache = /* @__PURE__ */ new WeakMap();
  const expectedAndRealType = (sourceFile) => {
    const cached2 = expectedAndRealTypeCache.get(sourceFile);
    if (cached2) return cached2;
    const result = [];
    const nodeToVisit = [sourceFile];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isVariableDeclaration(node) && node.initializer) {
        const expectedType = typeChecker.getTypeAtLocation(node.name);
        const realType = typeChecker.getTypeAtLocation(node.initializer);
        result.push([node.name, expectedType, node.initializer, realType]);
        appendNodeToVisit(node.initializer);
        continue;
      } else if (ts.isCallExpression(node)) {
        const resolvedSignature = typeChecker.getResolvedSignature(node);
        if (resolvedSignature) {
          resolvedSignature.parameters.map((parameter, index) => {
            const expectedType = typeChecker.getTypeOfSymbolAtLocation(parameter, node);
            const realType = typeChecker.getTypeAtLocation(node.arguments[index]);
            result.push([
              node.arguments[index],
              expectedType,
              node.arguments[index],
              realType
            ]);
          });
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node)) {
        const parent = node.parent;
        if (ts.isObjectLiteralElement(parent)) {
          if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {
            const type = typeChecker.getContextualType(parent.parent);
            if (type) {
              const name = ts.isIdentifier(node) ? ts.idText(node) : ts.isStringLiteral(node) ? node.text : void 0;
              if (name) {
                const symbol3 = typeChecker.getPropertyOfType(type, name);
                if (symbol3) {
                  const expectedType = typeChecker.getTypeOfSymbolAtLocation(symbol3, node);
                  const realType = typeChecker.getTypeAtLocation(node);
                  result.push([node, expectedType, node, realType]);
                }
              }
            }
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
        const expectedType = typeChecker.getTypeAtLocation(node.left);
        const realType = typeChecker.getTypeAtLocation(node.right);
        result.push([node.left, expectedType, node.right, realType]);
        appendNodeToVisit(node.right);
        continue;
      } else if (ts.isReturnStatement(node) && node.expression) {
        const parentDeclaration = getAncestorConvertibleDeclaration(node);
        if (parentDeclaration) {
          const expectedType = getInferredReturnType(parentDeclaration);
          const realType = typeChecker.getTypeAtLocation(node.expression);
          if (expectedType) {
            result.push([node, expectedType, node, realType]);
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length === 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = typeChecker.getContextualType(body);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length > 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = getInferredReturnType(node);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isSatisfiesExpression(node)) {
        const expectedType = typeChecker.getTypeAtLocation(node.type);
        const realType = typeChecker.getTypeAtLocation(node.expression);
        result.push([node.expression, expectedType, node.expression, realType]);
        appendNodeToVisit(node.expression);
        continue;
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
    expectedAndRealTypeCache.set(sourceFile, result);
    return result;
  };
  function typeToSimplifiedTypeNode(type, enclosingNode, flags) {
    return typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, 0);
  }
  function typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, depth) {
    const fallbackStandard = () => {
      const typeNode = typeChecker.typeToTypeNode(type, enclosingNode, flags);
      if (!typeNode) return void 0;
      return tsUtils.simplifyTypeNode(typeNode);
    };
    if (depth > 20) return fallbackStandard();
    const members = unrollUnionMembers(type);
    if (members.length > 1 && !(type.flags & ts.TypeFlags.Boolean)) {
      const typeNodes = [];
      members.sort(deterministicTypeOrder);
      for (const member of members) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createUnionTypeNode(typeNodes));
    }
    if (type.flags & ts.TypeFlags.Intersection) {
      const intersectionType = type;
      const typeNodes = [];
      for (const member of intersectionType.types) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createIntersectionTypeNode(typeNodes));
    }
    if (type.flags & ts.TypeFlags.Object && type.objectFlags & ts.ObjectFlags.Reference) {
      const typeReference = type;
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isTypeReferenceNode(standard2)) return standard2;
      if (typeReference.target.typeParameters?.length !== typeReference.typeArguments?.length) return standard2;
      if (standard2.typeArguments?.length !== typeReference.typeArguments?.length) return standard2;
      const typeParametersCount = (typeReference.target.typeParameters || []).length;
      for (let i = typeParametersCount - 1; i >= 0; i--) {
        const typeParameter = typeReference.target.typeParameters[i];
        const typeArgument = typeReference.typeArguments[i];
        const defaultType = typeChecker.getDefaultFromTypeParameter(typeParameter);
        if (defaultType !== typeArgument || i === 0) {
          return tsUtils.simplifyTypeNode(ts.factory.updateTypeReferenceNode(
            standard2,
            standard2.typeName,
            ts.factory.createNodeArray((standard2.typeArguments || []).slice(0, Math.min(typeParametersCount, i + 1)))
          ));
        }
      }
      return standard2;
    }
    if (type.flags & ts.TypeFlags.Object) {
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isFunctionTypeNode(standard2)) return standard2;
      const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
      if (signatures.length !== 1) return standard2;
      const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
      if (!returnType) return standard2;
      const returnTypeNode = typeToSimplifiedTypeNodeWorker(returnType, enclosingNode, flags, depth + 1);
      if (!returnTypeNode) return standard2;
      return tsUtils.simplifyTypeNode(ts.factory.updateFunctionTypeNode(
        standard2,
        standard2.typeParameters,
        standard2.parameters,
        returnTypeNode
      ));
    }
    return fallbackStandard();
  }
  return {
    isUnion,
    getTypeParameterAtPosition,
    getMissingTypeEntriesInTargetType,
    unrollUnionMembers,
    appendToUniqueTypesMap,
    deterministicTypeOrder,
    getInferredReturnType,
    expectedAndRealType,
    typeToSimplifiedTypeNode
  };
}

// src/completions/durationInput.ts
var durationInput = createCompletion({
  name: "durationInput",
  apply: fn("durationInput")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    let isInString = false;
    const previousToken = ts.findPrecedingToken(position, sourceFile);
    if (previousToken && ts.isStringTextContainingNode(previousToken)) {
      const start = ts.getTokenPosOfNode(previousToken, sourceFile);
      const end = previousToken.end;
      if (start < position && position < end) {
        isInString = true;
      }
      if (position === end) {
        isInString = !!previousToken.isUnterminated;
      }
      if (isInString && ts.isExpression(previousToken)) {
        const type = typeChecker.getContextualType(previousToken);
        if (type) {
          if (!typeCheckerUtils.isUnion(type)) return [];
          for (const member of type.types) {
            if (member.flags & ts.TypeFlags.TemplateLiteral) {
              if (hasProperty(member, "texts") && isArray(member.texts) && member.texts.length === 2 && String(member.texts[1]).trim() === "nanos") {
                return ["nanos", "micros", "millis", "seconds", "minutes", "hours", "days", "weeks"].map(
                  (name) => ({
                    name,
                    kind: ts.ScriptElementKind.string,
                    insertText: `${"${0}"} ${name}`,
                    isSnippet: true
                  })
                );
              }
            }
          }
        }
      }
    }
    return [];
  })
});

// src/core/TypeParser.ts
var TypeParser = Tag("@effect/language-service/TypeParser");
var nanoLayer3 = (fa) => gen(function* () {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  const program = yield* service(TypeScriptProgram);
  return yield* pipe(
    fa,
    provideService(TypeParser, make3(ts, tsUtils, typeChecker, typeCheckerUtils, program))
  );
});
var TypeParserIssue = class _TypeParserIssue {
  _tag = "@effect/language-service/TypeParserIssue";
  static issue = fail(new _TypeParserIssue());
};
function typeParserIssue(_message, _type, _node) {
  return TypeParserIssue.issue;
}
function make3(ts, tsUtils, typeChecker, typeCheckerUtils, program) {
  const getSourceFilePackageInfo = cachedBy(
    fn("TypeParser.getSourceFilePackageInfo")(function* (sourceFile) {
      return tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    }),
    `TypeParser.getSourceFilePackageInfo`,
    (sourceFile) => sourceFile
  );
  const getSourceFilesDeclaringSymbolModule = (packageName) => cachedBy(
    fn("TypeParser.getSourceFilesDeclaringSymbolModule")(function* (symbol3) {
      const result = [];
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const sourceFile of symbol3.declarations) {
        if (!ts.isSourceFile(sourceFile)) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        result.push(sourceFile);
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no source file declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolModule(${packageName})`,
    (symbol3) => symbol3
  );
  const isSymbolReferenceToPackageModule = (givenSymbol, packageName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolModule(packageName)(symbol3),
      flatMap2(
        (sourceFiles) => firstSuccessOf(
          sourceFiles.map((_) => checkSourceFile(_))
        )
      )
    );
  };
  const isNodeReferenceToPackageModule = (givenNode, packageName, isCorrectSourceFile) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolReferenceToPackageModule(symbol3, packageName, isCorrectSourceFile);
  };
  const getSourceFilesDeclaringSymbolExportedUnderPackageModule = (packageName, memberName) => cachedBy(
    fn("TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember")(function* (symbol3) {
      const result = [];
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const declaration of symbol3.declarations) {
        const sourceFile = tsUtils.getSourceFileOfNode(declaration);
        if (!sourceFile) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) continue;
        const memberSymbol = typeChecker.tryGetMemberInModuleExports(memberName, moduleSymbol);
        if (memberSymbol && memberSymbol === symbol3) result.push({ memberSymbol, moduleSymbol, sourceFile });
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember(${packageName}, ${memberName})`,
    (sym) => sym
  );
  const isSymbolExportOfPackageModule = (givenSymbol, packageName, memberName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolExportedUnderPackageModule(packageName, memberName)(symbol3),
      flatMap2(
        (sourceFiles) => firstSuccessOf(
          sourceFiles.map((_) => checkSourceFile(_.sourceFile, _.moduleSymbol, _.memberSymbol))
        )
      )
    );
  };
  const isNodeReferenceToExportOfPackageModule = (givenNode, packageName, isCorrectSourceFile, memberName) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolExportOfPackageModule(symbol3, packageName, memberName, isCorrectSourceFile);
  };
  function covariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Covariant type has no call signature", type);
    }
    return succeed(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  function contravariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Contravariant type has no call signature", type);
    }
    return succeed(typeCheckerUtils.getTypeParameterAtPosition(signatures[0], 0));
  }
  function invariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Invariant type has no call signature", type);
    }
    return succeed(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  const pipeableType = cachedBy(
    function(type, atLocation) {
      const pipeSymbol = typeChecker.getPropertyOfType(type, "pipe");
      if (!pipeSymbol) {
        return typeParserIssue("Type has no 'pipe' property", type, atLocation);
      }
      const pipeType = typeChecker.getTypeOfSymbolAtLocation(pipeSymbol, atLocation);
      const signatures = typeChecker.getSignaturesOfType(pipeType, ts.SignatureKind.Call);
      if (signatures.length === 0) {
        return typeParserIssue("'pipe' property is not callable", type, atLocation);
      }
      return succeed(type);
    },
    "TypeParser.pipeableType",
    (type) => type
  );
  const varianceStructCovariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return covariantTypeArgument(propertyType);
  };
  const varianceStructContravariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return contravariantTypeArgument(propertyType);
  };
  const varianceStructInvariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return invariantTypeArgument(propertyType);
  };
  const effectVarianceStruct = (type, atLocation) => map5(
    all(
      varianceStructCovariantType(type, atLocation, "_A"),
      varianceStructCovariantType(type, atLocation, "_E"),
      varianceStructCovariantType(type, atLocation, "_R")
    ),
    ([A, E, R]) => ({ A, E, R })
  );
  const layerVarianceStruct = (type, atLocation) => map5(
    all(
      varianceStructContravariantType(type, atLocation, "_ROut"),
      varianceStructCovariantType(type, atLocation, "_E"),
      varianceStructCovariantType(type, atLocation, "_RIn")
    ),
    ([ROut, E, RIn]) => ({ ROut, E, RIn })
  );
  const effectType = cachedBy(
    fn("TypeParser.effectType")(function* (type, atLocation) {
      let result = typeParserIssue("Type has no effect variance struct", type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("EffectTypeId") - ts.symbolName(a).indexOf("EffectTypeId")
      );
      for (const propertySymbol of propertiesSymbols) {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        result = pipe(result, orElse2(() => effectVarianceStruct(propertyType, atLocation)));
      }
      return yield* result;
    }),
    "TypeParser.effectType",
    (type) => type
  );
  const strictEffectType = cachedBy(
    fn("TypeParser.strictEffectType")(function* (type, atLocation) {
      if (!(type.symbol && ts.symbolName(type.symbol) === "Effect" && !type.aliasSymbol)) {
        return yield* typeParserIssue("Type name should be Effect with no alias symbol", type, atLocation);
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.strictEffectType",
    (type) => type
  );
  const isEffectTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const effectTypeSymbol = typeChecker.tryGetMemberInModuleExports("Effect", moduleSymbol);
      if (!effectTypeSymbol) return yield* typeParserIssue("Effect type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(effectTypeSymbol);
      yield* effectType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectModuleApi(${memberName})`,
    (node) => node
  );
  const layerType = cachedBy(
    fn("TypeParser.layerType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("LayerTypeId") - ts.symbolName(a).indexOf("LayerTypeId")
      );
      for (const propertySymbol of propertiesSymbols) {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        const varianceArgs = yield* option(layerVarianceStruct(
          propertyType,
          atLocation
        ));
        if (isSome2(varianceArgs)) {
          return varianceArgs.value;
        }
      }
      return yield* typeParserIssue("Type has no layer variance struct", type, atLocation);
    }),
    "TypeParser.layerType",
    (type) => type
  );
  const fiberType = cachedBy(
    fn("TypeParser.fiberType")(function* (type, atLocation) {
      const awaitSymbol = typeChecker.getPropertyOfType(type, "await");
      const pollSymbol = typeChecker.getPropertyOfType(type, "poll");
      if (!awaitSymbol || !pollSymbol) {
        return yield* typeParserIssue(
          "Type is not a fiber because it does not have 'await' or 'poll' property",
          type,
          atLocation
        );
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.fiberType",
    (type) => type
  );
  const effectSubtype = cachedBy(
    fn("TypeParser.effectSubtype")(function* (type, atLocation) {
      const tagSymbol = typeChecker.getPropertyOfType(type, "_tag");
      const getSymbol = typeChecker.getPropertyOfType(type, "get");
      if (!(tagSymbol || getSymbol)) {
        return yield* typeParserIssue(
          "Type is not a subtype of effect because it does not have '_tag' or 'get' property",
          type,
          atLocation
        );
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.effectSubtype",
    (type) => type
  );
  const importedContextModule = cachedBy(
    fn("TypeParser.importedContextModule")(function* (node) {
      const type = typeChecker.getTypeAtLocation(node);
      const propertySymbol = typeChecker.getPropertyOfType(type, "Tag");
      if (!propertySymbol) {
        return yield* typeParserIssue("Type has no 'Tag' property", type, node);
      }
      if (!ts.isIdentifier(node)) {
        return yield* typeParserIssue("Node is not an identifier", type, node);
      }
      const sourceFile = tsUtils.getSourceFileOfNode(node);
      if (!sourceFile) {
        return yield* typeParserIssue("Node is not in a source file", void 0, node);
      }
      const contextIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
        sourceFile,
        "effect",
        "Context"
      );
      if (!contextIdentifier) {
        return yield* typeParserIssue("Context module not found", void 0, node);
      }
      if (ts.idText(node) !== contextIdentifier) {
        return yield* typeParserIssue("Node is not a context module reference", void 0, node);
      }
      return node;
    }),
    "TypeParser.importedContextModule",
    (node) => node
  );
  const importedEffectModule = (node) => pipe(
    isNodeReferenceToPackageModule(node, "effect", isEffectTypeSourceFile),
    map5(() => node)
  );
  const importedDataModule = cachedBy(
    fn("TypeParser.importedDataModule")(function* (node) {
      const type = typeChecker.getTypeAtLocation(node);
      const propertySymbol = typeChecker.getPropertyOfType(type, "TaggedError");
      if (!propertySymbol) {
        return yield* typeParserIssue("Type has no 'TaggedError' property", type, node);
      }
      if (!ts.isIdentifier(node)) {
        return yield* typeParserIssue("Node is not an expression", type, node);
      }
      const sourceFile = tsUtils.getSourceFileOfNode(node);
      if (!sourceFile) {
        return yield* typeParserIssue("Node is not in a source file", void 0, node);
      }
      const dataIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
        sourceFile,
        "effect",
        "Data"
      );
      if (!dataIdentifier) {
        return yield* typeParserIssue("Data module not found", void 0, node);
      }
      if (ts.idText(node) !== dataIdentifier) {
        return yield* typeParserIssue("Node is not a data module reference", void 0, node);
      }
      return node;
    }),
    "TypeParser.importedDataModule",
    (node) => node
  );
  const effectGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue("Node is not a generator function", void 0, node);
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue("Node is not a property access expression", void 0, node);
      }
      const propertyAccess = node.expression;
      return pipe(
        isNodeReferenceToEffectModuleApi("gen")(propertyAccess),
        map5(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectGen",
    (node) => node
  );
  const effectFnUntracedGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const propertyAccess = node.expression;
      return pipe(
        isNodeReferenceToEffectModuleApi("fnUntraced")(propertyAccess),
        map5(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectFnUntracedGen",
    (node) => node
  );
  const effectFnGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue(
          "Node is not a function expression",
          void 0,
          node
        );
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      const expressionToTest = ts.isCallExpression(node.expression) ? node.expression.expression : node.expression;
      if (!ts.isPropertyAccessExpression(expressionToTest)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const propertyAccess = expressionToTest;
      return pipe(
        isNodeReferenceToEffectModuleApi("fn")(propertyAccess),
        map5(() => ({
          node,
          generatorFunction,
          effectModule: propertyAccess.expression,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectFnGen",
    (node) => node
  );
  const unnecessaryEffectGen2 = cachedBy(
    fn("TypeParser.unnecessaryEffectGen")(function* (node) {
      const { body } = yield* effectGen(node);
      if (body.statements.length !== 1) {
        return yield* typeParserIssue(
          "Generator body should have a single statement",
          void 0,
          node
        );
      }
      let explicitReturn = false;
      let nodeToCheck = body.statements[0];
      while (nodeToCheck) {
        if (ts.isReturnStatement(nodeToCheck) && nodeToCheck.expression) {
          nodeToCheck = nodeToCheck.expression;
          explicitReturn = true;
          continue;
        }
        if (ts.isExpressionStatement(nodeToCheck)) {
          nodeToCheck = nodeToCheck.expression;
          continue;
        }
        if (ts.isYieldExpression(nodeToCheck) && nodeToCheck.asteriskToken && nodeToCheck.expression) {
          const yieldedExpression = nodeToCheck.expression;
          const type = typeChecker.getTypeAtLocation(yieldedExpression);
          const { A: successType } = yield* effectType(type, yieldedExpression);
          let replacementNode = succeed(yieldedExpression);
          if (!explicitReturn && !(successType.flags & ts.TypeFlags.VoidLike)) {
            replacementNode = pipe(
              gen(function* () {
                const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
                  node.getSourceFile(),
                  "effect",
                  "Effect"
                ) || "Effect";
                return ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(effectIdentifier),
                    "asVoid"
                  ),
                  void 0,
                  [
                    yieldedExpression
                  ]
                );
              }),
              provideService(TypeScriptApi, ts)
            );
          }
          return { node, body, yieldedExpression, replacementNode };
        }
        break;
      }
      return yield* typeParserIssue(
        "Not an handled node",
        void 0,
        node
      );
    }),
    "TypeParser.unnecessaryEffectGen",
    (node) => node
  );
  const effectSchemaVarianceStruct = (type, atLocation) => map5(
    all(
      varianceStructInvariantType(type, atLocation, "_A"),
      varianceStructInvariantType(type, atLocation, "_I"),
      varianceStructCovariantType(type, atLocation, "_R")
    ),
    ([A, I, R]) => ({ A, I, R })
  );
  const effectSchemaType = cachedBy(
    fn("TypeParser.effectSchemaType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const ast = typeChecker.getPropertyOfType(type, "ast");
      if (!ast) return yield* typeParserIssue("Has no 'ast' property", type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      for (const propertySymbol of propertiesSymbols) {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        const varianceArgs = yield* option(effectSchemaVarianceStruct(
          propertyType,
          atLocation
        ));
        if (isSome2(varianceArgs)) {
          return varianceArgs.value;
        }
      }
      return yield* typeParserIssue("Type has no schema variance struct", type, atLocation);
    }),
    "TypeParser.effectSchemaType",
    (type) => type
  );
  const isEffectSchemaTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectSchemaTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const typeSymbol = typeChecker.tryGetMemberInModuleExports("Schema", moduleSymbol);
      if (!typeSymbol) return yield* typeParserIssue("Schema type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(typeSymbol);
      yield* effectSchemaType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectSchemaTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectSchemaModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectSchemaModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectSchemaTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectSchemaModuleApi(${memberName})`,
    (node) => node
  );
  const contextTagVarianceStruct = (type, atLocation) => map5(
    all(
      varianceStructInvariantType(type, atLocation, "_Identifier"),
      varianceStructInvariantType(type, atLocation, "_Service")
    ),
    ([Identifier, Service]) => ({ Identifier, Service })
  );
  const contextTag = cachedBy(
    fn("TypeParser.contextTag")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      for (const propertySymbol of propertiesSymbols) {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        const varianceArgs = yield* option(contextTagVarianceStruct(
          propertyType,
          atLocation
        ));
        if (isSome2(varianceArgs)) {
          return varianceArgs.value;
        }
      }
      return yield* typeParserIssue("Type has no tag variance struct", type, atLocation);
    }),
    "TypeParser.contextTag",
    (type) => type
  );
  const pipeCall = cachedBy(
    function(node) {
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "pipe") {
        return succeed({
          node,
          subject: node.expression.expression,
          args: Array.from(node.arguments),
          kind: "pipeable"
        });
      }
      if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && ts.idText(node.expression) === "pipe" && node.arguments.length > 0) {
        const [subject, ...args2] = node.arguments;
        return succeed({ node, subject, args: args2, kind: "pipe" });
      }
      return typeParserIssue("Node is not a pipe call", void 0, node);
    },
    "TypeParser.pipeCall",
    (node) => node
  );
  const scopeType = cachedBy(
    fn("TypeParser.scopeType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("ScopeTypeId") - ts.symbolName(a).indexOf("ScopeTypeId")
      );
      for (const propertySymbol of propertiesSymbols) {
        const computedPropertyExpression = propertySymbol.valueDeclaration.name;
        const symbol3 = typeChecker.getSymbolAtLocation(computedPropertyExpression.expression);
        if (symbol3 && ts.symbolName(symbol3) === "ScopeTypeId") {
          return type;
        }
      }
      return yield* typeParserIssue("Type has no scope type id", type, atLocation);
    }),
    "TypeParser.scopeType",
    (type) => type
  );
  const promiseLike = cachedBy(
    function(type, atLocation) {
      const thenProperty = type.getProperty("then");
      if (!thenProperty) return typeParserIssue("not a promise - missing then property", type, atLocation);
      const thenType = typeChecker.getTypeOfSymbolAtLocation(thenProperty, atLocation);
      if (!thenType) return typeParserIssue("not a promise - missing then property", type, atLocation);
      for (const callSignature of typeChecker.getSignaturesOfType(thenType, ts.SignatureKind.Call)) {
        const parameter = callSignature.parameters[0];
        if (!parameter) continue;
        const parameterType = typeCheckerUtils.getTypeParameterAtPosition(callSignature, 0);
        if (!parameterType) continue;
        let callbackCallSignatures = [];
        let toTest = [parameterType];
        while (toTest.length > 0) {
          const type2 = toTest.shift();
          if (!type2) continue;
          const callSignatures = typeChecker.getSignaturesOfType(type2, ts.SignatureKind.Call);
          callbackCallSignatures = callbackCallSignatures.concat(callSignatures);
          if (typeCheckerUtils.isUnion(type2)) {
            toTest = toTest.concat(type2.types);
          }
        }
        for (const callableType of callbackCallSignatures) {
          const callbackParameter = callableType.parameters[0];
          if (!callbackParameter) {
            continue;
          }
          const callbackParameterType = typeCheckerUtils.getTypeParameterAtPosition(callableType, 0);
          if (!callbackParameterType) {
            continue;
          }
          return succeed({
            type: callbackParameterType
          });
        }
      }
      return typeParserIssue("not a promise", type, atLocation);
    },
    "TypeParser.promiseLike",
    (type) => type
  );
  const extendsSchemaClass = cachedBy(
    fn("TypeParser.extendsSchemaClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaCall = expression.expression;
              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("Class")(schemaCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode: schemaCall.typeArguments[0]
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.Class", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedClass = cachedBy(
    fn("TypeParser.extendsSchemaTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression) && expression.arguments.length > 0) {
              const schemaTaggedClassTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedClassTCall) && schemaTaggedClassTCall.typeArguments && schemaTaggedClassTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedClassTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedClass")(schemaTaggedClassTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedClassTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedClassTCall.arguments[0]) ? schemaTaggedClassTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedError = cachedBy(
    fn("TypeParser.extendsSchemaTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedErrorTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedErrorTCall) && schemaTaggedErrorTCall.typeArguments && schemaTaggedErrorTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedErrorTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedError")(schemaTaggedErrorTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedErrorTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedErrorTCall.arguments[0]) ? schemaTaggedErrorTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedError",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedRequest = cachedBy(
    fn("TypeParser.extendsSchemaTaggedRequest")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedRequestTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedRequestTCall) && schemaTaggedRequestTCall.typeArguments && schemaTaggedRequestTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedRequestTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedRequest")(schemaTaggedRequestTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0,
                    keyStringLiteral: schemaTaggedRequestTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedRequestTCall.arguments[0]) ? schemaTaggedRequestTCall.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedRequest", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedRequest",
    (atLocation) => atLocation
  );
  const extendsDataTaggedError = cachedBy(
    fn("TypeParser.extendsDataTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedErrorCall = expression;
              const dataIdentifier = dataTaggedErrorCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedError") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedErrorCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedErrorCall.arguments[0]) ? dataTaggedErrorCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedError",
    (atLocation) => atLocation
  );
  const extendsDataTaggedClass = cachedBy(
    fn("TypeParser.extendsDataTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedClassCall = expression;
              const dataIdentifier = dataTaggedClassCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedClass") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedClassCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedClassCall.arguments[0]) ? dataTaggedClassCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedClass",
    (atLocation) => atLocation
  );
  const extendsContextTag = cachedBy(
    fn("TypeParser.extendsContextTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const contextTagCall = wholeCall.expression;
              if (ts.isCallExpression(contextTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const contextTagIdentifier = contextTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                if (ts.isPropertyAccessExpression(contextTagIdentifier) && ts.isIdentifier(contextTagIdentifier.name) && ts.idText(contextTagIdentifier.name) === "Tag") {
                  const parsedContextModule = yield* pipe(
                    importedContextModule(contextTagIdentifier.expression),
                    option
                  );
                  if (isSome2(parsedContextModule)) {
                    const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                    if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                    const type = typeChecker.getTypeOfSymbol(classSym);
                    const tagType = yield* contextTag(type, atLocation);
                    return {
                      className: atLocation.name,
                      selfTypeNode,
                      keyStringLiteral: ts.isStringLiteral(contextTagCall.arguments[0]) ? contextTagCall.arguments[0] : void 0,
                      args: contextTagCall.arguments,
                      Identifier: tagType.Identifier,
                      Tag: parsedContextModule.value
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Context.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsContextTag",
    (atLocation) => atLocation
  );
  const extendsEffectTag = cachedBy(
    fn("TypeParser.extendsEffectTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
      if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
      const type = typeChecker.getTypeOfSymbol(classSym);
      const tagType = yield* contextTag(type, atLocation);
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectTagCall = wholeCall.expression;
              if (ts.isCallExpression(effectTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const effectTagIdentifier = effectTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                const isEffectTag = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Tag")(effectTagIdentifier),
                  option
                );
                if (isSome2(isEffectTag)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: ts.isStringLiteral(effectTagCall.arguments[0]) ? effectTagCall.arguments[0] : void 0,
                    args: effectTagCall.arguments,
                    Identifier: tagType.Identifier,
                    Service: tagType.Service
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsEffectTag",
    (atLocation) => atLocation
  );
  const extendsEffectService = cachedBy(
    fn("TypeParser.extendsEffectService")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectServiceCall = wholeCall.expression;
              if (ts.isCallExpression(effectServiceCall) && effectServiceCall.typeArguments && effectServiceCall.typeArguments.length > 0) {
                const effectServiceIdentifier = effectServiceCall.expression;
                const selfTypeNode = effectServiceCall.typeArguments[0];
                const isEffectService = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Service")(effectServiceIdentifier),
                  option
                );
                if (isSome2(isEffectService)) {
                  const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                  if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                  const type = typeChecker.getTypeOfSymbol(classSym);
                  const parsedContextTag = yield* pipe(
                    contextTag(type, atLocation),
                    option
                  );
                  if (isSome2(parsedContextTag)) {
                    let accessors2 = void 0;
                    let dependencies = void 0;
                    if (wholeCall.arguments.length >= 2) {
                      const args2 = wholeCall.arguments[1];
                      if (ts.isObjectLiteralExpression(args2)) {
                        for (const property of args2.properties) {
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "accessors" && property.initializer && property.initializer.kind === ts.SyntaxKind.TrueKeyword) {
                            accessors2 = true;
                          }
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "dependencies" && property.initializer && ts.isArrayLiteralExpression(property.initializer)) {
                            dependencies = property.initializer.elements;
                          }
                        }
                      }
                    }
                    return {
                      ...parsedContextTag.value,
                      className: atLocation.name,
                      selfTypeNode,
                      args: wholeCall.arguments,
                      keyStringLiteral: ts.isStringLiteral(wholeCall.arguments[0]) ? wholeCall.arguments[0] : void 0,
                      options: wholeCall.arguments[1],
                      accessors: accessors2,
                      dependencies
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Service", void 0, atLocation);
    }),
    "TypeParser.extendsEffectService",
    (atLocation) => atLocation
  );
  return {
    isNodeReferenceToEffectModuleApi,
    effectType,
    strictEffectType,
    layerType,
    fiberType,
    effectSubtype,
    importedEffectModule,
    effectGen,
    effectFnUntracedGen,
    effectFnGen,
    unnecessaryEffectGen: unnecessaryEffectGen2,
    effectSchemaType,
    contextTag,
    pipeableType,
    pipeCall,
    scopeType,
    promiseLike,
    extendsEffectTag,
    extendsEffectService,
    extendsContextTag,
    extendsSchemaClass,
    extendsSchemaTaggedClass,
    extendsSchemaTaggedError,
    extendsDataTaggedError,
    extendsDataTaggedClass,
    extendsSchemaTaggedRequest
  };
}

// src/refactors/writeTagClassAccessors.ts
var generate = fn("writeTagClassAccessors.generate")(function* (sourceFile, service2, className, atLocation, involvedMembers) {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const changeTracker = yield* service(ChangeTracker);
  const insertLocation = atLocation.members.length > 0 ? atLocation.members[0].pos : atLocation.end - 1;
  const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
    sourceFile,
    "effect",
    "Effect"
  ) || "Effect";
  const createFunctionProperty = (className2, propertyName, type, forceAny) => {
    const arrowBody = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectIdentifier),
        "andThen"
      ),
      void 0,
      [
        ts.factory.createIdentifier(ts.idText(className2)),
        ts.factory.createArrowFunction(
          void 0,
          void 0,
          [ts.factory.createParameterDeclaration(
            void 0,
            void 0,
            "_",
            void 0,
            forceAny ? ts.factory.createTypeReferenceNode("any") : void 0
          )],
          void 0,
          void 0,
          ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              ts.factory.createIdentifier("_"),
              propertyName
            ),
            void 0,
            [
              ts.factory.createSpreadElement(ts.factory.createIdentifier("args"))
            ]
          )
        )
      ]
    );
    return ts.factory.createPropertyDeclaration(
      [
        ts.factory.createModifier(ts.SyntaxKind.StaticKeyword),
        ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword)
      ],
      propertyName,
      void 0,
      type,
      ts.factory.createArrowFunction(
        void 0,
        void 0,
        [ts.factory.createParameterDeclaration(
          void 0,
          ts.factory.createToken(ts.SyntaxKind.DotDotDotToken),
          "args",
          void 0,
          forceAny ? ts.factory.createArrayTypeNode(ts.factory.createTypeReferenceNode("any")) : void 0
        )],
        void 0,
        void 0,
        forceAny ? ts.factory.createAsExpression(arrowBody, ts.factory.createTypeReferenceNode("any")) : arrowBody
      )
    );
  };
  const generateReturnType = (type, atLocation2, className2) => pipe(
    typeParser.effectType(type, atLocation2),
    flatMap2((returnedEffect) => {
      const contextType = returnedEffect.R.flags & ts.TypeFlags.Never ? ts.factory.createTypeReferenceNode(ts.idText(className2)) : ts.factory.createUnionTypeNode(
        [
          ts.factory.createTypeReferenceNode(ts.idText(className2)),
          typeChecker.typeToTypeNode(returnedEffect.R, atLocation2, ts.NodeBuilderFlags.NoTruncation)
        ]
      );
      const successType = typeChecker.typeToTypeNode(
        returnedEffect.A,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!successType) return fail("error generating success type");
      const failureType = typeChecker.typeToTypeNode(
        returnedEffect.E,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!failureType) return fail("error generating failure type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [successType, failureType, contextType]
      );
      return succeed(typeNode);
    }),
    orElse2(
      () => pipe(
        typeParser.promiseLike(type, atLocation2),
        flatMap2(({ type: type2 }) => {
          const successType = typeChecker.typeToTypeNode(
            type2,
            atLocation2,
            ts.NodeBuilderFlags.NoTruncation
          );
          if (!successType) return fail("error generating success type");
          return succeed(ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectIdentifier),
              ts.factory.createIdentifier("Effect")
            ),
            [
              successType,
              ts.factory.createTypeReferenceNode(
                ts.factory.createQualifiedName(
                  ts.factory.createIdentifier("Cause"),
                  ts.factory.createIdentifier("UnknownException")
                )
              ),
              ts.factory.createTypeReferenceNode(ts.idText(className2))
            ]
          ));
        })
      )
    ),
    orElse2(() => {
      const successType = typeChecker.typeToTypeNode(type, atLocation2, ts.NodeBuilderFlags.NoTruncation);
      if (!successType) return fail("error generating success type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [
          successType,
          ts.factory.createTypeReferenceNode("never"),
          ts.factory.createTypeReferenceNode(ts.idText(className2))
        ]
      );
      return succeed(typeNode);
    })
  );
  const proxySignature = (signature, atLocation2, className2) => gen(function* () {
    const signatureDeclaration = typeChecker.signatureToSignatureDeclaration(
      signature,
      ts.SyntaxKind.FunctionType,
      atLocation2,
      ts.NodeBuilderFlags.NoTruncation
    );
    if (!signatureDeclaration) return yield* fail("error generating signature");
    const returnType = yield* generateReturnType(
      typeChecker.getReturnTypeOfSignature(signature),
      atLocation2,
      className2
    );
    return ts.factory.createFunctionTypeNode(
      signatureDeclaration.typeParameters,
      signatureDeclaration.parameters,
      returnType
    );
  });
  for (const { property, propertyType } of involvedMembers) {
    const callSignatures = [];
    let propertyDeclaration = void 0;
    for (const signature of typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)) {
      yield* pipe(
        proxySignature(signature, atLocation, className),
        map5((sig) => {
          callSignatures.push(sig);
        }),
        ignore
      );
    }
    const allSignatures = ts.factory.createIntersectionTypeNode(callSignatures);
    const type = tsUtils.simplifyTypeNode(allSignatures);
    propertyDeclaration = createFunctionProperty(className, ts.symbolName(property), type, callSignatures.length > 1);
    const oldProperty = atLocation.members.filter(ts.isPropertyDeclaration).find((p) => {
      const symbol3 = typeChecker.getSymbolAtLocation(p.name);
      return symbol3 && ts.symbolName(symbol3) === ts.symbolName(property);
    });
    if (oldProperty) {
      const start = ts.getTokenPosOfNode(oldProperty, sourceFile);
      changeTracker.deleteRange(sourceFile, {
        pos: start,
        end: oldProperty.end
      });
      changeTracker.insertNodeAt(sourceFile, start, propertyDeclaration);
    } else {
      changeTracker.insertNodeAt(sourceFile, insertLocation, propertyDeclaration, { suffix: "\n" });
    }
  }
});
var parse2 = fn("writeTagClassAccessors.parse")(function* (node) {
  const ts = yield* service(TypeScriptApi);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  if (!ts.isClassDeclaration(node)) return yield* fail("not a class declaration");
  const { Service, accessors: accessors2, className } = yield* pipe(
    typeParser.extendsEffectService(node),
    orElse2(() => map5(typeParser.extendsEffectTag(node), (_) => ({ accessors: true, ..._ }))),
    orElse2(() => fail("not a class extending Effect.Service call"))
  );
  if (accessors2 !== true) return yield* fail("accessors are not enabled in the Effect.Service call");
  const involvedMembers = [];
  const nonPrimitiveServices = typeCheckerUtils.unrollUnionMembers(Service).filter(
    (_) => !(_.flags & ts.TypeFlags.Number || _.flags & ts.TypeFlags.String || _.flags & ts.TypeFlags.Boolean || _.flags & ts.TypeFlags.Literal)
  );
  if (nonPrimitiveServices.length === 0) return yield* fail("Service type is a primitive type");
  for (const serviceShape of nonPrimitiveServices) {
    for (const property of typeChecker.getPropertiesOfType(serviceShape)) {
      const propertyType = typeChecker.getTypeOfSymbolAtLocation(property, node);
      const callSignatures = typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call);
      if (callSignatures.length > 0) {
        const withTypeParameters = callSignatures.filter((_) => _.typeParameters && _.typeParameters.length > 0);
        if (callSignatures.length > 1 || withTypeParameters.length > 0) involvedMembers.push({ property, propertyType });
      }
    }
  }
  const hash2 = involvedMembers.map(({ property, propertyType }) => {
    return ts.symbolName(property) + ": " + typeChecker.typeToString(propertyType);
  }).concat([ts.idText(className)]).join("\n");
  return { Service, className, atLocation: node, hash: cyrb53(hash2), involvedMembers };
});
var writeTagClassAccessors = createRefactor({
  name: "writeTagClassAccessors",
  description: "Implement accessors methods with generics or multiple signatures",
  apply: fn("writeTagClassAccessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const parseNode = (node) => pipe(
      parse2(node),
      map5(({ Service, atLocation, className, involvedMembers }) => ({
        kind: "refactor.rewrite.effect.writeTagClassAccessors",
        description: "Implement Service accessors",
        apply: pipe(
          generate(sourceFile, Service, className, atLocation, involvedMembers),
          provideService(TypeScriptUtils, tsUtils),
          provideService(TypeParser, typeParser),
          provideService(TypeCheckerApi, typeChecker),
          provideService(TypeScriptApi, ts)
        )
      }))
    );
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    return yield* pipe(
      firstSuccessOf(parentNodes.map(parseNode)),
      orElse2(() => fail(new RefactorNotApplicableError()))
    );
  })
});

// src/codegens/accessors.ts
var accessors = createCodegen({
  name: "accessors",
  apply: fn("accessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) return yield* fail(new CodegenNotApplicableError("no node and comment range"));
    return yield* pipe(
      parse2(nodeAndCommentRange.node),
      map5(
        (_) => ({
          hash: _.hash,
          description: "Generate accessors for the service",
          apply: pipe(
            generate(sourceFile, _.Service, _.className, _.atLocation, _.involvedMembers),
            provideService(TypeScriptApi, ts),
            provideService(TypeScriptUtils, tsUtils),
            provideService(TypeCheckerApi, typeChecker),
            provideService(TypeParser, typeParser),
            provideService(TypeCheckerUtils, typeCheckerUtils)
          )
        })
      ),
      orElse2((cause) => fail(new CodegenNotApplicableError(cause)))
    );
  })
});

// src/codegens.ts
var codegens = [accessors];

// src/completions/effectCodegensComment.ts
var effectCodegensComment = createCompletion({
  name: "effectCodegensComment",
  apply: fn("effectCodegensComment")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const sourceText = sourceFile.text;
    const match3 = /(\/\/|\/\*(?:\*?))\s*(@)\s*$/id.exec(sourceText.substring(0, position));
    if (match3 && match3.indices) {
      const lastIndex = match3.indices[2][0];
      const replacementSpan = {
        start: lastIndex,
        length: Math.max(0, position - lastIndex)
      };
      const allCodegens = sort(Object.values(codegens).map((codegen) => codegen.name), string2).join(",");
      const enableSnippet = "${1|" + allCodegens + "|} $0";
      return [{
        name: `@effect-codegens`,
        kind: ts.ScriptElementKind.string,
        insertText: "@effect-codegens " + enableSnippet,
        isSnippet: true,
        replacementSpan
      }];
    }
    return [];
  })
});

// src/completions/effectDataClasses.ts
var effectDataClasses = createCompletion({
  name: "effectDataClasses",
  apply: fn("effectDataClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const effectDataIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Data"
    ) || "Data";
    if (effectDataIdentifier !== ts.idText(accessedObject)) return [];
    const name = ts.idText(className);
    const errorTagKey = (yield* createString(sourceFile, name, "error")) || name;
    return [{
      name: `TaggedError("${name}")`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${effectDataIdentifier}.TaggedError("${errorTagKey}")<{${"${0}"}}>{}`,
      replacementSpan,
      isSnippet: true
    }, {
      name: `TaggedClass("${name}")`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${effectDataIdentifier}.TaggedClass("${name}")<{${"${0}"}}>{}`,
      replacementSpan,
      isSnippet: true
    }];
  })
});

// src/diagnostics/catchUnfailableEffect.ts
var catchUnfailableEffect = createDiagnostic({
  name: "catchUnfailableEffect",
  code: 2,
  severity: "suggestion",
  apply: fn("catchUnfailableEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const catchFunctions = ["catchAll", "catch", "catchIf", "catchSome", "catchTag", "catchTags"];
        const isCatchCall = yield* pipe(
          firstSuccessOf(
            catchFunctions.map((catchFn) => typeParser.isNodeReferenceToEffectModuleApi(catchFn)(node.expression))
          ),
          option
        );
        if (isSome2(isCatchCall)) {
          const parent = node.parent;
          if (parent && ts.isCallExpression(parent)) {
            const pipeCallResult = yield* pipe(
              typeParser.pipeCall(parent),
              option
            );
            if (isSome2(pipeCallResult)) {
              const { args: args2, node: pipeCallNode, subject } = pipeCallResult.value;
              const argIndex = args2.findIndex((arg) => arg === node);
              if (argIndex !== -1) {
                let effectTypeToCheck;
                if (argIndex === 0) {
                  effectTypeToCheck = typeChecker.getTypeAtLocation(subject);
                } else {
                  const signature = typeChecker.getResolvedSignature(pipeCallNode);
                  if (signature) {
                    const typeArguments = typeChecker.getTypeArgumentsForResolvedSignature(signature);
                    if (typeArguments && typeArguments.length > argIndex) {
                      effectTypeToCheck = typeArguments[argIndex];
                    }
                  }
                }
                if (effectTypeToCheck) {
                  const effectType = yield* pipe(
                    typeParser.effectType(effectTypeToCheck, node),
                    option
                  );
                  if (isSome2(effectType)) {
                    const { E } = effectType.value;
                    if (E.flags & ts.TypeFlags.Never) {
                      report({
                        location: node.expression,
                        messageText: `Looks like the previous effect never fails, so probably this error handling will never be triggered.`,
                        fixes: []
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  })
});

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Chunk.js
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet2(that, i))));
var _equivalence2 = /* @__PURE__ */ getEquivalence(equals);
var ChunkProto = {
  [TypeId3]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence2(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk.length = 0;
      chunk.depth = 0;
      chunk.left = chunk;
      chunk.right = chunk;
      break;
    }
    case "IConcat": {
      chunk.length = backing.left.length + backing.right.length;
      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk.left = backing.left;
      chunk.right = backing.right;
      break;
    }
    case "IArray": {
      chunk.length = backing.array.length;
      chunk.depth = 0;
      chunk.left = _empty;
      chunk.right = _empty;
      break;
    }
    case "ISingleton": {
      chunk.length = 1;
      chunk.depth = 0;
      chunk.left = _empty;
      chunk.right = _empty;
      break;
    }
    case "ISlice": {
      chunk.length = backing.length;
      chunk.depth = backing.chunk.depth + 1;
      chunk.left = _empty;
      chunk.right = _empty;
      break;
    }
  }
  return chunk;
};
var isChunk = (u) => hasProperty(u, TypeId3);
var _empty = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty2 = () => _empty;
var make4 = (...as) => unsafeFromNonEmptyArray(as);
var of = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable(self));
var copyToArray = (self, array3, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy(self.backing.array, 0, array3, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array3, initial);
      copyToArray(self.right, array3, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array3[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array3[j] = unsafeGet2(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty;
      self.right = _empty;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self.backing.right),
        right: reverse2(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self)));
  }
};
var reverse2 = reverseChunk;
var unsafeFromArray = (self) => self.length === 0 ? empty2() : self.length === 1 ? of(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet2 = /* @__PURE__ */ dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet2(self.left, index) : unsafeGet2(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet2(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var prepend = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of(elem), self));
var appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff = that.depth - self.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll2(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var isEmpty = (self) => self.length === 0;
var isNonEmpty = (self) => self.length > 0;
var unsafeHead = (self) => unsafeGet2(self, 0);
var headNonEmpty2 = unsafeHead;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift, h) {
  return h >>> shift & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/stack.js
var make5 = (value, previous) => ({
  value,
  previous
});

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate3, at, v, arr) {
  let out = arr;
  if (!mutate3) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate3, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate3) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate3) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate3, at, v, arr) {
  const len = arr.length;
  if (mutate3) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size4) {
    const v = f(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size4.value;
    return new LeafNode(edit, hash2, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash2, key, size4) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        --size4.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size4.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new _LeafNode(edit, hash2, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size4) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size4);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size4.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate3, edit, hash2, list, f, key, size4) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value) return list;
        if (isNone2(newValue2)) {
          --size4.value;
          return arraySpliceOut(mutate3, i, list);
        }
        return arrayUpdate(mutate3, i, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue)) return list;
    ++size4.value;
    return arrayUpdate(mutate3, len, new LeafNode(edit, hash2, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size4) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size4);
      if (!_newChild) return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash2, key, size4);
    if (current === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size4, children) {
    this.edit = edit;
    this.size = size4;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size4) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift + SIZE, f, hash2, key, size4);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count, newChildren);
  }
};
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make5(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size4) => {
  const map9 = Object.create(HashMapProto);
  map9._editable = editable;
  map9._edit = edit;
  map9._root = root;
  map9._size = size4;
  return map9;
};
var HashMapIterator = class _HashMapIterator {
  map;
  f;
  v;
  constructor(map9, f) {
    this.map = map9;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty2 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty3 = () => _empty2;
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var getHash = /* @__PURE__ */ dual(3, (self, key, hash2) => {
  let node = self._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length; i < len; ++i) {
            const child = children[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift, hash2)];
        if (node) {
          shift += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var set = /* @__PURE__ */ dual(3, (self, key, value) => modifyAt(self, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys2 = (self) => new HashMapIterator(self, (key) => key);
var size = (self) => self._size;
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self, key, hash2, f) => {
  const size4 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash2, key, size4);
  return pipe(self, setTree(newRoot, size4.value));
});
var forEach = /* @__PURE__ */ dual(2, (self, f) => reduce2(self, void 0, (_, value, key) => f(value, key)));
var reduce2 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero2, root.value.value, root.key) : zero2;
  }
  if (root._tag === "EmptyNode") {
    return zero2;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length; i < len; ) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero2 = f(zero2, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero2;
});

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set2 = Object.create(HashSetProto);
  set2._keyMap = keyMap;
  return set2;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty3 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty3());
var empty4 = () => _empty3;
var size2 = (self) => size(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation = (self) => {
  ;
  self._keyMap._editable = false;
  return self;
};
var mutate = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation(transient);
});
var add = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (set(value, true)(self._keyMap), self) : makeImpl2(set(value, true)(self._keyMap)));
var union2 = /* @__PURE__ */ dual(2, (self, that) => mutate(empty4(), (set2) => {
  forEach2(self, (value) => add(set2, value));
  for (const value of that) {
    add(set2, value);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self, f) => forEach(self._keyMap, (_, k) => f(k)));

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/HashSet.js
var empty5 = empty4;
var size3 = size2;
var add2 = add;
var union3 = union2;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ (function() {
  function Structural2(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
})();

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var fail2 = (error) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
var causeEquals = (left3, right3) => {
  let leftStack = of(left3);
  let rightStack = of(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce4([empty5(), empty2()], ([parallel2, sequential2], cause) => {
      const [par, seq] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par)), pipe(sequential2, appendAll2(seq))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce4([empty5(), empty2()], ([parallel2, sequential2], cause) => {
      const [par, seq] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par)), pipe(sequential2, appendAll2(seq))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause) => {
  return flattenCauseLoop(of(cause), empty2());
};
var flattenCauseLoop = (causes, flattened) => {
  while (1) {
    const [parallel2, sequential2] = pipe(causes, reduce([empty5(), empty2()], ([parallel3, sequential3], cause) => {
      const [par, seq] = evaluateCause(cause);
      return [pipe(parallel3, union3(par)), pipe(sequential3, appendAll2(seq))];
    }));
    const updated = size3(parallel2) > 0 ? pipe(flattened, prepend(parallel2)) : flattened;
    if (isEmpty(sequential2)) {
      return reverse2(updated);
    }
    causes = sequential2;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var evaluateCause = (self) => {
  let cause = self;
  const stack = [];
  let _parallel = empty5();
  let _sequential = empty2();
  while (cause !== void 0) {
    switch (cause._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add2(_parallel, make4(cause._tag, cause.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add2(_parallel, make4(cause._tag, cause.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add2(_parallel, make4(cause._tag, cause.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause.left._tag) {
          case OP_EMPTY: {
            cause = cause.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
            break;
          }
          case OP_PARALLEL: {
            cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
            break;
          }
          default: {
            _sequential = prepend(_sequential, cause.right);
            cause = cause.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause.right);
        cause = cause.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var reduce4 = /* @__PURE__ */ dual(3, (self, zero2, pf) => {
  let accumulator = zero2;
  let cause = self;
  const causes = [];
  while (cause !== void 0) {
    const option2 = pf(accumulator, cause);
    accumulator = isSome2(option2) ? option2.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      default: {
        cause = void 0;
        break;
      }
    }
    if (cause === void 0 && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self, context, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context, cause.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context, cause.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context, cause.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either = output.pop();
    switch (either._tag) {
      case "Left": {
        switch (either.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.sequentialCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.parallelCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  span = void 0;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span) {
    let current = span;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match3 = false;
          for (const [, location] of locationMatchAll) {
            match3 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match3) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause) => reduceWithContext(cause, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen3 = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/core.js
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var EffectPrimitive = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen3(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen3(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen3(new YieldWrap(this));
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span) => {
  if (isSome2(span)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var fail3 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail2(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail2(error));
var failCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var RequestResolverImpl = class _RequestResolverImpl {
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
  }
  [symbol]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol2](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids) {
    return new _RequestResolverImpl(this.runAll, fromIterable2(ids));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
var YieldableError = /* @__PURE__ */ (function() {
  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail3(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail2(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
})();
var makeException = (proto2, tag) => {
  class Base extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base.prototype, proto2);
  Base.prototype.name = tag;
  return Base;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var currentSpanFromFiber = (fiber) => {
  const span = fiber.currentSpan;
  return span !== void 0 && span._tag === "Span" ? some2(span) : none2();
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Data.js
var Class2 = Structural;
var Error2 = /* @__PURE__ */ (function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
})();
var TaggedError = (tag) => {
  const O = {
    BaseEffectError: class extends Error2 {
      _tag = tag;
    }
  };
  O.BaseEffectError.prototype.name = tag;
  return O.BaseEffectError;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/encoding/common.js
var encoder = /* @__PURE__ */ new TextEncoder();

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes) => {
  const length = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Encoding.js
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Graph.js
var TypeId4 = "~effect/Graph";
var Edge = class extends Class2 {
};
var ProtoGraph = {
  [TypeId4]: TypeId4,
  [Symbol.iterator]() {
    return this.nodes[Symbol.iterator]();
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    if (isGraph(that)) {
      if (this.nodes.size !== that.nodes.size || this.edges.size !== that.edges.size || this.type !== that.type) {
        return false;
      }
      for (const [nodeIndex, nodeData] of this.nodes) {
        if (!that.nodes.has(nodeIndex)) {
          return false;
        }
        const otherNodeData = that.nodes.get(nodeIndex);
        if (!equals(nodeData, otherNodeData)) {
          return false;
        }
      }
      for (const [edgeIndex, edgeData] of this.edges) {
        if (!that.edges.has(edgeIndex)) {
          return false;
        }
        const otherEdge = that.edges.get(edgeIndex);
        if (!equals(edgeData, otherEdge)) {
          return false;
        }
      }
      return true;
    }
    return false;
  },
  [symbol]() {
    let hash2 = string("Graph");
    hash2 = hash2 ^ string(this.type);
    hash2 = hash2 ^ number(this.nodes.size);
    hash2 = hash2 ^ number(this.edges.size);
    for (const [nodeIndex, nodeData] of this.nodes) {
      hash2 = hash2 ^ hash(nodeIndex) + hash(nodeData);
    }
    for (const [edgeIndex, edgeData] of this.edges) {
      hash2 = hash2 ^ hash(edgeIndex) + hash(edgeData);
    }
    return hash2;
  },
  toJSON() {
    return {
      _id: "Graph",
      nodeCount: this.nodes.size,
      edgeCount: this.edges.size,
      type: this.type
    };
  },
  toString() {
    return format(this);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GraphError = class extends (/* @__PURE__ */ TaggedError("GraphError")) {
};
var missingNode = (node) => new GraphError({
  message: `Node ${node} does not exist`
});
var isGraph = (u) => typeof u === "object" && u !== null && TypeId4 in u;
var directed = (mutate3) => {
  const graph = Object.create(ProtoGraph);
  graph.type = "directed";
  graph.nodes = /* @__PURE__ */ new Map();
  graph.edges = /* @__PURE__ */ new Map();
  graph.adjacency = /* @__PURE__ */ new Map();
  graph.reverseAdjacency = /* @__PURE__ */ new Map();
  graph.nextNodeIndex = 0;
  graph.nextEdgeIndex = 0;
  graph.isAcyclic = some2(true);
  graph.mutable = false;
  if (mutate3) {
    const mutable = beginMutation3(graph);
    mutate3(mutable);
    return endMutation2(mutable);
  }
  return graph;
};
var beginMutation3 = (graph) => {
  const adjacency = /* @__PURE__ */ new Map();
  const reverseAdjacency = /* @__PURE__ */ new Map();
  for (const [nodeIndex, edges2] of graph.adjacency) {
    adjacency.set(nodeIndex, [...edges2]);
  }
  for (const [nodeIndex, edges2] of graph.reverseAdjacency) {
    reverseAdjacency.set(nodeIndex, [...edges2]);
  }
  const mutable = Object.create(ProtoGraph);
  mutable.type = graph.type;
  mutable.nodes = new Map(graph.nodes);
  mutable.edges = new Map(graph.edges);
  mutable.adjacency = adjacency;
  mutable.reverseAdjacency = reverseAdjacency;
  mutable.nextNodeIndex = graph.nextNodeIndex;
  mutable.nextEdgeIndex = graph.nextEdgeIndex;
  mutable.isAcyclic = graph.isAcyclic;
  mutable.mutable = true;
  return mutable;
};
var endMutation2 = (mutable) => {
  const graph = Object.create(ProtoGraph);
  graph.type = mutable.type;
  graph.nodes = new Map(mutable.nodes);
  graph.edges = new Map(mutable.edges);
  graph.adjacency = mutable.adjacency;
  graph.reverseAdjacency = mutable.reverseAdjacency;
  graph.nextNodeIndex = mutable.nextNodeIndex;
  graph.nextEdgeIndex = mutable.nextEdgeIndex;
  graph.isAcyclic = mutable.isAcyclic;
  graph.mutable = false;
  return graph;
};
var mutate2 = /* @__PURE__ */ dual(2, (graph, f) => {
  const mutable = beginMutation3(graph);
  f(mutable);
  return endMutation2(mutable);
});
var addNode = (mutable, data) => {
  const nodeIndex = mutable.nextNodeIndex;
  mutable.nodes.set(nodeIndex, data);
  mutable.adjacency.set(nodeIndex, []);
  mutable.reverseAdjacency.set(nodeIndex, []);
  mutable.nextNodeIndex = mutable.nextNodeIndex + 1;
  return nodeIndex;
};
var getNode = (graph, nodeIndex) => graph.nodes.has(nodeIndex) ? some2(graph.nodes.get(nodeIndex)) : none2();
var hasNode = (graph, nodeIndex) => graph.nodes.has(nodeIndex);
var nodeCount = (graph) => graph.nodes.size;
var reverse3 = (mutable) => {
  for (const [index, edgeData] of mutable.edges) {
    mutable.edges.set(index, {
      source: edgeData.target,
      target: edgeData.source,
      data: edgeData.data
    });
  }
  mutable.adjacency.clear();
  mutable.reverseAdjacency.clear();
  for (const [edgeIndex, edgeData] of mutable.edges) {
    const sourceEdges = mutable.adjacency.get(edgeData.source) || [];
    sourceEdges.push(edgeIndex);
    mutable.adjacency.set(edgeData.source, sourceEdges);
    const targetEdges = mutable.reverseAdjacency.get(edgeData.target) || [];
    targetEdges.push(edgeIndex);
    mutable.reverseAdjacency.set(edgeData.target, targetEdges);
  }
  mutable.isAcyclic = none2();
};
var invalidateCycleFlagOnRemoval = (mutable) => {
  if (isSome2(mutable.isAcyclic) && mutable.isAcyclic.value === false) {
    mutable.isAcyclic = none2();
  }
};
var invalidateCycleFlagOnAddition = (mutable) => {
  if (isSome2(mutable.isAcyclic) && mutable.isAcyclic.value === true) {
    mutable.isAcyclic = none2();
  }
};
var addEdge = (mutable, source, target, data) => {
  if (!mutable.nodes.has(source)) {
    throw missingNode(source);
  }
  if (!mutable.nodes.has(target)) {
    throw missingNode(target);
  }
  const edgeIndex = mutable.nextEdgeIndex;
  const edgeData = new Edge({
    source,
    target,
    data
  });
  mutable.edges.set(edgeIndex, edgeData);
  const sourceAdjacency = mutable.adjacency.get(source);
  if (sourceAdjacency !== void 0) {
    sourceAdjacency.push(edgeIndex);
  }
  const targetReverseAdjacency = mutable.reverseAdjacency.get(target);
  if (targetReverseAdjacency !== void 0) {
    targetReverseAdjacency.push(edgeIndex);
  }
  if (mutable.type === "undirected") {
    const targetAdjacency = mutable.adjacency.get(target);
    if (targetAdjacency !== void 0) {
      targetAdjacency.push(edgeIndex);
    }
    const sourceReverseAdjacency = mutable.reverseAdjacency.get(source);
    if (sourceReverseAdjacency !== void 0) {
      sourceReverseAdjacency.push(edgeIndex);
    }
  }
  mutable.nextEdgeIndex = mutable.nextEdgeIndex + 1;
  invalidateCycleFlagOnAddition(mutable);
  return edgeIndex;
};
var removeNode = (mutable, nodeIndex) => {
  if (!mutable.nodes.has(nodeIndex)) {
    return;
  }
  const edgesToRemove = [];
  const outgoingEdges = mutable.adjacency.get(nodeIndex);
  if (outgoingEdges !== void 0) {
    for (const edge of outgoingEdges) {
      edgesToRemove.push(edge);
    }
  }
  const incomingEdges = mutable.reverseAdjacency.get(nodeIndex);
  if (incomingEdges !== void 0) {
    for (const edge of incomingEdges) {
      edgesToRemove.push(edge);
    }
  }
  for (const edgeIndex of edgesToRemove) {
    removeEdgeInternal(mutable, edgeIndex);
  }
  mutable.nodes.delete(nodeIndex);
  mutable.adjacency.delete(nodeIndex);
  mutable.reverseAdjacency.delete(nodeIndex);
  invalidateCycleFlagOnRemoval(mutable);
};
var removeEdgeInternal = (mutable, edgeIndex) => {
  const edge = mutable.edges.get(edgeIndex);
  if (edge === void 0) {
    return false;
  }
  const {
    source,
    target
  } = edge;
  const sourceAdjacency = mutable.adjacency.get(source);
  if (sourceAdjacency !== void 0) {
    const index = sourceAdjacency.indexOf(edgeIndex);
    if (index !== -1) {
      sourceAdjacency.splice(index, 1);
    }
  }
  const targetReverseAdjacency = mutable.reverseAdjacency.get(target);
  if (targetReverseAdjacency !== void 0) {
    const index = targetReverseAdjacency.indexOf(edgeIndex);
    if (index !== -1) {
      targetReverseAdjacency.splice(index, 1);
    }
  }
  if (mutable.type === "undirected") {
    const targetAdjacency = mutable.adjacency.get(target);
    if (targetAdjacency !== void 0) {
      const index = targetAdjacency.indexOf(edgeIndex);
      if (index !== -1) {
        targetAdjacency.splice(index, 1);
      }
    }
    const sourceReverseAdjacency = mutable.reverseAdjacency.get(source);
    if (sourceReverseAdjacency !== void 0) {
      const index = sourceReverseAdjacency.indexOf(edgeIndex);
      if (index !== -1) {
        sourceReverseAdjacency.splice(index, 1);
      }
    }
  }
  mutable.edges.delete(edgeIndex);
  return true;
};
var neighborsDirected = (graph, nodeIndex, direction) => {
  const adjacencyMap = direction === "incoming" ? graph.reverseAdjacency : graph.adjacency;
  const adjacencyList = adjacencyMap.get(nodeIndex);
  if (adjacencyList === void 0) {
    return [];
  }
  const result = [];
  for (const edgeIndex of adjacencyList) {
    const edge = graph.edges.get(edgeIndex);
    if (edge !== void 0) {
      const neighborNode = direction === "incoming" ? edge.source : edge.target;
      result.push(neighborNode);
    }
  }
  return result;
};
var escapeMermaidLabel = (label) => {
  return label.replace(/#/g, "#35;").replace(/"/g, "#quot;").replace(/</g, "#lt;").replace(/>/g, "#gt;").replace(/&/g, "#amp;").replace(/\[/g, "#91;").replace(/\]/g, "#93;").replace(/\{/g, "#123;").replace(/\}/g, "#125;").replace(/\(/g, "#40;").replace(/\)/g, "#41;").replace(/\|/g, "#124;").replace(/\\/g, "#92;").replace(/\n/g, "<br/>");
};
var formatMermaidNode = (nodeId, label, shape) => {
  switch (shape) {
    case "rectangle":
      return `${nodeId}["${label}"]`;
    case "rounded":
      return `${nodeId}("${label}")`;
    case "circle":
      return `${nodeId}(("${label}"))`;
    case "diamond":
      return `${nodeId}{"${label}"}`;
    case "hexagon":
      return `${nodeId}{{"${label}"}}`;
    case "stadium":
      return `${nodeId}(["${label}"])`;
    case "subroutine":
      return `${nodeId}[["${label}"]]`;
    case "cylindrical":
      return `${nodeId}[("${label}")]`;
  }
};
var toMermaid = (graph, options) => {
  const {
    diagramType,
    direction = "TD",
    edgeLabel = (data) => String(data),
    nodeLabel = (data) => String(data),
    nodeShape = () => "rectangle"
  } = options ?? {};
  const finalDiagramType = diagramType ?? (graph.type === "directed" ? "flowchart" : "graph");
  const lines = [];
  lines.push(`${finalDiagramType} ${direction}`);
  for (const [nodeIndex, nodeData] of graph.nodes) {
    const nodeId = String(nodeIndex);
    const label = escapeMermaidLabel(nodeLabel(nodeData));
    const shape = nodeShape(nodeData);
    const formattedNode = formatMermaidNode(nodeId, label, shape);
    lines.push(`  ${formattedNode}`);
  }
  const edgeOperator = finalDiagramType === "flowchart" ? "-->" : "---";
  for (const [, edgeData] of graph.edges) {
    const sourceId = String(edgeData.source);
    const targetId = String(edgeData.target);
    const label = escapeMermaidLabel(edgeLabel(edgeData.data));
    if (label) {
      lines.push(`  ${sourceId} ${edgeOperator}|"${label}"| ${targetId}`);
    } else {
      lines.push(`  ${sourceId} ${edgeOperator} ${targetId}`);
    }
  }
  return lines.join("\n");
};
var Walker = class {
  // @ts-ignore
  [Symbol.iterator];
  /**
   * Visits each element and maps it to a value using the provided function.
   *
   * Takes a function that receives the index and data,
   * and returns an iterable of the mapped values. Skips elements that
   * no longer exist in the graph.
   *
   * @example
   * ```ts
   * import { Graph } from "effect"
   *
   * const graph = Graph.directed<string, number>((mutable) => {
   *   const a = Graph.addNode(mutable, "A")
   *   const b = Graph.addNode(mutable, "B")
   *   Graph.addEdge(mutable, a, b, 1)
   * })
   *
   * const dfs = Graph.dfs(graph, { start: [0] })
   *
   * // Map to just the node data
   * const values = Array.from(dfs.visit((index, data) => data))
   * console.log(values) // ["A", "B"]
   *
   * // Map to custom objects
   * const custom = Array.from(dfs.visit((index, data) => ({ id: index, name: data })))
   * console.log(custom) // [{ id: 0, name: "A" }, { id: 1, name: "B" }]
   * ```
   *
   * @since 3.18.0
   * @category iterators
   */
  visit;
  constructor(visit) {
    this.visit = visit;
    this[Symbol.iterator] = visit((index, data) => [index, data])[Symbol.iterator];
  }
};
var indices = (walker) => walker.visit((index, _) => index);
var values2 = (walker) => walker.visit((_, data) => data);
var entries = (walker) => walker.visit((index, data) => [index, data]);
var dfsPostOrder = (graph, config = {}) => {
  const start = config.start ?? [];
  const direction = config.direction ?? "outgoing";
  for (const nodeIndex of start) {
    if (!hasNode(graph, nodeIndex)) {
      throw missingNode(nodeIndex);
    }
  }
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      const stack = [];
      const discovered = /* @__PURE__ */ new Set();
      const finished = /* @__PURE__ */ new Set();
      for (let i = start.length - 1; i >= 0; i--) {
        stack.push({
          node: start[i],
          visitedChildren: false
        });
      }
      const nextMapped = () => {
        while (stack.length > 0) {
          const current = stack[stack.length - 1];
          if (!discovered.has(current.node)) {
            discovered.add(current.node);
            current.visitedChildren = false;
          }
          if (!current.visitedChildren) {
            current.visitedChildren = true;
            const neighbors = neighborsDirected(graph, current.node, direction);
            for (let i = neighbors.length - 1; i >= 0; i--) {
              const neighbor = neighbors[i];
              if (!discovered.has(neighbor) && !finished.has(neighbor)) {
                stack.push({
                  node: neighbor,
                  visitedChildren: false
                });
              }
            }
          } else {
            const nodeToEmit = stack.pop().node;
            if (!finished.has(nodeToEmit)) {
              finished.add(nodeToEmit);
              const nodeData = getNode(graph, nodeToEmit);
              if (isSome2(nodeData)) {
                return {
                  done: false,
                  value: f(nodeToEmit, nodeData.value)
                };
              }
              return nextMapped();
            }
          }
        }
        return {
          done: true,
          value: void 0
        };
      };
      return {
        next: nextMapped
      };
    }
  }));
};
var nodes = (graph) => new Walker((f) => ({
  [Symbol.iterator]() {
    const nodeMap = graph.nodes;
    const iterator = nodeMap.entries();
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const [nodeIndex, nodeData] = result.value;
        return {
          done: false,
          value: f(nodeIndex, nodeData)
        };
      }
    };
  }
}));
var edges = (graph) => new Walker((f) => ({
  [Symbol.iterator]() {
    const edgeMap = graph.edges;
    const iterator = edgeMap.entries();
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const [edgeIndex, edgeData] = result.value;
        return {
          done: false,
          value: f(edgeIndex, edgeData)
        };
      }
    };
  }
}));
var externals = (graph, config = {}) => {
  const direction = config.direction ?? "outgoing";
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      const nodeMap = graph.nodes;
      const adjacencyMap = direction === "incoming" ? graph.reverseAdjacency : graph.adjacency;
      const nodeIterator = nodeMap.entries();
      const nextMapped = () => {
        let current = nodeIterator.next();
        while (!current.done) {
          const [nodeIndex, nodeData] = current.value;
          const adjacencyList = adjacencyMap.get(nodeIndex);
          if (adjacencyList === void 0 || adjacencyList.length === 0) {
            return {
              done: false,
              value: f(nodeIndex, nodeData)
            };
          }
          current = nodeIterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      };
      return {
        next: nextMapped
      };
    }
  }));
};

// src/diagnostics/classSelfMismatch.ts
var classSelfMismatch = createDiagnostic({
  name: "classSelfMismatch",
  code: 20,
  severity: "error",
  apply: fn("classSelfMismatch.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => typeParser.extendsContextTag(node)),
          orElse2(() => typeParser.extendsEffectTag(node)),
          orElse2(() => typeParser.extendsSchemaClass(node)),
          orElse2(() => typeParser.extendsSchemaTaggedClass(node)),
          orElse2(() => typeParser.extendsSchemaTaggedError(node)),
          orElse2(() => typeParser.extendsSchemaTaggedRequest(node)),
          orElse2(() => void_)
        );
        if (result) {
          const { className, selfTypeNode } = result;
          let actualName = sourceFile.text.substring(selfTypeNode.pos, selfTypeNode.end);
          if (ts.isTypeReferenceNode(selfTypeNode)) {
            if (ts.isIdentifier(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName);
            } else if (ts.isQualifiedName(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName.right);
            }
          }
          const expectedName = ts.idText(className);
          if (actualName !== expectedName) {
            report({
              location: selfTypeNode,
              messageText: `Self type parameter should be '${expectedName}'`,
              fixes: [{
                fixName: "classSelfMismatch_fix",
                description: `Replace '${actualName}' with '${expectedName}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const typeArgs = ts.isTypeReferenceNode(selfTypeNode) ? selfTypeNode.typeArguments : void 0;
                  const newTypeReference = ts.factory.createTypeReferenceNode(
                    ts.factory.createIdentifier(expectedName),
                    typeArgs
                  );
                  changeTracker.replaceNode(sourceFile, selfTypeNode, newTypeReference);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/deterministicKeys.ts
var deterministicKeys = createDiagnostic({
  name: "deterministicKeys",
  code: 25,
  severity: "off",
  apply: fn("deterministicKeys.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeScriptUtils = yield* service(TypeScriptUtils);
    const options = yield* service(LanguageServicePluginOptions);
    const parseExtendsCustom = cachedBy(
      fn("parseExtendsCustom")(function* (classDeclaration) {
        if (!options.extendedKeyDetection) {
          return yield* typeParserIssue("Extended key detection is disabled", void 0, classDeclaration);
        }
        if (!classDeclaration.name) {
          return yield* typeParserIssue("Class has no name", void 0, classDeclaration);
        }
        if (!ts.isIdentifier(classDeclaration.name)) {
          return yield* typeParserIssue("Class name is not an identifier", void 0, classDeclaration);
        }
        const heritageClauses = classDeclaration.heritageClauses;
        if (!heritageClauses) {
          return yield* typeParserIssue("Class has no heritage clauses", void 0, classDeclaration);
        }
        const nodeToVisit2 = [...classDeclaration.heritageClauses];
        const appendNodeToVisit2 = (node) => {
          nodeToVisit2.push(node);
          return void 0;
        };
        while (nodeToVisit2.length > 0) {
          const node = nodeToVisit2.shift();
          if (ts.isCallExpression(node)) {
            for (let i = 0; i < node.arguments.length; i++) {
              const arg = node.arguments[i];
              if (!ts.isStringLiteral(arg)) continue;
              const resolvedSignature = typeChecker.getResolvedSignature(node);
              if (resolvedSignature) {
                const parameter = resolvedSignature.parameters[i];
                if (!parameter) continue;
                if (parameter.declarations) {
                  for (const declaration of parameter.declarations) {
                    const parameterSourceFile = typeScriptUtils.getSourceFileOfNode(declaration);
                    const paramText = parameterSourceFile.text.substring(declaration.pos, declaration.end);
                    if (paramText.toLowerCase().includes("@effect-identifier")) {
                      return { className: classDeclaration.name, keyStringLiteral: arg, target: "custom" };
                    }
                  }
                }
              }
            }
          }
          ts.forEachChild(node, appendNodeToVisit2);
        }
        return yield* typeParserIssue(
          "Class does not extend any custom pattern",
          void 0,
          classDeclaration
        );
      }),
      "deterministicKeys.parseExtendsCustom",
      (classDeclaration) => classDeclaration
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          pipe(
            typeParser.extendsEffectService(node),
            orElse2(() => typeParser.extendsContextTag(node)),
            orElse2(() => typeParser.extendsEffectTag(node)),
            map5(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "service" }))
          ),
          orElse2(
            () => pipe(
              typeParser.extendsDataTaggedError(node),
              orElse2(() => typeParser.extendsSchemaTaggedError(node)),
              map5(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "error" }))
            )
          ),
          orElse2(() => parseExtendsCustom(node)),
          orElse2(() => void_)
        );
        if (result && result.keyStringLiteral) {
          const { className, keyStringLiteral, target } = result;
          const classNameText = ts.idText(className);
          const expectedKey = yield* createString(sourceFile, classNameText, target);
          if (!expectedKey) continue;
          const actualIdentifier = keyStringLiteral.text;
          if (actualIdentifier !== expectedKey) {
            report({
              location: keyStringLiteral,
              messageText: `Key should be '${expectedKey}'`,
              fixes: [{
                fixName: "deterministicKeys_fix",
                description: `Replace '${actualIdentifier}' with '${expectedKey}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const newStringLiteral = ts.factory.createStringLiteral(expectedKey);
                  changeTracker.replaceNode(sourceFile, keyStringLiteral, newStringLiteral);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/duplicatePackage.ts
var checkedPackagesCache = /* @__PURE__ */ new Map();
var programResolvedCacheSize = /* @__PURE__ */ new Map();
var duplicatePackage = createDiagnostic({
  name: "duplicatePackage",
  code: 6,
  severity: "warning",
  apply: fn("duplicatePackage.apply")(function* (sourceFile, report) {
    const program = yield* service(TypeScriptProgram);
    const tsUtils = yield* service(TypeScriptUtils);
    const options = yield* service(LanguageServicePluginOptions);
    if (sourceFile.statements.length < 1) return;
    let resolvedPackages = checkedPackagesCache.get(sourceFile.fileName) || {};
    const newResolvedModuleSize = hasProperty(program, "resolvedModules") && hasProperty(program.resolvedModules, "size") && isNumber(program.resolvedModules.size) ? program.resolvedModules.size : 0;
    const oldResolvedSize = programResolvedCacheSize.get(sourceFile.fileName) || -1;
    if (newResolvedModuleSize !== oldResolvedSize) {
      const seenPackages = /* @__PURE__ */ new Set();
      resolvedPackages = {};
      program.getSourceFiles().map((_) => {
        const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(_);
        if (!packageInfo) return;
        const packageNameAndVersion = packageInfo.name + "@" + packageInfo.version;
        if (seenPackages.has(packageNameAndVersion)) return;
        seenPackages.add(packageNameAndVersion);
        if (!(packageInfo.name === "effect" || packageInfo.hasEffectInPeerDependencies)) return;
        if (options.allowedDuplicatedPackages.indexOf(packageInfo.name) > -1) return;
        resolvedPackages[packageInfo.name] = resolvedPackages[packageInfo.name] || {};
        resolvedPackages[packageInfo.name][packageInfo.version] = packageInfo.packageDirectory;
      });
      checkedPackagesCache.set(sourceFile.fileName, resolvedPackages);
      programResolvedCacheSize.set(sourceFile.fileName, newResolvedModuleSize);
    }
    for (const packageName of Object.keys(resolvedPackages)) {
      if (Object.keys(resolvedPackages[packageName]).length > 1) {
        const versions = Object.keys(resolvedPackages[packageName]);
        report({
          location: sourceFile.statements[0],
          messageText: `Package ${packageName} is referenced multiple times with different versions (${versions.join(", ")}) and may cause unexpected type errors.
Cleanup your dependencies and your package lockfile to avoid multiple instances of this package and reload the project.
If this is intended set the LSP config "allowedDuplicatedPackages" to ${JSON.stringify(options.allowedDuplicatedPackages.concat([packageName]))}.

${versions.map((version) => `- found ${version} at ${resolvedPackages[packageName][version]}`).join("\n")}`,
          fixes: []
        });
      }
    }
  })
});

// src/diagnostics/effectGenUsesAdapter.ts
var effectGenUsesAdapter = createDiagnostic({
  name: "effectGenUsesAdapter",
  code: 23,
  severity: "warning",
  apply: fn("effectGenUsesAdapter.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.effectGen(node),
          map5(({ generatorFunction }) => {
            if (generatorFunction.parameters.length > 0) {
              const adapter = generatorFunction.parameters[0];
              report({
                location: adapter,
                messageText: `The adapter of Effect.gen is not required anymore, it is now just an alias of pipe.`,
                fixes: []
              });
            }
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/effectInVoidSuccess.ts
var effectInVoidSuccess = createDiagnostic({
  name: "effectInVoidSuccess",
  code: 14,
  severity: "warning",
  apply: fn("effectInVoidSuccess.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForEffectInVoid = fn("effectInVoidSuccess.checkForEffectInVoid")(function* (node, expectedType, valueNode, realType) {
      const expectedEffect = yield* typeParser.effectType(expectedType, node);
      const realEffect = yield* typeParser.effectType(realType, valueNode);
      if (expectedEffect.A.flags & ts.TypeFlags.Void) {
        const voidValueTypes = typeCheckerUtils.unrollUnionMembers(realEffect.A);
        const voidedEffect = yield* firstSuccessOf(
          voidValueTypes.map((_) => map5(typeParser.strictEffectType(_, node), () => _))
        );
        return { voidedEffect };
      }
      return yield* fail(typeParserIssue("expectedEffect success is not void"));
    });
    const entries2 = typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries2) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForEffectInVoid(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map5(({ voidedEffect }) => {
            report(
              {
                location: node,
                messageText: `There is a nested '${typeChecker.typeToString(voidedEffect)}' in the 'void' success channel, beware that this could lead to nested Effect<Effect<...>> that won't be executed.`,
                fixes: []
              }
            );
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/floatingEffect.ts
var floatingEffect = createDiagnostic({
  name: "floatingEffect",
  code: 3,
  severity: "error",
  apply: fn("floatingEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    function isFloatingExpression(node) {
      if (!ts.isExpressionStatement(node)) return false;
      if (!(ts.isBlock(node.parent) || ts.isSourceFile(node.parent))) return false;
      const expression = node.expression;
      if (ts.isBinaryExpression(expression) && expression.operatorToken && (expression.operatorToken.kind === ts.SyntaxKind.EqualsToken || expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.BarBarEqualsToken)) return false;
      return true;
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!isFloatingExpression(node)) continue;
      const type = typeChecker.getTypeAtLocation(node.expression);
      const effect = yield* option(typeParser.effectType(type, node.expression));
      if (isSome2(effect)) {
        const allowedFloatingEffects = yield* pipe(
          typeParser.fiberType(type, node.expression),
          orElse2(() => typeParser.effectSubtype(type, node.expression)),
          option
        );
        if (isNone2(allowedFloatingEffects)) {
          const isStrictEffect = yield* option(typeParser.strictEffectType(type, node.expression));
          const name = isSome2(isStrictEffect) ? "Effect" : "Effect-able " + typeChecker.typeToString(type);
          report({
            location: node,
            messageText: `${name} must be yielded or assigned to a variable.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/genericEffectServices.ts
var genericEffectServices = createDiagnostic({
  name: "genericEffectServices",
  code: 10,
  severity: "warning",
  apply: fn("genericEffectServices.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isClassDeclaration(node) && node.name && node.typeParameters && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type, node),
          map5(() => {
            report({
              location: reportAt,
              messageText: `Effect Services with type parameters are not supported because they cannot be properly discriminated at runtime, which may cause unexpected behavior.`,
              fixes: []
            });
          }),
          orElse2(() => sync(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/importFromBarrel.ts
var importFromBarrel = createDiagnostic({
  name: "importFromBarrel",
  code: 12,
  severity: "off",
  apply: fn("importFromBarrel.apply")(function* (sourceFile, report) {
    const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0) return;
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const program = yield* service(TypeScriptProgram);
    const getModuleSpecifier = makeGetModuleSpecifier(ts);
    const resolveExternalModuleName = makeResolveExternalModuleName(typeChecker);
    const packageNamesToCheck = flatten(
      languageServicePluginOptions.namespaceImportPackages.map(
        (packageName) => tsUtils.resolveModulePattern(program, sourceFile, packageName)
      )
    );
    const isImportedFromBarrelExport = (element) => {
      if (!(getModuleSpecifier && resolveExternalModuleName)) return;
      const importDeclaration = ts.findAncestor(element, (node) => ts.isImportDeclaration(node));
      if (!importDeclaration) return;
      if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) return;
      const importClause = importDeclaration.importClause;
      if (!importClause) return;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) return;
      if (!ts.isNamedImports(namedBindings)) return;
      const barrelModuleName = importDeclaration.moduleSpecifier.text;
      if (packageNamesToCheck.indexOf(barrelModuleName.toLowerCase()) === -1) return;
      const moduleSymbol = resolveExternalModuleName(importDeclaration.moduleSpecifier);
      if (!moduleSymbol) return;
      if (!moduleSymbol.exports) return;
      const sourceFile2 = tsUtils.getSourceFileOfNode(importDeclaration);
      if (!sourceFile2) return;
      const nodeForSymbol = element.propertyName || element.name;
      const aliasSymbol = element.name || element.propertyName;
      const aliasedName = ts.idText(aliasSymbol);
      if (!ts.isIdentifier(nodeForSymbol)) return;
      const importedName = ts.idText(nodeForSymbol);
      if (!importedName) return;
      const reexportedSymbol = moduleSymbol.exports.get(ts.escapeLeadingUnderscores(importedName));
      if (!reexportedSymbol) return;
      if (!(reexportedSymbol.declarations && reexportedSymbol.declarations.length === 1)) return;
      const namespaceExport = reexportedSymbol.declarations[0];
      if (!ts.isNamespaceExport(namespaceExport)) return;
      const exportDeclaration = namespaceExport.parent;
      if (!ts.isExportDeclaration(exportDeclaration)) return;
      if (!exportDeclaration.moduleSpecifier) return;
      const originalModuleSymbol = resolveExternalModuleName(exportDeclaration.moduleSpecifier);
      if (!originalModuleSymbol) return;
      if (!originalModuleSymbol.valueDeclaration) return;
      const originalSourceFile = tsUtils.getSourceFileOfNode(originalModuleSymbol.valueDeclaration);
      if (!originalSourceFile) return;
      const unbarrelledFileName = getModuleSpecifier(
        program.getCompilerOptions(),
        sourceFile2,
        sourceFile2.fileName,
        originalSourceFile.fileName,
        program
      );
      if (unbarrelledFileName.toLowerCase().indexOf(barrelModuleName.toLowerCase() + "/") === -1) return;
      return {
        unbarrelledFileName,
        importedName,
        barrelModuleName,
        importClause,
        namedBindings,
        importDeclaration,
        aliasedName
      };
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const parent = node.parent;
      if (!(ts.isImportSpecifier(node) && ts.isNamedImports(parent))) {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      const result = isImportedFromBarrelExport(node);
      if (!result) continue;
      const {
        aliasedName,
        barrelModuleName,
        importClause,
        importDeclaration,
        namedBindings,
        unbarrelledFileName
      } = result;
      report({
        location: node,
        messageText: `Importing from barrel module ${barrelModuleName} is not allowed.`,
        fixes: [
          {
            fixName: "replaceWithUnbarrelledImport",
            description: `Import * as ${aliasedName} from ${unbarrelledFileName}`,
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              const newImport = ts.factory.createImportDeclaration(
                void 0,
                ts.factory.createImportClause(
                  importClause.isTypeOnly || node.isTypeOnly,
                  void 0,
                  ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasedName))
                ),
                ts.factory.createStringLiteral(unbarrelledFileName)
              );
              if (namedBindings.elements.length === 1) {
                changeTracker.replaceNode(
                  sourceFile,
                  importDeclaration,
                  newImport
                );
              } else {
                changeTracker.insertNodeAfter(sourceFile, importDeclaration, newImport);
                changeTracker.replaceNode(
                  sourceFile,
                  namedBindings,
                  ts.factory.updateNamedImports(
                    namedBindings,
                    namedBindings.elements.filter((e) => e !== node)
                  )
                );
              }
            })
          }
        ]
      });
    }
  })
});

// src/diagnostics/leakingRequirements.ts
var leakingRequirements = createDiagnostic({
  name: "leakingRequirements",
  code: 8,
  severity: "suggestion",
  apply: fn("leakingRequirements.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const parseLeakedRequirements = cachedBy(
      fn("leakingServices.checkServiceLeaking")(
        function* (service2, atLocation) {
          const properties = typeChecker.getPropertiesOfType(service2);
          if (properties.length < 1) return [];
          const memory = /* @__PURE__ */ new Map();
          let sharedRequirementsKeys = void 0;
          let effectMembers = 0;
          for (const property of properties) {
            const servicePropertyType = typeChecker.getTypeOfSymbolAtLocation(property, atLocation);
            let effectContextType = void 0;
            yield* pipe(
              typeParser.effectType(servicePropertyType, atLocation),
              map5((_) => effectContextType = _.R),
              orElse2(() => {
                const servicePropertyCallSignatures = typeChecker.getSignaturesOfType(
                  servicePropertyType,
                  ts.SignatureKind.Call
                );
                if (servicePropertyCallSignatures.length === 1) {
                  return pipe(
                    typeParser.effectType(
                      typeChecker.getReturnTypeOfSignature(servicePropertyCallSignatures[0]),
                      atLocation
                    ),
                    map5((_) => {
                      effectContextType = _.R;
                    })
                  );
                }
                return void_;
              }),
              ignore
            );
            if (effectContextType) {
              effectMembers++;
              const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                memory,
                effectContextType,
                (type) => {
                  if (type.flags & ts.TypeFlags.Never) return succeed(true);
                  return pipe(
                    typeParser.scopeType(type, atLocation),
                    map5(() => true),
                    orElse2(() => succeed(false))
                  );
                }
              );
              if (!sharedRequirementsKeys) {
                sharedRequirementsKeys = allIndexes;
              } else {
                sharedRequirementsKeys = intersection(sharedRequirementsKeys, allIndexes);
                if (sharedRequirementsKeys.length === 0) return [];
              }
            }
          }
          if (sharedRequirementsKeys && sharedRequirementsKeys.length > 0 && effectMembers >= 2) {
            return sharedRequirementsKeys.map((key) => memory.get(key)).filter(
              (type) => {
                let symbol3 = type.symbol;
                if (symbol3 && symbol3.flags & ts.SymbolFlags.Alias) {
                  symbol3 = typeChecker.getAliasedSymbol(symbol3);
                }
                return !(symbol3.declarations || []).some((declaration) => {
                  const declarationSource = tsUtils.getSourceFileOfNode(declaration);
                  if (!declarationSource) return false;
                  return declarationSource.text.substring(declaration.pos, declaration.end).toLowerCase().indexOf(
                    "@effect-leakable-service"
                  ) > -1;
                });
              }
            );
          }
          return [];
        }
      ),
      "leakingServices.checkServiceLeaking",
      (_, service2) => service2
    );
    function reportLeakingRequirements(node, requirements) {
      if (requirements.length === 0) return;
      report({
        location: node,
        messageText: `This Service is leaking the ${requirements.map((_) => typeChecker.typeToString(_)).join(" | ")} requirement.
If these requirements cannot be cached and are expected to be provided per method invocation (e.g. HttpServerRequest), you can either safely disable this diagnostic for this line through quickfixes or mark the service declaration with a JSDoc @effect-leakable-service.
More info at https://effect.website/docs/requirements-management/layers/#avoiding-requirement-leakage`,
        fixes: []
      });
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "GenericTag") {
        typesToCheck.push([typeChecker.getTypeAtLocation(node), node]);
      } else if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type, node),
          flatMap2(
            ({ Service }) => pipe(
              parseLeakedRequirements(Service, node),
              map5(
                (requirements) => reportLeakingRequirements(reportAt, sort(requirements, typeCheckerUtils.deterministicTypeOrder))
              )
            )
          ),
          orElse2(() => sync(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missedPipeableOpportunity.ts
var missedPipeableOpportunity = createDiagnostic({
  name: "missedPipeableOpportunity",
  code: 26,
  severity: "off",
  apply: fn("missedPipeableOpportunity.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const options = yield* service(LanguageServicePluginOptions);
    const nodeToVisit = [sourceFile];
    const prependNodeToVisit = (node) => {
      nodeToVisit.unshift(node);
      return void 0;
    };
    const callChainNodes = /* @__PURE__ */ new WeakMap();
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node) && node.arguments.length === 1 && node.parent) {
        const parentChain = callChainNodes.get(node.parent) || [];
        callChainNodes.set(node, parentChain.concat(node));
      } else if (node.parent && callChainNodes.has(node.parent) && ts.isExpression(node)) {
        const parentChain = callChainNodes.get(node.parent) || [];
        const originalParentChain = parentChain.slice();
        parentChain.push(node);
        while (parentChain.length > options.pipeableMinArgCount) {
          const subject = parentChain.pop();
          const resultType = typeChecker.getTypeAtLocation(subject);
          const pipeableType = yield* pipe(typeParser.pipeableType(resultType, subject), orElse2(() => void_));
          if (pipeableType) {
            report({
              location: parentChain[0],
              messageText: `Nested function calls can be converted to pipeable style for better readability.`,
              fixes: [{
                fixName: "missedPipeableOpportunity_fix",
                description: "Convert to pipe style",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  changeTracker.replaceNode(
                    sourceFile,
                    parentChain[0],
                    ts.factory.createCallExpression(
                      ts.factory.createPropertyAccessExpression(
                        subject,
                        "pipe"
                      ),
                      void 0,
                      pipe(
                        parentChain,
                        filter(ts.isCallExpression),
                        map4((call) => call.expression),
                        reverse
                      )
                    )
                  );
                })
              }]
            });
            originalParentChain.forEach((node2) => callChainNodes.delete(node2));
            break;
          }
        }
      }
      ts.forEachChild(node, prependNodeToVisit);
    }
  })
});

// src/diagnostics/missingEffectContext.ts
var missingEffectContext = createDiagnostic({
  name: "missingEffectContext",
  code: 1,
  severity: "error",
  apply: fn("missingEffectContext.apply")(function* (sourceFile, report) {
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForMissingContextTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map5(
        ([expectedEffect, realEffect]) => typeCheckerUtils.getMissingTypeEntriesInTargetType(
          realEffect.R,
          expectedEffect.R
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries2 = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries2) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingContextTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map5(
            (missingTypes) => missingTypes.length > 0 ? report(
              {
                location: node,
                messageText: `Missing '${sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(" | ")}' in the expected Effect context.`,
                fixes: []
              }
            ) : void 0
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingEffectError.ts
var missingEffectError = createDiagnostic({
  name: "missingEffectError",
  code: 1,
  severity: "error",
  apply: fn("missingEffectError.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const createDieMessage = (message) => ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifier),
        "dieMessage"
      ),
      void 0,
      [ts.factory.createStringLiteral(message)]
    );
    const checkForMissingErrorTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map5(
        ([expectedEffect, realEffect]) => pipe(
          typeCheckerUtils.getMissingTypeEntriesInTargetType(
            realEffect.E,
            expectedEffect.E
          ),
          (missingErrorTypes) => ({ missingErrorTypes, expectedErrorType: expectedEffect.E })
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries2 = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries2) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingErrorTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map5((result) => {
            if (result.missingErrorTypes.length === 0) return;
            const fixes = [];
            if (ts.isExpression(valueNode) && result.expectedErrorType.flags & ts.TypeFlags.Never) {
              fixes.push({
                fixName: "missingEffectError_catchAll",
                description: "Catch all errors with Effect.catchAll",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  changeTracker.insertText(
                    sourceFile,
                    ts.getTokenPosOfNode(valueNode, sourceFile),
                    effectModuleIdentifier + ".catchAll("
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ", () => ");
                  changeTracker.insertNodeAt(
                    sourceFile,
                    valueNode.end,
                    createDieMessage("TODO: catchAll not implemented")
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ")");
                })
              });
            }
            if (ts.isExpression(valueNode)) {
              const propertyAssignments = pipe(
                result.missingErrorTypes,
                map4((_) => typeChecker.getPropertyOfType(_, "_tag")),
                filter((_) => !!_),
                map4((_) => typeChecker.getTypeOfSymbolAtLocation(_, valueNode)),
                filter((_) => !!(_.flags & ts.TypeFlags.Literal)),
                map4((_) => typeChecker.typeToTypeNode(_, void 0, ts.NodeBuilderFlags.NoTruncation)),
                filter((_) => !!_ && ts.isLiteralTypeNode(_)),
                map4((_) => _.literal),
                filter((_) => ts.isLiteralExpression(_)),
                map4((_) => _.text),
                sort(string2),
                map4(
                  (_) => ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier(_),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      createDieMessage(`TODO: catchTags() not implemented for ${_}`)
                    )
                  )
                )
              );
              if (propertyAssignments.length === result.missingErrorTypes.length) {
                fixes.push({
                  fixName: "missingEffectError_tagged",
                  description: "Catch unexpected errors with Effect.catchTag",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.insertText(
                      sourceFile,
                      ts.getTokenPosOfNode(valueNode, sourceFile),
                      effectModuleIdentifier + ".catchTags("
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ", ");
                    changeTracker.insertNodeAt(
                      sourceFile,
                      valueNode.end,
                      ts.factory.createObjectLiteralExpression(propertyAssignments)
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ")");
                  })
                });
              }
            }
            const typeNames = sortTypes(result.missingErrorTypes).map((_) => typeChecker.typeToString(_));
            report(
              {
                location: node,
                messageText: `Missing '${typeNames.join(" | ")}' in the expected Effect errors.`,
                fixes
              }
            );
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingEffectServiceDependency.ts
var missingEffectServiceDependency = createDiagnostic({
  name: "missingEffectServiceDependency",
  code: 22,
  severity: "off",
  apply: fn("missingEffectServiceDependency.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => void_)
        );
        if (serviceResult) {
          const { className, options } = serviceResult;
          const classSymbol = typeChecker.getSymbolAtLocation(className);
          if (classSymbol) {
            const classType = typeChecker.getTypeOfSymbol(classSymbol);
            const defaultWithoutDepsProperty = typeChecker.getPropertyOfType(classType, "DefaultWithoutDependencies");
            const defaultProperty = defaultWithoutDepsProperty || typeChecker.getPropertyOfType(classType, "Default");
            if (defaultProperty) {
              const defaultType = typeChecker.getTypeOfSymbolAtLocation(defaultProperty, node);
              const layerResult = yield* pipe(
                typeParser.layerType(defaultType, node),
                orElse2(() => void_)
              );
              if (layerResult) {
                const servicesMemory = /* @__PURE__ */ new Map();
                const excludeNever = (type) => succeed((type.flags & ts.TypeFlags.Never) !== 0);
                const { allIndexes: requiredIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                  servicesMemory,
                  layerResult.RIn,
                  excludeNever
                );
                const providedIndexes = /* @__PURE__ */ new Set();
                const optionsType = typeChecker.getTypeAtLocation(options);
                const dependenciesProperty = typeChecker.getPropertyOfType(optionsType, "dependencies");
                let types = [];
                if (dependenciesProperty) {
                  const dependenciesTypes = typeChecker.getTypeOfSymbolAtLocation(dependenciesProperty, options);
                  const numberIndexType = typeChecker.getIndexTypeOfType(dependenciesTypes, ts.IndexKind.Number);
                  types = numberIndexType ? typeCheckerUtils.unrollUnionMembers(numberIndexType) : [];
                }
                for (const depType of types) {
                  const depLayerResult = yield* pipe(
                    typeParser.layerType(depType, options),
                    orElse2(() => void_)
                  );
                  if (depLayerResult) {
                    const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                      servicesMemory,
                      depLayerResult.ROut,
                      excludeNever
                    );
                    for (const index of allIndexes) {
                      providedIndexes.add(index);
                    }
                  }
                }
                const missingIndexes = requiredIndexes.filter((index) => !providedIndexes.has(index));
                if (missingIndexes.length > 0) {
                  const missingTypes = missingIndexes.map((index) => servicesMemory.get(index));
                  const missingTypeNames = missingTypes.map((t) => typeChecker.typeToString(t));
                  const message = missingTypeNames.length === 1 ? `Service '${missingTypeNames[0]}' is required but not provided by dependencies` : `Services ${missingTypeNames.map((s) => `'${s}'`).join(", ")} are required but not provided by dependencies`;
                  report({
                    location: className,
                    messageText: message,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/missingReturnYieldStar.ts
var missingReturnYieldStar = createDiagnostic({
  name: "missingReturnYieldStar",
  code: 7,
  severity: "error",
  apply: fn("missingReturnYieldStar.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken) {
        const type = typeChecker.getTypeAtLocation(node.expression);
        const maybeEffect = yield* option(typeParser.effectType(type, node.expression));
        if (isSome2(maybeEffect) && maybeEffect.value.A.flags & ts.TypeFlags.Never) {
          const generatorFunctionOrReturnStatement = ts.findAncestor(
            node,
            (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isReturnStatement(_) || ts.isThrowStatement(_)
          );
          if (generatorFunctionOrReturnStatement && !ts.isReturnStatement(generatorFunctionOrReturnStatement) && !ts.isThrowStatement(generatorFunctionOrReturnStatement)) {
            if (generatorFunctionOrReturnStatement && generatorFunctionOrReturnStatement.parent) {
              const effectGenNode = generatorFunctionOrReturnStatement.parent;
              const effectGenLike = yield* pipe(
                typeParser.effectGen(effectGenNode),
                orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
                orElse2(() => typeParser.effectFnGen(effectGenNode)),
                option
              );
              if (isSome2(effectGenLike)) {
                const fix = node.expression ? [{
                  fixName: "missingReturnYieldStar_fix",
                  description: "Add return statement",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.replaceNode(
                      sourceFile,
                      node,
                      ts.factory.createReturnStatement(
                        node
                      )
                    );
                  })
                }] : [];
                report({
                  location: node,
                  messageText: `It is recommended to use return yield* for Effects that never succeed to signal a definitive exit point for type narrowing and tooling support.`,
                  fixes: fix
                });
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/missingStarInYieldEffectGen.ts
var missingStarInYieldEffectGen = createDiagnostic({
  name: "missingStarInYieldEffectGen",
  code: 4,
  severity: "error",
  apply: fn("missingStarInYieldEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const brokenGenerators = /* @__PURE__ */ new Set();
    const brokenYields = /* @__PURE__ */ new Set();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken === void 0) {
        const functionStarNode = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_)
        );
        if (functionStarNode && functionStarNode.parent) {
          const effectGenNode = functionStarNode.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse2(() => typeParser.effectFnGen(effectGenNode)),
            map5(({ generatorFunction }) => {
              if (generatorFunction) {
                brokenGenerators.add(ts.getTokenPosOfNode(generatorFunction, tsUtils.getSourceFileOfNode(node)));
              }
              brokenYields.add(node);
            }),
            ignore
          );
        }
      }
    }
    brokenGenerators.forEach(
      (pos) => report({
        location: { pos, end: pos + "function".length },
        messageText: `Seems like you used yield instead of yield* inside this Effect.gen.`,
        fixes: []
      })
    );
    brokenYields.forEach((node) => {
      const fix = node.expression ? [{
        fixName: "missingStarInYieldEffectGen_fix",
        description: "Replace yield with yield*",
        apply: gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          changeTracker.replaceNode(
            sourceFile,
            node,
            ts.factory.createYieldExpression(
              ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
              node.expression
            )
          );
        })
      }] : [];
      report({
        location: node,
        messageText: `When yielding Effects inside Effect.gen, you should use yield* instead of yield.`,
        fixes: fix
      });
    });
  })
});

// src/diagnostics/multipleEffectProvide.ts
var multipleEffectProvide = createDiagnostic({
  name: "multipleEffectProvide",
  code: 18,
  severity: "warning",
  apply: fn("multipleEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const parseEffectProvideLayer = (node) => {
      if (ts.isCallExpression(node) && node.arguments.length > 0) {
        const layer = node.arguments[0];
        const type = typeChecker.getTypeAtLocation(layer);
        return pipe(
          typeParser.isNodeReferenceToEffectModuleApi("provide")(node.expression),
          flatMap2(() => typeParser.layerType(type, layer)),
          map5(() => ({ layer, node })),
          orElse2(() => void_)
        );
      }
      return void_;
    };
    const parsePipeCall = (node) => gen(function* () {
      const { args: args2 } = yield* typeParser.pipeCall(node);
      let currentChunk = 0;
      const previousLayers = [[]];
      for (const pipeArg of args2) {
        const parsedProvide = yield* parseEffectProvideLayer(pipeArg);
        if (parsedProvide) {
          previousLayers[currentChunk].push(parsedProvide);
        } else {
          currentChunk++;
          previousLayers.push([]);
        }
      }
      for (const chunk of previousLayers) {
        if (chunk.length < 2) continue;
        report({
          location: chunk[0].node,
          messageText: "Avoid chaining Effect.provide calls, as this can lead to service lifecycle issues. Instead, merge layers and provide them in a single call.",
          fixes: [{
            fixName: "multipleEffectProvide_fix",
            description: "Combine into a single provide",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              changeTracker.deleteRange(sourceFile, {
                pos: ts.getTokenPosOfNode(chunk[0].node, sourceFile),
                end: chunk[chunk.length - 1].node.end
              });
              const newNode = ts.factory.createCallExpression(
                ts.factory.createPropertyAccessExpression(
                  ts.factory.createIdentifier(effectModuleIdentifier),
                  ts.factory.createIdentifier("provide")
                ),
                void 0,
                [ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(layerModuleIdentifier),
                    ts.factory.createIdentifier("mergeAll")
                  ),
                  void 0,
                  chunk.map((c) => c.layer)
                )]
              );
              changeTracker.insertNodeAt(sourceFile, ts.getTokenPosOfNode(chunk[0].node, sourceFile), newNode);
            })
          }]
        });
      }
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(parsePipeCall(node), ignore);
      }
    }
  })
});

// src/diagnostics/nonObjectEffectServiceType.ts
var nonObjectEffectServiceType = createDiagnostic({
  name: "nonObjectEffectServiceType",
  code: 24,
  severity: "error",
  apply: fn("nonObjectEffectServiceType.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    function isPrimitiveType(type) {
      return typeCheckerUtils.unrollUnionMembers(type).some(
        (type2) => !!(type2.flags & ts.TypeFlags.String || type2.flags & ts.TypeFlags.Number || type2.flags & ts.TypeFlags.Boolean || type2.flags & ts.TypeFlags.StringLiteral || type2.flags & ts.TypeFlags.NumberLiteral || type2.flags & ts.TypeFlags.BooleanLiteral || type2.flags & ts.TypeFlags.Undefined || type2.flags & ts.TypeFlags.Null)
      );
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => void_)
        );
        if (serviceResult && serviceResult.options && ts.isObjectLiteralExpression(serviceResult.options)) {
          const options = serviceResult.options;
          for (const property of options.properties) {
            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {
              continue;
            }
            const propertyName = ts.idText(property.name);
            const propertyValue = property.initializer;
            const errorToReport = {
              location: property.name,
              messageText: "Effect.Service requires the service type to be an object {} and not a primitive type. \nConsider wrapping the value in an object, or manually using Context.Tag or Effect.Tag if you want to use a primitive instead.",
              fixes: []
            };
            if (propertyName === "succeed") {
              const valueType = typeChecker.getTypeAtLocation(propertyValue);
              if (isPrimitiveType(valueType)) {
                report(errorToReport);
              }
            } else if (propertyName === "sync") {
              const valueType = typeChecker.getTypeAtLocation(propertyValue);
              const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
              for (const signature of signatures) {
                const returnType = typeChecker.getReturnTypeOfSignature(signature);
                if (isPrimitiveType(returnType)) {
                  report(errorToReport);
                  break;
                }
              }
            } else if (propertyName === "effect" || propertyName === "scoped") {
              const valueType = typeChecker.getTypeAtLocation(propertyValue);
              const effectResult = yield* pipe(
                typeParser.effectType(valueType, propertyValue),
                orElse2(() => void_)
              );
              if (effectResult) {
                if (isPrimitiveType(effectResult.A)) {
                  report(errorToReport);
                  continue;
                }
              } else {
                const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
                for (const signature of signatures) {
                  const returnType = typeChecker.getReturnTypeOfSignature(signature);
                  const effectReturnResult = yield* pipe(
                    typeParser.effectType(returnType, propertyValue),
                    orElse2(() => void_)
                  );
                  if (effectReturnResult && isPrimitiveType(effectReturnResult.A)) {
                    report(errorToReport);
                    break;
                  }
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/outdatedEffectCodegen.ts
var outdatedEffectCodegen = createDiagnostic({
  name: "outdatedEffectCodegen",
  code: 19,
  severity: "warning",
  apply: fn("outdatedEffectCodegen.apply")(function* (sourceFile, _report) {
    const codegensWithRanges = yield* getCodegensForSourceFile(codegens, sourceFile);
    for (const { codegen, hash: hash2, range } of codegensWithRanges) {
      yield* pipe(
        getEditsForCodegen([codegen], sourceFile, range),
        map5((applicable) => {
          if (applicable.hash !== hash2) {
            _report({
              location: range,
              messageText: `Codegen ${codegen.name} result is outdated`,
              fixes: [
                {
                  fixName: "outdatedEffectCodegen_fix",
                  description: `Re-run ${codegen.name}`,
                  apply: applicable.apply
                },
                {
                  fixName: "outdatedEffectCodegen_ignore",
                  description: `Ignore this ${codegen.name} update`,
                  apply: applicable.ignore
                }
              ]
            });
          }
        }),
        orElse2(
          (e) => sync(() => {
            _report({
              location: range,
              messageText: `Codegen ${codegen.name} is not applicable here: ${e.cause}`,
              fixes: []
            });
          })
        ),
        ignore
      );
    }
  })
});

// src/diagnostics/overriddenSchemaConstructor.ts
var overriddenSchemaConstructor = createDiagnostic({
  name: "overriddenSchemaConstructor",
  code: 30,
  severity: "error",
  apply: fn("overriddenSchemaConstructor.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.heritageClauses) {
        let extendsSchema = false;
        for (const heritageClause of node.heritageClauses) {
          if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
            for (const type of heritageClause.types) {
              const typeAtLocation = typeChecker.getTypeAtLocation(type.expression);
              const isSchema = yield* pipe(
                typeParser.effectSchemaType(typeAtLocation, type.expression),
                map5(() => true),
                orElse2(() => succeed(false))
              );
              if (isSchema) {
                extendsSchema = true;
                break;
              }
            }
          }
          if (extendsSchema) break;
        }
        if (extendsSchema) {
          const members = node.members;
          for (const member of members) {
            if (ts.isConstructorDeclaration(member)) {
              const fixAsStaticNew = {
                fixName: "overriddenSchemaConstructor_static",
                description: "Rewrite using the static 'new' pattern",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const visitor = (node2) => {
                    if (ts.isExpressionStatement(node2) && ts.isCallExpression(node2.expression) && ts.isToken(node2.expression.expression) && node2.expression.expression.kind === ts.SyntaxKind.SuperKeyword) {
                      const constructThis = ts.factory.createNewExpression(
                        ts.factory.createIdentifier("this"),
                        void 0,
                        node2.expression.arguments
                      );
                      return ts.factory.createVariableStatement(
                        void 0,
                        ts.factory.createVariableDeclarationList(
                          [ts.factory.createVariableDeclaration(
                            "_this",
                            void 0,
                            void 0,
                            constructThis
                          )],
                          ts.NodeFlags.Const
                        )
                      );
                    }
                    if (ts.isToken(node2) && node2.kind === ts.SyntaxKind.ThisKeyword) {
                      return ts.factory.createIdentifier("_this");
                    }
                    return ts.visitEachChild(node2, visitor, ts.nullTransformationContext);
                  };
                  const newBody = visitor(member.body);
                  const bodyWithReturn = ts.factory.updateBlock(
                    newBody,
                    newBody.statements.concat([
                      ts.factory.createReturnStatement(ts.factory.createIdentifier("_this"))
                    ])
                  );
                  const newMethod = ts.factory.createMethodDeclaration(
                    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Public | ts.ModifierFlags.Static),
                    void 0,
                    "new",
                    void 0,
                    member.typeParameters,
                    member.parameters,
                    member.type,
                    bodyWithReturn
                  );
                  changeTracker.replaceNode(sourceFile, member, newMethod);
                })
              };
              report({
                location: member,
                messageText: "Classes extending Schema must not override the constructor; this is because it silently breaks the schema decoding behaviour. If that's needed, we recommend instead to use a static 'new' method that constructs the instance.",
                fixes: (member.body ? [fixAsStaticNew] : []).concat([{
                  fixName: "overriddenSchemaConstructor_fix",
                  description: "Remove the constructor override",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.delete(sourceFile, member);
                  })
                }])
              });
              break;
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/returnEffectInGen.ts
var returnEffectInGen = createDiagnostic({
  name: "returnEffectInGen",
  code: 11,
  severity: "suggestion",
  apply: fn("returnEffectInGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isReturnStatement(node) && node.expression) {
        if (ts.isYieldExpression(node.expression)) continue;
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        const type = typeChecker.getTypeAtLocation(node.expression);
        const maybeEffect = yield* option(typeParser.strictEffectType(type, node.expression));
        if (isSome2(maybeEffect)) {
          if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
            const effectGenNode = generatorOrRegularFunction.parent;
            yield* pipe(
              typeParser.effectGen(effectGenNode),
              orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
              orElse2(() => typeParser.effectFnGen(effectGenNode)),
              map5(() => {
                const fix = node.expression ? [{
                  fixName: "returnEffectInGen_fix",
                  description: "Add yield* statement",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.replaceNode(
                      sourceFile,
                      node.expression,
                      ts.factory.createYieldExpression(
                        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
                        node.expression
                      )
                    );
                  })
                }] : [];
                report({
                  location: node,
                  messageText: `You are returning an Effect-able type inside a generator function, and will result in nested Effect<Effect<...>>.
Maybe you wanted to return yield* instead?
Nested Effect-able types may be intended if you plan to later manually flatten or unwrap this Effect, if so you can safely disable this diagnostic for this line through quickfixes.`,
                  fixes: fix
                });
              }),
              ignore
            );
          }
        }
      }
    }
  })
});

// src/diagnostics/scopeInLayerEffect.ts
var scopeInLayerEffect = createDiagnostic({
  name: "scopeInLayerEffect",
  code: 13,
  severity: "warning",
  apply: fn("scopeInLayerEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    function parseLayerEffectApiCall(node) {
      if (!ts.isCallExpression(node)) return;
      const expression = node.expression;
      if (!ts.isPropertyAccessExpression(expression)) return;
      const calledModule = expression.expression;
      if (!(ts.isIdentifier(calledModule) && ts.idText(calledModule) === layerModuleIdentifier)) return;
      const methodIdentifier = expression.name;
      if (!(ts.isIdentifier(methodIdentifier) && ts.idText(methodIdentifier).toLowerCase().startsWith("effect"))) return;
      return { methodIdentifier };
    }
    const reportIfLayerRequireScope = (type, node, methodIdentifier) => {
      const entries2 = typeCheckerUtils.unrollUnionMembers(type);
      return pipe(
        firstSuccessOf(entries2.map((type2) => typeParser.scopeType(type2, node))),
        map5(
          () => report({
            location: node,
            messageText: `Seems like you are constructing a layer with a scope in the requirements.
Consider using "scoped" instead to get rid of the scope in the requirements.`,
            fixes: methodIdentifier ? [{
              fixName: "scopeInLayerEffect_scoped",
              description: "Use scoped for Layer creation",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                changeTracker.replaceNode(
                  sourceFile,
                  methodIdentifier,
                  ts.factory.createIdentifier("scoped")
                );
              })
            }] : []
          })
        ),
        ignore
      );
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const layerEffectApiCall = parseLayerEffectApiCall(node);
      if (layerEffectApiCall) {
        const type = typeChecker.getTypeAtLocation(node);
        yield* pipe(
          typeParser.layerType(type, node),
          flatMap2(({ RIn }) => reportIfLayerRequireScope(RIn, node, layerEffectApiCall.methodIdentifier)),
          ignore
        );
        continue;
      }
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const classType = typeChecker.getTypeOfSymbol(classSym);
          const defaultLayer = typeChecker.getPropertyOfType(classType, "Default");
          if (defaultLayer) {
            const type = typeChecker.getTypeOfSymbolAtLocation(defaultLayer, node);
            yield* pipe(
              typeParser.layerType(type, node),
              flatMap2(({ RIn }) => reportIfLayerRequireScope(RIn, node, void 0)),
              ignore
            );
            continue;
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/strictBooleanExpressions.ts
var strictBooleanExpressions = createDiagnostic({
  name: "strictBooleanExpressions",
  code: 17,
  severity: "off",
  apply: fn("strictBooleanExpressions.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const conditionChecks = /* @__PURE__ */ new WeakMap();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const nodes2 = [];
      if (ts.isIfStatement(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.expression);
      } else if (ts.isWhileStatement(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.expression);
      } else if (ts.isConditionalExpression(node)) {
        conditionChecks.set(node, true);
        nodes2.push(node.condition);
      } else if (ts.isPrefixUnaryExpression(node) && node.operator === ts.SyntaxKind.ExclamationToken) {
        conditionChecks.set(node, true);
        nodes2.push(node.operand);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes2.push(node.left);
        nodes2.push(node.right);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes2.push(node.left);
        nodes2.push(node.right);
      }
      for (const nodeToCheck of nodes2) {
        if (!nodeToCheck) continue;
        if (!conditionChecks.has(nodeToCheck.parent)) continue;
        const nodeType = typeChecker.getTypeAtLocation(nodeToCheck);
        const constrainedType = typeChecker.getBaseConstraintOfType(nodeType);
        let typesToCheck = [constrainedType || nodeType];
        while (typesToCheck.length > 0) {
          const type = typesToCheck.pop();
          if (typeCheckerUtils.isUnion(type)) {
            typesToCheck = typesToCheck.concat(type.types);
            continue;
          }
          if (type.flags & ts.TypeFlags.Boolean) continue;
          if (type.flags & ts.TypeFlags.Never) continue;
          if (type.flags & ts.TypeFlags.BooleanLiteral) continue;
          const typeName = typeChecker.typeToString(type);
          report({
            location: nodeToCheck,
            messageText: `Unexpected \`${typeName}\` type in condition, expected strictly a boolean instead.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/strictEffectProvide.ts
var strictEffectProvide = createDiagnostic({
  name: "strictEffectProvide",
  code: 27,
  severity: "off",
  apply: fn("strictEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const parseEffectProvideWithLayer = (node) => gen(function* () {
      if (!ts.isCallExpression(node) || node.arguments.length === 0) {
        return yield* typeParserIssue("Not an Effect.provide call");
      }
      yield* typeParser.isNodeReferenceToEffectModuleApi("provide")(node.expression);
      return yield* firstSuccessOf(
        node.arguments.map((arg) => {
          const argType = typeChecker.getTypeAtLocation(arg);
          return typeParser.layerType(argType, arg);
        })
      );
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const layerCheck = yield* pipe(parseEffectProvideWithLayer(node), option);
        if (isSome2(layerCheck)) {
          report({
            location: node,
            messageText: "Effect.provide with a Layer should only be used at application entry points. If this is an entry point, you can safely disable this diagnostic. Otherwise, using Effect.provide may break scope lifetimes. Compose all layers at your entry point and provide them at once.",
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/tryCatchInEffectGen.ts
var tryCatchInEffectGen = createDiagnostic({
  name: "tryCatchInEffectGen",
  code: 15,
  severity: "suggestion",
  apply: fn("tryCatchInEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isTryStatement(node) && node.catchClause) {
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_) || ts.isFunctionLike(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        if (!generatorOrRegularFunction) continue;
        if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
          const effectGenNode = generatorOrRegularFunction.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse2(() => typeParser.effectFnGen(effectGenNode)),
            map5(() => {
              report({
                location: node,
                messageText: "Avoid using try/catch inside Effect generators. Use Effect's error handling mechanisms instead (e.g., Effect.try, Effect.tryPromise, Effect.catchAll, Effect.catchTag).",
                fixes: []
              });
            }),
            ignore
          );
        }
      }
    }
  })
});

// src/diagnostics/unnecessaryEffectGen.ts
var unnecessaryEffectGen = createDiagnostic({
  name: "unnecessaryEffectGen",
  code: 5,
  severity: "suggestion",
  apply: fn("unnecessaryEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.unnecessaryEffectGen(node),
          map5(
            ({ replacementNode }) => report({
              location: node,
              messageText: `This Effect.gen contains a single return statement.`,
              fixes: [{
                fixName: "unnecessaryEffectGen_fix",
                description: "Remove the Effect.gen, and keep the body",
                apply: gen(function* () {
                  const textChanges = yield* service(
                    ChangeTracker
                  );
                  textChanges.replaceNode(sourceFile, node, yield* replacementNode);
                })
              }]
            })
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipe.ts
var unnecessaryPipe = createDiagnostic({
  name: "unnecessaryPipe",
  code: 9,
  severity: "suggestion",
  apply: fn("unnecessaryPipe.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          map5(({ args: args2, subject }) => {
            if (args2.length === 0) {
              report({
                location: node,
                messageText: `This pipe call contains no arguments.`,
                fixes: [{
                  fixName: "unnecessaryPipe_fix",
                  description: "Remove the pipe call",
                  apply: gen(function* () {
                    const textChanges = yield* service(
                      ChangeTracker
                    );
                    textChanges.replaceNode(sourceFile, node, subject);
                  })
                }]
              });
            }
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipeChain.ts
var unnecessaryPipeChain = createDiagnostic({
  name: "unnecessaryPipeChain",
  code: 16,
  severity: "suggestion",
  apply: fn("unnecessaryPipeChain.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          flatMap2(
            (pipeCall) => map5(typeParser.pipeCall(pipeCall.subject), (innerCall) => ({ pipeCall, innerCall }))
          ),
          map5(({ innerCall, pipeCall }) => {
            report({
              location: node,
              messageText: `Chained pipe calls can be simplified to a single pipe call`,
              fixes: [{
                fixName: "unnecessaryPipeChain_fix",
                description: "Rewrite as single pipe call",
                apply: gen(function* () {
                  const changeTracker = yield* service(
                    ChangeTracker
                  );
                  switch (innerCall.kind) {
                    case "pipe": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createIdentifier("pipe"),
                          void 0,
                          [innerCall.subject, ...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                    case "pipeable": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createPropertyAccessExpression(
                            innerCall.subject,
                            "pipe"
                          ),
                          void 0,
                          [...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                  }
                })
              }]
            });
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unsupportedServiceAccessors.ts
var unsupportedServiceAccessors = createDiagnostic({
  name: "unsupportedServiceAccessors",
  code: 21,
  severity: "warning",
  apply: fn("unsupportedServiceAccessors.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isClassDeclaration(node)) {
        const parseResult = yield* pipe(
          parse2(node),
          orElse2(() => succeed(null))
        );
        if (parseResult && parseResult.involvedMembers.length > 0) {
          const existingStaticMembers = /* @__PURE__ */ new Set();
          node.members?.forEach((member) => {
            if (ts.isPropertyDeclaration(member) && member.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.StaticKeyword)) {
              if (member.name && ts.isIdentifier(member.name)) {
                existingStaticMembers.add(ts.idText(member.name));
              }
            }
          });
          const missingMembers = parseResult.involvedMembers.filter(
            ({ property }) => !existingStaticMembers.has(ts.symbolName(property))
          );
          if (missingMembers.length > 0) {
            const memberNames = missingMembers.map(({ property }) => `'${ts.symbolName(property)}'`).join(", ");
            report({
              location: parseResult.className,
              messageText: `Even if accessors are enabled, accessors for ${memberNames} won't be available because the signature have generic type parameters or multiple call signatures.`,
              fixes: [{
                fixName: "unsupportedServiceAccessors_enableCodegen",
                description: "Enable accessors codegen",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const comment = "// @effect-codegens accessors\n";
                  changeTracker.insertText(sourceFile, ts.getTokenPosOfNode(node, sourceFile), comment);
                })
              }]
            });
          }
        }
      }
    }
  })
});

// src/diagnostics.ts
var diagnostics = [
  catchUnfailableEffect,
  classSelfMismatch,
  duplicatePackage,
  effectGenUsesAdapter,
  missingEffectContext,
  missingEffectError,
  missingEffectServiceDependency,
  floatingEffect,
  missingStarInYieldEffectGen,
  unnecessaryEffectGen,
  missingReturnYieldStar,
  leakingRequirements,
  unnecessaryPipe,
  genericEffectServices,
  returnEffectInGen,
  tryCatchInEffectGen,
  importFromBarrel,
  scopeInLayerEffect,
  effectInVoidSuccess,
  unnecessaryPipeChain,
  strictBooleanExpressions,
  multipleEffectProvide,
  outdatedEffectCodegen,
  overriddenSchemaConstructor,
  unsupportedServiceAccessors,
  nonObjectEffectServiceType,
  deterministicKeys,
  missedPipeableOpportunity,
  strictEffectProvide
];

// src/completions/effectDiagnosticsComment.ts
var effectDiagnosticsComment = createCompletion({
  name: "effectDiagnosticsComment",
  apply: fn("effectDiagnosticsComment")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const sourceText = sourceFile.text;
    const match3 = /(\/\/|\/\*(?:\*?))\s*(@)\s*$/id.exec(sourceText.substring(0, position));
    if (match3 && match3.indices) {
      const lastIndex = match3.indices[2][0];
      const replacementSpan = {
        start: lastIndex,
        length: Math.max(0, position - lastIndex)
      };
      const allDiagnostics = sort(Object.values(diagnostics).map((diagnostic) => diagnostic.name), string2).join(",");
      const disableSnippet = "${1|" + allDiagnostics + "|}:${2|off,warning,error,message,suggestion|}$0";
      return [{
        name: `@effect-diagnostics`,
        kind: ts.ScriptElementKind.string,
        insertText: "@effect-diagnostics " + disableSnippet,
        isSnippet: true,
        replacementSpan
      }, {
        name: `@effect-diagnostics-next-line`,
        kind: ts.ScriptElementKind.string,
        insertText: "@effect-diagnostics-next-line " + disableSnippet,
        isSnippet: true,
        replacementSpan
      }];
    }
    return [];
  })
});

// src/completions/effectJsdocComment.ts
var effectJsdocComment = createCompletion({
  name: "effectJsdocComment",
  apply: fn("effectJsdocComment")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const sourceText = sourceFile.text;
    const match3 = /(\/\/|\/\*(?:\*?))\s*(@)\s*$/id.exec(sourceText.substring(0, position));
    if (match3 && match3.indices) {
      const lastIndex = match3.indices[2][0];
      const replacementSpan = {
        start: lastIndex,
        length: Math.max(0, position - lastIndex)
      };
      return [{
        name: `@effect-identifier`,
        kind: ts.ScriptElementKind.string,
        insertText: "@effect-identifier",
        isSnippet: true,
        replacementSpan
      }];
    }
    return [];
  })
});

// src/completions/effectSchemaSelfInClasses.ts
var effectSchemaSelfInClasses = createCompletion({
  name: "effectSchemaSelfInClasses",
  apply: fn("effectSchemaSelfInClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const schemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Schema"
    ) || "Schema";
    if (schemaIdentifier !== ts.idText(accessedObject)) return [];
    const name = ts.idText(className);
    const errorTagKey = (yield* createString(sourceFile, name, "error")) || name;
    return [{
      name: `Class<${name}>`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${schemaIdentifier}.Class<${name}>("${name}")({${"${0}"}}){}`,
      replacementSpan,
      isSnippet: true
    }, {
      name: `TaggedError<${name}>`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${schemaIdentifier}.TaggedError<${name}>("${errorTagKey}")("${errorTagKey}", {${"${0}"}}){}`,
      replacementSpan,
      isSnippet: true
    }, {
      name: `TaggedClass<${name}>`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${schemaIdentifier}.TaggedClass<${name}>("${name}")("${name}", {${"${0}"}}){}`,
      replacementSpan,
      isSnippet: true
    }, {
      name: `TaggedRequest<${name}>`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${schemaIdentifier}.TaggedRequest<${name}>("${name}")("${name}", {${"${0}"}}){}`,
      replacementSpan,
      isSnippet: true
    }];
  })
});

// src/completions/effectSelfInClasses.ts
var effectSelfInClasses = createCompletion({
  name: "effectSelfInClasses",
  apply: fn("effectSelfInClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    if (effectIdentifier !== ts.idText(accessedObject)) return [];
    const name = ts.idText(className);
    const tagKey = (yield* createString(sourceFile, name, "service")) || name;
    return [{
      name: `Service<${name}>`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${effectIdentifier}.Service<${name}>()("${tagKey}", {${"${0}"}}){}`,
      replacementSpan,
      isSnippet: true
    }, {
      name: `Tag("${name}")`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${effectIdentifier}.Tag("${tagKey}")<${name}, {${"${0}"}}>(){}`,
      replacementSpan,
      isSnippet: true
    }];
  })
});

// src/completions/fnFunctionStar.ts
var fnFunctionStar = createCompletion({
  name: "fnFunctionStar",
  apply: fn("fnFunctionStar")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject } = maybeInfos;
    const isEffectModule = yield* option(typeParser.importedEffectModule(accessedObject));
    if (isNone2(isEffectModule)) return [];
    const span = ts.createTextSpan(
      accessedObject.end + 1,
      Math.max(0, position - accessedObject.end - 1)
    );
    const maybeFnName = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, tsUtils.toTextRange(accessedObject.pos)),
      filter(ts.isVariableDeclaration),
      map4((_) => _.name && ts.isIdentifier(_.name) ? ts.idText(_.name) : ""),
      filter((_) => _.length > 0),
      head,
      map2((name) => [
        {
          name: `fn("${name}")`,
          kind: ts.ScriptElementKind.constElement,
          insertText: `fn("${name}")(function*(${"${1}"}){${"${0}"}})`,
          replacementSpan: span,
          isSnippet: true
        }
      ]),
      getOrElse2(() => [])
    );
    return maybeFnName.concat([{
      name: `fn(function*(){})`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `fn(function*(${"${1}"}){${"${0}"}})`,
      replacementSpan: span,
      isSnippet: true
    }, {
      name: `fnUntraced(function*(){})`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `fnUntraced(function*(${"${1}"}){${"${0}"}})`,
      replacementSpan: span,
      isSnippet: true
    }]);
  })
});

// src/completions/genFunctionStar.ts
var genFunctionStar = createCompletion({
  name: "genFunctionStar",
  apply: fn("genFunctionStar")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject } = maybeInfos;
    const type = typeChecker.getTypeAtLocation(accessedObject);
    const genMemberSymbol = type.getProperty("gen");
    if (!genMemberSymbol) return [];
    const genType = typeChecker.getTypeOfSymbolAtLocation(genMemberSymbol, accessedObject);
    if (typeChecker.getSignaturesOfType(genType, ts.SignatureKind.Call).length === 0) return [];
    const span = ts.createTextSpan(
      accessedObject.end + 1,
      Math.max(0, position - accessedObject.end - 1)
    );
    return [{
      name: `gen(function*(){})`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `gen(function*(){${"${0}"}})`,
      replacementSpan: span,
      isSnippet: true
    }];
  })
});

// src/completions/rpcMakeClasses.ts
var rpcMakeClasses = createCompletion({
  name: "rpcMakeClasses",
  apply: fn("rpcMakeClasses")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeInfos = tsUtils.parseDataForExtendsClassCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject, className, replacementSpan } = maybeInfos;
    const rpcIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "@effect/rpc",
      "Rpc"
    ) || "Rpc";
    if (rpcIdentifier !== ts.idText(accessedObject)) return [];
    const name = ts.idText(className);
    return [{
      name: `make("${name}")`,
      kind: ts.ScriptElementKind.constElement,
      insertText: `${rpcIdentifier}.make("${name}", {${"${0}"}}) {}`,
      replacementSpan,
      isSnippet: true
    }];
  })
});

// src/completions/schemaBrand.ts
var schemaBrand = createCompletion({
  name: "schemaBrand",
  apply: fn("schemaBrand")(function* (sourceFile, position) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeInfos = tsUtils.parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return [];
    const { accessedObject } = maybeInfos;
    if (!ts.isIdentifier(accessedObject)) return [];
    const schemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Schema"
    ) || "Schema";
    if (schemaName !== ts.idText(accessedObject)) return [];
    const span = ts.createTextSpan(
      accessedObject.end + 1,
      Math.max(0, position - accessedObject.end - 1)
    );
    return pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, tsUtils.toTextRange(accessedObject.pos)),
      filter(ts.isVariableDeclaration),
      map4((_) => _.name && ts.isIdentifier(_.name) ? ts.idText(_.name) : ""),
      filter((_) => _.length > 0),
      head,
      map2((name) => [
        {
          name: `brand("${name}")`,
          kind: ts.ScriptElementKind.constElement,
          insertText: `brand("${name}")`,
          replacementSpan: span,
          isSnippet: true
        }
      ]),
      getOrElse2(() => [])
    );
  })
});

// src/completions.ts
var completions = [
  effectSchemaSelfInClasses,
  effectSelfInClasses,
  contextSelfInClasses,
  rpcMakeClasses,
  genFunctionStar,
  fnFunctionStar,
  effectDataClasses,
  effectDiagnosticsComment,
  effectCodegensComment,
  effectJsdocComment,
  durationInput,
  schemaBrand
];

// src/core/AutoImport.ts
var makeAutoImportProvider = fn("TypeScriptApi")(function* (fromSourceFile) {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const program = yield* service(TypeScriptProgram);
  const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
  const host = program;
  const getModuleSpecifier = makeGetModuleSpecifier(ts);
  const resolvePackageNameToPackageJson = makeResolvePackageNameToPackageJson(ts);
  const getEntrypointsFromPackageJsonInfo = makeGetEntrypointsFromPackageJsonInfo(ts);
  function collectSourceFileReexports(sourceFile) {
    const namespaceExports = [];
    const namedExports = [];
    for (const statement of sourceFile.statements) {
      if (!ts.isExportDeclaration(statement)) continue;
      if (!statement.exportClause) continue;
      const moduleSpecifier = statement.moduleSpecifier;
      if (!moduleSpecifier) continue;
      if (!ts.isStringLiteral(moduleSpecifier)) continue;
      const exportClause = statement.exportClause;
      if (ts.isNamespaceExport(exportClause)) {
        if (!exportClause.name) continue;
        if (!ts.isIdentifier(exportClause.name)) continue;
        namespaceExports.push({
          moduleSpecifier,
          exportClause,
          name: ts.idText(exportClause.name)
        });
      }
      if (ts.isNamedExports(exportClause)) {
        for (const exportSpecifier of exportClause.elements) {
          const exportName = exportSpecifier.propertyName || exportSpecifier.name;
          if (!ts.isIdentifier(exportName)) continue;
          if (!ts.isIdentifier(exportSpecifier.name)) continue;
          namedExports.push({
            moduleSpecifier,
            exportClause,
            name: ts.idText(exportName),
            aliasName: ts.idText(exportSpecifier.name)
          });
        }
      }
    }
    return { namespaceExports, namedExports };
  }
  function getPackageInfo(fromFileName, packageName) {
    try {
      if (!resolvePackageNameToPackageJson || !getEntrypointsFromPackageJsonInfo) return;
      const packageJsonInfo = resolvePackageNameToPackageJson(
        packageName,
        fromFileName,
        program.getCompilerOptions(),
        host
      );
      if (!packageJsonInfo) return;
      const _entrypoints = getEntrypointsFromPackageJsonInfo(
        packageJsonInfo,
        program.getCompilerOptions(),
        host
      );
      if (!_entrypoints) return;
      if (!isArray(_entrypoints)) return;
      if (!every(isString)) return;
      const entrypoints = _entrypoints.map((_) => String(_));
      const info = tsUtils.parsePackageContentNameAndVersionFromScope({ packageJsonScope: packageJsonInfo });
      if (!info) return { entrypoints, exportedKeys: [] };
      return { entrypoints, exportedKeys: info.exportsKeys };
    } catch (_) {
      return void 0;
    }
  }
  const mapFromBarrelToNamespace = /* @__PURE__ */ new Map();
  const mapFromBarrelToBarrel = /* @__PURE__ */ new Map();
  const mapFromNamespaceToBarrel = /* @__PURE__ */ new Map();
  const mapFilenameToModuleAlias = /* @__PURE__ */ new Map();
  const mapFilenameToExportExcludes = /* @__PURE__ */ new Map();
  const mapFilenameToModuleName = /* @__PURE__ */ new Map();
  const collectModuleNames = (packageName, exportedKey) => {
    const appendPart = exportedKey === "." ? "" : exportedKey.startsWith("./") ? exportedKey.slice(1) : exportedKey;
    const absoluteName = packageName + appendPart;
    const absoluteFileName = ts.resolveModuleName(
      absoluteName,
      fromSourceFile.fileName,
      program.getCompilerOptions(),
      host
    );
    if (!absoluteFileName) return;
    if (!absoluteFileName.resolvedModule) return;
    const realPath = host.realpath ? host.realpath(absoluteFileName.resolvedModule.resolvedFileName) : absoluteFileName.resolvedModule.resolvedFileName;
    if (mapFilenameToModuleName.has(realPath)) return;
    mapFilenameToModuleName.set(realPath, absoluteName);
  };
  const collectImportCache = fn("TypeScriptApi")(
    function* (packagePatterns, kind, topLevelNamedReexports) {
      for (const packagePattern of packagePatterns) {
        const packageNames = tsUtils.resolveModulePattern(program, fromSourceFile, packagePattern);
        for (const packageName of packageNames) {
          const packageInfo = getPackageInfo(fromSourceFile.fileName, packageName);
          if (!packageInfo) continue;
          for (const exportedKey of packageInfo.exportedKeys) {
            collectModuleNames(packageName, exportedKey);
          }
          for (const _fileName of packageInfo.entrypoints) {
            const realFileName = host.realpath ? host.realpath(_fileName) : _fileName;
            const isPackageRoot = mapFilenameToModuleName.get(realFileName) === packageName;
            const barrelSourceFile = program.getSourceFile(realFileName) || ts.createSourceFile(realFileName, host.readFile(realFileName) || "", fromSourceFile.languageVersion, true);
            const reExports = collectSourceFileReexports(barrelSourceFile);
            if (!reExports) continue;
            if (reExports.namespaceExports.length === 0) continue;
            for (const namespaceReexport of reExports.namespaceExports) {
              const reexportedFile = ts.resolveModuleName(
                namespaceReexport.moduleSpecifier.text,
                barrelSourceFile.fileName,
                program.getCompilerOptions(),
                host
              );
              if (!reexportedFile) continue;
              if (!reexportedFile.resolvedModule) continue;
              switch (kind) {
                case "namespace": {
                  mapFromBarrelToNamespace.set(
                    barrelSourceFile.fileName,
                    {
                      ...mapFromBarrelToNamespace.get(barrelSourceFile.fileName) || {},
                      [namespaceReexport.name]: reexportedFile.resolvedModule.resolvedFileName
                    }
                  );
                  mapFilenameToModuleAlias.set(
                    reexportedFile.resolvedModule.resolvedFileName,
                    namespaceReexport.name
                  );
                  continue;
                }
                case "barrel": {
                  mapFromNamespaceToBarrel.set(reexportedFile.resolvedModule.resolvedFileName, {
                    fileName: barrelSourceFile.fileName,
                    alias: namespaceReexport.name
                  });
                }
              }
            }
            if (isPackageRoot) {
              for (const namedExport of reExports.namedExports) {
                if (topLevelNamedReexports === "ignore") {
                  mapFilenameToExportExcludes.set(barrelSourceFile.fileName, [
                    ...mapFilenameToExportExcludes.get(barrelSourceFile.fileName) || [],
                    namedExport.name
                  ]);
                } else if (topLevelNamedReexports === "follow") {
                  const reexportedFile = ts.resolveModuleName(
                    namedExport.moduleSpecifier.text,
                    barrelSourceFile.fileName,
                    program.getCompilerOptions(),
                    host
                  );
                  if (!reexportedFile) continue;
                  if (!reexportedFile.resolvedModule) continue;
                  mapFromBarrelToBarrel.set(barrelSourceFile.fileName, {
                    ...mapFromBarrelToBarrel.get(barrelSourceFile.fileName) || {},
                    [namedExport.name]: {
                      fileName: reexportedFile.resolvedModule.resolvedFileName,
                      exportName: namedExport.name
                    }
                  });
                  mapFromBarrelToBarrel.set(reexportedFile.resolvedModule.resolvedFileName, {
                    ...mapFromBarrelToBarrel.get(reexportedFile.resolvedModule.resolvedFileName) || {},
                    [namedExport.name]: {
                      fileName: reexportedFile.resolvedModule.resolvedFileName,
                      exportName: namedExport.name
                    }
                  });
                }
              }
            }
          }
        }
      }
    }
  );
  yield* collectImportCache(
    languageServicePluginOptions.namespaceImportPackages,
    "namespace",
    languageServicePluginOptions.topLevelNamedReexports
  );
  yield* collectImportCache(languageServicePluginOptions.barrelImportPackages, "barrel", "ignore");
  const resolveModuleName = (fileName) => {
    const fixedModuleName = mapFilenameToModuleName.get(fileName);
    if (fixedModuleName) return fixedModuleName;
    if (!getModuleSpecifier) return fileName;
    const moduleSpecifier = getModuleSpecifier(
      program.getCompilerOptions(),
      fromSourceFile,
      fromSourceFile.fileName,
      fileName,
      host
    );
    if (!moduleSpecifier) return fileName;
    return moduleSpecifier;
  };
  const resolveAliasName = (chosenName) => {
    const aliasName = languageServicePluginOptions.importAliases[chosenName];
    if (aliasName) return aliasName;
    return void 0;
  };
  const resolve = (exportFileName, exportName) => {
    const excludedExports = mapFilenameToExportExcludes.get(exportFileName);
    if (excludedExports && excludedExports.includes(exportName)) return;
    const mapToBarrelRewritten = mapFromBarrelToBarrel.get(exportFileName);
    if (mapToBarrelRewritten && exportName in mapToBarrelRewritten) {
      const reexportedFile = mapToBarrelRewritten[exportName];
      if (reexportedFile) {
        return {
          _tag: "NamedImport",
          fileName: reexportedFile.fileName,
          moduleName: resolveModuleName(reexportedFile.fileName),
          name: exportName,
          aliasName: resolveAliasName(exportName),
          introducedPrefix: void 0
        };
      }
    }
    const mapToNamespace = mapFromBarrelToNamespace.get(exportFileName);
    if (mapToNamespace && exportName in mapToNamespace) {
      const namespacedFileName = mapToNamespace[exportName];
      if (namespacedFileName) {
        const introducedAlias2 = mapFilenameToModuleAlias.get(namespacedFileName);
        if (introducedAlias2) {
          return {
            _tag: "NamespaceImport",
            fileName: namespacedFileName,
            moduleName: resolveModuleName(namespacedFileName),
            name: introducedAlias2,
            aliasName: resolveAliasName(introducedAlias2),
            introducedPrefix: void 0
          };
        }
      }
    }
    const introducedAlias = mapFilenameToModuleAlias.get(exportFileName);
    if (introducedAlias) {
      return {
        _tag: "NamespaceImport",
        fileName: exportFileName,
        moduleName: resolveModuleName(exportFileName),
        name: introducedAlias,
        aliasName: resolveAliasName(introducedAlias),
        introducedPrefix: resolveAliasName(introducedAlias) || introducedAlias
      };
    }
    const mapToBarrel = mapFromNamespaceToBarrel.get(exportFileName);
    if (mapToBarrel) {
      return {
        _tag: "NamedImport",
        fileName: mapToBarrel.fileName,
        moduleName: resolveModuleName(mapToBarrel.fileName),
        name: mapToBarrel.alias,
        aliasName: resolveAliasName(mapToBarrel.alias),
        introducedPrefix: resolveAliasName(mapToBarrel.alias) || mapToBarrel.alias
      };
    }
  };
  const sortText = (exportFileName, exportName) => {
    const excludedExports = mapFilenameToExportExcludes.get(exportFileName);
    if (excludedExports && excludedExports.includes(exportName)) return;
    const mapToNamespace = mapFromBarrelToNamespace.get(exportFileName);
    if (mapToNamespace && exportName in mapToNamespace) return "99";
  };
  return { resolve, sortText };
});
var importProvidersCache = /* @__PURE__ */ new Map();
var getOrMakeAutoImportProvider = fn("getOrMakeAutoImportProvider")(function* (sourceFile) {
  while (importProvidersCache.size > 5) {
    const oldest = importProvidersCache.keys().next().value;
    if (oldest) importProvidersCache.delete(oldest);
  }
  const autoImportProvider = importProvidersCache.get(sourceFile.fileName) || (yield* makeAutoImportProvider(sourceFile));
  importProvidersCache.set(sourceFile.fileName, autoImportProvider);
  return autoImportProvider;
});
var parseImportOnlyChanges = fn("parseImportOnlyChanges")(function* (sourceFile, changes) {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const deletions = [];
  const imports = [];
  for (const change of changes) {
    if (change.newText.length === 0) {
      deletions.push(change);
      continue;
    }
    if (change.newText.trim().startsWith("import") && change.newText.trim().includes("from")) {
      try {
        const parsedImport = ts.createSourceFile("test.ts", change.newText, sourceFile.languageVersion, false);
        for (const statement of parsedImport.statements) {
          if (!ts.isImportDeclaration(statement)) return;
          const moduleSpecifier = statement.moduleSpecifier;
          if (!ts.isStringLiteral(moduleSpecifier)) return;
          const moduleName = moduleSpecifier.text;
          const importClause = statement.importClause;
          if (!importClause) return;
          const namedBindings = importClause.namedBindings;
          if (!namedBindings) return;
          if (ts.isNamedImports(namedBindings)) {
            for (const importSpecifier of namedBindings.elements) {
              if (!ts.isIdentifier(importSpecifier.name)) return;
              const exportName = ts.idText(importSpecifier.name);
              imports.push({ moduleName, exportName });
              continue;
            }
          } else if (ts.isNamespaceImport(namedBindings)) {
            imports.push({ moduleName, exportName: void 0 });
            continue;
          }
        }
      } catch (_) {
        return;
      }
    } else {
      const ancestorNodes = tsUtils.getAncestorNodesInRange(sourceFile, {
        pos: change.span.start,
        end: change.span.start
      });
      const importNodes = ancestorNodes.filter((node) => ts.isImportDeclaration(node));
      const importNode = importNodes[0];
      if (!importNode) return;
      const moduleSpecifier = importNode.moduleSpecifier;
      if (!ts.isStringLiteral(moduleSpecifier)) return;
      const moduleName = moduleSpecifier.text;
      const exportName = change.newText.replace(/,/ig, "").trim();
      if (exportName.length === 0) return;
      imports.push({ moduleName, exportName });
    }
  }
  return { deletions, imports };
});
var addImport = (ts, sourceFile, changeTracker, preferences, effectAutoImport) => {
  let description = "";
  switch (effectAutoImport._tag) {
    case "NamespaceImport": {
      const aliasName = effectAutoImport.aliasName || effectAutoImport.name;
      const importModule = effectAutoImport.moduleName || effectAutoImport.fileName;
      description = `Import * as ${aliasName} from "${importModule}"`;
      ts.insertImports(
        changeTracker,
        sourceFile,
        ts.factory.createImportDeclaration(
          void 0,
          ts.factory.createImportClause(
            false,
            void 0,
            ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasName))
          ),
          ts.factory.createStringLiteral(importModule)
        ),
        true,
        preferences || {}
      );
      break;
    }
    case "NamedImport": {
      const importModule = effectAutoImport.moduleName || effectAutoImport.fileName;
      if (effectAutoImport.aliasName) {
        description = `Import { ${effectAutoImport.name} as ${effectAutoImport.aliasName} } from "${importModule}"`;
      } else {
        description = `Import { ${effectAutoImport.name} } from "${importModule}"`;
      }
      let foundImportDeclaration = false;
      for (const statement of sourceFile.statements) {
        if (ts.isImportDeclaration(statement)) {
          const moduleSpecifier = statement.moduleSpecifier;
          if (moduleSpecifier && ts.isStringLiteral(moduleSpecifier) && moduleSpecifier.text === importModule) {
            const importClause = statement.importClause;
            if (importClause && importClause.namedBindings && ts.isNamedImports(importClause.namedBindings)) {
              const namedImports = importClause.namedBindings;
              const existingImportSpecifier = namedImports.elements.find((element) => {
                if (effectAutoImport.aliasName) {
                  return ts.idText(element.name) === effectAutoImport.name && element.propertyName && ts.isIdentifier(element.propertyName) && ts.idText(element.propertyName) === effectAutoImport.aliasName;
                }
                return ts.idText(element.name) === effectAutoImport.name;
              });
              if (existingImportSpecifier) {
                foundImportDeclaration = true;
                break;
              }
              changeTracker.replaceNode(
                sourceFile,
                namedImports,
                ts.factory.createNamedImports(
                  namedImports.elements.concat([
                    ts.factory.createImportSpecifier(
                      false,
                      effectAutoImport.aliasName ? ts.factory.createIdentifier(effectAutoImport.name) : void 0,
                      ts.factory.createIdentifier(effectAutoImport.aliasName || effectAutoImport.name)
                    )
                  ])
                )
              );
              foundImportDeclaration = true;
              break;
            }
          }
        }
      }
      if (!foundImportDeclaration) {
        ts.insertImports(
          changeTracker,
          sourceFile,
          ts.factory.createImportDeclaration(
            void 0,
            ts.factory.createImportClause(
              false,
              void 0,
              ts.factory.createNamedImports(
                [
                  ts.factory.createImportSpecifier(
                    false,
                    effectAutoImport.aliasName ? ts.factory.createIdentifier(effectAutoImport.name) : void 0,
                    ts.factory.createIdentifier(effectAutoImport.aliasName || effectAutoImport.name)
                  )
                ]
              )
            ),
            ts.factory.createStringLiteral(importModule)
          ),
          true,
          preferences || {}
        );
      }
      break;
    }
  }
  return { description };
};

// src/completions/middlewareAutoImports.ts
var appendEffectCompletionEntryData = fn("appendEffectCompletionEntryData")(
  function* (_sourceFile, applicableCompletions) {
    const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0 && languageServicePluginOptions.barrelImportPackages.length === 0) return applicableCompletions;
    if (applicableCompletions) {
      return {
        ...applicableCompletions,
        entries: applicableCompletions.entries.map(
          (entry) => entry.data ? {
            ...entry,
            data: {
              ...entry.data,
              effectReplaceSpan: entry.replacementSpan || applicableCompletions.optionalReplacementSpan
            }
          } : entry
        )
      };
    }
    return applicableCompletions;
  }
);
var isAutoImportOnlyCodeActions = fn("isAutoImportOnlyCodeActions")(
  function* (sourceFile, codeActions, exportName) {
    if (!codeActions) return;
    if (codeActions.length !== 1) return;
    const action = codeActions[0];
    const changes = action.changes;
    if (changes.length !== 1) return;
    const fileTextChanges = action.changes[0];
    if (fileTextChanges.fileName !== sourceFile.fileName) return;
    const textChanges = fileTextChanges.textChanges;
    const parsedImportChanges = yield* parseImportOnlyChanges(sourceFile, textChanges);
    if (!parsedImportChanges) return;
    if (parsedImportChanges.deletions.length !== 0) return;
    if (parsedImportChanges.imports.length !== 1) return;
    if (parsedImportChanges.imports[0].exportName !== exportName) return;
    return parsedImportChanges.imports[0];
  }
);
var addImportCodeAction = fn("getImportFromNamespaceCodeActions")(function* (formatOptions, preferences, languageServiceHost, sourceFile, effectReplaceSpan, effectAutoImport) {
  const ts = yield* service(TypeScriptApi);
  let description = "auto-import";
  const formatContext = ts.formatting.getFormatContext(
    formatOptions || {},
    languageServiceHost
  );
  const changes = ts.textChanges.ChangeTracker.with(
    {
      formatContext,
      host: languageServiceHost,
      preferences: preferences || {}
    },
    (changeTracker) => {
      if (effectAutoImport.introducedPrefix) {
        changeTracker.insertText(
          sourceFile,
          effectReplaceSpan.start,
          effectAutoImport.introducedPrefix + "."
        );
      }
      description = addImport(
        ts,
        sourceFile,
        changeTracker,
        preferences,
        effectAutoImport
      ).description;
    }
  );
  return [
    {
      description,
      changes
    }
  ];
});
var postprocessCompletionEntryDetails = fn("postprocessCompletionEntryDetails")(
  function* (sourceFile, data, applicableCompletionEntryDetails, formatOptions, preferences, languageServiceHost) {
    const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0 && languageServicePluginOptions.barrelImportPackages.length === 0) return applicableCompletionEntryDetails;
    if (!applicableCompletionEntryDetails) return applicableCompletionEntryDetails;
    if (!data) return applicableCompletionEntryDetails;
    const { exportName, fileName, moduleSpecifier } = data;
    if (!fileName) return applicableCompletionEntryDetails;
    if (!exportName) return applicableCompletionEntryDetails;
    if (!moduleSpecifier) return applicableCompletionEntryDetails;
    if (!("effectReplaceSpan" in data)) return applicableCompletionEntryDetails;
    const effectReplaceSpan = data.effectReplaceSpan;
    const result = yield* isAutoImportOnlyCodeActions(
      sourceFile,
      applicableCompletionEntryDetails.codeActions,
      exportName
    );
    if (!result) return applicableCompletionEntryDetails;
    const autoImportProvider = yield* getOrMakeAutoImportProvider(sourceFile);
    const effectAutoImport = autoImportProvider.resolve(fileName, exportName);
    if (!effectAutoImport) return applicableCompletionEntryDetails;
    const codeActions = yield* addImportCodeAction(
      formatOptions,
      preferences,
      languageServiceHost,
      sourceFile,
      effectReplaceSpan,
      effectAutoImport
    );
    return {
      ...applicableCompletionEntryDetails,
      codeActions
    };
  }
);

// src/diagnostics/middlewareAutoImportQuickfixes.ts
var middlewareAutoImportQuickfixes = fn("middlewareAutoImportQuickfixes")(function* (sourceFile, languageServiceHost, formatOptions, preferences, codeFixes) {
  const ts = yield* service(TypeScriptApi);
  const program = yield* service(TypeScriptProgram);
  const autoImportProvider = yield* getOrMakeAutoImportProvider(sourceFile);
  const changedCodeFixes = [];
  const createImportAllChanges = (imports) => gen(function* () {
    const newImports = [];
    for (const importToAdd of imports) {
      if (!importToAdd.exportName) return;
      const fileName = ts.resolveModuleName(
        importToAdd.moduleName,
        sourceFile.fileName,
        program.getCompilerOptions(),
        program
      );
      if (!fileName.resolvedModule) return;
      const importKind = autoImportProvider.resolve(fileName.resolvedModule.resolvedFileName, importToAdd.exportName);
      if (!importKind) return;
      if (importKind.introducedPrefix) return;
      newImports.push(importKind);
    }
    const formatContext = ts.formatting.getFormatContext(
      formatOptions,
      languageServiceHost
    );
    const edits = ts.textChanges.ChangeTracker.with(
      {
        formatContext,
        host: languageServiceHost,
        preferences: preferences || {}
      },
      (changeTracker) => newImports.forEach((_) => addImport(ts, sourceFile, changeTracker, preferences, _))
    );
    return edits;
  });
  for (const codeFix of codeFixes) {
    const textFileChanges = codeFix.changes;
    if (textFileChanges.length !== 1) {
      changedCodeFixes.push(codeFix);
      continue;
    }
    if (textFileChanges[0].fileName !== sourceFile.fileName) {
      changedCodeFixes.push(codeFix);
      continue;
    }
    const parsedChanges = yield* parseImportOnlyChanges(sourceFile, textFileChanges[0].textChanges);
    if (!parsedChanges) {
      changedCodeFixes.push(codeFix);
      continue;
    }
    if (parsedChanges.deletions.length !== 0) {
      changedCodeFixes.push(codeFix);
      continue;
    }
    const changes = yield* pipe(
      createImportAllChanges(parsedChanges.imports),
      orElse2(() => succeed(codeFix.changes))
    );
    if (changes) {
      changedCodeFixes.push({ ...codeFix, changes });
    } else {
      changedCodeFixes.push(codeFix);
    }
  }
  return changedCodeFixes;
});

// src/goto/effectRpcDefinition.ts
function effectRpcDefinition(applicableGotoDefinition, sourceFile, position) {
  return gen(function* () {
    const program = yield* service(TypeScriptProgram);
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const textRange = tsUtils.toTextRange(position);
    function isSymbolFromEffectRpcModule(symbol3) {
      if (symbol3.valueDeclaration) {
        const sourceFile2 = tsUtils.getSourceFileOfNode(symbol3.valueDeclaration);
        if (sourceFile2) {
          const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(sourceFile2);
          if (packageInfo && packageInfo.name === "@effect/rpc") {
            const fileSymbol = typeChecker.getSymbolAtLocation(sourceFile2);
            return fileSymbol && fileSymbol.exports && fileSymbol.exports.has("isRpc") && fileSymbol.exports.has("make") && fileSymbol.exports.has("fromTaggedRequest");
          }
        }
      }
      return false;
    }
    function isSymbolFromEffectRpcClientModule(symbol3) {
      if (symbol3.valueDeclaration) {
        const sourceFile2 = tsUtils.getSourceFileOfNode(symbol3.valueDeclaration);
        if (sourceFile2) {
          const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(sourceFile2);
          if (packageInfo && packageInfo.name === "@effect/rpc") {
            const fileSymbol = typeChecker.getSymbolAtLocation(sourceFile2);
            return fileSymbol && fileSymbol.exports && fileSymbol.exports.has("RpcClient") && fileSymbol.exports.has("make");
          }
        }
      }
      return false;
    }
    let rpcName = null;
    let callNode = null;
    for (const node of tsUtils.getAncestorNodesInRange(sourceFile, textRange)) {
      if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && tsUtils.isNodeInRange(textRange)(node.name)) {
        const type = typeChecker.getTypeAtLocation(node);
        for (const callSig of typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)) {
          if (callSig.parameters.length >= 2 && isSymbolFromEffectRpcClientModule(callSig.parameters[1])) {
            rpcName = ts.idText(node.name);
            callNode = node.name;
          }
        }
      }
    }
    if (rpcName === null || callNode === null) return applicableGotoDefinition;
    const result = [];
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    const filesToTest = [];
    for (const programFile of program.getSourceFiles()) {
      if (programFile.isDeclarationFile) continue;
      if (programFile.text.indexOf("make") === -1 && programFile.text.indexOf("fromTaggedRequest") === -1) continue;
      if (programFile.text.indexOf(rpcName) > -1) {
        filesToTest.unshift(programFile);
      } else {
        filesToTest.push(programFile);
      }
    }
    for (const fileToTest of filesToTest) {
      if (result.length > 0) break;
      ts.forEachChild(fileToTest, appendNodeToVisit);
      while (result.length === 0 && nodeToVisit.length > 0) {
        const node = nodeToVisit.shift();
        if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && (ts.idText(node.expression.name) === "make" || ts.idText(node.expression.name) === "fromTaggedRequest")) {
          const symbol3 = typeChecker.getSymbolAtLocation(node.expression.name);
          if (symbol3 && isSymbolFromEffectRpcModule(symbol3)) {
            const type = typeChecker.getTypeAtLocation(node);
            const _tag = type.getProperty("_tag");
            if (_tag) {
              const tagValue = typeChecker.getTypeOfSymbolAtLocation(_tag, node);
              if ("value" in tagValue && tagValue.value === rpcName) result.push([node, symbol3]);
            }
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
      }
    }
    if (result.length === 0) return applicableGotoDefinition;
    const effectRpcResult = result.map(([node]) => ({
      fileName: node.getSourceFile().fileName,
      textSpan: ts.createTextSpan(node.getStart(), node.end - node.getStart()),
      kind: ts.ScriptElementKind.constElement,
      name: rpcName,
      containerKind: ts.ScriptElementKind.constElement,
      containerName: rpcName
    }));
    if (applicableGotoDefinition) {
      return {
        ...applicableGotoDefinition,
        definitions: (applicableGotoDefinition.definitions || []).concat(effectRpcResult)
      };
    }
    return {
      textSpan: ts.createTextSpan(callNode.getStart(), callNode.end - callNode.getStart()),
      definitions: effectRpcResult
    };
  });
}

// src/goto.ts
function goto(applicableGotoDefinition, sourceFile, position) {
  return effectRpcDefinition(applicableGotoDefinition, sourceFile, position);
}

// src/inlays/middlewareGenLike.ts
var middlewareGenLike = fn("middlewareGenLike")(function* (sourceFile, _span, preferences, inlayHints) {
  if (!preferences) return inlayHints;
  if (preferences.includeInlayFunctionLikeReturnTypeHints !== true) return inlayHints;
  if (!inlayHints) return inlayHints;
  const tsUtils = yield* service(TypeScriptUtils);
  const ts = yield* service(TypeScriptApi);
  const typeParser = yield* service(TypeParser);
  const result = [];
  const parseType = (node) => {
    return pipe(
      typeParser.effectGen(node),
      orElse2(() => pipe(typeParser.effectFnGen(node), orElse2(() => typeParser.effectFnUntracedGen(node))))
    );
  };
  for (const inlayHint of inlayHints) {
    let shouldOmit = false;
    if (inlayHint.kind === ts.InlayHintKind.Type) {
      const node = tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, inlayHint.position - 1);
      if (node && node.parent) {
        const possiblyGen = node.parent;
        yield* pipe(
          parseType(possiblyGen),
          map5((_) => {
            const argsCloseParen = ts.findChildOfKind(_.generatorFunction, ts.SyntaxKind.CloseParenToken, sourceFile);
            if (argsCloseParen && _.body && inlayHint.position >= argsCloseParen.end && inlayHint.position <= _.body.getStart(sourceFile)) {
              shouldOmit = true;
            }
          }),
          ignore
        );
      }
    }
    if (!shouldOmit) result.push(inlayHint);
  }
  return result;
});

// src/quickinfo/dedupeJsDocs.ts
var SymbolDisplayPartEq = make((fa, fb) => fa.kind === fb.kind && fa.text === fb.text);
var JSDocTagInfoEq = make(
  (fa, fb) => fa.name === fb.name && typeof fa.text === typeof fb.text && (typeof fa.text !== "undefined" ? array(SymbolDisplayPartEq)(fa.text, fb.text) : true)
);
function dedupeJsDocs(quickInfo2) {
  if (!quickInfo2) return succeed(quickInfo2);
  if (quickInfo2.tags) {
    return succeed({
      ...quickInfo2,
      tags: dedupeWith(quickInfo2.tags, JSDocTagInfoEq)
    });
  }
  return succeed(quickInfo2);
}

// src/quickinfo/effectTypeArgs.ts
function effectTypeArgs(sourceFile, position, quickInfo2) {
  return pipe(
    gen(function* () {
      const ts = yield* service(TypeScriptApi);
      const typeChecker = yield* service(TypeCheckerApi);
      const typeParser = yield* service(TypeParser);
      const options = yield* service(LanguageServicePluginOptions);
      if (options.quickinfoEffectParameters === "never") return quickInfo2;
      function formatTypeForQuickInfo(channelType, channelName) {
        let stringRepresentation = "";
        if (options.quickinfoMaximumLength > 0) {
          const typeNode = typeChecker.typeToTypeNode(
            channelType,
            void 0,
            ts.NodeBuilderFlags.None,
            // @ts-expect-error
            void 0,
            void 0,
            options.quickinfoMaximumLength
          );
          const printer = ts.createPrinter({});
          stringRepresentation = typeNode ? printer.printNode(ts.EmitHint.Unspecified, typeNode, sourceFile) : "";
        } else {
          stringRepresentation = typeChecker.typeToString(channelType, void 0, ts.TypeFormatFlags.NoTruncation);
        }
        return `type ${channelName} = ${stringRepresentation}`;
      }
      function makeSymbolDisplayParts(title, A, E, R) {
        return [{
          kind: "text",
          text: "```ts\n/* " + title + " */\n" + formatTypeForQuickInfo(A, "Success") + "\n" + formatTypeForQuickInfo(E, "Failure") + "\n" + formatTypeForQuickInfo(R, "Requirements") + "\n```\n"
        }];
      }
      function getNodeForQuickInfo(node2) {
        if (ts.isNewExpression(node2.parent) && node2.pos === node2.parent.pos) {
          return node2.parent.expression;
        }
        if (ts.isNamedTupleMember(node2.parent) && node2.pos === node2.parent.pos) {
          return node2.parent;
        }
        if (ts.isJsxNamespacedName(node2.parent)) {
          return node2.parent;
        }
        return node2;
      }
      function getDataForQuickInfo() {
        if (!("getTouchingPropertyName" in ts && typeof ts.getTouchingPropertyName === "function")) return;
        const touchingNode = ts.getTouchingPropertyName(sourceFile, position);
        if (touchingNode === sourceFile) return;
        const adjustedNode = getNodeForQuickInfo(touchingNode);
        if (ts.isToken(adjustedNode) && adjustedNode.kind === ts.SyntaxKind.YieldKeyword) {
          if (ts.isYieldExpression(adjustedNode.parent) && adjustedNode.parent.asteriskToken && adjustedNode.parent.expression) {
            return {
              type: typeChecker.getTypeAtLocation(adjustedNode.parent.expression),
              atLocation: adjustedNode.parent.expression,
              node: adjustedNode.parent,
              shouldTry: true
            };
          }
        }
        return {
          type: typeChecker.getTypeAtLocation(adjustedNode),
          atLocation: adjustedNode,
          node: adjustedNode,
          shouldTry: options.quickinfoEffectParameters === "always" && quickInfo2 ? true : quickInfo2 && ts.displayPartsToString(quickInfo2.displayParts).indexOf("...") > -1
        };
      }
      const data = getDataForQuickInfo();
      if (!(data && data.shouldTry)) return quickInfo2;
      const { atLocation, node, type } = data;
      const effectTypeArgsDocumentation = yield* pipe(
        typeParser.effectType(
          type,
          atLocation
        ),
        map5((_) => makeSymbolDisplayParts("Effect Type Parameters", _.A, _.E, _.R)),
        orElse2(() => {
          const callSignatues = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
          if (callSignatues.length !== 1) return succeed([]);
          const returnType = typeChecker.getReturnTypeOfSignature(callSignatues[0]);
          return pipe(
            typeParser.effectType(
              returnType,
              atLocation
            ),
            map5((_) => makeSymbolDisplayParts("Returned Effect Type Parameters", _.A, _.E, _.R))
          );
        })
      );
      if (!quickInfo2) {
        const start = ts.getTokenPosOfNode(node, sourceFile);
        const end = node.end;
        return {
          kind: ts.ScriptElementKind.callSignatureElement,
          kindModifiers: "",
          textSpan: { start, length: end - start },
          documentation: effectTypeArgsDocumentation
        };
      }
      if (quickInfo2.documentation) {
        return {
          ...quickInfo2,
          documentation: effectTypeArgsDocumentation.concat(quickInfo2.documentation)
        };
      }
      return {
        ...quickInfo2,
        documentation: effectTypeArgsDocumentation
      };
    }),
    orElse2(() => succeed(quickInfo2))
  );
}

// node_modules/.pnpm/pako@2.1.0/node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size4) => {
  let len = strm.avail_in;
  if (len > size4) {
    len = size4;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match3;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match3 = cur_match;
    if (_win[match3 + best_len] !== scan_end || _win[match3 + best_len - 1] !== scan_end1 || _win[match3] !== _win[scan] || _win[++match3] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match3++;
    do {
    } while (_win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left3, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left3 = s.strstart - s.block_start;
    if (len > left3 + s.strm.avail_in) {
      len = left3 + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left3 + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left3 + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left3) {
      if (left3 > len) {
        left3 = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left3), s.strm.next_out);
      s.strm.next_out += left3;
      s.strm.avail_out -= left3;
      s.strm.total_out += left3;
      s.block_start += left3;
      len -= left3;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left3 = s.strstart - s.block_start;
  if (left3 >= min_block || (left3 || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left3 <= have) {
    len = left3 > have ? have : left3;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left3 ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head3) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head3;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left3 = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left3 > s.pending_buf_size) {
        let copy2 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy2;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left3 -= copy2;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left3), s.pending);
      s.pending += left3;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left3 = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match3;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left3 = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left3 <<= 1;
    left3 -= count[len];
    if (left3 < 0) {
      return -1;
    }
  }
  if (left3 > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match3 = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match3 = 257;
  } else {
    base = dbase;
    extra = dext;
    match3 = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match3) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match3) {
      here_op = extra[work[sym] - match3];
      here_val = base[work[sym] - match3];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left3 = 1 << curr;
      while (curr + drop < max) {
        left3 -= count[curr + drop];
        if (left3 <= 0) {
          break;
        }
        curr++;
        left3 <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy2) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy2 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
    copy2 -= dist;
    if (copy2) {
      state.window.set(src.subarray(end - copy2, end), 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left3;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left3 = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left3;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy2
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left3;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left3) {
              copy2 = left3;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left3 -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left3 >= 258) {
            strm.next_out = put;
            strm.avail_out = left3;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left3 = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left3 === 0) {
            break inf_leave;
          }
          copy2 = _out - left3;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left3) {
            copy2 = left3;
          }
          left3 -= copy2;
          state.length -= copy2;
          do {
            output[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left3 === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left3--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left3;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left3;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left3;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head3) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head3;
  head3.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var deflate_1 = deflate;

// src/core/LayerGraph.ts
var UnableToProduceLayerGraphError = class {
  constructor(message, node) {
    this.message = message;
    this.node = node;
  }
  _tag = "@effect/language-service/UnableToProduceLayerGraphError";
};
var extractLayerGraph = fn("extractLayerGraph")(function* (node, opts) {
  const ts = yield* service(TypeScriptApi);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  const tsUtils = yield* service(TypeScriptUtils);
  const sourceFile = tsUtils.getSourceFileOfNode(node);
  const layerModuleName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", "Layer") || "Layer";
  const visitedNodes = /* @__PURE__ */ new WeakSet();
  const nodeInPipeContext = /* @__PURE__ */ new WeakSet();
  const nodeToGraph = /* @__PURE__ */ new WeakMap();
  const nodeToVisit = [node];
  const appendNodeToVisit = (node2) => {
    nodeToVisit.push(node2);
    return void 0;
  };
  const mutableGraph = beginMutation3(directed());
  const extractNodeInfo = fn("extractNodeInfo")(function* (node2) {
    let provides = [];
    let requires = [];
    let layerType = void 0;
    let layerTypes = void 0;
    if (nodeInPipeContext.has(node2)) {
      if (ts.isExpression(node2)) {
        const contextualType = typeChecker.getContextualType(node2);
        if (contextualType) {
          const callSignatures = typeChecker.getSignaturesOfType(contextualType, ts.SignatureKind.Call);
          if (callSignatures.length === 1) {
            layerType = typeChecker.getReturnTypeOfSignature(callSignatures[0]);
          }
        }
      }
    } else {
      layerType = typeChecker.getTypeAtLocation(node2);
    }
    if (layerType) {
      layerTypes = yield* pipe(typeParser.layerType(layerType, node2), orElse2(() => void_));
    }
    if (!layerTypes) layerType = void 0;
    if (layerTypes) {
      provides = typeCheckerUtils.unrollUnionMembers(layerTypes.ROut).filter((_) => !(_.flags & ts.TypeFlags.Never));
      requires = typeCheckerUtils.unrollUnionMembers(layerTypes.RIn).filter((_) => !(_.flags & ts.TypeFlags.Never));
    }
    return { node: node2, layerType, layerTypes, provides, requires };
  });
  const addNode2 = fn("addNode")(function* (node2, nodeInfo) {
    const graphNode = addNode(mutableGraph, nodeInfo ? nodeInfo : yield* extractNodeInfo(node2));
    nodeToGraph.set(node2, graphNode);
    return graphNode;
  });
  while (nodeToVisit.length > 0) {
    const node2 = nodeToVisit.pop();
    const pipeArgs = yield* pipe(typeParser.pipeCall(node2), orElse2(() => void_));
    if (pipeArgs) {
      if (!visitedNodes.has(node2)) {
        appendNodeToVisit(node2);
        appendNodeToVisit(pipeArgs.subject);
        pipeArgs.args.forEach(appendNodeToVisit);
        pipeArgs.args.forEach((_) => nodeInPipeContext.add(_));
        visitedNodes.add(node2);
      } else {
        const childNodes = [pipeArgs.subject, ...pipeArgs.args].map((_) => nodeToGraph.get(_)).filter(
          isNumber
        ).filter(
          (_) => hasNode(mutableGraph, _)
        );
        if (childNodes.length === pipeArgs.args.length + 1) {
          let lastNode = null;
          for (const childNode of childNodes) {
            if (lastNode !== null) addEdge(mutableGraph, childNode, lastNode, { relationship: "pipe" });
            lastNode = childNode;
          }
          if (lastNode !== null) {
            const graphNode = yield* addNode2(node2);
            addEdge(mutableGraph, graphNode, lastNode, { relationship: "pipe" });
          }
        } else {
          childNodes.forEach((_) => removeNode(mutableGraph, _));
          const nodeInfo = yield* extractNodeInfo(node2);
          if (nodeInfo.layerTypes) yield* addNode2(node2, nodeInfo);
        }
      }
      continue;
    }
    if (ts.isCallExpression(node2)) {
      let shouldExplode = !opts.explodeOnlyLayerCalls;
      if (opts.explodeOnlyLayerCalls) {
        const isLayerCall = ts.isPropertyAccessExpression(node2.expression) && ts.isIdentifier(node2.expression.expression) && ts.idText(node2.expression.expression) === layerModuleName;
        if (isLayerCall) shouldExplode = true;
      }
      if (shouldExplode) {
        if (!visitedNodes.has(node2)) {
          appendNodeToVisit(node2);
          node2.arguments.forEach(appendNodeToVisit);
          visitedNodes.add(node2);
        } else {
          const childNodes = node2.arguments.map((_) => nodeToGraph.get(_)).filter(isNumber).filter(
            (_) => hasNode(mutableGraph, _)
          );
          if (childNodes.length === node2.arguments.length) {
            const graphNode = yield* addNode2(node2);
            childNodes.forEach(
              (_, argumentIndex) => addEdge(mutableGraph, graphNode, _, { relationship: "call", argumentIndex })
            );
          } else {
            childNodes.forEach((_) => removeNode(mutableGraph, _));
            const nodeInfo = yield* extractNodeInfo(node2);
            if (nodeInfo.layerTypes) yield* addNode2(node2, nodeInfo);
          }
        }
        continue;
      }
    }
    if (opts.arrayLiteralAsMerge && ts.isArrayLiteralExpression(node2)) {
      if (!visitedNodes.has(node2)) {
        appendNodeToVisit(node2);
        node2.elements.forEach(appendNodeToVisit);
        visitedNodes.add(node2);
      } else {
        const childNodes = node2.elements.map((_) => nodeToGraph.get(_)).filter(isNumber).filter(
          (_) => hasNode(mutableGraph, _)
        );
        if (childNodes.length > 0) {
          const graphNode = yield* addNode2(node2);
          childNodes.forEach(
            (_, index) => addEdge(mutableGraph, graphNode, _, { relationship: "arrayLiteral", index })
          );
        }
      }
      continue;
    }
    if (ts.isExpression(node2)) {
      const nodeInfo = yield* extractNodeInfo(node2);
      if (nodeInfo.layerTypes) {
        yield* addNode2(node2, nodeInfo);
        continue;
      }
    }
    return yield* fail(new UnableToProduceLayerGraphError("Unable to produce layer graph for node", node2));
  }
  return endMutation2(mutableGraph);
});
var formatLayerGraph = fn("formatLayerGraph")(function* (layerGraph) {
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const ts = yield* service(TypeScriptApi);
  return toMermaid(layerGraph, {
    edgeLabel: (edge) => JSON.stringify(edge),
    nodeLabel: (graphNode) => {
      const sourceFile = tsUtils.getSourceFileOfNode(graphNode.node);
      let text = sourceFile.text.substring(graphNode.node.pos, graphNode.node.end).trim();
      text += "\nprovides: " + graphNode.provides.map((_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)).join(
        ", "
      );
      text += "\nrequires: " + graphNode.requires.map((_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)).join(
        ", "
      );
      return text;
    }
  });
});
var formatNestedLayerGraph = fn("formatNestedLayerGraph")(function* (layerGraph) {
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const ts = yield* service(TypeScriptApi);
  const mermaidSafe = (value) => value.replace(/\n/g, " ").replace(
    /\s+/g,
    " "
  ).substring(0, 50).replace(/"/g, "#quot;").replace(/</mg, "#lt;").replace(/>/mg, "#gt;").trim();
  const typeNameCache = /* @__PURE__ */ new Map();
  const typeName = (type) => {
    if (typeNameCache.has(type)) return typeNameCache.get(type);
    const name = typeChecker.typeToString(type, void 0, ts.TypeFormatFlags.NoTruncation);
    typeNameCache.set(type, name);
    return name;
  };
  let result = [];
  for (const [graphNodeIndex, graphNode] of entries(nodes(layerGraph))) {
    let subgraphDefs = [];
    for (const kind of ["requires", "provides"]) {
      const typesMermaidNodes = [];
      for (let i = 0; i < graphNode[kind].length; i++) {
        typesMermaidNodes.push(`${graphNodeIndex}_${kind}_${i}["${mermaidSafe(typeName(graphNode[kind][i]))}"]`);
      }
      if (typesMermaidNodes.length > 0) {
        subgraphDefs = [
          ...subgraphDefs,
          `subgraph ${graphNodeIndex}_${kind} [${kind === "provides" ? "Provides" : "Requires"}]`,
          ...typesMermaidNodes.map((_) => `  ${_}`),
          `end`,
          `style ${graphNodeIndex}_${kind} stroke:none`
        ];
      }
    }
    subgraphDefs = [
      `subgraph ${graphNodeIndex}_wrap[" "]`,
      ...subgraphDefs.map((_) => `  ${_}`),
      `end`,
      `style ${graphNodeIndex}_wrap fill:transparent`,
      `style ${graphNodeIndex}_wrap stroke:none`
    ];
    const sourceFile = tsUtils.getSourceFileOfNode(graphNode.node);
    const nodePosition = graphNode.node.getStart(sourceFile, false);
    const { character, line } = ts.getLineAndCharacterOfPosition(sourceFile, nodePosition);
    const nodeText = sourceFile.text.substring(graphNode.node.pos, graphNode.node.end).trim();
    result = [
      ...result,
      `subgraph ${graphNodeIndex} ["\`${mermaidSafe(nodeText)}<br/>_at ln ${line + 1} col ${character}_\`"]`,
      ...subgraphDefs.map((_) => `  ${_}`),
      `end`,
      `style ${graphNodeIndex} fill:transparent`
    ];
  }
  for (const edgeInfo of values2(edges(layerGraph))) {
    const sourceData = layerGraph.nodes.get(edgeInfo.source);
    const targetData = layerGraph.nodes.get(edgeInfo.target);
    let connected = false;
    for (const kind of ["requires", "provides"]) {
      for (let i = 0; i < sourceData[kind].length; i++) {
        const targetIdx = targetData[kind].indexOf(sourceData[kind][i]);
        if (targetIdx > -1) {
          result.push(`${edgeInfo.source}_${kind}_${i} -.-> ${edgeInfo.target}_${kind}_${targetIdx}`);
          connected = true;
        }
      }
    }
    if (!connected) {
      result.push(`${edgeInfo.source} -.-x ${edgeInfo.target}`);
    }
  }
  return [
    `flowchart TB`,
    ...result.map((_) => `  ${_}`)
  ].join("\n");
});
var extractOutlineGraph = fn("extractOutlineGraph")(function* (layerGraph) {
  const typeChecker = yield* service(TypeCheckerApi);
  const mutableGraph = beginMutation3(directed());
  const providers = /* @__PURE__ */ new Map();
  const knownSymbols = /* @__PURE__ */ new WeakSet();
  const leafNodes = values2(externals(layerGraph, { direction: "outgoing" }));
  const dedupedLeafNodes = [];
  for (const leafNode of leafNodes) {
    const symbol3 = typeChecker.getSymbolAtLocation(leafNode.node);
    if (!symbol3) {
      dedupedLeafNodes.push(leafNode);
    } else if (symbol3 && !knownSymbols.has(symbol3)) {
      dedupedLeafNodes.push(leafNode);
      knownSymbols.add(symbol3);
    }
  }
  for (const leafNode of dedupedLeafNodes) {
    const nodeIndex = addNode(mutableGraph, {
      node: leafNode.node,
      requires: leafNode.requires,
      provides: leafNode.provides
    });
    for (const providedType of leafNode.provides) {
      if (leafNode.requires.indexOf(providedType) > -1) continue;
      const previousProviders = providers.get(providedType) || [];
      providers.set(providedType, [...previousProviders, nodeIndex]);
    }
  }
  for (const [nodeIndex, nodeInfo] of entries(nodes(mutableGraph))) {
    for (const requiredType of nodeInfo.requires) {
      for (const [providedType, providerNodeIndexes] of providers.entries()) {
        if (requiredType === providedType || typeChecker.isTypeAssignableTo(requiredType, providedType)) {
          for (const providerNodeIndex of providerNodeIndexes) {
            addEdge(mutableGraph, nodeIndex, providerNodeIndex, {});
          }
        }
      }
    }
  }
  return endMutation2(mutableGraph);
});
var formatLayerOutlineGraph = fn("formatLayerOutlineGraph")(
  function* (layerOutlineGraph) {
    const tsUtils = yield* service(TypeScriptUtils);
    return toMermaid(layerOutlineGraph, {
      edgeLabel: () => "",
      nodeLabel: (graphNode) => {
        const sourceFile = tsUtils.getSourceFileOfNode(graphNode.node);
        return sourceFile.text.substring(graphNode.node.pos, graphNode.node.end).trim();
      }
    });
  }
);
var convertOutlineGraphToLayerMagic = fn("convertOutlineGraphToLayerMagic")(
  function* (outlineGraph, targetOutput) {
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const ts = yield* service(TypeScriptApi);
    const result = [];
    const missingOutputTypes = new Set(typeCheckerUtils.unrollUnionMembers(targetOutput));
    const currentRequiredTypes = /* @__PURE__ */ new Set();
    const reversedGraph = mutate2(outlineGraph, reverse3);
    const rootIndexes = fromIterable(indices(externals(reversedGraph, { direction: "incoming" })));
    const allNodes = fromIterable(values2(dfsPostOrder(reversedGraph, { start: rootIndexes })));
    for (const nodeInfo of allNodes) {
      if (!ts.isExpression(nodeInfo.node)) continue;
      const reallyProvidedTypes = nodeInfo.provides.filter((_) => nodeInfo.requires.indexOf(_) === -1);
      const shouldMerge = reallyProvidedTypes.some((_) => missingOutputTypes.has(_));
      if (shouldMerge) {
        reallyProvidedTypes.forEach((_) => missingOutputTypes.delete(_));
      }
      nodeInfo.provides.forEach((_) => currentRequiredTypes.delete(_));
      nodeInfo.requires.forEach((_) => currentRequiredTypes.add(_));
      result.push({
        merges: shouldMerge,
        provides: true,
        layerExpression: nodeInfo.node
      });
    }
    return {
      layerMagicNodes: result,
      missingOutputTypes
    };
  }
);
var walkLeavesMatching = (graph, predicate, config = {}) => {
  const start = config.start ?? [];
  const direction = config.direction ?? "outgoing";
  return new Walker((f) => ({
    [Symbol.iterator]: () => {
      let queue = [...start];
      const discovered = /* @__PURE__ */ new Set();
      const nextMapped = () => {
        while (queue.length > 0) {
          const current = queue.shift();
          if (discovered.has(current)) continue;
          discovered.add(current);
          const neighbors = neighborsDirected(graph, current, direction);
          const neighborsMatching = [];
          for (const neighbor of neighbors) {
            const neighborNode = getNode(graph, neighbor);
            if (isSome2(neighborNode) && predicate(neighborNode.value)) {
              neighborsMatching.push(neighbor);
            }
          }
          if (neighborsMatching.length > 0) {
            queue = [...queue, ...neighborsMatching];
          } else {
            const nodeData = getNode(graph, current);
            if (isSome2(nodeData) && predicate(nodeData.value)) {
              return { done: false, value: f(current, nodeData.value) };
            }
          }
        }
        return { done: true, value: void 0 };
      };
      return { next: nextMapped };
    }
  }));
};
var extractProvidersAndRequirers = fn("extractProvidersAndRequirers")(
  function* (layerGraph) {
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const rootWalker = externals(layerGraph, { direction: "incoming" });
    const rootNodes = fromIterable(values2(rootWalker));
    const rootNodeIndexes = fromIterable(indices(rootWalker));
    const result = [];
    const walkTypes = (rootTypes, kind) => {
      const sortedTypes = pipe(fromIterable(rootTypes), sort(typeCheckerUtils.deterministicTypeOrder));
      for (const layerType of sortedTypes) {
        const tsNodes = [];
        for (const layerNode of values2(
          walkLeavesMatching(
            layerGraph,
            (_) => (kind === "provided" ? _.provides : _.requires).some(
              (_2) => _2 === layerType || typeChecker.isTypeAssignableTo(_2, layerType)
            ),
            { start: rootNodeIndexes }
          )
        )) {
          tsNodes.push(layerNode.node);
        }
        result.push({
          kind,
          type: layerType,
          nodes: tsNodes
        });
      }
    };
    walkTypes(new Set(rootNodes.flatMap((_) => _.provides)), "provided");
    walkTypes(new Set(rootNodes.flatMap((_) => _.requires)), "required");
    return result;
  }
);
var formatLayerProvidersAndRequirersInfo = fn("formatLayerProvidersAndRequirersInfo")(
  function* (info) {
    const typeChecker = yield* service(TypeCheckerApi);
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    if (info.length === 0) return "";
    const textualExplanation = [];
    const appendInfo = (infoNode) => {
      const typeString = typeChecker.typeToString(
        infoNode.type,
        void 0,
        ts.TypeFormatFlags.NoTruncation
      );
      const positions = infoNode.nodes.map((_) => {
        const sourceFile = tsUtils.getSourceFileOfNode(_);
        const nodePosition = ts.getTokenPosOfNode(_, sourceFile);
        const { character, line } = ts.getLineAndCharacterOfPosition(sourceFile, nodePosition);
        const nodeText = sourceFile.text.substring(_.pos, _.end).trim().replace(/\n/g, " ").substr(0, 50);
        return `ln ${line + 1} col ${character} by \`${nodeText}\``;
      });
      textualExplanation.push(`- ${typeString} ${infoNode.kind} at ${positions.join(", ")}`);
    };
    const providedItems = info.filter((_) => _.kind === "provided");
    const requiredItems = info.filter((_) => _.kind === "required");
    if (providedItems.length > 0) {
      for (const item of providedItems) {
        appendInfo(item);
      }
      if (textualExplanation.length > 0 && requiredItems.length > 0) textualExplanation.push("");
    }
    if (requiredItems.length > 0) {
      for (const item of requiredItems) {
        appendInfo(item);
      }
    }
    return "/**\n" + textualExplanation.map((l) => " * " + l).join("\n") + "\n */";
  }
);

// src/quickinfo/layerInfo.ts
function generateMarmaidUri(code) {
  return gen(function* () {
    const state = JSON.stringify({ code });
    const data = new TextEncoder().encode(state);
    const compressed = deflate_1(data, { level: 9 });
    const pakoString = "pako:" + encodeBase64Url(compressed);
    return "https://www.mermaidchart.com/play#" + pakoString;
  });
}
function getAdjustedNode(sourceFile, position) {
  return gen(function* () {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const range = tsUtils.toTextRange(position);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, range),
      filter((_) => ts.isVariableDeclaration(_) || ts.isPropertyDeclaration(_)),
      filter((_) => tsUtils.isNodeInRange(range)(_.name)),
      head
    );
    if (isNone2(maybeNode)) return void 0;
    const node = maybeNode.value;
    const layerNode = node.initializer ? node.initializer : node;
    const layerType = typeChecker.getTypeAtLocation(layerNode);
    const maybeLayer = yield* option(typeParser.layerType(layerType, layerNode));
    if (isNone2(maybeLayer)) return void 0;
    return { node, layerNode };
  });
}
function parseLayerGraph(layerNode) {
  return gen(function* () {
    const layerGraph = yield* extractLayerGraph(layerNode, {
      arrayLiteralAsMerge: false,
      explodeOnlyLayerCalls: false
    });
    const nestedGraphMermaid = yield* formatNestedLayerGraph(layerGraph);
    const outlineGraph = yield* extractOutlineGraph(layerGraph);
    const outlineGraphMermaid = yield* formatLayerOutlineGraph(outlineGraph);
    const providersAndRequirers = yield* extractProvidersAndRequirers(layerGraph);
    const providersAndRequirersTextualExplanation = yield* formatLayerProvidersAndRequirersInfo(
      providersAndRequirers
    );
    return { nestedGraphMermaid, outlineGraphMermaid, providersAndRequirersTextualExplanation };
  });
}
function effectApiGetLayerGraph(sourceFile, line, character) {
  return gen(function* () {
    const ts = yield* service(TypeScriptApi);
    const position = ts.getPositionOfLineAndCharacter(sourceFile, line, character);
    const maybeNodes = yield* getAdjustedNode(sourceFile, position);
    if (!maybeNodes) return yield* fail(new UnableToProduceLayerGraphError("No node found"));
    const { layerNode, node } = maybeNodes;
    const { nestedGraphMermaid } = yield* parseLayerGraph(layerNode);
    return { start: node.pos, end: node.end, mermaidCode: nestedGraphMermaid };
  });
}
function layerInfo(sourceFile, position, quickInfo2) {
  return pipe(
    gen(function* () {
      const ts = yield* service(TypeScriptApi);
      const options = yield* service(LanguageServicePluginOptions);
      const maybeNodes = yield* getAdjustedNode(sourceFile, position);
      if (!maybeNodes) return quickInfo2;
      const { layerNode, node } = maybeNodes;
      const layerInfoDisplayParts = yield* pipe(
        parseLayerGraph(layerNode),
        flatMap2(
          ({ nestedGraphMermaid, outlineGraphMermaid, providersAndRequirersTextualExplanation }) => gen(function* () {
            const linkParts = [];
            if (!options.noExternal) {
              const mermaidUri = yield* generateMarmaidUri(nestedGraphMermaid);
              const outlineMermaidUri = yield* generateMarmaidUri(outlineGraphMermaid);
              linkParts.push({ kind: "space", text: "\n" });
              linkParts.push({ kind: "link", text: "{@link " });
              linkParts.push({ kind: "linkText", text: mermaidUri + " Show full Layer graph" });
              linkParts.push({ kind: "link", text: "}" });
              linkParts.push({ kind: "text", text: " - " });
              linkParts.push({ kind: "link", text: "{@link " });
              linkParts.push({ kind: "linkText", text: outlineMermaidUri + " Show Layer outline" });
              linkParts.push({ kind: "link", text: "}" });
              linkParts.push({ kind: "space", text: "\n" });
            }
            if (providersAndRequirersTextualExplanation.length === 0) return linkParts;
            return [
              {
                kind: "text",
                text: "```\n" + providersAndRequirersTextualExplanation + "\n```\n"
              },
              ...linkParts
            ];
          })
        ),
        orElse2(() => succeed([]))
      );
      if (layerInfoDisplayParts.length === 0) return quickInfo2;
      if (!quickInfo2) {
        const start = ts.getTokenPosOfNode(node, sourceFile);
        const end = node.end;
        return {
          kind: ts.ScriptElementKind.callSignatureElement,
          kindModifiers: "",
          textSpan: { start, length: end - start },
          documentation: layerInfoDisplayParts
        };
      }
      if (quickInfo2.documentation) {
        return {
          ...quickInfo2,
          documentation: quickInfo2.documentation.concat([{ kind: "space", text: "\n" }]).concat(layerInfoDisplayParts)
        };
      }
      return {
        ...quickInfo2,
        documentation: layerInfoDisplayParts
      };
    }),
    orElse2(() => succeed(quickInfo2))
  );
}

// src/quickinfo.ts
function quickInfo(sourceFile, position, quickInfo2) {
  return gen(function* () {
    const deduped = yield* dedupeJsDocs(quickInfo2);
    const withEffectTypeArgs = yield* effectTypeArgs(sourceFile, position, deduped);
    const withLayerInfo = yield* layerInfo(sourceFile, position, withEffectTypeArgs);
    return withLayerInfo;
  });
}

// src/refactors/asyncAwaitToFn.ts
var asyncAwaitToFn = createRefactor({
  name: "asyncAwaitToFn",
  description: "Convert to Effect.fn",
  apply: fn("asyncAwaitToFn.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2) || ts.isFunctionExpression(node2)
      ),
      filter((node2) => !!node2.body),
      filter((node2) => !!(ts.getCombinedModifierFlags(node2) & ts.ModifierFlags.Async)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.asyncAwaitToFn",
      description: "Rewrite to Effect.fn",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Effect"
          ) || "Effect";
          const newDeclaration = tsUtils.transformAsyncAwaitToEffectFn(
            node,
            effectModuleIdentifierName,
            (expression) => ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleIdentifierName),
                "promise"
              ),
              void 0,
              [
                ts.factory.createArrowFunction(
                  void 0,
                  void 0,
                  [],
                  void 0,
                  void 0,
                  expression
                )
              ]
            )
          );
          changeTracker.replaceNode(sourceFile, node, newDeclaration);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/asyncAwaitToFnTryPromise.ts
var asyncAwaitToFnTryPromise = createRefactor({
  name: "asyncAwaitToFnTryPromise",
  description: "Convert to Effect.fn with failures",
  apply: fn("asyncAwaitToFnTryPromise.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2) || ts.isFunctionExpression(node2)
      ),
      filter((node2) => !!node2.body),
      filter((node2) => !!(ts.getCombinedModifierFlags(node2) & ts.ModifierFlags.Async)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.asyncAwaitToFnTryPromise",
      description: "Rewrite to Effect.fn with failures",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Effect"
          ) || "Effect";
          const dataModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Data"
          ) || "Data";
          let errorCount = 0;
          const errors = [];
          function createErrorADT() {
            errorCount++;
            const errorName = "Error" + errorCount;
            errors.push(tsUtils.createDataTaggedErrorDeclaration(dataModuleIdentifierName, errorName, [
              ts.factory.createPropertySignature(
                void 0,
                "cause",
                void 0,
                ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)
              )
            ]));
            return ts.factory.createNewExpression(
              ts.factory.createIdentifier(errorName),
              void 0,
              [ts.factory.createObjectLiteralExpression([
                ts.factory.createShorthandPropertyAssignment("cause")
              ])]
            );
          }
          const newDeclaration = tsUtils.transformAsyncAwaitToEffectFn(
            node,
            effectModuleIdentifierName,
            (expression) => ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleIdentifierName),
                "tryPromise"
              ),
              void 0,
              [
                ts.factory.createObjectLiteralExpression([
                  ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier("try"),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      expression
                    )
                  ),
                  ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier("catch"),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [ts.factory.createParameterDeclaration(void 0, void 0, "cause")],
                      void 0,
                      void 0,
                      createErrorADT()
                    )
                  )
                ])
              ]
            )
          );
          let beforeNode = node;
          while (beforeNode.parent && !ts.isSourceFile(beforeNode.parent)) {
            beforeNode = beforeNode.parent;
          }
          for (const error of errors) {
            changeTracker.insertNodeBefore(sourceFile, beforeNode, error, true);
          }
          changeTracker.replaceNode(sourceFile, node, newDeclaration);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/asyncAwaitToGen.ts
var asyncAwaitToGen = createRefactor({
  name: "asyncAwaitToGen",
  description: "Convert to Effect.gen",
  apply: fn("asyncAwaitToGen.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2) || ts.isFunctionExpression(node2)
      ),
      filter((node2) => !!node2.body),
      filter((node2) => !!(ts.getCombinedModifierFlags(node2) & ts.ModifierFlags.Async)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.asyncAwaitToGen",
      description: "Rewrite to Effect.gen",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Effect"
          ) || "Effect";
          const newDeclaration = tsUtils.transformAsyncAwaitToEffectGen(
            node,
            effectModuleIdentifierName,
            (expression) => ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleIdentifierName),
                "promise"
              ),
              void 0,
              [
                ts.factory.createArrowFunction(
                  void 0,
                  void 0,
                  [],
                  void 0,
                  void 0,
                  expression
                )
              ]
            )
          );
          changeTracker.replaceNode(sourceFile, node, newDeclaration);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/asyncAwaitToGenTryPromise.ts
var asyncAwaitToGenTryPromise = createRefactor({
  name: "asyncAwaitToGenTryPromise",
  description: "Convert to Effect.gen with failures",
  apply: fn("asyncAwaitToGenTryPromise.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2) || ts.isFunctionExpression(node2)
      ),
      filter((node2) => !!node2.body),
      filter((node2) => !!(ts.getCombinedModifierFlags(node2) & ts.ModifierFlags.Async)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.asyncAwaitToGenTryPromise",
      description: "Rewrite to Effect.gen with failures",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Effect"
          ) || "Effect";
          const dataModuleIdentifierName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Data"
          ) || "Data";
          let errorCount = 0;
          const errors = [];
          function createErrorADT() {
            errorCount++;
            const errorName = "Error" + errorCount;
            errors.push(tsUtils.createDataTaggedErrorDeclaration(dataModuleIdentifierName, errorName, [
              ts.factory.createPropertySignature(
                void 0,
                "cause",
                void 0,
                ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)
              )
            ]));
            return ts.factory.createNewExpression(
              ts.factory.createIdentifier(errorName),
              void 0,
              [ts.factory.createObjectLiteralExpression([
                ts.factory.createShorthandPropertyAssignment("cause")
              ])]
            );
          }
          const newDeclaration = tsUtils.transformAsyncAwaitToEffectGen(
            node,
            effectModuleIdentifierName,
            (expression) => ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier(effectModuleIdentifierName),
                "tryPromise"
              ),
              void 0,
              [
                ts.factory.createObjectLiteralExpression([
                  ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier("try"),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      expression
                    )
                  ),
                  ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier("catch"),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [ts.factory.createParameterDeclaration(void 0, void 0, "cause")],
                      void 0,
                      void 0,
                      createErrorADT()
                    )
                  )
                ])
              ]
            )
          );
          let beforeNode = node;
          while (beforeNode.parent && !ts.isSourceFile(beforeNode.parent)) {
            beforeNode = beforeNode.parent;
          }
          for (const error of errors) {
            changeTracker.insertNodeBefore(sourceFile, beforeNode, error, true);
          }
          changeTracker.replaceNode(sourceFile, node, newDeclaration);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/effectGenToFn.ts
var effectGenToFn = createRefactor({
  name: "effectGenToFn",
  description: "Convert to Effect.fn",
  apply: fn("effectGenToFn.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    const skipReturnBlock = (node) => ts.isBlock(node) && node.statements.length === 1 && ts.isReturnStatement(node.statements[0]) && node.statements[0].expression ? node.statements[0].expression : node;
    const parseFunctionLikeReturnEffectGen = fn("parseFunctionLikeReturnEffect.apply")(function* (node) {
      if ((ts.isArrowFunction(node) || ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node)) && node.body) {
        let subject = skipReturnBlock(node.body);
        let pipeArgs2 = [];
        while (true) {
          const maybePipe = yield* option(typeParser.pipeCall(subject));
          if (isNone2(maybePipe)) break;
          subject = maybePipe.value.subject;
          pipeArgs2 = maybePipe.value.args.concat(pipeArgs2);
        }
        const fnIdentifier2 = node.name && ts.isIdentifier(node.name) ? node.name : ts.isVariableDeclaration(node.parent) && node.parent.name && ts.isIdentifier(node.parent.name) ? node.parent.name : void 0;
        const effectGen = yield* typeParser.effectGen(subject);
        return { ...effectGen, nodeToReplace: node, pipeArgs: pipeArgs2, fnIdentifier: fnIdentifier2 };
      }
      return yield* fail(new RefactorNotApplicableError());
    });
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    if (parentNodes.length === 0) return yield* fail(new RefactorNotApplicableError());
    const nodesFromInitializers = pipe(
      parentNodes,
      filter((_) => ts.isVariableDeclaration(_) && _.initializer ? true : false),
      filter((_) => tsUtils.isNodeInRange(textRange)(_.name)),
      map4((_) => _.initializer)
    );
    const maybeNode = yield* pipe(
      nodesFromInitializers.concat(parentNodes),
      map4(parseFunctionLikeReturnEffectGen),
      firstSuccessOf,
      option
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const { effectModule, fnIdentifier, generatorFunction, nodeToReplace, pipeArgs } = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.effectGenToFn",
      description: fnIdentifier ? `Convert to Effect.fn("${ts.idText(fnIdentifier)}")` : "Convert to Effect.fn",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectFn = fnIdentifier ? ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              effectModule,
              "fn"
            ),
            void 0,
            [ts.factory.createStringLiteral(ts.idText(fnIdentifier))]
          ) : ts.factory.createPropertyAccessExpression(
            effectModule,
            "fn"
          );
          const effectFnCallWithGenerator = ts.factory.createCallExpression(
            effectFn,
            void 0,
            [ts.factory.createFunctionExpression(
              void 0,
              ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
              void 0,
              nodeToReplace.typeParameters,
              nodeToReplace.parameters,
              nodeToReplace.type,
              generatorFunction.body
            )].concat(pipeArgs)
          );
          changeTracker.replaceNode(
            sourceFile,
            nodeToReplace,
            tsUtils.tryPreserveDeclarationSemantics(nodeToReplace, effectFnCallWithGenerator, false)
          );
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/refactors/functionToArrow.ts
var functionToArrow = createRefactor({
  name: "functionToArrow",
  description: "Convert to arrow",
  apply: fn("functionToArrow.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter((_) => ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_)),
      filter((_) => !!_.body),
      filter((_) => !!_.name && tsUtils.isNodeInRange(textRange)(_.name)),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.functionToArrow",
      description: "Convert to arrow",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const body = node.body;
          let newBody = ts.factory.createBlock(body.statements);
          if (body.statements.length === 1) {
            const statement = body.statements[0];
            if (statement && ts.isReturnStatement(statement) && statement.expression) {
              newBody = statement.expression;
            }
          }
          let arrowFlags = ts.getCombinedModifierFlags(node);
          arrowFlags &= ~ts.ModifierFlags.Export;
          arrowFlags &= ~ts.ModifierFlags.Default;
          const arrowModifiers = ts.factory.createModifiersFromModifierFlags(arrowFlags);
          const arrowFunction = ts.factory.createArrowFunction(
            arrowModifiers,
            node.typeParameters,
            node.parameters,
            void 0,
            ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            newBody
          );
          const newDeclaration = tsUtils.tryPreserveDeclarationSemantics(
            node,
            arrowFunction,
            false
          );
          changeTracker.replaceNode(sourceFile, node, newDeclaration, {
            leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
            trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
          });
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/refactors/layerMagic.ts
var layerMagic = createRefactor({
  name: "layerMagic",
  description: "Layer Magic",
  apply: fn("layerMagic.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const layerIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const adjustedNode = (node) => {
      if (node.parent && (ts.isVariableDeclaration(node.parent) || ts.isPropertyDeclaration(node.parent)) && ts.isIdentifier(node) && node.parent.initializer && node.parent.name === node) {
        return node.parent.initializer;
      }
      return node;
    };
    const computeAsAnyAsLayerRefactor = (node) => {
      const atLocation = adjustedNode(node);
      return pipe(
        extractLayerGraph(atLocation, {
          arrayLiteralAsMerge: true,
          explodeOnlyLayerCalls: true
        }),
        flatMap2(extractOutlineGraph),
        flatMap2(
          (extractedLayer) => nodeCount(extractedLayer) <= 1 ? TypeParserIssue.issue : succeed(extractedLayer)
        ),
        map5((extractedLayers) => ({
          kind: "refactor.rewrite.effect.layerMagicPrepare",
          description: "Prepare layers for automatic composition",
          apply: pipe(
            gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              const layerOutputTypes = /* @__PURE__ */ new Set();
              for (const layer of values2(nodes(extractedLayers))) {
                layer.provides.forEach((_) => layerOutputTypes.add(_));
              }
              const layerNodes = pipe(
                values2(nodes(extractedLayers)),
                fromIterable,
                map4((_) => _.node),
                filter(ts.isExpression),
                sort(mapInput(
                  number2,
                  (_) => _.pos
                ))
              );
              const previouslyProvided = yield* pipe(
                typeParser.layerType(typeChecker.getTypeAtLocation(atLocation), atLocation),
                map5((_) => _.ROut),
                option
              );
              const [existingBefore, newlyIntroduced] = pipe(
                fromIterable(layerOutputTypes),
                sort(typeCheckerUtils.deterministicTypeOrder),
                partition(
                  (_) => isNone2(previouslyProvided) || typeChecker.isTypeAssignableTo(_, previouslyProvided.value)
                )
              );
              const typeReferences = pipe(
                newlyIntroduced,
                map4((_) => typeChecker.typeToTypeNode(_, void 0, ts.NodeBuilderFlags.NoTruncation)),
                filter((_) => !!_)
              );
              const providesUnion = typeReferences.length === 0 ? ts.factory.createTypeReferenceNode("never") : ts.factory.createUnionTypeNode(typeReferences);
              const typeStrings = pipe(
                existingBefore,
                map4((_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)),
                filter((_) => !!_)
              );
              const unionWithComment = typeStrings.length === 0 ? providesUnion : ts.addSyntheticTrailingComment(
                providesUnion,
                ts.SyntaxKind.MultiLineCommentTrivia,
                " " + typeStrings.join(" | ") + " ",
                false
              );
              const newDeclaration = ts.factory.createAsExpression(
                ts.factory.createAsExpression(
                  ts.factory.createArrayLiteralExpression(layerNodes),
                  ts.factory.createTypeReferenceNode("any")
                ),
                ts.factory.createTypeReferenceNode(
                  ts.factory.createQualifiedName(ts.factory.createIdentifier(layerIdentifier), "Layer"),
                  [unionWithComment]
                )
              );
              changeTracker.replaceNode(sourceFile, atLocation, newDeclaration, {
                leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
                trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
              });
            }),
            provideService(TypeScriptApi, ts)
          )
        }))
      );
    };
    const parseAsAnyAsLayer = (node) => {
      if (ts.isAsExpression(node) && ts.isTypeReferenceNode(node.type)) {
        const expression = node.expression;
        if (ts.isAsExpression(expression) && expression.type.kind === ts.SyntaxKind.AnyKeyword) {
          const type = typeChecker.getTypeAtLocation(node.type);
          return pipe(
            typeParser.layerType(type, node.type),
            map5((_) => ({ node, ..._, castedStructure: expression.expression }))
          );
        }
      }
      return TypeParserIssue.issue;
    };
    const computeBuildRefactor = (node) => {
      const atLocation = adjustedNode(node);
      return pipe(
        parseAsAnyAsLayer(atLocation),
        flatMap2(
          (_targetLayer) => pipe(
            extractLayerGraph(_targetLayer.castedStructure, {
              arrayLiteralAsMerge: true,
              explodeOnlyLayerCalls: true
            }),
            flatMap2(extractOutlineGraph),
            flatMap2(
              (extractedLayer) => nodeCount(extractedLayer) <= 1 ? TypeParserIssue.issue : succeed(extractedLayer)
            ),
            map5((extractedLayers) => ({
              kind: "refactor.rewrite.effect.layerMagicBuild",
              description: "Compose layers automatically with target output services",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                const { layerMagicNodes, missingOutputTypes } = yield* pipe(
                  convertOutlineGraphToLayerMagic(
                    extractedLayers,
                    _targetLayer.ROut
                  ),
                  provideService(TypeCheckerApi, typeChecker),
                  provideService(TypeCheckerUtils, typeCheckerUtils),
                  provideService(TypeScriptApi, ts)
                );
                const newDeclaration = ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    layerMagicNodes[0].layerExpression,
                    "pipe"
                  ),
                  [],
                  layerMagicNodes.slice(1).map(
                    (_) => ts.factory.createCallExpression(
                      ts.factory.createPropertyAccessExpression(
                        ts.factory.createIdentifier(layerIdentifier),
                        _.merges && _.provides ? "provideMerge" : _.merges ? "merge" : "provide"
                      ),
                      [],
                      [_.layerExpression]
                    )
                  )
                );
                const newDeclarationWithComment = missingOutputTypes.size > 0 ? ts.addSyntheticTrailingComment(
                  newDeclaration,
                  ts.SyntaxKind.MultiLineCommentTrivia,
                  " Unable to find " + fromIterable(missingOutputTypes.values()).map(
                    (_) => typeChecker.typeToString(_, void 0, ts.TypeFormatFlags.NoTruncation)
                  ).join(", ") + " in the provided layers. ",
                  false
                ) : newDeclaration;
                changeTracker.replaceNode(sourceFile, atLocation, newDeclarationWithComment, {
                  leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
                  trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
                });
              })
            }))
          )
        )
      );
    };
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    if (parentNodes.length === 0) return yield* fail(new RefactorNotApplicableError());
    return yield* pipe(
      firstSuccessOf(parentNodes.map(computeBuildRefactor)),
      orElse2(() => firstSuccessOf(parentNodes.map(computeAsAnyAsLayerRefactor))),
      orElse2(() => fail(new RefactorNotApplicableError()))
    );
  })
});

// src/refactors/makeSchemaOpaque.ts
var _findSchemaVariableDeclaration = fn(
  "makeSchemaOpaque._findSchemaVariableDeclaration"
)(
  function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const findSchema = fn("makeSchemaOpaque.apply.findSchema")(
      function* (node) {
        if (!ts.isVariableDeclaration(node)) {
          return yield* fail("parent should be variable declaration");
        }
        const identifier = node.name;
        if (!ts.isIdentifier(identifier)) return yield* fail("name should be an identifier");
        const initializer = node.initializer;
        if (!initializer) return yield* fail("should have an initializer");
        const variableDeclarationList = node.parent;
        if (!variableDeclarationList || !ts.isVariableDeclarationList(variableDeclarationList)) {
          return yield* fail("parent is not a variable declaration list");
        }
        const variableStatement = variableDeclarationList.parent;
        if (!variableStatement || !ts.isVariableStatement(variableStatement)) {
          return yield* fail("parent not variable declaration statement");
        }
        const type = typeChecker.getTypeAtLocation(initializer);
        const types = yield* typeParser.effectSchemaType(type, initializer);
        return { identifier, variableStatement, variableDeclarationList, types };
      }
    );
    return yield* pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      map4(findSchema),
      firstSuccessOf,
      option
    );
  }
);
var _createOpaqueTypes = fn("_createOpaqueTypes")(function* (effectSchemaName, inferFromName, typeA, opaqueTypeName, typeE, opaqueEncodedName, opaqueContextName) {
  const ts = yield* service(TypeScriptApi);
  const opaqueInferred = ts.factory.createExpressionWithTypeArguments(
    ts.factory.createPropertyAccessExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaName),
        ts.factory.createIdentifier("Schema")
      ),
      ts.factory.createIdentifier("Type")
    ),
    [ts.factory.createTypeQueryNode(
      ts.factory.createIdentifier(inferFromName)
    )]
  );
  const opaqueType = !(typeA.flags & ts.TypeFlags.Object) ? ts.factory.createTypeAliasDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueTypeName,
    [],
    opaqueInferred
  ) : ts.factory.createInterfaceDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueTypeName,
    void 0,
    [ts.factory.createHeritageClause(
      ts.SyntaxKind.ExtendsKeyword,
      [opaqueInferred]
    )],
    []
  );
  const encodedInferred = ts.factory.createExpressionWithTypeArguments(
    ts.factory.createPropertyAccessExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaName),
        ts.factory.createIdentifier("Schema")
      ),
      ts.factory.createIdentifier("Encoded")
    ),
    [ts.factory.createTypeQueryNode(
      ts.factory.createIdentifier(inferFromName)
    )]
  );
  const encodedType = !(typeE.flags & ts.TypeFlags.Object) ? ts.factory.createTypeAliasDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueEncodedName,
    [],
    encodedInferred
  ) : ts.factory.createInterfaceDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueEncodedName,
    void 0,
    [ts.factory.createHeritageClause(
      ts.SyntaxKind.ExtendsKeyword,
      [encodedInferred]
    )],
    []
  );
  const contextInferred = ts.factory.createExpressionWithTypeArguments(
    ts.factory.createPropertyAccessExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaName),
        ts.factory.createIdentifier("Schema")
      ),
      ts.factory.createIdentifier("Context")
    ),
    [ts.factory.createTypeQueryNode(
      ts.factory.createIdentifier(inferFromName)
    )]
  );
  const contextType = ts.factory.createTypeAliasDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    opaqueContextName,
    [],
    contextInferred
  );
  return { contextType, encodedType, opaqueType };
});
var makeSchemaOpaque = createRefactor({
  name: "makeSchemaOpaque",
  description: "Make Schema opaque",
  apply: fn("makeSchemaOpaque.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeNode = yield* _findSchemaVariableDeclaration(sourceFile, textRange);
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const { identifier, types, variableDeclarationList, variableStatement } = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.makeSchemaOpaque",
      description: `Make Schema opaque`,
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectSchemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Schema"
          ) || "Schema";
          const newIdentifier = ts.factory.createIdentifier(ts.idText(identifier) + "_");
          const { contextType, encodedType, opaqueType } = yield* _createOpaqueTypes(
            effectSchemaName,
            ts.idText(newIdentifier),
            types.A,
            ts.idText(identifier),
            types.I,
            ts.idText(identifier) + "Encoded",
            ts.idText(identifier) + "Context"
          );
          changeTracker.replaceNode(
            sourceFile,
            identifier,
            newIdentifier
          );
          changeTracker.insertNodeAfter(sourceFile, variableStatement, opaqueType);
          changeTracker.insertNodeAfter(sourceFile, variableStatement, encodedType);
          changeTracker.insertNodeAfter(sourceFile, variableStatement, contextType);
          const newSchemaType = ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectSchemaName),
              ts.factory.createIdentifier("Schema")
            ),
            [
              ts.factory.createTypeReferenceNode(opaqueType.name),
              ts.factory.createTypeReferenceNode(encodedType.name),
              ts.factory.createTypeReferenceNode(contextType.name)
            ]
          );
          const newConstDeclaration = ts.factory.createVariableStatement(
            variableStatement.modifiers,
            ts.factory.createVariableDeclarationList(
              [ts.factory.createVariableDeclaration(
                ts.idText(identifier),
                void 0,
                newSchemaType,
                ts.factory.createIdentifier(ts.idText(newIdentifier))
              )],
              variableDeclarationList.flags
            )
          );
          changeTracker.insertNodeAfter(sourceFile, variableStatement, newConstDeclaration);
          changeTracker.insertText(sourceFile, variableStatement.end, "\n");
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/refactors/makeSchemaOpaqueWithNs.ts
var makeSchemaOpaqueWithNs = createRefactor({
  name: "makeSchemaOpaqueWithNs",
  description: "Make Schema opaque with namespace",
  apply: fn("makeSchemaOpaqueWithNs.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeNode = yield* _findSchemaVariableDeclaration(sourceFile, textRange);
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const { identifier, types, variableDeclarationList, variableStatement } = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.makeSchemaOpaqueWithNs",
      description: `Make Schema opaque with namespace`,
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectSchemaName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
            sourceFile,
            "effect",
            "Schema"
          ) || "Schema";
          const newIdentifier = ts.factory.createIdentifier(ts.idText(identifier) + "_");
          const { contextType, encodedType, opaqueType } = yield* _createOpaqueTypes(
            effectSchemaName,
            ts.idText(newIdentifier),
            types.A,
            ts.idText(identifier),
            types.I,
            "Encoded",
            "Context"
          );
          const namespace = ts.factory.createModuleDeclaration(
            [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
            ts.factory.createIdentifier(ts.idText(identifier)),
            ts.factory.createModuleBlock([
              encodedType,
              contextType
            ]),
            ts.NodeFlags.Namespace
          );
          changeTracker.replaceNode(
            sourceFile,
            identifier,
            newIdentifier
          );
          changeTracker.insertNodeAfter(sourceFile, variableStatement, opaqueType);
          changeTracker.insertNodeAfter(sourceFile, variableStatement, namespace);
          const namespaceName = ts.isStringLiteral(namespace.name) ? namespace.name.text : ts.idText(namespace.name);
          const newSchemaType = ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectSchemaName),
              ts.factory.createIdentifier("Schema")
            ),
            [
              ts.factory.createTypeReferenceNode(opaqueType.name),
              ts.factory.createTypeReferenceNode(
                ts.factory.createQualifiedName(
                  ts.factory.createIdentifier(
                    namespaceName
                  ),
                  ts.idText(encodedType.name)
                )
              ),
              ts.factory.createTypeReferenceNode(ts.factory.createQualifiedName(
                ts.factory.createIdentifier(namespaceName),
                ts.idText(contextType.name)
              ))
            ]
          );
          const newConstDeclaration = ts.factory.createVariableStatement(
            variableStatement.modifiers,
            ts.factory.createVariableDeclarationList(
              [ts.factory.createVariableDeclaration(
                ts.idText(identifier),
                void 0,
                newSchemaType,
                ts.factory.createIdentifier(ts.idText(newIdentifier))
              )],
              variableDeclarationList.flags
            )
          );
          changeTracker.insertNodeAfter(sourceFile, variableStatement, newConstDeclaration);
          changeTracker.insertText(sourceFile, variableStatement.end, "\n");
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/refactors/pipeableToDatafirst.ts
var pipeableToDatafirst = createRefactor({
  name: "pipeableToDatafirst",
  description: "Rewrite to datafirst",
  apply: fn("pipeableToDatafirst.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const tsUtils = yield* service(TypeScriptUtils);
    function isPipeCall(node2) {
      if (!ts.isCallExpression(node2)) return false;
      const expression = node2.expression;
      if (!ts.isIdentifier(expression)) return false;
      if (ts.idText(expression) !== "pipe") return false;
      return true;
    }
    function asDataFirstExpression(node2, self) {
      if (!ts.isCallExpression(node2)) return none2();
      const signature = typeChecker.getResolvedSignature(node2);
      if (!signature) return none2();
      const callSignatures = typeChecker.getSignaturesOfType(
        typeChecker.getTypeAtLocation(node2.expression),
        ts.SignatureKind.Call
      );
      for (let i = 0; i < callSignatures.length; i++) {
        const callSignature = callSignatures[i];
        if (callSignature.parameters.length === node2.arguments.length + 1) {
          return some2(
            ts.factory.createCallExpression(
              node2.expression,
              [],
              [self].concat(node2.arguments)
            )
          );
        }
      }
      return none2();
    }
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(isPipeCall),
      filter((node2) => tsUtils.isNodeInRange(textRange)(node2.expression)),
      filter(
        (node2) => node2.arguments.length > 0
      ),
      map4((node2) => {
        let newNode2 = node2.arguments[0];
        let didSomething = false;
        for (let i = 1; i < node2.arguments.length; i++) {
          const arg = node2.arguments[i];
          const a = asDataFirstExpression(arg, newNode2);
          if (isSome2(a)) {
            newNode2 = a.value;
            didSomething = true;
          } else {
            if (isPipeCall(newNode2)) {
              newNode2 = ts.factory.createCallExpression(
                ts.factory.createIdentifier("pipe"),
                [],
                newNode2.arguments.concat([arg])
              );
            } else {
              newNode2 = ts.factory.createCallExpression(ts.factory.createIdentifier("pipe"), [], [
                newNode2,
                arg
              ]);
            }
          }
        }
        return didSomething ? some2([node2, newNode2]) : none2();
      }),
      filter(isSome2),
      map4((_) => _.value),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const [node, newNode] = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.pipeableToDatafirst",
      description: "Rewrite to datafirst",
      apply: gen(function* () {
        const changeTracker = yield* service(ChangeTracker);
        changeTracker.replaceNode(sourceFile, node, newNode);
      })
    };
  })
});

// src/refactors/removeUnnecessaryEffectGen.ts
var removeUnnecessaryEffectGen = createRefactor({
  name: "removeUnnecessaryEffectGen",
  description: "Remove unnecessary Effect.gen",
  apply: fn("removeUnnecessaryEffectGen.apply")(function* (sourceFile, textRange) {
    const tsUtils = yield* service(TypeScriptUtils);
    const typeParser = yield* service(TypeParser);
    for (const nodeToReplace of tsUtils.getAncestorNodesInRange(sourceFile, textRange)) {
      const maybeNode = yield* option(typeParser.unnecessaryEffectGen(nodeToReplace));
      if (isNone2(maybeNode)) continue;
      const replacementNode = maybeNode.value.replacementNode;
      return {
        kind: "refactor.rewrite.effect.removeUnnecessaryEffectGen",
        description: "Remove unnecessary Effect.gen",
        apply: gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          changeTracker.replaceNode(sourceFile, nodeToReplace, yield* replacementNode);
        })
      };
    }
    return yield* fail(new RefactorNotApplicableError());
  })
});

// src/refactors/toggleLazyConst.ts
var toggleLazyConst = createRefactor({
  name: "toggleLazyConst",
  description: "Toggle lazy const",
  apply: fn("toggleLazyConst.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(ts.isVariableDeclaration),
      filter((node2) => tsUtils.isNodeInRange(textRange)(node2.name)),
      filter(
        (node2) => !!node2.initializer && !(ts.isArrowFunction(node2.initializer) && ts.isBlock(node2.initializer.body))
      ),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.toggleLazyConst",
      description: "Toggle lazy const",
      apply: gen(function* () {
        const changeTracker = yield* service(ChangeTracker);
        const initializer = node.initializer;
        if (ts.isArrowFunction(initializer) && initializer.parameters.length === 0) {
          changeTracker.deleteRange(sourceFile, {
            pos: initializer.body.end,
            end: initializer.end
          });
          changeTracker.deleteRange(sourceFile, {
            pos: initializer.pos,
            end: initializer.body.pos
          });
          return;
        }
        changeTracker.insertText(sourceFile, initializer.pos, " () =>");
      })
    };
  })
});

// src/refactors/togglePipeStyle.ts
var togglePipeStyle = createRefactor({
  name: "togglePipeStyle",
  description: "Toggle pipe style",
  apply: fn("togglePipeStyle.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const togglePipeStyle2 = (node) => gen(function* () {
      const pipeCall = yield* typeParser.pipeCall(node);
      switch (pipeCall.kind) {
        case "pipe": {
          yield* typeParser.pipeableType(typeChecker.getTypeAtLocation(pipeCall.subject), pipeCall.subject);
          return {
            kind: "refactor.rewrite.effect.togglePipeStyle",
            description: "Rewrite as X.pipe(Y, Z, ...)",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              changeTracker.replaceNode(
                sourceFile,
                node,
                ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    pipeCall.subject,
                    "pipe"
                  ),
                  void 0,
                  pipeCall.args
                )
              );
            })
          };
        }
        case "pipeable":
          return {
            kind: "refactor.rewrite.effect.togglePipeStyle",
            description: "Rewrite as pipe(X, Y, Z, ...)",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              changeTracker.replaceNode(
                sourceFile,
                node,
                ts.factory.createCallExpression(
                  ts.factory.createIdentifier("pipe"),
                  void 0,
                  [pipeCall.subject].concat(pipeCall.args)
                )
              );
            })
          };
      }
    });
    const ancestorNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    return yield* pipe(
      firstSuccessOf(ancestorNodes.map(togglePipeStyle2)),
      orElse2(() => fail(new RefactorNotApplicableError()))
    );
  })
});

// src/refactors/toggleReturnTypeAnnotation.ts
var toggleReturnTypeAnnotation = createRefactor({
  name: "toggleReturnTypeAnnotation",
  description: "Toggle return type annotation",
  apply: fn("toggleReturnTypeAnnotation.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    function addReturnTypeAnnotation(sourceFile2, changeTracker, declaration, typeNode) {
      const closeParen = ts.findChildOfKind(declaration, ts.SyntaxKind.CloseParenToken, sourceFile2);
      const needParens = ts.isArrowFunction(declaration) && closeParen === void 0;
      const endNode = needParens ? declaration.parameters[0] : closeParen;
      if (endNode) {
        if (needParens) {
          changeTracker.insertNodeBefore(
            sourceFile2,
            endNode,
            ts.factory.createToken(ts.SyntaxKind.OpenParenToken)
          );
          changeTracker.insertNodeAfter(
            sourceFile2,
            endNode,
            ts.factory.createToken(ts.SyntaxKind.CloseParenToken)
          );
        }
        changeTracker.insertNodeAt(sourceFile2, endNode.end, typeNode, { prefix: ": " });
      }
    }
    function removeReturnTypeAnnotation(sourceFile2, changeTracker, declaration) {
      const closeParen = ts.findChildOfKind(declaration, ts.SyntaxKind.CloseParenToken, sourceFile2);
      const needParens = ts.isArrowFunction(declaration) && closeParen === void 0;
      const endNode = needParens ? declaration.parameters[0] : closeParen;
      if (endNode && declaration.type) {
        changeTracker.deleteRange(sourceFile2, { pos: endNode.end, end: declaration.type.end });
      }
    }
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter(
        (node2) => ts.isFunctionDeclaration(node2) || ts.isFunctionExpression(node2) || ts.isArrowFunction(node2) || ts.isMethodDeclaration(node2)
      ),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    if (node.type) {
      return {
        kind: "refactor.rewrite.effect.toggleReturnTypeAnnotation",
        description: "Toggle return type annotation",
        apply: pipe(
          service(ChangeTracker),
          map5((changeTracker) => removeReturnTypeAnnotation(sourceFile, changeTracker, node))
        )
      };
    }
    const returnType = typeCheckerUtils.getInferredReturnType(node);
    if (!returnType) return yield* fail(new RefactorNotApplicableError());
    const returnTypeNode = typeCheckerUtils.typeToSimplifiedTypeNode(
      returnType,
      node,
      ts.NodeBuilderFlags.NoTruncation
    );
    if (!returnTypeNode) return yield* fail(new RefactorNotApplicableError());
    return {
      kind: "refactor.rewrite.effect.toggleReturnTypeAnnotation",
      description: "Toggle return type annotation",
      apply: pipe(
        service(ChangeTracker),
        map5((changeTracker) => addReturnTypeAnnotation(sourceFile, changeTracker, node, returnTypeNode))
      )
    };
  })
});

// src/refactors/toggleTypeAnnotation.ts
var toggleTypeAnnotation = createRefactor({
  name: "toggleTypeAnnotation",
  description: "Toggle type annotation",
  apply: fn("toggleTypeAnnotation.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const maybeNode = pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter((node2) => ts.isVariableDeclaration(node2) || ts.isPropertyDeclaration(node2)),
      filter((node2) => tsUtils.isNodeInRange(textRange)(node2.name)),
      filter((node2) => !!node2.initializer),
      head
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.toggleTypeAnnotation",
      description: "Toggle type annotation",
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          if (node.type) {
            changeTracker.deleteRange(sourceFile, { pos: node.name.end, end: node.type.end });
            return;
          }
          const initializer = node.initializer;
          const initializerType = typeChecker.getTypeAtLocation(initializer);
          const initializerTypeNode = fromNullable(typeCheckerUtils.typeToSimplifiedTypeNode(
            initializerType,
            node,
            ts.NodeBuilderFlags.NoTruncation
          )).pipe(
            orElse(
              () => fromNullable(typeCheckerUtils.typeToSimplifiedTypeNode(
                initializerType,
                void 0,
                ts.NodeBuilderFlags.NoTruncation
              ))
            ),
            getOrUndefined
          );
          if (initializerTypeNode) {
            changeTracker.insertNodeAt(
              sourceFile,
              node.name.end,
              initializerTypeNode,
              {
                prefix: ": "
              }
            );
          }
        }),
        provideService(TypeScriptApi, ts)
      )
    };
  })
});

// src/utils/SchemaGen.ts
var TypeParametersNotSupportedError = class {
  constructor(node) {
    this.node = node;
  }
  _tag = "@effect/language-service/TypeParametersNotSupportedError";
  toString() {
    return `Could not process types with type parameters.`;
  }
};
var OnlyLiteralPropertiesSupportedError = class {
  constructor(node) {
    this.node = node;
  }
  _tag = "@effect/language-service/OnlyLiteralPropertiesSupportedError";
  toString() {
    return `Could not process ${this.node.getText()} as only literal properties are supported.`;
  }
};
var RequiredExplicitTypesError = class {
  constructor(node) {
    this.node = node;
  }
  _tag = "@effect/language-service/RequiredExplicitTypesError";
  toString() {
    return `Could not process ${this.node.getText()} as only explicit types are supported.`;
  }
};
var IndexSignatureWithMoreThanOneParameterError = class {
  constructor(node) {
    this.node = node;
  }
  _tag = "@effect/language-service/IndexSignatureWithMoreThanOneParameterError";
  toString() {
    return `Could not process ${this.node.getText()} as only index signatures with one parameter are supported.`;
  }
};
var SchemaGenContext = Tag("SchemaGenContext");
var makeSchemaGenContext = fn("SchemaGen.makeSchemaGenContext")(function* (sourceFile) {
  const tsUtils = yield* service(TypeScriptUtils);
  const effectSchemaIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
    sourceFile,
    "effect",
    "Schema"
  ) || "Schema";
  const moduleToImportedName = {};
  for (const moduleName of ["Option", "Either", "Chunk", "Duration"]) {
    const importedName = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, "effect", moduleName);
    if (importedName) moduleToImportedName[moduleName] = importedName;
  }
  const ts = yield* service(TypeScriptApi);
  return {
    sourceFile,
    createApiPropertyAccess: (apiName) => ts.factory.createPropertyAccessExpression(
      ts.factory.createIdentifier(effectSchemaIdentifier),
      apiName
    ),
    createApiCall: (apiName, args2) => ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectSchemaIdentifier),
        apiName
      ),
      [],
      args2
    ),
    entityNameToDataTypeName: (name) => {
      if (ts.isIdentifier(name)) {
        switch (ts.idText(name)) {
          case "Date":
          case "Pick":
          case "Omit":
          case "Record":
            return some2(ts.idText(name));
          case "ReadonlyArray":
          case "Array":
            return some2("Array");
        }
        return none2();
      }
      if (!ts.isIdentifier(name.left)) return none2();
      for (const moduleName in moduleToImportedName) {
        if (ts.idText(name.left) === moduleToImportedName[moduleName] && ts.idText(name.right) === moduleName) {
          return some2(moduleName);
        }
      }
      return none2();
    },
    ts
  };
});
var typeEntityNameToNode = fn(
  "SchemaGen.typeEntityNameToNode"
)(
  function* (entityName) {
    const { ts } = yield* service(SchemaGenContext);
    if (ts.isIdentifier(entityName)) return ts.factory.createIdentifier(ts.idText(entityName));
    const left3 = yield* typeEntityNameToNode(entityName.left);
    return ts.factory.createPropertyAccessExpression(
      left3,
      ts.factory.createIdentifier(ts.idText(entityName.right))
    );
  }
);
var parseAllLiterals = fn(
  "SchemaGen.parseAllLiterals"
)(
  function* (node) {
    const { ts } = yield* service(SchemaGenContext);
    if (ts.isLiteralTypeNode(node)) {
      switch (node.literal.kind) {
        case ts.SyntaxKind.StringLiteral:
          return [ts.factory.createStringLiteral(node.literal.text)];
        case ts.SyntaxKind.NumericLiteral:
          return [ts.factory.createNumericLiteral(node.literal.text)];
        case ts.SyntaxKind.TrueKeyword:
          return [ts.factory.createTrue()];
        case ts.SyntaxKind.FalseKeyword:
          return [ts.factory.createFalse()];
      }
    }
    if (ts.isUnionTypeNode(node)) {
      return flatten(yield* all(...node.types.map((_) => parseAllLiterals(_))));
    }
    if (ts.isParenthesizedTypeNode(node)) {
      return yield* parseAllLiterals(node.type);
    }
    return yield* fail(node);
  }
);
var createUnsupportedNodeComment = (ts, sourceFile, node) => ts.addSyntheticTrailingComment(
  ts.factory.createIdentifier(""),
  ts.SyntaxKind.MultiLineCommentTrivia,
  " Not supported conversion: " + node.getText(sourceFile) + " "
);
var processNode = (node, isVirtualTypeNode) => gen(function* () {
  const { createApiCall, createApiPropertyAccess, entityNameToDataTypeName, sourceFile, ts } = yield* service(
    SchemaGenContext
  );
  switch (node.kind) {
    case ts.SyntaxKind.AnyKeyword:
      return createApiPropertyAccess("Any");
    case ts.SyntaxKind.NeverKeyword:
      return createApiPropertyAccess("Never");
    case ts.SyntaxKind.UnknownKeyword:
      return createApiPropertyAccess("Unknown");
    case ts.SyntaxKind.VoidKeyword:
      return createApiPropertyAccess("Void");
    case ts.SyntaxKind.NullKeyword:
      return createApiPropertyAccess("Null");
    case ts.SyntaxKind.UndefinedKeyword:
      return createApiPropertyAccess("Undefined");
    case ts.SyntaxKind.StringKeyword:
      return createApiPropertyAccess("String");
    case ts.SyntaxKind.NumberKeyword:
      return createApiPropertyAccess("Number");
    case ts.SyntaxKind.BooleanKeyword:
      return createApiPropertyAccess("Boolean");
    case ts.SyntaxKind.BigIntKeyword:
      return createApiPropertyAccess("BigInt");
  }
  if (ts.isLiteralTypeNode(node)) {
    if (node.literal.kind === ts.SyntaxKind.NullKeyword) return createApiPropertyAccess("Null");
    const literalMembers = yield* option(parseAllLiterals(node));
    if (isSome2(literalMembers)) return createApiCall("Literal", literalMembers.value);
  }
  if (ts.isUnionTypeNode(node)) {
    const allLiterals = yield* option(parseAllLiterals(node));
    if (isSome2(allLiterals)) return createApiCall("Literal", allLiterals.value);
    const members = yield* all(...node.types.map((_) => processNode(_, isVirtualTypeNode)));
    return createApiCall("Union", members);
  }
  if (ts.isIntersectionTypeNode(node)) {
    const [firstSchema, ...otherSchemas] = yield* all(
      ...node.types.map((_) => processNode(_, isVirtualTypeNode))
    );
    if (otherSchemas.length === 0) return firstSchema;
    return ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        firstSchema,
        "pipe"
      ),
      [],
      otherSchemas.map((_) => createApiCall("extend", [_]))
    );
  }
  if (ts.isTypeOperatorNode(node)) {
    if (node.operator === ts.SyntaxKind.KeyOfKeyword) {
      return createApiCall("keyof", [yield* processNode(node.type, isVirtualTypeNode)]);
    } else if (node.operator === ts.SyntaxKind.ReadonlyKeyword) {
      return yield* processNode(node.type, isVirtualTypeNode);
    }
  }
  if (ts.isArrayTypeNode(node)) {
    const typeSchema = yield* processNode(node.elementType, isVirtualTypeNode);
    return createApiCall("Array", [typeSchema]);
  }
  if (ts.isTypeLiteralNode(node)) {
    const { properties, records } = yield* processMembers(node.members, isVirtualTypeNode);
    return createApiCall(
      "Struct",
      [ts.factory.createObjectLiteralExpression(properties, true)].concat(records)
    );
  }
  if (ts.isParenthesizedTypeNode(node)) {
    return yield* processNode(node.type, isVirtualTypeNode);
  }
  if (ts.isTypeQueryNode(node)) {
    const typeChecker = yield* service(TypeCheckerApi);
    const type = typeChecker.getTypeAtLocation(node.exprName);
    const typeNode = typeChecker.typeToTypeNode(type, void 0, ts.NodeBuilderFlags.NoTruncation);
    if (typeNode) return yield* processNode(typeNode, true);
  }
  if (!isVirtualTypeNode && ts.isIndexedAccessTypeNode(node) && ts.isParenthesizedTypeNode(node.objectType) && ts.isTypeQueryNode(node.objectType.type) && ts.isTypeOperatorNode(node.indexType) && node.indexType.operator === ts.SyntaxKind.KeyOfKeyword && ts.isTypeQueryNode(node.indexType.type) && node.indexType.type.exprName.getText().trim() === node.objectType.type.exprName.getText().trim()) {
    const typeChecker = yield* service(TypeCheckerApi);
    const type = typeChecker.getTypeAtLocation(node);
    const typeNode = typeChecker.typeToTypeNode(type, void 0, ts.NodeBuilderFlags.NoTruncation);
    if (typeNode) return yield* processNode(typeNode, true);
  }
  if (ts.isTypeReferenceNode(node)) {
    const parsedName = entityNameToDataTypeName(node.typeName);
    if (isSome2(parsedName)) {
      switch (parsedName.value) {
        case "Duration":
        case "Date":
          return createApiPropertyAccess(parsedName.value);
        case "Option":
        case "Chunk":
        case "Array": {
          const elements = yield* all(
            ...node.typeArguments ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode)) : []
          );
          return createApiCall(parsedName.value, elements);
        }
        case "Record": {
          const elements = yield* all(
            ...node.typeArguments ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode)) : []
          );
          if (elements.length >= 2) {
            return createApiCall(parsedName.value, [
              ts.factory.createObjectLiteralExpression([
                ts.factory.createPropertyAssignment("key", elements[0]),
                ts.factory.createPropertyAssignment("value", elements[1])
              ])
            ]);
          }
          return createUnsupportedNodeComment(ts, sourceFile, node);
        }
        case "Either": {
          const elements = yield* all(
            ...node.typeArguments ? node.typeArguments.map((_) => processNode(_, isVirtualTypeNode)) : []
          );
          if (elements.length >= 2) {
            return createApiCall(parsedName.value, [
              ts.factory.createObjectLiteralExpression([
                ts.factory.createPropertyAssignment("right", elements[0]),
                ts.factory.createPropertyAssignment("left", elements[1])
              ])
            ]);
          }
          return createUnsupportedNodeComment(ts, sourceFile, node);
        }
        case "Pick":
        case "Omit": {
          const typeArguments = fromIterable(node.typeArguments || []);
          if (typeArguments.length !== 2) {
            return createUnsupportedNodeComment(ts, sourceFile, node);
          }
          const baseType = yield* processNode(typeArguments[0], isVirtualTypeNode);
          const stringLiteralArguments = yield* option(parseAllLiterals(typeArguments[1]));
          if (isNone2(stringLiteralArguments)) {
            return createUnsupportedNodeComment(ts, sourceFile, node);
          }
          return ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              baseType,
              "pipe"
            ),
            [],
            [createApiCall(parsedName.value.toLowerCase(), stringLiteralArguments.value)]
          );
        }
      }
    }
  }
  if (ts.isTypeReferenceNode(node)) {
    if (!(node.typeArguments && node.typeArguments.length > 0)) {
      return yield* typeEntityNameToNode(node.typeName);
    }
  }
  return createUnsupportedNodeComment(ts, sourceFile, node);
});
var processMembers = fn(
  "SchemaGen.processMembers"
)(
  function* (members, isVirtualTypeNode) {
    const { createApiCall, ts } = yield* service(
      SchemaGenContext
    );
    const properties = [];
    for (const propertySignature of members.filter(ts.isPropertySignature)) {
      const name = propertySignature.name;
      if (!(ts.isIdentifier(name) || ts.isStringLiteral(name))) {
        return yield* fail(new OnlyLiteralPropertiesSupportedError(propertySignature));
      }
      if (!propertySignature.type) {
        return yield* fail(new RequiredExplicitTypesError(propertySignature));
      }
      const propertyAssignment = pipe(
        yield* processNode(propertySignature.type, isVirtualTypeNode),
        propertySignature.questionToken ? (_) => createApiCall("optional", [_]) : identity,
        (_) => ts.factory.createPropertyAssignment(name, _)
      );
      properties.push(propertyAssignment);
    }
    const records = [];
    for (const indexSignature of members.filter(ts.isIndexSignatureDeclaration)) {
      if (indexSignature.parameters.length !== 1) {
        return yield* fail(new IndexSignatureWithMoreThanOneParameterError(indexSignature));
      }
      const parameter = indexSignature.parameters[0];
      if (!parameter.type) return yield* fail(new RequiredExplicitTypesError(parameter));
      const parameterType = parameter.type;
      const key = yield* processNode(parameterType, isVirtualTypeNode);
      const value = yield* processNode(indexSignature.type, isVirtualTypeNode);
      records.push(
        ts.factory.createObjectLiteralExpression([
          ts.factory.createPropertyAssignment("key", key),
          ts.factory.createPropertyAssignment("value", value)
        ])
      );
    }
    return { properties, records };
  }
);
var processInterfaceDeclaration = fn("SchemaGen.processInterfaceDeclaration")(
  function* (node, preferClass) {
    if (node.typeParameters && node.typeParameters.length > 0) {
      return yield* fail(new TypeParametersNotSupportedError(node));
    }
    const { createApiCall, ts } = yield* service(
      SchemaGenContext
    );
    const { properties, records } = yield* processMembers(node.members, false);
    if (preferClass && records.length === 0) {
      return yield* createExportSchemaClassDeclaration(ts.idText(node.name), properties);
    }
    const schemaStruct = createApiCall(
      "Struct",
      [ts.factory.createObjectLiteralExpression(properties, true)].concat(records)
    );
    return yield* createExportVariableDeclaration(ts.idText(node.name), schemaStruct);
  }
);
var processTypeAliasDeclaration = fn("SchemaGen.processInterfaceDeclaration")(
  function* (node, preferClass) {
    const { ts } = yield* service(SchemaGenContext);
    if (node.typeParameters && node.typeParameters.length > 0) {
      return yield* fail(new TypeParametersNotSupportedError(node));
    }
    if (preferClass && ts.isTypeLiteralNode(node.type)) {
      const { properties, records } = yield* processMembers(node.type.members, false);
      if (records.length === 0) {
        return yield* createExportSchemaClassDeclaration(ts.idText(node.name), properties);
      }
    }
    const effectSchema = yield* processNode(node.type, false);
    return yield* createExportVariableDeclaration(ts.idText(node.name), effectSchema);
  }
);
var createExportVariableDeclaration = fn("SchemaGen.createExportVariableDeclaration")(
  function* (name, initializer) {
    const ts = yield* service(TypeScriptApi);
    return ts.factory.createVariableStatement(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      ts.factory.createVariableDeclarationList([
        ts.factory.createVariableDeclaration(
          ts.factory.createIdentifier(name),
          void 0,
          void 0,
          initializer
        )
      ], ts.NodeFlags.Const)
    );
  }
);
var createExportSchemaClassDeclaration = fn("SchemaGen.createExportSchemaClassDeclaration")(
  function* (name, members) {
    const { createApiPropertyAccess } = yield* service(SchemaGenContext);
    const ts = yield* service(TypeScriptApi);
    return ts.factory.createClassDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      ts.factory.createIdentifier(name),
      [],
      [ts.factory.createHeritageClause(
        ts.SyntaxKind.ExtendsKeyword,
        [
          ts.factory.createExpressionWithTypeArguments(
            ts.factory.createCallExpression(
              ts.factory.createCallExpression(
                createApiPropertyAccess("Class"),
                [ts.factory.createTypeReferenceNode(
                  name
                )],
                [ts.factory.createStringLiteral(name)]
              ),
              [],
              [ts.factory.createObjectLiteralExpression(
                members,
                true
              )]
            ),
            []
          )
        ]
      )],
      []
    );
  }
);
var process = fn("SchemaGen.process")(
  function* (sourceFile, node, preferClass) {
    const ctx = yield* makeSchemaGenContext(sourceFile);
    const ts = yield* service(TypeScriptApi);
    return yield* pipe(
      ts.isInterfaceDeclaration(node) ? processInterfaceDeclaration(node, preferClass) : processTypeAliasDeclaration(node, preferClass),
      provideService(SchemaGenContext, ctx)
    );
  }
);
var findNodeToProcess = fn("SchemaGen.findNodeToProcess")(
  function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    return pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      filter((node) => ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)),
      filter((node) => tsUtils.isNodeInRange(textRange)(node.name)),
      filter((node) => (node.typeParameters || []).length === 0),
      head
    );
  }
);
var applyAtNode = fn("SchemaGen.applyAtNode")(
  function* (sourceFile, node, preferClass) {
    const ts = yield* service(TypeScriptApi);
    const changeTracker = yield* service(ChangeTracker);
    const newNode = yield* pipe(
      process(sourceFile, node, preferClass),
      orElse2(
        (error) => succeed(ts.addSyntheticLeadingComment(
          ts.factory.createIdentifier(""),
          ts.SyntaxKind.MultiLineCommentTrivia,
          " " + String(error) + " ",
          true
        ))
      )
    );
    changeTracker.insertNodeBefore(sourceFile, node, newNode, true, {
      leadingTriviaOption: ts.textChanges.LeadingTriviaOption.StartLine
    });
  }
);

// src/refactors/typeToEffectSchema.ts
var typeToEffectSchema = createRefactor({
  name: "typeToEffectSchema",
  description: "Refactor to Schema",
  apply: fn("typeToEffectSchema.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const maybeNode = yield* findNodeToProcess(sourceFile, textRange);
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.typeToEffectSchema",
      description: "Refactor to Schema",
      apply: pipe(
        applyAtNode(sourceFile, node, false),
        provideService(TypeCheckerApi, typeChecker),
        provideService(TypeScriptUtils, tsUtils),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerUtils, typeCheckerUtils)
      )
    };
  })
});

// src/refactors/typeToEffectSchemaClass.ts
var typeToEffectSchemaClass = createRefactor({
  name: "typeToEffectSchemaClass",
  description: "Refactor to Schema.Class",
  apply: fn("typeToEffectSchemaClass.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const maybeNode = yield* findNodeToProcess(sourceFile, textRange);
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const node = maybeNode.value;
    return {
      kind: "refactor.rewrite.effect.typeToEffectSchemaClass",
      description: "Refactor to Schema.Class",
      apply: pipe(
        applyAtNode(sourceFile, node, true),
        provideService(TypeCheckerApi, typeChecker),
        provideService(TypeScriptUtils, tsUtils),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerUtils, typeCheckerUtils)
      )
    };
  })
});

// src/refactors/wrapWithEffectGen.ts
var wrapWithEffectGen = createRefactor({
  name: "wrapWithEffectGen",
  description: "Wrap with Effect.gen",
  apply: fn("wrapWithEffectGen.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const findEffectToWrap = fn("wrapWithEffectGen.apply.findEffectToWrap")(
      function* (node) {
        if (!ts.isExpression(node)) return yield* fail("is not an expression");
        if (node.parent && ts.isHeritageClause(node.parent)) return yield* fail("is in a heritage clause");
        const parent = node.parent;
        if (parent != null && ts.isVariableDeclaration(parent) && parent.initializer !== node) return yield* fail("is LHS of variable declaration");
        const type = typeChecker.getTypeAtLocation(node);
        yield* typeParser.strictEffectType(type, node);
        return node;
      }
    );
    const maybeNode = yield* pipe(
      tsUtils.getAncestorNodesInRange(sourceFile, textRange),
      map4(findEffectToWrap),
      firstSuccessOf,
      option
    );
    if (isNone2(maybeNode)) return yield* fail(new RefactorNotApplicableError());
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    return {
      kind: "refactor.rewrite.effect.wrapWithEffectGen",
      description: `Wrap with Effect.gen`,
      apply: pipe(
        gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          const effectGen = tsUtils.createEffectGenCallExpressionWithBlock(
            effectModuleIdentifier,
            tsUtils.createReturnYieldStarStatement(maybeNode.value)
          );
          changeTracker.replaceNode(sourceFile, maybeNode.value, effectGen);
        }),
        provideService(TypeScriptApi, ts),
        provideService(TypeCheckerApi, typeChecker)
      )
    };
  })
});

// src/refactors/wrapWithPipe.ts
var wrapWithPipe = createRefactor({
  name: "wrapWithPipe",
  description: "Wrap with pipe",
  apply: fn("wrapWithPipe.apply")(function* (sourceFile, textRange) {
    if (textRange.end - textRange.pos === 0) {
      return yield* fail(new RefactorNotApplicableError());
    }
    return {
      kind: "refactor.rewrite.effect.wrapWithPipe",
      description: `Wrap with pipe(...)`,
      apply: gen(function* () {
        const changeTracker = yield* service(ChangeTracker);
        changeTracker.insertText(sourceFile, textRange.pos, "pipe(");
        changeTracker.insertText(sourceFile, textRange.end, ")");
      })
    };
  })
});

// src/refactors.ts
var refactors = [
  layerMagic,
  asyncAwaitToGen,
  asyncAwaitToGenTryPromise,
  asyncAwaitToFn,
  asyncAwaitToFnTryPromise,
  functionToArrow,
  typeToEffectSchema,
  typeToEffectSchemaClass,
  makeSchemaOpaque,
  makeSchemaOpaqueWithNs,
  pipeableToDatafirst,
  removeUnnecessaryEffectGen,
  toggleLazyConst,
  toggleReturnTypeAnnotation,
  toggleTypeAnnotation,
  wrapWithEffectGen,
  wrapWithPipe,
  effectGenToFn,
  togglePipeStyle,
  writeTagClassAccessors
];

// src/renames/keyStrings.ts
var renameKeyStrings = (sourceFile, position, _findInStrings, _findInComments, _preferences, renameLocations) => gen(function* () {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeParser = yield* service(TypeParser);
  const additionalPositions = [];
  const node = tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, position);
  if (node && ts.isIdentifier(node)) {
    const textToReplace = ts.idText(node);
    const parentClass = node.parent;
    if (ts.isClassDeclaration(parentClass) && parentClass.name === node) {
      const baseIdentifier = yield* pipe(
        map5(typeParser.extendsContextTag(parentClass), (_) => [_.keyStringLiteral]),
        orElse2(() => map5(typeParser.extendsEffectService(parentClass), (_) => [_.keyStringLiteral])),
        orElse2(() => map5(typeParser.extendsEffectTag(parentClass), (_) => [_.keyStringLiteral])),
        orElse2(
          () => map5(typeParser.extendsSchemaTaggedClass(parentClass), (_) => [_.keyStringLiteral, _.tagStringLiteral])
        ),
        orElse2(
          () => map5(typeParser.extendsSchemaTaggedError(parentClass), (_) => [_.keyStringLiteral, _.tagStringLiteral])
        ),
        orElse2(() => map5(typeParser.extendsDataTaggedError(parentClass), (_) => [_.keyStringLiteral])),
        orElse2(() => map5(typeParser.extendsDataTaggedClass(parentClass), (_) => [_.keyStringLiteral])),
        orElse2(
          () => map5(
            typeParser.extendsSchemaTaggedRequest(parentClass),
            (_) => [_.keyStringLiteral, _.tagStringLiteral]
          )
        ),
        option
      );
      if (isSome2(baseIdentifier)) {
        for (const keyStringLiteral of baseIdentifier.value) {
          if (!keyStringLiteral) continue;
          const baseText = sourceFile.text.slice(keyStringLiteral.pos, keyStringLiteral.end);
          const lastIndex = baseText.lastIndexOf(textToReplace);
          if (lastIndex !== -1) {
            additionalPositions.push({
              fileName: sourceFile.fileName,
              textSpan: {
                start: keyStringLiteral.pos + lastIndex,
                length: textToReplace.length
              }
            });
          }
        }
      }
    }
  }
  return additionalPositions.length === 0 ? renameLocations : additionalPositions.concat(renameLocations || []);
});

// src/index.ts
var LSP_INJECTED_URI = "@effect/language-service/injected";
var init = (modules) => {
  const diagnosticsErrorCodes = diagnostics.map((diagnostic) => diagnostic.code);
  try {
    ;
    modules.typescript.codefix.registerCodeFix({
      errorCodes: diagnosticsErrorCodes,
      getCodeActions: () => void 0
    });
  } catch (_) {
  }
  let languageServicePluginOptions = parse({});
  function onConfigurationChanged(config) {
    languageServicePluginOptions = parse(config);
  }
  function create(info) {
    const languageService = info.languageService;
    languageServicePluginOptions = parse(info.config);
    if (languageService[LSP_INJECTED_URI]) return languageService;
    info.project.log("[@effect/language-service] Started!");
    const proxy = /* @__PURE__ */ Object.create(null);
    proxy[LSP_INJECTED_URI] = true;
    for (const k of Object.keys(languageService)) {
      proxy[k] = (...args2) => languageService[k].apply(languageService, args2);
    }
    function runNano(program) {
      return (fa) => pipe(
        fa,
        nanoLayer3,
        nanoLayer2,
        nanoLayer,
        provideService(TypeCheckerApi, program.getTypeChecker()),
        provideService(TypeScriptProgram, program),
        provideService(TypeScriptApi, modules.typescript),
        provideService(
          LanguageServicePluginOptions,
          languageServicePluginOptions
        ),
        run
      );
    }
    const effectCodeFixesForFile = /* @__PURE__ */ new Map();
    const runDiagnosticsAndCacheCodeFixes = (fileName) => {
      const program = languageService.getProgram();
      while (effectCodeFixesForFile.size > 5) {
        const oldest = effectCodeFixesForFile.keys().next().value;
        if (oldest) effectCodeFixesForFile.delete(oldest);
      }
      if (languageServicePluginOptions.diagnostics && program) {
        effectCodeFixesForFile.delete(fileName);
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
          return pipe(
            getSemanticDiagnosticsWithCodeFixes(diagnostics, sourceFile),
            runNano(program),
            map(({ codeFixes, diagnostics: diagnostics2 }) => {
              effectCodeFixesForFile.set(fileName, codeFixes);
              return diagnostics2;
            }),
            getOrElse(() => [])
          );
        }
      }
      return [];
    };
    proxy.getSemanticDiagnostics = (fileName, ...args2) => {
      const applicableDiagnostics = languageService.getSemanticDiagnostics(fileName, ...args2);
      return concatDiagnostics(runDiagnosticsAndCacheCodeFixes(fileName), applicableDiagnostics);
    };
    proxy.getSupportedCodeFixes = (...args2) => languageService.getSupportedCodeFixes(...args2).concat(
      diagnosticsErrorCodes.map((_) => "" + _)
    );
    proxy.getCodeFixesAtPosition = (fileName, start, end, errorCodes, formatOptions, preferences, ...args2) => {
      const applicableCodeFixes = languageService.getCodeFixesAtPosition(
        fileName,
        start,
        end,
        errorCodes,
        formatOptions,
        preferences,
        ...args2
      );
      const program = languageService.getProgram();
      if (languageServicePluginOptions.diagnostics && program) {
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
          return pipe(
            sync(() => {
              const effectCodeFixes = [];
              if (!effectCodeFixesForFile.has(fileName)) {
                runDiagnosticsAndCacheCodeFixes(fileName);
              }
              const applicableFixes = (effectCodeFixesForFile.get(fileName) || []).filter(
                (_) => _.start === start && _.end === end && errorCodes.indexOf(_.code) > -1
              );
              const formatContext = modules.typescript.formatting.getFormatContext(
                formatOptions,
                info.languageServiceHost
              );
              for (const applicableFix of applicableFixes) {
                const changes = modules.typescript.textChanges.ChangeTracker.with(
                  {
                    formatContext,
                    host: info.languageServiceHost,
                    preferences: preferences || {}
                  },
                  (changeTracker) => pipe(
                    applicableFix.apply,
                    provideService(ChangeTracker, changeTracker),
                    run
                  )
                );
                effectCodeFixes.push({
                  fixName: applicableFix.fixName,
                  description: applicableFix.description,
                  changes
                });
              }
              return effectCodeFixes;
            }),
            flatMap2(
              (effectCodeFixes) => pipe(
                middlewareAutoImportQuickfixes(
                  sourceFile,
                  info.languageServiceHost,
                  formatOptions,
                  preferences,
                  applicableCodeFixes
                ),
                map5((modifiedCodeFixes) => effectCodeFixes.concat(modifiedCodeFixes))
              )
            ),
            runNano(program),
            getOrElse(() => applicableCodeFixes)
          );
        }
      }
      return applicableCodeFixes;
    };
    proxy.getApplicableRefactors = (...args2) => {
      const applicableRefactors = languageService.getApplicableRefactors(...args2);
      const [fileName, positionOrRange] = args2;
      const program = languageService.getProgram();
      if (program) {
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
          return pipe(
            getApplicableRefactors(refactors, sourceFile, positionOrRange),
            runNano(program),
            map((effectRefactors) => applicableRefactors.concat(effectRefactors)),
            getOrElse(() => applicableRefactors)
          );
        }
      }
      return applicableRefactors;
    };
    proxy.getEditsForRefactor = (fileName, formatOptions, positionOrRange, refactorName, actionName, preferences, ...args2) => {
      const program = languageService.getProgram();
      if (program) {
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
          const result = pipe(
            gen(function* () {
              const applicableRefactor = yield* getEditsForRefactor(
                refactors,
                sourceFile,
                positionOrRange,
                refactorName
              );
              const formatContext = modules.typescript.formatting.getFormatContext(
                formatOptions,
                info.languageServiceHost
              );
              const edits = modules.typescript.textChanges.ChangeTracker.with(
                {
                  formatContext,
                  host: info.languageServiceHost,
                  preferences: preferences || {}
                },
                (changeTracker) => pipe(
                  applicableRefactor.apply,
                  provideService(ChangeTracker, changeTracker),
                  run
                )
              );
              return { edits };
            }),
            runNano(program)
          );
          if (isRight2(result)) return result.right;
        }
      }
      return languageService.getEditsForRefactor(
        fileName,
        formatOptions,
        positionOrRange,
        refactorName,
        actionName,
        preferences,
        ...args2
      );
    };
    proxy.getQuickInfoAtPosition = (fileName, position, ...args2) => {
      const applicableQuickInfo = languageService.getQuickInfoAtPosition(fileName, position, ...args2);
      if (languageServicePluginOptions.quickinfo) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              quickInfo(
                sourceFile,
                position,
                applicableQuickInfo
              ),
              runNano(program),
              getOrElse(() => applicableQuickInfo)
            );
          }
        }
      }
      return applicableQuickInfo;
    };
    proxy.getCompletionsAtPosition = (fileName, position, options, formattingSettings, ...args2) => {
      const applicableCompletions = languageService.getCompletionsAtPosition(
        fileName,
        position,
        options,
        formattingSettings,
        ...args2
      );
      if (languageServicePluginOptions.completions) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              appendEffectCompletionEntryData(sourceFile, applicableCompletions),
              flatMap2(
                (augmentedCompletions) => pipe(
                  getCompletionsAtPosition(
                    completions,
                    sourceFile,
                    position,
                    options,
                    formattingSettings
                  ),
                  map5(
                    (effectCompletions) => augmentedCompletions ? {
                      ...augmentedCompletions,
                      entries: effectCompletions.concat(augmentedCompletions.entries)
                    } : effectCompletions.length > 0 ? {
                      entries: effectCompletions,
                      isGlobalCompletion: false,
                      isMemberCompletion: false,
                      isNewIdentifierLocation: false
                    } : void 0
                  )
                )
              ),
              runNano(program),
              getOrElse(() => applicableCompletions)
            );
          }
        }
      }
      return applicableCompletions;
    };
    proxy.getCompletionEntryDetails = (fileName, position, entryName, formatOptions, source, preferences, _data, ...args2) => {
      const applicableCompletionEntryDetails = languageService.getCompletionEntryDetails(
        fileName,
        position,
        entryName,
        formatOptions,
        source,
        preferences,
        _data,
        ...args2
      );
      if (languageServicePluginOptions.completions) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              postprocessCompletionEntryDetails(
                sourceFile,
                _data,
                applicableCompletionEntryDetails,
                formatOptions,
                preferences,
                info.languageServiceHost
              ),
              runNano(program),
              getOrElse(() => applicableCompletionEntryDetails)
            );
          }
        }
      }
      return applicableCompletionEntryDetails;
    };
    proxy.getDefinitionAndBoundSpan = (fileName, position, ...args2) => {
      const applicableDefinition = languageService.getDefinitionAndBoundSpan(fileName, position, ...args2);
      if (languageServicePluginOptions.goto) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              goto(applicableDefinition, sourceFile, position),
              runNano(program),
              getOrElse(() => applicableDefinition)
            );
          }
        }
      }
      return applicableDefinition;
    };
    proxy.provideInlayHints = (fileName, span, preferences, ...args2) => {
      const applicableInlayHints = languageService.provideInlayHints(fileName, span, preferences, ...args2);
      if (languageServicePluginOptions.inlays) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              middlewareGenLike(sourceFile, span, preferences, applicableInlayHints),
              runNano(program),
              getOrElse(() => applicableInlayHints)
            );
          }
        }
      }
      return applicableInlayHints;
    };
    proxy.findRenameLocations = (fileName, position, findInStrings, findInComments, userPreferences, ...args2) => {
      const applicableRenameInfo = languageService.findRenameLocations(
        fileName,
        position,
        findInStrings,
        findInComments,
        userPreferences,
        ...args2
      );
      if (languageServicePluginOptions.renames) {
        const program = languageService.getProgram();
        if (program) {
          const sourceFile = program.getSourceFile(fileName);
          if (sourceFile) {
            return pipe(
              renameKeyStrings(
                sourceFile,
                position,
                findInStrings,
                findInComments,
                userPreferences,
                applicableRenameInfo
              ),
              runNano(program),
              getOrElse(() => applicableRenameInfo)
            );
          }
        }
      }
      return applicableRenameInfo;
    };
    const additionalProtocolHandlers = {
      "_effectGetLayerMermaid": (arg) => {
        const { character, line, path } = arg.arguments;
        const normalizedPath = modules.typescript.server.toNormalizedPath(path);
        const projectService = info.project.projectService;
        const scriptInfo = projectService.getScriptInfoForNormalizedPath(normalizedPath);
        if (scriptInfo) {
          const targetProject = scriptInfo.getDefaultProject();
          if (targetProject) {
            const program = targetProject.getLanguageService().getProgram();
            if (program) {
              const sourceFile = targetProject.getSourceFile(scriptInfo.path);
              if (sourceFile) {
                return pipe(
                  effectApiGetLayerGraph(sourceFile, line, character),
                  map5((response) => ({
                    response: {
                      success: true,
                      ...response
                    }
                  })),
                  runNano(program),
                  getOrElse((e) => ({
                    response: {
                      success: false,
                      error: e.message
                    }
                  }))
                );
              }
            }
          }
        }
        return {
          response: {
            success: false,
            error: "No source file found"
          }
        };
      }
    };
    if (info.session) {
      for (const [key, value] of Object.entries(additionalProtocolHandlers)) {
        try {
          info.session.addProtocolHandler(key, value);
        } catch (e) {
          info.project.log("[@effect/language-service] Skipped adding " + key + " protocol handler due to error: " + e);
        }
      }
    }
    return proxy;
  }
  return { create, onConfigurationChanged };
};
module.exports = init;
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
//# sourceMappingURL=index.js.map