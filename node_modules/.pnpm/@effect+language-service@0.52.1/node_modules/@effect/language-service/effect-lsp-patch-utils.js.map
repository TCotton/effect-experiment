{"version":3,"sources":["../src/effect-lsp-patch-utils.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Function.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/GlobalValue.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Predicate.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Utils.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Hash.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Equal.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Inspectable.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Pipeable.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/opCodes/effect.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/version.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/effectable.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/option.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/either.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Either.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/internal/array.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Order.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Option.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Record.ts","../node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/src/Array.ts","../src/core/Nano.ts","../src/core/LanguageServicePluginOptions.ts","../src/core/TypeScriptApi.ts","../src/core/TypeScriptUtils.ts","../src/core/LSP.ts","../src/core/TypeCheckerApi.ts","../src/core/TypeCheckerUtils.ts","../src/core/TypeParser.ts","../src/diagnostics/catchUnfailableEffect.ts","../src/diagnostics/classSelfMismatch.ts","../src/core/KeyBuilder.ts","../src/diagnostics/deterministicKeys.ts","../src/diagnostics/duplicatePackage.ts","../src/diagnostics/effectGenUsesAdapter.ts","../src/diagnostics/effectInVoidSuccess.ts","../src/diagnostics/floatingEffect.ts","../src/diagnostics/genericEffectServices.ts","../src/diagnostics/importFromBarrel.ts","../src/diagnostics/leakingRequirements.ts","../src/diagnostics/missedPipeableOpportunity.ts","../src/diagnostics/missingEffectContext.ts","../src/diagnostics/missingEffectError.ts","../src/diagnostics/missingEffectServiceDependency.ts","../src/diagnostics/missingReturnYieldStar.ts","../src/diagnostics/missingStarInYieldEffectGen.ts","../src/diagnostics/multipleEffectProvide.ts","../src/diagnostics/nonObjectEffectServiceType.ts","../src/refactors/writeTagClassAccessors.ts","../src/codegens/accessors.ts","../src/codegens.ts","../src/diagnostics/outdatedEffectCodegen.ts","../src/diagnostics/overriddenSchemaConstructor.ts","../src/diagnostics/returnEffectInGen.ts","../src/diagnostics/scopeInLayerEffect.ts","../src/diagnostics/strictBooleanExpressions.ts","../src/diagnostics/strictEffectProvide.ts","../src/diagnostics/tryCatchInEffectGen.ts","../src/diagnostics/unnecessaryEffectGen.ts","../src/diagnostics/unnecessaryPipe.ts","../src/diagnostics/unnecessaryPipeChain.ts","../src/diagnostics/unsupportedServiceAccessors.ts","../src/diagnostics.ts"],"sourcesContent":["import * as Array from \"effect/Array\"\nimport * as Either from \"effect/Either\"\nimport { pipe } from \"effect/Function\"\nimport * as Predicate from \"effect/Predicate\"\nimport type * as ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"./core/LanguageServicePluginOptions\"\nimport * as LSP from \"./core/LSP\"\nimport * as Nano from \"./core/Nano\"\nimport * as TypeCheckerApi from \"./core/TypeCheckerApi\"\nimport * as TypeCheckerUtils from \"./core/TypeCheckerUtils\"\nimport * as TypeParser from \"./core/TypeParser\"\nimport * as TypeScriptApi from \"./core/TypeScriptApi\"\nimport * as TypeScriptUtils from \"./core/TypeScriptUtils\"\nimport { diagnostics } from \"./diagnostics\"\n\nconst extractEffectLspOptions = (compilerOptions: ts.CompilerOptions) => {\n  return (Predicate.hasProperty(compilerOptions, \"plugins\") && Array.isArray(compilerOptions.plugins)\n    ? compilerOptions.plugins\n    : []).find((_) => Predicate.hasProperty(_, \"name\") && _.name === \"@effect/language-service\")\n}\n\nexport function clearSourceFileEffectMetadata(\n  sourceFile: ts.SourceFile\n) {\n  LSP.getOrDefaultEffectLspPatchSourceFileMetadata(sourceFile).relationErrors = []\n}\n\nexport function appendMetadataRelationError(\n  tsInstance: TypeScriptApi.TypeScriptApi,\n  errorNode: ts.Node,\n  source: ts.Type,\n  target: ts.Type\n) {\n  let sourceFile = errorNode\n  while (sourceFile.parent && !tsInstance.isSourceFile(sourceFile)) {\n    sourceFile = sourceFile.parent\n  }\n  if (tsInstance.isSourceFile(sourceFile)) {\n    LSP.getOrDefaultEffectLspPatchSourceFileMetadata(sourceFile).relationErrors.push([\n      errorNode,\n      target,\n      errorNode,\n      source\n    ])\n  }\n}\n\nexport function checkSourceFileWorker(\n  tsInstance: TypeScriptApi.TypeScriptApi,\n  program: ts.Program,\n  sourceFile: ts.SourceFile,\n  compilerOptions: ts.CompilerOptions,\n  addDiagnostic: (diagnostic: ts.Diagnostic) => void\n) {\n  // check if the plugin is enabled\n  const pluginOptions = extractEffectLspOptions(compilerOptions)\n  if (!pluginOptions) return\n\n  // run the diagnostics and pipe them into addDiagnostic\n  pipe(\n    LSP.getSemanticDiagnosticsWithCodeFixes(diagnostics, sourceFile),\n    TypeParser.nanoLayer,\n    TypeCheckerUtils.nanoLayer,\n    TypeScriptUtils.nanoLayer,\n    Nano.provideService(TypeCheckerApi.TypeCheckerApi, program.getTypeChecker()),\n    Nano.provideService(TypeScriptApi.TypeScriptProgram, program),\n    Nano.provideService(TypeScriptApi.TypeScriptApi, tsInstance),\n    Nano.provideService(\n      LanguageServicePluginOptions.LanguageServicePluginOptions,\n      LanguageServicePluginOptions.parse(pluginOptions)\n    ),\n    Nano.unsafeRun,\n    Either.map((_) => _.diagnostics),\n    Either.map(\n      Array.filter((_) =>\n        _.category === tsInstance.DiagnosticCategory.Error ||\n        _.category === tsInstance.DiagnosticCategory.Warning\n      )\n    ),\n    Either.getOrElse((e) => {\n      console.error(e)\n      return []\n    }),\n    Array.map(addDiagnostic)\n  )\n}\n","/**\n * @since 2.0.0\n */\nimport type { TypeLambda } from \"./HKT.js\"\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface FunctionTypeLambda extends TypeLambda {\n  readonly type: (a: this[\"In\"]) => this[\"Target\"]\n}\n\n/**\n * Tests if a value is a `function`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isFunction = (input: unknown): input is Function => typeof input === \"function\"\n\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * You can pass either the arity of the uncurried function or a predicate\n * which determines if the function is being used in a data-first or\n * data-last style.\n *\n * **Example** (Using arity to determine data-first or data-last style)\n *\n * ```ts\n * import { dual, pipe } from \"effect/Function\"\n *\n * const sum = dual<\n *   (that: number) => (self: number) => number,\n *   (self: number, that: number) => number\n * >(2, (self, that) => self + that)\n *\n * console.log(sum(2, 3)) // 5\n * console.log(pipe(2, sum(3))) // 5\n * ```\n *\n * **Example** (Using call signatures to define the overloads)\n *\n * ```ts\n * import { dual, pipe } from \"effect/Function\"\n *\n * const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * console.log(sum(2, 3)) // 5\n * console.log(pipe(2, sum(3))) // 5\n * ```\n *\n * **Example** (Using a predicate to determine data-first or data-last style)\n *\n * ```ts\n * import { dual, pipe } from \"effect/Function\"\n *\n * const sum = dual<\n *   (that: number) => (self: number) => number,\n *   (self: number, that: number) => number\n * >(\n *   (args) => args.length === 2,\n *   (self, that) => self + that\n * )\n *\n * console.log(sum(2, 3)) // 5\n * console.log(pipe(2, sum(3))) // 5\n * ```\n *\n * @since 2.0.0\n */\nexport const dual: {\n  /**\n   * Creates a function that can be used in a data-last (aka `pipe`able) or\n   * data-first style.\n   *\n   * The first parameter to `dual` is either the arity of the uncurried function\n   * or a predicate that determines if the function is being used in a data-first\n   * or data-last style.\n   *\n   * Using the arity is the most common use case, but there are some cases where\n   * you may want to use a predicate. For example, if you have a function that\n   * takes an optional argument, you can use a predicate to determine if the\n   * function is being used in a data-first or data-last style.\n   *\n   * You can pass either the arity of the uncurried function or a predicate\n   * which determines if the function is being used in a data-first or\n   * data-last style.\n   *\n   * **Example** (Using arity to determine data-first or data-last style)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum = dual<\n   *   (that: number) => (self: number) => number,\n   *   (self: number, that: number) => number\n   * >(2, (self, that) => self + that)\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * **Example** (Using call signatures to define the overloads)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum: {\n   *   (that: number): (self: number) => number\n   *   (self: number, that: number): number\n   * } = dual(2, (self: number, that: number): number => self + that)\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * **Example** (Using a predicate to determine data-first or data-last style)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum = dual<\n   *   (that: number) => (self: number) => number,\n   *   (self: number, that: number) => number\n   * >(\n   *   (args) => args.length === 2,\n   *   (self, that) => self + that\n   * )\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(arity: Parameters<DataFirst>[\"length\"], body: DataFirst): DataLast & DataFirst\n  /**\n   * Creates a function that can be used in a data-last (aka `pipe`able) or\n   * data-first style.\n   *\n   * The first parameter to `dual` is either the arity of the uncurried function\n   * or a predicate that determines if the function is being used in a data-first\n   * or data-last style.\n   *\n   * Using the arity is the most common use case, but there are some cases where\n   * you may want to use a predicate. For example, if you have a function that\n   * takes an optional argument, you can use a predicate to determine if the\n   * function is being used in a data-first or data-last style.\n   *\n   * You can pass either the arity of the uncurried function or a predicate\n   * which determines if the function is being used in a data-first or\n   * data-last style.\n   *\n   * **Example** (Using arity to determine data-first or data-last style)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum = dual<\n   *   (that: number) => (self: number) => number,\n   *   (self: number, that: number) => number\n   * >(2, (self, that) => self + that)\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * **Example** (Using call signatures to define the overloads)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum: {\n   *   (that: number): (self: number) => number\n   *   (self: number, that: number): number\n   * } = dual(2, (self: number, that: number): number => self + that)\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * **Example** (Using a predicate to determine data-first or data-last style)\n   *\n   * ```ts\n   * import { dual, pipe } from \"effect/Function\"\n   *\n   * const sum = dual<\n   *   (that: number) => (self: number) => number,\n   *   (self: number, that: number) => number\n   * >(\n   *   (args) => args.length === 2,\n   *   (self, that) => self + that\n   * )\n   *\n   * console.log(sum(2, 3)) // 5\n   * console.log(pipe(2, sum(3))) // 5\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(isDataFirst: (args: IArguments) => boolean, body: DataFirst): DataLast & DataFirst\n} = function(arity, body) {\n  if (typeof arity === \"function\") {\n    return function() {\n      if (arity(arguments)) {\n        // @ts-expect-error\n        return body.apply(this, arguments)\n      }\n      return ((self: any) => body(self, ...arguments)) as any\n    }\n  }\n\n  switch (arity) {\n    case 0:\n    case 1:\n      throw new RangeError(`Invalid arity ${arity}`)\n\n    case 2:\n      return function(a, b) {\n        if (arguments.length >= 2) {\n          return body(a, b)\n        }\n        return function(self: any) {\n          return body(self, a)\n        }\n      }\n\n    case 3:\n      return function(a, b, c) {\n        if (arguments.length >= 3) {\n          return body(a, b, c)\n        }\n        return function(self: any) {\n          return body(self, a, b)\n        }\n      }\n\n    case 4:\n      return function(a, b, c, d) {\n        if (arguments.length >= 4) {\n          return body(a, b, c, d)\n        }\n        return function(self: any) {\n          return body(self, a, b, c)\n        }\n      }\n\n    case 5:\n      return function(a, b, c, d, e) {\n        if (arguments.length >= 5) {\n          return body(a, b, c, d, e)\n        }\n        return function(self: any) {\n          return body(self, a, b, c, d)\n        }\n      }\n\n    default:\n      return function() {\n        if (arguments.length >= arity) {\n          // @ts-expect-error\n          return body.apply(this, arguments)\n        }\n        const args = arguments\n        return function(self: any) {\n          return body(self, ...args)\n        }\n      }\n  }\n}\n/**\n * Apply a function to given values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, apply } from \"effect/Function\"\n * import { length } from \"effect/String\"\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const apply = <A extends ReadonlyArray<unknown>>(...a: A) => <B>(self: (...a: A) => B): B => self(...a)\n\n/**\n * A lazy argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { LazyArg, constant } from \"effect/Function\"\n *\n * const constNull: LazyArg<null> = constant(null)\n * ```\n *\n * @since 2.0.0\n */\nexport interface LazyArg<A> {\n  (): A\n}\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { FunctionN } from \"effect/Function\"\n *\n * const sum: FunctionN<[number, number], number> = (a, b) => a + b\n * ```\n *\n * @since 2.0.0\n */\nexport interface FunctionN<A extends ReadonlyArray<unknown>, B> {\n  (...args: A): B\n}\n\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const identity = <A>(a: A): A => a\n\n/**\n * A function that ensures that the type of an expression matches some type,\n * without changing the resulting type of that expression.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { satisfies } from \"effect/Function\"\n *\n * const test1 = satisfies<number>()(5 as const)\n *     //^? const test: 5\n *     // @ts-expect-error\n * const test2 = satisfies<string>()(5)\n *     //^? Argument of type 'number' is not assignable to parameter of type 'string'\n *\n * assert.deepStrictEqual(satisfies<number>()(5), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const satisfies = <A>() => <B extends A>(b: B) => b\n\n/**\n * Casts the result to the specified type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeCoerce, identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n * ```\n *\n * @since 2.0.0\n */\nexport const unsafeCoerce: <A, B>(a: A) => B = identity as any\n\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constant } from \"effect/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n * ```\n *\n * @since 2.0.0\n */\nexport const constant = <A>(value: A): LazyArg<A> => () => value\n\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constTrue } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n * ```\n *\n * @since 2.0.0\n */\nexport const constTrue: LazyArg<boolean> = constant(true)\n\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constFalse } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const constFalse: LazyArg<boolean> = constant(false)\n\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constNull } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n * ```\n *\n * @since 2.0.0\n */\nexport const constNull: LazyArg<null> = constant(null)\n\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constUndefined } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n * ```\n *\n * @since 2.0.0\n */\nexport const constUndefined: LazyArg<undefined> = constant(undefined)\n\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constVoid } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n * ```\n *\n * @since 2.0.0\n */\nexport const constVoid: LazyArg<void> = constUndefined\n\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { flip } from \"effect/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n * ```\n *\n * @since 2.0.0\n */\nexport const flip = <A extends Array<unknown>, B extends Array<unknown>, C>(\n  f: (...a: A) => (...b: B) => C\n): (...b: B) => (...a: A) => C =>\n(...b) =>\n(...a) => f(...a)(...b)\n\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { compose } from \"effect/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n * ```\n *\n * @since 2.0.0\n */\nexport const compose: {\n  /**\n   * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n   * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { compose } from \"effect/Function\"\n   *\n   * const increment = (n: number) => n + 1;\n   * const square = (n: number) => n * n;\n   *\n   * assert.strictEqual(compose(increment, square)(2), 9);\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C\n  /**\n   * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n   * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { compose } from \"effect/Function\"\n   *\n   * const increment = (n: number) => n + 1;\n   * const square = (n: number) => n * n;\n   *\n   * assert.strictEqual(compose(increment, square)(2), 9);\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C\n} = dual(2, <A, B, C>(ab: (a: A) => B, bc: (b: B) => C): (a: A) => C => (a) => bc(ab(a)))\n\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly useful when it's necessary to specify that certain cases are impossible.\n *\n * @since 2.0.0\n */\nexport const absurd = <A>(_: never): A => {\n  throw new Error(\"Called `absurd` function which should be uncallable\")\n}\n\n/**\n * Creates a   version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { tupled } from \"effect/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n * ```\n *\n * @since 2.0.0\n */\nexport const tupled = <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): (a: A) => B => (a) => f(...a)\n\n/**\n * Inverse function of `tupled`\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { untupled } from \"effect/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n * ```\n *\n * @since 2.0.0\n */\nexport const untupled = <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B): (...a: A) => B => (...a) => f(a)\n\n/**\n * Pipes the value of an expression into a pipeline of functions.\n *\n * **Details**\n *\n * The `pipe` function is a utility that allows us to compose functions in a\n * readable and sequential manner. It takes the output of one function and\n * passes it as the input to the next function in the pipeline. This enables us\n * to build complex transformations by chaining multiple functions together.\n *\n * ```ts skip-type-checking\n * import { pipe } from \"effect\"\n *\n * const result = pipe(input, func1, func2, ..., funcN)\n * ```\n *\n * In this syntax, `input` is the initial value, and `func1`, `func2`, ...,\n * `funcN` are the functions to be applied in sequence. The result of each\n * function becomes the input for the next function, and the final result is\n * returned.\n *\n * Here's an illustration of how `pipe` works:\n *\n * ```\n * ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐    ┌────────┐\n * │ input │───►│ func1 │───►│ func2 │───►│  ...  │───►│ funcN │───►│ result │\n * └───────┘    └───────┘    └───────┘    └───────┘    └───────┘    └────────┘\n * ```\n *\n * It's important to note that functions passed to `pipe` must have a **single\n * argument** because they are only called with a single argument.\n *\n * **When to Use**\n *\n * This is useful in combination with data-last functions as a simulation of\n * methods:\n *\n * ```ts skip-type-checking\n * as.map(f).filter(g)\n * ```\n *\n * becomes:\n *\n * ```ts skip-type-checking\n * import { pipe, Array } from \"effect\"\n *\n * pipe(as, Array.map(f), Array.filter(g))\n * ```\n *\n * **Example** (Chaining Arithmetic Operations)\n *\n * ```ts\n * import { pipe } from \"effect\"\n *\n * // Define simple arithmetic operations\n * const increment = (x: number) => x + 1\n * const double = (x: number) => x * 2\n * const subtractTen = (x: number) => x - 10\n *\n * // Sequentially apply these operations using `pipe`\n * const result = pipe(5, increment, double, subtractTen)\n *\n * console.log(result)\n * // Output: 2\n * ```\n *\n * @since 2.0.0\n */\nexport function pipe<A>(a: A): A\nexport function pipe<A, B = never>(a: A, ab: (a: A) => B): B\nexport function pipe<A, B = never, C = never>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C\n): C\nexport function pipe<A, B = never, C = never, D = never>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D\n): D\nexport function pipe<A, B = never, C = never, D = never, E = never>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): E\nexport function pipe<A, B = never, C = never, D = never, E = never, F = never>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): F\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): G\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): H\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): I\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): J\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K\n): K\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L\n): L\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M\n): M\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N\n): N\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O\n): O\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P\n): P\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never,\n  Q = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q\n): Q\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never,\n  Q = never,\n  R = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R\n): R\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never,\n  Q = never,\n  R = never,\n  S = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S\n): S\nexport function pipe<\n  A,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never,\n  K = never,\n  L = never,\n  M = never,\n  N = never,\n  O = never,\n  P = never,\n  Q = never,\n  R = never,\n  S = never,\n  T = never\n>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S,\n  st: (s: S) => T\n): T\nexport function pipe(\n  a: unknown,\n  ab?: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return a\n    case 2:\n      return ab!(a)\n    case 3:\n      return bc!(ab!(a))\n    case 4:\n      return cd!(bc!(ab!(a)))\n    case 5:\n      return de!(cd!(bc!(ab!(a))))\n    case 6:\n      return ef!(de!(cd!(bc!(ab!(a)))))\n    case 7:\n      return fg!(ef!(de!(cd!(bc!(ab!(a))))))\n    case 8:\n      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n    case 9:\n      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n    default: {\n      let ret = arguments[0]\n      for (let i = 1; i < arguments.length; i++) {\n        ret = arguments[i](ret)\n      }\n      return ret\n    }\n  }\n}\n\n/**\n * Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n *\n * See also [`pipe`](#pipe).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { flow } from \"effect/Function\"\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'), 6)\n * ```\n *\n * @since 2.0.0\n */\nexport function flow<A extends ReadonlyArray<unknown>, B = never>(\n  ab: (...a: A) => B\n): (...a: A) => B\nexport function flow<A extends ReadonlyArray<unknown>, B = never, C = never>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C\n): (...a: A) => C\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never\n>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D): (...a: A) => D\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): (...a: A) => E\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): (...a: A) => F\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): (...a: A) => G\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): (...a: A) => H\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): (...a: A) => I\nexport function flow<\n  A extends ReadonlyArray<unknown>,\n  B = never,\n  C = never,\n  D = never,\n  E = never,\n  F = never,\n  G = never,\n  H = never,\n  I = never,\n  J = never\n>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): (...a: A) => J\nexport function flow(\n  ab: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function,\n  ij?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return ab\n    case 2:\n      return function(this: unknown) {\n        return bc!(ab.apply(this, arguments))\n      }\n    case 3:\n      return function(this: unknown) {\n        return cd!(bc!(ab.apply(this, arguments)))\n      }\n    case 4:\n      return function(this: unknown) {\n        return de!(cd!(bc!(ab.apply(this, arguments))))\n      }\n    case 5:\n      return function(this: unknown) {\n        return ef!(de!(cd!(bc!(ab.apply(this, arguments)))))\n      }\n    case 6:\n      return function(this: unknown) {\n        return fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))\n      }\n    case 7:\n      return function(this: unknown) {\n        return gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))\n      }\n    case 8:\n      return function(this: unknown) {\n        return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))))\n      }\n    case 9:\n      return function(this: unknown) {\n        return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))))\n      }\n  }\n  return\n}\n\n/**\n * Type hole simulation.\n *\n * @since 2.0.0\n */\nexport const hole: <T>() => T = unsafeCoerce(absurd)\n\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { SK } from \"effect/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n * ```\n *\n * @since 2.0.0\n */\nexport const SK = <A, B>(_: A, b: B): B => b\n","/**\n * The `GlobalValue` module ensures that a single instance of a value is created globally,\n * even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)\n * or during hot-reloading in development environments like Next.js or Remix.\n *\n * It achieves this by using a versioned global store, identified by a unique `Symbol` tied to\n * the current version of the `effect` library. The store holds values that are keyed by an identifier,\n * allowing the reuse of previously computed instances across imports or reloads.\n *\n * This pattern is particularly useful in scenarios where frequent reloading can cause services or\n * single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.\n *\n * @since 2.0.0\n */\nconst globalStoreId = `effect/GlobalValue`\n\nlet globalStore: Map<unknown, any>\n\n/**\n * Retrieves or computes a global value associated with the given `id`. If the value for this `id`\n * has already been computed, it will be returned from the global store. If it does not exist yet,\n * the provided `compute` function will be executed to compute the value, store it, and then return it.\n *\n * This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments\n * like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused\n * thereafter.\n *\n * @example\n * ```ts\n * import { globalValue } from \"effect/GlobalValue\"\n *\n * // This cache will persist as long as the module is running,\n * // even if reloaded or imported elsewhere\n * const myCache = globalValue(\n *   Symbol.for(\"myCache\"),\n *   () => new WeakMap<object, number>()\n * )\n * ```\n *\n * @since 2.0.0\n */\nexport const globalValue = <A>(id: unknown, compute: () => A): A => {\n  if (!globalStore) {\n    // @ts-expect-error\n    globalThis[globalStoreId] ??= new Map()\n    // @ts-expect-error\n    globalStore = globalThis[globalStoreId] as Map<unknown, any>\n  }\n  if (!globalStore.has(id)) {\n    globalStore.set(id, compute())\n  }\n  return globalStore.get(id)!\n}\n","/**\n * This module provides a collection of functions for working with predicates and refinements.\n *\n * A `Predicate<A>` is a function that takes a value of type `A` and returns a boolean.\n * It is used to check if a value satisfies a certain condition.\n *\n * A `Refinement<A, B>` is a special type of predicate that not only checks a condition\n * but also provides a type guard, allowing TypeScript to narrow the type of the input\n * value from `A` to a more specific type `B` within a conditional block.\n *\n * The module includes:\n * - Basic predicates and refinements for common types (e.g., `isString`, `isNumber`).\n * - Combinators to create new predicates from existing ones (e.g., `and`, `or`, `not`).\n * - Advanced combinators for working with data structures (e.g., `tuple`, `struct`).\n * - Type-level utilities for inspecting predicate and refinement types.\n *\n * @since 2.0.0\n */\nimport { dual, isFunction as isFunction_ } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { TupleOf, TupleOfAtLeast } from \"./Types.js\"\n\n/**\n * Represents a function that takes a value of type `A` and returns `true` if the value\n * satisfies some condition, `false` otherwise.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n * import * as assert from \"node:assert\"\n *\n * const isEven: Predicate.Predicate<number> = (n) => n % 2 === 0\n *\n * assert.strictEqual(isEven(2), true)\n * assert.strictEqual(isEven(3), false)\n * ```\n *\n * @category models\n * @since 2.0.0\n */\nexport interface Predicate<in A> {\n  (a: A): boolean\n}\n\n/**\n * A `TypeLambda` for `Predicate`. This is used to support higher-kinded types\n * and allows `Predicate` to be used in generic contexts within the `effect` ecosystem.\n *\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface PredicateTypeLambda extends TypeLambda {\n  readonly type: Predicate<this[\"Target\"]>\n}\n\n/**\n * Represents a function that serves as a type guard.\n *\n * A `Refinement<A, B>` is a function that takes a value of type `A` and returns a\n * type predicate `a is B`, where `B` is a subtype of `A`. If the function returns\n * `true`, TypeScript will narrow the type of the input variable to `B`.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n * import * as assert from \"node:assert\"\n *\n * const isString: Predicate.Refinement<unknown, string> = (u): u is string => typeof u === \"string\"\n *\n * const value: unknown = \"hello\"\n *\n * if (isString(value)) {\n *   // value is now known to be a string\n *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n * }\n * ```\n *\n * @category models\n * @since 2.0.0\n */\nexport interface Refinement<in A, out B extends A> {\n  (a: A): a is B\n}\n\n/**\n * A namespace for type-level utilities for `Predicate`.\n *\n * @since 3.6.0\n * @category type-level\n */\nexport declare namespace Predicate {\n  /**\n   * Extracts the input type `A` from a `Predicate<A>`.\n   *\n   * @example\n   * ```ts\n   * import { type Predicate } from \"effect\"\n   *\n   * type T = Predicate.Predicate.In<Predicate.Predicate<string>> // T is string\n   * ```\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type In<T extends Any> = [T] extends [Predicate<infer _A>] ? _A : never\n  /**\n   * A type representing any `Predicate`.\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type Any = Predicate<never>\n}\n\n/**\n * A namespace for type-level utilities for `Refinement`.\n *\n * @since 3.6.0\n * @category type-level\n */\nexport declare namespace Refinement {\n  /**\n   * Extracts the input type `A` from a `Refinement<A, B>`.\n   *\n   * @example\n   * ```ts\n   * import { type Predicate } from \"effect\"\n   *\n   * type IsString = Predicate.Refinement<unknown, string>\n   * type T = Predicate.Refinement.In<IsString> // T is unknown\n   * ```\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type In<T extends Any> = [T] extends [Refinement<infer _A, infer _>] ? _A : never\n  /**\n   * Extracts the output (refined) type `B` from a `Refinement<A, B>`.\n   *\n   * @example\n   * ```ts\n   * import { type Predicate } from \"effect\"\n   *\n   * type IsString = Predicate.Refinement<unknown, string>\n   * type T = Predicate.Refinement.Out<IsString> // T is string\n   * ```\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type Out<T extends Any> = [T] extends [Refinement<infer _, infer _B>] ? _B : never\n  /**\n   * A type representing any `Refinement`.\n   *\n   * @since 3.6.0\n   * @category type-level\n   */\n  export type Any = Refinement<any, any>\n}\n\n/**\n * Transforms a `Predicate<A>` into a `Predicate<B>` by applying a function `(b: B) => A`\n * to the input before passing it to the predicate. This is also known as \"contramap\" or\n * \"pre-composition\".\n *\n * @example\n * ```ts\n * import { Predicate, Number } from \"effect\"\n * import * as assert from \"node:assert\"\n *\n * // A predicate on numbers\n * const isPositive: Predicate.Predicate<number> = Number.greaterThan(0)\n *\n * // A function from `string` to `number`\n * const stringLength = (s: string): number => s.length\n *\n * // Create a new predicate on strings by mapping the input\n * const hasPositiveLength = Predicate.mapInput(isPositive, stringLength)\n *\n * assert.strictEqual(hasPositiveLength(\"hello\"), true)\n * assert.strictEqual(hasPositiveLength(\"\"), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const mapInput: {\n  /**\n   * Transforms a `Predicate<A>` into a `Predicate<B>` by applying a function `(b: B) => A`\n   * to the input before passing it to the predicate. This is also known as \"contramap\" or\n   * \"pre-composition\".\n   *\n   * @example\n   * ```ts\n   * import { Predicate, Number } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * // A predicate on numbers\n   * const isPositive: Predicate.Predicate<number> = Number.greaterThan(0)\n   *\n   * // A function from `string` to `number`\n   * const stringLength = (s: string): number => s.length\n   *\n   * // Create a new predicate on strings by mapping the input\n   * const hasPositiveLength = Predicate.mapInput(isPositive, stringLength)\n   *\n   * assert.strictEqual(hasPositiveLength(\"hello\"), true)\n   * assert.strictEqual(hasPositiveLength(\"\"), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>\n  /**\n   * Transforms a `Predicate<A>` into a `Predicate<B>` by applying a function `(b: B) => A`\n   * to the input before passing it to the predicate. This is also known as \"contramap\" or\n   * \"pre-composition\".\n   *\n   * @example\n   * ```ts\n   * import { Predicate, Number } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * // A predicate on numbers\n   * const isPositive: Predicate.Predicate<number> = Number.greaterThan(0)\n   *\n   * // A function from `string` to `number`\n   * const stringLength = (s: string): number => s.length\n   *\n   * // Create a new predicate on strings by mapping the input\n   * const hasPositiveLength = Predicate.mapInput(isPositive, stringLength)\n   *\n   * assert.strictEqual(hasPositiveLength(\"hello\"), true)\n   * assert.strictEqual(hasPositiveLength(\"\"), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>\n} = dual(2, <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B> => (b) => self(f(b)))\n\n/**\n * A refinement that checks if a `ReadonlyArray<T>` is a tuple with exactly `N` elements.\n * If the check is successful, the type is narrowed to `TupleOf<N, T>`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTupleOf } from \"effect/Predicate\"\n *\n * const isTupleOf3 = isTupleOf(3)\n *\n * assert.strictEqual(isTupleOf3([1, 2, 3]), true);\n * assert.strictEqual(isTupleOf3([1, 2]), false);\n *\n * const arr: number[] = [1, 2, 3];\n * if (isTupleOf(arr, 3)) {\n *   // The type of arr is now [number, number, number]\n *   const [a, b, c] = arr;\n *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n * }\n * ```\n *\n * @category guards\n * @since 3.3.0\n */\nexport const isTupleOf: {\n  /**\n   * A refinement that checks if a `ReadonlyArray<T>` is a tuple with exactly `N` elements.\n   * If the check is successful, the type is narrowed to `TupleOf<N, T>`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTupleOf } from \"effect/Predicate\"\n   *\n   * const isTupleOf3 = isTupleOf(3)\n   *\n   * assert.strictEqual(isTupleOf3([1, 2, 3]), true);\n   * assert.strictEqual(isTupleOf3([1, 2]), false);\n   *\n   * const arr: number[] = [1, 2, 3];\n   * if (isTupleOf(arr, 3)) {\n   *   // The type of arr is now [number, number, number]\n   *   const [a, b, c] = arr;\n   *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 3.3.0\n   */\n  <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>\n  /**\n   * A refinement that checks if a `ReadonlyArray<T>` is a tuple with exactly `N` elements.\n   * If the check is successful, the type is narrowed to `TupleOf<N, T>`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTupleOf } from \"effect/Predicate\"\n   *\n   * const isTupleOf3 = isTupleOf(3)\n   *\n   * assert.strictEqual(isTupleOf3([1, 2, 3]), true);\n   * assert.strictEqual(isTupleOf3([1, 2]), false);\n   *\n   * const arr: number[] = [1, 2, 3];\n   * if (isTupleOf(arr, 3)) {\n   *   // The type of arr is now [number, number, number]\n   *   const [a, b, c] = arr;\n   *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 3.3.0\n   */\n  <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>\n} = dual(2, <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T> => self.length === n)\n\n/**\n * A refinement that checks if a `ReadonlyArray<T>` is a tuple with at least `N` elements.\n * If the check is successful, the type is narrowed to `TupleOfAtLeast<N, T>`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTupleOfAtLeast } from \"effect/Predicate\"\n *\n * const isTupleOfAtLeast3 = isTupleOfAtLeast(3)\n *\n * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3]), true);\n * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3, 4]), true);\n * assert.strictEqual(isTupleOfAtLeast3([1, 2]), false);\n *\n * const arr: number[] = [1, 2, 3, 4];\n * if (isTupleOfAtLeast(arr, 3)) {\n *   // The type of arr is now [number, number, number, ...number[]]\n *   const [a, b, c] = arr;\n *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n * }\n * ```\n *\n * @category guards\n * @since 3.3.0\n */\nexport const isTupleOfAtLeast: {\n  /**\n   * A refinement that checks if a `ReadonlyArray<T>` is a tuple with at least `N` elements.\n   * If the check is successful, the type is narrowed to `TupleOfAtLeast<N, T>`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTupleOfAtLeast } from \"effect/Predicate\"\n   *\n   * const isTupleOfAtLeast3 = isTupleOfAtLeast(3)\n   *\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3]), true);\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3, 4]), true);\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2]), false);\n   *\n   * const arr: number[] = [1, 2, 3, 4];\n   * if (isTupleOfAtLeast(arr, 3)) {\n   *   // The type of arr is now [number, number, number, ...number[]]\n   *   const [a, b, c] = arr;\n   *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 3.3.0\n   */\n  <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>\n  /**\n   * A refinement that checks if a `ReadonlyArray<T>` is a tuple with at least `N` elements.\n   * If the check is successful, the type is narrowed to `TupleOfAtLeast<N, T>`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTupleOfAtLeast } from \"effect/Predicate\"\n   *\n   * const isTupleOfAtLeast3 = isTupleOfAtLeast(3)\n   *\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3]), true);\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2, 3, 4]), true);\n   * assert.strictEqual(isTupleOfAtLeast3([1, 2]), false);\n   *\n   * const arr: number[] = [1, 2, 3, 4];\n   * if (isTupleOfAtLeast(arr, 3)) {\n   *   // The type of arr is now [number, number, number, ...number[]]\n   *   const [a, b, c] = arr;\n   *   assert.deepStrictEqual([a, b, c], [1, 2, 3])\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 3.3.0\n   */\n  <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>\n} = dual(2, <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T> => self.length >= n)\n\n/**\n * A predicate that checks if a value is \"truthy\" in JavaScript.\n * Fails for `false`, `0`, `-0`, `0n`, `\"\"`, `null`, `undefined`, and `NaN`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTruthy } from \"effect/Predicate\"\n *\n * assert.strictEqual(isTruthy(1), true)\n * assert.strictEqual(isTruthy(\"hello\"), true)\n * assert.strictEqual(isTruthy({}), true)\n *\n * assert.strictEqual(isTruthy(0), false)\n * assert.strictEqual(isTruthy(\"\"), false)\n * assert.strictEqual(isTruthy(null), false)\n * assert.strictEqual(isTruthy(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isTruthy = (input: unknown) => !!input\n\n/**\n * A refinement that checks if a value is a `Set`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isSet } from \"effect/Predicate\"\n *\n * assert.strictEqual(isSet(new Set([1, 2])), true)\n * assert.strictEqual(isSet(new Set()), true)\n *\n * assert.strictEqual(isSet({}), false)\n * assert.strictEqual(isSet([1, 2]), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSet = (input: unknown): input is Set<unknown> => input instanceof Set\n\n/**\n * A refinement that checks if a value is a `Map`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isMap } from \"effect/Predicate\"\n *\n * assert.strictEqual(isMap(new Map()), true)\n *\n * assert.strictEqual(isMap({}), false)\n * assert.strictEqual(isMap(new Set()), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isMap = (input: unknown): input is Map<unknown, unknown> => input instanceof Map\n\n/**\n * A refinement that checks if a value is a `string`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isString } from \"effect/Predicate\"\n *\n * assert.strictEqual(isString(\"hello\"), true)\n * assert.strictEqual(isString(\"\"), true)\n *\n * assert.strictEqual(isString(123), false)\n * assert.strictEqual(isString(null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isString = (input: unknown): input is string => typeof input === \"string\"\n\n/**\n * A refinement that checks if a value is a `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNumber } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNumber(123), true)\n * assert.strictEqual(isNumber(0), true)\n * assert.strictEqual(isNumber(-1.5), true)\n * assert.strictEqual(isNumber(NaN), true)\n *\n * assert.strictEqual(isNumber(\"123\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNumber = (input: unknown): input is number => typeof input === \"number\"\n\n/**\n * A refinement that checks if a value is a `boolean`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isBoolean } from \"effect/Predicate\"\n *\n * assert.strictEqual(isBoolean(true), true)\n * assert.strictEqual(isBoolean(false), true)\n *\n * assert.strictEqual(isBoolean(\"true\"), false)\n * assert.strictEqual(isBoolean(0), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBoolean = (input: unknown): input is boolean => typeof input === \"boolean\"\n\n/**\n * A refinement that checks if a value is a `bigint`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isBigInt } from \"effect/Predicate\"\n *\n * assert.strictEqual(isBigInt(1n), true)\n *\n * assert.strictEqual(isBigInt(1), false)\n * assert.strictEqual(isBigInt(\"1\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBigInt = (input: unknown): input is bigint => typeof input === \"bigint\"\n\n/**\n * A refinement that checks if a value is a `symbol`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isSymbol } from \"effect/Predicate\"\n *\n * assert.strictEqual(isSymbol(Symbol.for(\"a\")), true)\n *\n * assert.strictEqual(isSymbol(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSymbol = (input: unknown): input is symbol => typeof input === \"symbol\"\n\n// TODO: make public\n/**\n * A refinement that checks if a value is a valid `PropertyKey` (a `string`, `number`, or `symbol`).\n * @internal\n */\nexport const isPropertyKey = (u: unknown): u is PropertyKey => isString(u) || isNumber(u) || isSymbol(u)\n\n/**\n * A refinement that checks if a value is a `Function`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.strictEqual(isFunction(() => {}), true)\n * assert.strictEqual(isFunction(isFunction), true)\n *\n * assert.strictEqual(isFunction(\"function\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isFunction: (input: unknown) => input is Function = isFunction_\n\n/**\n * A refinement that checks if a value is `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUndefined } from \"effect/Predicate\"\n *\n * assert.strictEqual(isUndefined(undefined), true)\n *\n * assert.strictEqual(isUndefined(null), false)\n * assert.strictEqual(isUndefined(\"undefined\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUndefined = (input: unknown): input is undefined => input === undefined\n\n/**\n * A refinement that checks if a value is not `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotUndefined } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNotUndefined(null), true)\n * assert.strictEqual(isNotUndefined(\"value\"), true)\n *\n * assert.strictEqual(isNotUndefined(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotUndefined = <A>(input: A): input is Exclude<A, undefined> => input !== undefined\n\n/**\n * A refinement that checks if a value is `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNull } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNull(null), true)\n *\n * assert.strictEqual(isNull(undefined), false)\n * assert.strictEqual(isNull(\"null\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNull = (input: unknown): input is null => input === null\n\n/**\n * A refinement that checks if a value is not `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotNull } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNotNull(undefined), true)\n * assert.strictEqual(isNotNull(\"value\"), true)\n *\n * assert.strictEqual(isNotNull(null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotNull = <A>(input: A): input is Exclude<A, null> => input !== null\n\n/**\n * A refinement that always returns `false`. The type is narrowed to `never`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNever } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNever(1), false)\n * assert.strictEqual(isNever(null), false)\n * assert.strictEqual(isNever({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNever: (input: unknown) => input is never = (_: unknown): _ is never => false\n\n/**\n * A refinement that always returns `true`. The type is narrowed to `unknown`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUnknown } from \"effect/Predicate\"\n *\n * assert.strictEqual(isUnknown(1), true)\n * assert.strictEqual(isUnknown(null), true)\n * assert.strictEqual(isUnknown({}), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUnknown: (input: unknown) => input is unknown = (_): _ is unknown => true\n\n/**\n * Checks if the input is an object or an array.\n * @internal\n */\nexport const isRecordOrArray = (input: unknown): input is { [x: PropertyKey]: unknown } =>\n  typeof input === \"object\" && input !== null\n\n/**\n * A refinement that checks if a value is an `object`. Note that in JavaScript,\n * arrays and functions are also considered objects.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isObject } from \"effect/Predicate\"\n *\n * assert.strictEqual(isObject({}), true)\n * assert.strictEqual(isObject([]), true)\n * assert.strictEqual(isObject(() => {}), true)\n *\n * assert.strictEqual(isObject(null), false)\n * assert.strictEqual(isObject(\"hello\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isRecord to check for plain objects (excluding arrays and functions).\n */\nexport const isObject = (input: unknown): input is object => isRecordOrArray(input) || isFunction(input)\n\n/**\n * A refinement that checks if a value is an object-like value and has a specific property key.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { hasProperty } from \"effect/Predicate\"\n *\n * assert.strictEqual(hasProperty({ a: 1 }, \"a\"), true)\n * assert.strictEqual(hasProperty({ a: 1 }, \"b\"), false)\n *\n * const value: unknown = { name: \"Alice\" };\n * if (hasProperty(value, \"name\")) {\n *   // The type of `value` is narrowed to `{ name: unknown }`\n *   // and we can safely access `value.name`\n *   console.log(value.name)\n * }\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const hasProperty: {\n  /**\n   * A refinement that checks if a value is an object-like value and has a specific property key.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { hasProperty } from \"effect/Predicate\"\n   *\n   * assert.strictEqual(hasProperty({ a: 1 }, \"a\"), true)\n   * assert.strictEqual(hasProperty({ a: 1 }, \"b\"), false)\n   *\n   * const value: unknown = { name: \"Alice\" };\n   * if (hasProperty(value, \"name\")) {\n   *   // The type of `value` is narrowed to `{ name: unknown }`\n   *   // and we can safely access `value.name`\n   *   console.log(value.name)\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown }\n  /**\n   * A refinement that checks if a value is an object-like value and has a specific property key.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { hasProperty } from \"effect/Predicate\"\n   *\n   * assert.strictEqual(hasProperty({ a: 1 }, \"a\"), true)\n   * assert.strictEqual(hasProperty({ a: 1 }, \"b\"), false)\n   *\n   * const value: unknown = { name: \"Alice\" };\n   * if (hasProperty(value, \"name\")) {\n   *   // The type of `value` is narrowed to `{ name: unknown }`\n   *   // and we can safely access `value.name`\n   *   console.log(value.name)\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown }\n} = dual(\n  2,\n  <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown } =>\n    isObject(self) && (property in self)\n)\n\n/**\n * A refinement that checks if a value is an object with a `_tag` property\n * that matches the given tag. This is a powerful tool for working with\n * discriminated union types.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTagged } from \"effect/Predicate\"\n *\n * type Shape = { _tag: \"circle\"; radius: number } | { _tag: \"square\"; side: number }\n *\n * const isCircle = isTagged(\"circle\")\n *\n * const shape1: Shape = { _tag: \"circle\", radius: 10 }\n * const shape2: Shape = { _tag: \"square\", side: 5 }\n *\n * assert.strictEqual(isCircle(shape1), true)\n * assert.strictEqual(isCircle(shape2), false)\n *\n * if (isCircle(shape1)) {\n *   // shape1 is now narrowed to { _tag: \"circle\"; radius: number }\n *   assert.strictEqual(shape1.radius, 10)\n * }\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isTagged: {\n  /**\n   * A refinement that checks if a value is an object with a `_tag` property\n   * that matches the given tag. This is a powerful tool for working with\n   * discriminated union types.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTagged } from \"effect/Predicate\"\n   *\n   * type Shape = { _tag: \"circle\"; radius: number } | { _tag: \"square\"; side: number }\n   *\n   * const isCircle = isTagged(\"circle\")\n   *\n   * const shape1: Shape = { _tag: \"circle\", radius: 10 }\n   * const shape2: Shape = { _tag: \"square\", side: 5 }\n   *\n   * assert.strictEqual(isCircle(shape1), true)\n   * assert.strictEqual(isCircle(shape2), false)\n   *\n   * if (isCircle(shape1)) {\n   *   // shape1 is now narrowed to { _tag: \"circle\"; radius: number }\n   *   assert.strictEqual(shape1.radius, 10)\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <K extends string>(tag: K): (self: unknown) => self is { _tag: K }\n  /**\n   * A refinement that checks if a value is an object with a `_tag` property\n   * that matches the given tag. This is a powerful tool for working with\n   * discriminated union types.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { isTagged } from \"effect/Predicate\"\n   *\n   * type Shape = { _tag: \"circle\"; radius: number } | { _tag: \"square\"; side: number }\n   *\n   * const isCircle = isTagged(\"circle\")\n   *\n   * const shape1: Shape = { _tag: \"circle\", radius: 10 }\n   * const shape2: Shape = { _tag: \"square\", side: 5 }\n   *\n   * assert.strictEqual(isCircle(shape1), true)\n   * assert.strictEqual(isCircle(shape2), false)\n   *\n   * if (isCircle(shape1)) {\n   *   // shape1 is now narrowed to { _tag: \"circle\"; radius: number }\n   *   assert.strictEqual(shape1.radius, 10)\n   * }\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <K extends string>(self: unknown, tag: K): self is { _tag: K }\n} = dual(\n  2,\n  <K extends string>(self: unknown, tag: K): self is { _tag: K } => hasProperty(self, \"_tag\") && self[\"_tag\"] === tag\n)\n\n/**\n * A refinement that checks if a value is either `null` or `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNullable } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNullable(null), true)\n * assert.strictEqual(isNullable(undefined), true)\n *\n * assert.strictEqual(isNullable(0), false)\n * assert.strictEqual(isNullable(\"\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isNotNullable\n */\nexport const isNullable = <A>(input: A): input is Extract<A, null | undefined> => input === null || input === undefined\n\n/**\n * A refinement that checks if a value is neither `null` nor `undefined`.\n * The type is narrowed to `NonNullable<A>`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotNullable } from \"effect/Predicate\"\n *\n * assert.strictEqual(isNotNullable(0), true)\n * assert.strictEqual(isNotNullable(\"hello\"), true)\n *\n * assert.strictEqual(isNotNullable(null), false)\n * assert.strictEqual(isNotNullable(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isNullable\n */\nexport const isNotNullable = <A>(input: A): input is NonNullable<A> => input !== null && input !== undefined\n\n/**\n * A refinement that checks if a value is an instance of `Error`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isError } from \"effect/Predicate\"\n *\n * assert.strictEqual(isError(new Error(\"boom\")), true)\n * assert.strictEqual(isError(new TypeError(\"boom\")), true)\n *\n * assert.strictEqual(isError({ message: \"boom\" }), false)\n * assert.strictEqual(isError(\"boom\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isError = (input: unknown): input is Error => input instanceof Error\n\n/**\n * A refinement that checks if a value is a `Uint8Array`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUint8Array } from \"effect/Predicate\"\n *\n * assert.strictEqual(isUint8Array(new Uint8Array()), true)\n *\n * assert.strictEqual(isUint8Array(new Uint16Array()), false)\n * assert.strictEqual(isUint8Array([1, 2, 3]), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUint8Array = (input: unknown): input is Uint8Array => input instanceof Uint8Array\n\n/**\n * A refinement that checks if a value is a `Date` object.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isDate } from \"effect/Predicate\"\n *\n * assert.strictEqual(isDate(new Date()), true)\n *\n * assert.strictEqual(isDate(Date.now()), false) // `Date.now()` returns a number\n * assert.strictEqual(isDate(\"2023-01-01\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isDate = (input: unknown): input is Date => input instanceof Date\n\n/**\n * A refinement that checks if a value is an `Iterable`.\n * Many built-in types are iterable, such as `Array`, `string`, `Map`, and `Set`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isIterable } from \"effect/Predicate\"\n *\n * assert.strictEqual(isIterable([]), true)\n * assert.strictEqual(isIterable(\"hello\"), true)\n * assert.strictEqual(isIterable(new Set()), true)\n *\n * assert.strictEqual(isIterable({}), false)\n * assert.strictEqual(isIterable(123), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isIterable = (input: unknown): input is Iterable<unknown> =>\n  typeof input === \"string\" || hasProperty(input, Symbol.iterator)\n\n/**\n * A refinement that checks if a value is a record (i.e., a plain object).\n * This check returns `false` for arrays, `null`, and functions.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isRecord } from \"effect/Predicate\"\n *\n * assert.strictEqual(isRecord({}), true)\n * assert.strictEqual(isRecord({ a: 1 }), true)\n *\n * assert.strictEqual(isRecord([]), false)\n * assert.strictEqual(isRecord(new Date()), false)\n * assert.strictEqual(isRecord(null), false)\n * assert.strictEqual(isRecord(() => null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isObject\n */\nexport const isRecord = (input: unknown): input is { [x: string | symbol]: unknown } =>\n  isRecordOrArray(input) && !Array.isArray(input)\n\n/**\n * A refinement that checks if a value is a readonly record (i.e., a plain object).\n * This check returns `false` for arrays, `null`, and functions.\n *\n * This is an alias for `isRecord`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isReadonlyRecord } from \"effect/Predicate\"\n *\n * assert.strictEqual(isReadonlyRecord({}), true)\n * assert.strictEqual(isReadonlyRecord({ a: 1 }), true)\n *\n * assert.strictEqual(isReadonlyRecord([]), false)\n * assert.strictEqual(isReadonlyRecord(null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isReadonlyRecord: (\n  input: unknown\n) => input is { readonly [x: string | symbol]: unknown } = isRecord\n\n/**\n * A refinement that checks if a value is a `Promise`. It performs a duck-typing check\n * for `.then` and `.catch` methods.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isPromise } from \"effect/Predicate\"\n *\n * assert.strictEqual(isPromise(Promise.resolve(1)), true)\n * assert.strictEqual(isPromise(new Promise(() => {})), true)\n *\n * assert.strictEqual(isPromise({ then() {} }), false) // Missing .catch\n * assert.strictEqual(isPromise({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isPromiseLike\n */\nexport const isPromise = (\n  input: unknown\n): input is Promise<unknown> =>\n  hasProperty(input, \"then\") && \"catch\" in input && isFunction(input.then) && isFunction(input.catch)\n\n/**\n * A refinement that checks if a value is `PromiseLike`. It performs a duck-typing\n * check for a `.then` method.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isPromiseLike } from \"effect/Predicate\"\n *\n * assert.strictEqual(isPromiseLike(Promise.resolve(1)), true)\n * assert.strictEqual(isPromiseLike({ then: () => {} }), true)\n *\n * assert.strictEqual(isPromiseLike({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n * @see isPromise\n */\nexport const isPromiseLike = (\n  input: unknown\n): input is PromiseLike<unknown> => hasProperty(input, \"then\") && isFunction(input.then)\n\n/**\n * A refinement that checks if a value is a `RegExp`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * assert.strictEqual(Predicate.isRegExp(/a/), true)\n * assert.strictEqual(Predicate.isRegExp(new RegExp(\"a\")), true)\n *\n * assert.strictEqual(Predicate.isRegExp(\"/a/\"), false)\n * ```\n *\n * @category guards\n * @since 3.9.0\n */\nexport const isRegExp = (input: unknown): input is RegExp => input instanceof RegExp\n\n/**\n * Composes a `Refinement` with another `Refinement` or `Predicate`.\n *\n * This can be used to chain checks. The first refinement is applied, and if it\n * passes, the second check is applied to the same value, potentially refining\n * the type further.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n * import * as assert from \"node:assert\"\n *\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n * const minLength = (n: number) => (s: string): boolean => s.length >= n\n *\n * // Create a refinement that checks for a string with a minimum length of 3\n * const isLongString = Predicate.compose(isString, minLength(3))\n *\n * let value: unknown = \"hello\"\n *\n * assert.strictEqual(isLongString(value), true)\n * if (isLongString(value)) {\n *   // value is narrowed to string\n *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n * }\n * assert.strictEqual(isLongString(\"hi\"), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const compose: {\n  /**\n   * Composes a `Refinement` with another `Refinement` or `Predicate`.\n   *\n   * This can be used to chain checks. The first refinement is applied, and if it\n   * passes, the second check is applied to the same value, potentially refining\n   * the type further.\n   *\n   * @example\n   * ```ts\n   * import { Predicate } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const minLength = (n: number) => (s: string): boolean => s.length >= n\n   *\n   * // Create a refinement that checks for a string with a minimum length of 3\n   * const isLongString = Predicate.compose(isString, minLength(3))\n   *\n   * let value: unknown = \"hello\"\n   *\n   * assert.strictEqual(isLongString(value), true)\n   * if (isLongString(value)) {\n   *   // value is narrowed to string\n   *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n   * }\n   * assert.strictEqual(isLongString(\"hi\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B extends A, C extends B, D extends C>(bc: Refinement<C, D>): (ab: Refinement<A, B>) => Refinement<A, D>\n  /**\n   * Composes a `Refinement` with another `Refinement` or `Predicate`.\n   *\n   * This can be used to chain checks. The first refinement is applied, and if it\n   * passes, the second check is applied to the same value, potentially refining\n   * the type further.\n   *\n   * @example\n   * ```ts\n   * import { Predicate } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const minLength = (n: number) => (s: string): boolean => s.length >= n\n   *\n   * // Create a refinement that checks for a string with a minimum length of 3\n   * const isLongString = Predicate.compose(isString, minLength(3))\n   *\n   * let value: unknown = \"hello\"\n   *\n   * assert.strictEqual(isLongString(value), true)\n   * if (isLongString(value)) {\n   *   // value is narrowed to string\n   *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n   * }\n   * assert.strictEqual(isLongString(\"hi\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B extends A>(bc: Predicate<NoInfer<B>>): (ab: Refinement<A, B>) => Refinement<A, B>\n  /**\n   * Composes a `Refinement` with another `Refinement` or `Predicate`.\n   *\n   * This can be used to chain checks. The first refinement is applied, and if it\n   * passes, the second check is applied to the same value, potentially refining\n   * the type further.\n   *\n   * @example\n   * ```ts\n   * import { Predicate } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const minLength = (n: number) => (s: string): boolean => s.length >= n\n   *\n   * // Create a refinement that checks for a string with a minimum length of 3\n   * const isLongString = Predicate.compose(isString, minLength(3))\n   *\n   * let value: unknown = \"hello\"\n   *\n   * assert.strictEqual(isLongString(value), true)\n   * if (isLongString(value)) {\n   *   // value is narrowed to string\n   *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n   * }\n   * assert.strictEqual(isLongString(\"hi\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B extends A, C extends B, D extends C>(ab: Refinement<A, B>, bc: Refinement<C, D>): Refinement<A, D>\n  /**\n   * Composes a `Refinement` with another `Refinement` or `Predicate`.\n   *\n   * This can be used to chain checks. The first refinement is applied, and if it\n   * passes, the second check is applied to the same value, potentially refining\n   * the type further.\n   *\n   * @example\n   * ```ts\n   * import { Predicate } from \"effect\"\n   * import * as assert from \"node:assert\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const minLength = (n: number) => (s: string): boolean => s.length >= n\n   *\n   * // Create a refinement that checks for a string with a minimum length of 3\n   * const isLongString = Predicate.compose(isString, minLength(3))\n   *\n   * let value: unknown = \"hello\"\n   *\n   * assert.strictEqual(isLongString(value), true)\n   * if (isLongString(value)) {\n   *   // value is narrowed to string\n   *   assert.strictEqual(value.toUpperCase(), \"HELLO\")\n   * }\n   * assert.strictEqual(isLongString(\"hi\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B extends A>(ab: Refinement<A, B>, bc: Predicate<NoInfer<B>>): Refinement<A, B>\n} = dual(\n  2,\n  <A, B extends A, C extends B, D extends C>(ab: Refinement<A, B>, bc: Refinement<C, D>): Refinement<A, D> =>\n  (a): a is D => ab(a) && bc(a as C)\n)\n\n/**\n * Combines two predicates to test a tuple of two values. The first predicate tests the\n * first element of the tuple, and the second predicate tests the second element.\n *\n * @category combining\n * @since 2.0.0\n */\nexport const product =\n  <A, B>(self: Predicate<A>, that: Predicate<B>): Predicate<readonly [A, B]> /* readonly because contravariant */ =>\n  ([a, b]) => self(a) && that(b)\n\n/**\n * Takes an iterable of predicates and returns a new predicate that tests an array of values.\n * The new predicate returns `true` if each predicate at a given index is satisfied by the\n * value at the same index in the array. The check stops at the length of the shorter of\n * the two iterables (predicates or values).\n *\n * @category combining\n * @since 2.0.0\n * @see tuple for a more powerful, variadic version.\n */\nexport const all = <A>(\n  collection: Iterable<Predicate<A>>\n): Predicate<ReadonlyArray<A>> => {\n  return (as) => {\n    let collectionIndex = 0\n    for (const p of collection) {\n      if (collectionIndex >= as.length) {\n        break\n      }\n      if (p(as[collectionIndex]) === false) {\n        return false\n      }\n      collectionIndex++\n    }\n    return true\n  }\n}\n\n/**\n * Combines a predicate for a single value and an iterable of predicates for the rest of an array.\n * Useful for checking the head and tail of an array separately.\n *\n * @category combining\n * @since 2.0.0\n */\nexport const productMany = <A>(\n  self: Predicate<A>,\n  collection: Iterable<Predicate<A>>\n): Predicate<readonly [A, ...Array<A>]> /* readonly because contravariant */ => {\n  const rest = all(collection)\n  return ([head, ...tail]) => self(head) === false ? false : rest(tail)\n}\n\n/**\n * Combines an array of predicates into a single predicate that tests an array of values.\n * This function is highly type-aware and will produce a `Refinement` if any of the provided\n * predicates are `Refinement`s, allowing for powerful type-narrowing of tuples.\n *\n * - If all predicates are `Predicate<T>`, the result is `Predicate<[T, T, ...]>`.\n * - If any predicate is a `Refinement<A, B>`, the result is a `Refinement` that narrows\n *   the input tuple type to a more specific tuple type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n *\n * // Create a refinement for a [string, number] tuple\n * const isStringNumberTuple = Predicate.tuple(isString, isNumber)\n *\n * const value: [unknown, unknown] = [\"hello\", 123]\n * if (isStringNumberTuple(value)) {\n *   // value is narrowed to [string, number]\n *   const [s, n] = value\n *   assert.strictEqual(s.toUpperCase(), \"HELLO\")\n *   assert.strictEqual(n.toFixed(2), \"123.00\")\n * }\n * assert.strictEqual(isStringNumberTuple([\"hello\", \"123\"]), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const tuple: {\n  /**\n   * Combines an array of predicates into a single predicate that tests an array of values.\n   * This function is highly type-aware and will produce a `Refinement` if any of the provided\n   * predicates are `Refinement`s, allowing for powerful type-narrowing of tuples.\n   *\n   * - If all predicates are `Predicate<T>`, the result is `Predicate<[T, T, ...]>`.\n   * - If any predicate is a `Refinement<A, B>`, the result is a `Refinement` that narrows\n   *   the input tuple type to a more specific tuple type.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * // Create a refinement for a [string, number] tuple\n   * const isStringNumberTuple = Predicate.tuple(isString, isNumber)\n   *\n   * const value: [unknown, unknown] = [\"hello\", 123]\n   * if (isStringNumberTuple(value)) {\n   *   // value is narrowed to [string, number]\n   *   const [s, n] = value\n   *   assert.strictEqual(s.toUpperCase(), \"HELLO\")\n   *   assert.strictEqual(n.toFixed(2), \"123.00\")\n   * }\n   * assert.strictEqual(isStringNumberTuple([\"hello\", \"123\"]), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <T extends ReadonlyArray<Predicate.Any>>(...elements: T): [Extract<T[number], Refinement.Any>] extends [never] ? Predicate<{ readonly [I in keyof T]: Predicate.In<T[I]> }>\n    : Refinement<\n      { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.In<T[I]> : Predicate.In<T[I]> },\n      { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.Out<T[I]> : Predicate.In<T[I]> }\n    >\n} = (...elements: ReadonlyArray<Predicate.Any>) => all(elements) as any\n\n/**\n * Combines a record of predicates into a single predicate that tests a record of values.\n * This function is highly type-aware and will produce a `Refinement` if any of the provided\n * predicates are `Refinement`s, allowing for powerful type-narrowing of structs.\n *\n * - If all predicates are `Predicate<T>`, the result is `Predicate<{ k: T, ... }>`.\n * - If any predicate is a `Refinement<A, B>`, the result is a `Refinement` that narrows\n *   the input record type to a more specific record type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n *\n * const personPredicate = Predicate.struct({\n *   name: isString,\n *   age: isNumber\n * })\n *\n * const value: { name: unknown; age: unknown } = { name: \"Alice\", age: 30 }\n * if (personPredicate(value)) {\n *   // value is narrowed to { name: string; age: number }\n *   assert.strictEqual(value.name.toUpperCase(), \"ALICE\")\n *   assert.strictEqual(value.age.toFixed(0), \"30\")\n * }\n * assert.strictEqual(personPredicate({ name: \"Bob\", age: \"40\" }), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const struct: {\n  /**\n   * Combines a record of predicates into a single predicate that tests a record of values.\n   * This function is highly type-aware and will produce a `Refinement` if any of the provided\n   * predicates are `Refinement`s, allowing for powerful type-narrowing of structs.\n   *\n   * - If all predicates are `Predicate<T>`, the result is `Predicate<{ k: T, ... }>`.\n   * - If any predicate is a `Refinement<A, B>`, the result is a `Refinement` that narrows\n   *   the input record type to a more specific record type.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const personPredicate = Predicate.struct({\n   *   name: isString,\n   *   age: isNumber\n   * })\n   *\n   * const value: { name: unknown; age: unknown } = { name: \"Alice\", age: 30 }\n   * if (personPredicate(value)) {\n   *   // value is narrowed to { name: string; age: number }\n   *   assert.strictEqual(value.name.toUpperCase(), \"ALICE\")\n   *   assert.strictEqual(value.age.toFixed(0), \"30\")\n   * }\n   * assert.strictEqual(personPredicate({ name: \"Bob\", age: \"40\" }), false)\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <R extends Record<string, Predicate.Any>>(fields: R): [Extract<R[keyof R], Refinement.Any>] extends [never] ?\n    Predicate<{ readonly [K in keyof R]: Predicate.In<R[K]> }> :\n    Refinement<\n      { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.In<R[K]> : Predicate.In<R[K]> },\n      { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.Out<R[K]> : Predicate.In<R[K]> }\n    >\n} = (<R extends Record<string, Predicate.Any>>(fields: R) => {\n  const keys = Object.keys(fields)\n  return (a: Record<string, unknown>) => {\n    for (const key of keys) {\n      if (!fields[key](a[key] as never)) {\n        return false\n      }\n    }\n    return true\n  }\n}) as any\n\n/**\n * Returns a new predicate that is the logical negation of the given predicate.\n *\n * **Note**: If the input is a `Refinement`, the resulting predicate will be a\n * simple `Predicate`, as TypeScript cannot infer the negative type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate, Number } from \"effect\"\n *\n * const isNonPositive = Predicate.not(Number.greaterThan(0))\n *\n * assert.strictEqual(isNonPositive(-1), true)\n * assert.strictEqual(isNonPositive(0), true)\n * assert.strictEqual(isNonPositive(1), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const not = <A>(self: Predicate<A>): Predicate<A> => (a) => !self(a)\n\n/**\n * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n * if at least one of the predicates returns `true`.\n *\n * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n * union of their target types (`B | C`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n *\n * const isStringOrNumber = Predicate.or(isString, isNumber)\n *\n * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n * assert.strictEqual(isStringOrNumber(123), true)\n * assert.strictEqual(isStringOrNumber(null), false)\n *\n * const value: unknown = \"world\"\n * if (isStringOrNumber(value)) {\n *   // value is narrowed to string | number\n *   console.log(value)\n * }\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const or: {\n  /**\n   * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n   * if at least one of the predicates returns `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * union of their target types (`B | C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const isStringOrNumber = Predicate.or(isString, isNumber)\n   *\n   * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n   * assert.strictEqual(isStringOrNumber(123), true)\n   * assert.strictEqual(isStringOrNumber(null), false)\n   *\n   * const value: unknown = \"world\"\n   * if (isStringOrNumber(value)) {\n   *   // value is narrowed to string | number\n   *   console.log(value)\n   * }\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B | C>\n  /**\n   * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n   * if at least one of the predicates returns `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * union of their target types (`B | C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const isStringOrNumber = Predicate.or(isString, isNumber)\n   *\n   * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n   * assert.strictEqual(isStringOrNumber(123), true)\n   * assert.strictEqual(isStringOrNumber(null), false)\n   *\n   * const value: unknown = \"world\"\n   * if (isStringOrNumber(value)) {\n   *   // value is narrowed to string | number\n   *   console.log(value)\n   * }\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B | C>\n  /**\n   * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n   * if at least one of the predicates returns `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * union of their target types (`B | C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const isStringOrNumber = Predicate.or(isString, isNumber)\n   *\n   * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n   * assert.strictEqual(isStringOrNumber(123), true)\n   * assert.strictEqual(isStringOrNumber(null), false)\n   *\n   * const value: unknown = \"world\"\n   * if (isStringOrNumber(value)) {\n   *   // value is narrowed to string | number\n   *   console.log(value)\n   * }\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"OR\". The resulting predicate returns `true`\n   * if at least one of the predicates returns `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * union of their target types (`B | C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isString = (u: unknown): u is string => typeof u === \"string\"\n   * const isNumber = (u: unknown): u is number => typeof u === \"number\"\n   *\n   * const isStringOrNumber = Predicate.or(isString, isNumber)\n   *\n   * assert.strictEqual(isStringOrNumber(\"hello\"), true)\n   * assert.strictEqual(isStringOrNumber(123), true)\n   * assert.strictEqual(isStringOrNumber(null), false)\n   *\n   * const value: unknown = \"world\"\n   * if (isStringOrNumber(value)) {\n   *   // value is narrowed to string | number\n   *   console.log(value)\n   * }\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) || that(a))\n\n/**\n * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n * only if both of the predicates return `true`.\n *\n * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n * intersection of their target types (`B & C`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * type Person = { name: string }\n * type Employee = { id: number }\n *\n * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n *\n * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n *\n * const val: unknown = { name: \"Alice\", id: 123 }\n * if (isPersonAndEmployee(val)) {\n *   // val is narrowed to Person & Employee\n *   assert.strictEqual(val.name, \"Alice\")\n *   assert.strictEqual(val.id, 123)\n * }\n *\n * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const and: {\n  /**\n   * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n   * only if both of the predicates return `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * intersection of their target types (`B & C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type Person = { name: string }\n   * type Employee = { id: number }\n   *\n   * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n   * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n   *\n   * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n   *\n   * const val: unknown = { name: \"Alice\", id: 123 }\n   * if (isPersonAndEmployee(val)) {\n   *   // val is narrowed to Person & Employee\n   *   assert.strictEqual(val.name, \"Alice\")\n   *   assert.strictEqual(val.id, 123)\n   * }\n   *\n   * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n   * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>\n  /**\n   * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n   * only if both of the predicates return `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * intersection of their target types (`B & C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type Person = { name: string }\n   * type Employee = { id: number }\n   *\n   * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n   * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n   *\n   * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n   *\n   * const val: unknown = { name: \"Alice\", id: 123 }\n   * if (isPersonAndEmployee(val)) {\n   *   // val is narrowed to Person & Employee\n   *   assert.strictEqual(val.name, \"Alice\")\n   *   assert.strictEqual(val.id, 123)\n   * }\n   *\n   * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n   * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>\n  /**\n   * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n   * only if both of the predicates return `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * intersection of their target types (`B & C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type Person = { name: string }\n   * type Employee = { id: number }\n   *\n   * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n   * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n   *\n   * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n   *\n   * const val: unknown = { name: \"Alice\", id: 123 }\n   * if (isPersonAndEmployee(val)) {\n   *   // val is narrowed to Person & Employee\n   *   assert.strictEqual(val.name, \"Alice\")\n   *   assert.strictEqual(val.id, 123)\n   * }\n   *\n   * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n   * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"AND\". The resulting predicate returns `true`\n   * only if both of the predicates return `true`.\n   *\n   * If both predicates are `Refinement`s, the resulting predicate is a `Refinement` to the\n   * intersection of their target types (`B & C`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type Person = { name: string }\n   * type Employee = { id: number }\n   *\n   * const hasName = (u: unknown): u is Person => Predicate.hasProperty(u, \"name\") && typeof (u as any).name === \"string\"\n   * const hasId = (u: unknown): u is Employee => Predicate.hasProperty(u, \"id\") && typeof (u as any).id === \"number\"\n   *\n   * const isPersonAndEmployee = Predicate.and(hasName, hasId)\n   *\n   * const val: unknown = { name: \"Alice\", id: 123 }\n   * if (isPersonAndEmployee(val)) {\n   *   // val is narrowed to Person & Employee\n   *   assert.strictEqual(val.name, \"Alice\")\n   *   assert.strictEqual(val.id, 123)\n   * }\n   *\n   * assert.strictEqual(isPersonAndEmployee({ name: \"Bob\" }), false) // Missing id\n   * assert.strictEqual(isPersonAndEmployee({ id: 456 }), false) // Missing name\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) && that(a))\n\n/**\n * Combines two predicates with a logical \"XOR\" (exclusive OR). The resulting predicate\n * returns `true` if one of the predicates returns `true`, but not both.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isPositive = (n: number) => n > 0\n * const isEven = (n: number) => n % 2 === 0\n *\n * const isPositiveXorEven = Predicate.xor(isPositive, isEven)\n *\n * assert.strictEqual(isPositiveXorEven(4), false)  // both true -> false\n * assert.strictEqual(isPositiveXorEven(3), true)   // one true -> true\n * assert.strictEqual(isPositiveXorEven(-2), true)  // one true -> true\n * assert.strictEqual(isPositiveXorEven(-1), false) // both false -> false\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const xor: {\n  /**\n   * Combines two predicates with a logical \"XOR\" (exclusive OR). The resulting predicate\n   * returns `true` if one of the predicates returns `true`, but not both.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isPositive = (n: number) => n > 0\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * const isPositiveXorEven = Predicate.xor(isPositive, isEven)\n   *\n   * assert.strictEqual(isPositiveXorEven(4), false)  // both true -> false\n   * assert.strictEqual(isPositiveXorEven(3), true)   // one true -> true\n   * assert.strictEqual(isPositiveXorEven(-2), true)  // one true -> true\n   * assert.strictEqual(isPositiveXorEven(-1), false) // both false -> false\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"XOR\" (exclusive OR). The resulting predicate\n   * returns `true` if one of the predicates returns `true`, but not both.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isPositive = (n: number) => n > 0\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * const isPositiveXorEven = Predicate.xor(isPositive, isEven)\n   *\n   * assert.strictEqual(isPositiveXorEven(4), false)  // both true -> false\n   * assert.strictEqual(isPositiveXorEven(3), true)   // one true -> true\n   * assert.strictEqual(isPositiveXorEven(-2), true)  // one true -> true\n   * assert.strictEqual(isPositiveXorEven(-1), false) // both false -> false\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) !== that(a))\n\n/**\n * Combines two predicates with a logical \"EQV\" (equivalence). The resulting predicate\n * returns `true` if both predicates return the same boolean value (both `true` or both `false`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isPositive = (n: number) => n > 0\n * const isEven = (n: number) => n % 2 === 0\n *\n * const isPositiveEqvEven = Predicate.eqv(isPositive, isEven)\n *\n * assert.strictEqual(isPositiveEqvEven(4), true)   // both true -> true\n * assert.strictEqual(isPositiveEqvEven(3), false)  // different -> false\n * assert.strictEqual(isPositiveEqvEven(-2), false) // different -> false\n * assert.strictEqual(isPositiveEqvEven(-1), true)  // both false -> true\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const eqv: {\n  /**\n   * Combines two predicates with a logical \"EQV\" (equivalence). The resulting predicate\n   * returns `true` if both predicates return the same boolean value (both `true` or both `false`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isPositive = (n: number) => n > 0\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * const isPositiveEqvEven = Predicate.eqv(isPositive, isEven)\n   *\n   * assert.strictEqual(isPositiveEqvEven(4), true)   // both true -> true\n   * assert.strictEqual(isPositiveEqvEven(3), false)  // different -> false\n   * assert.strictEqual(isPositiveEqvEven(-2), false) // different -> false\n   * assert.strictEqual(isPositiveEqvEven(-1), true)  // both false -> true\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"EQV\" (equivalence). The resulting predicate\n   * returns `true` if both predicates return the same boolean value (both `true` or both `false`).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * const isPositive = (n: number) => n > 0\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * const isPositiveEqvEven = Predicate.eqv(isPositive, isEven)\n   *\n   * assert.strictEqual(isPositiveEqvEven(4), true)   // both true -> true\n   * assert.strictEqual(isPositiveEqvEven(3), false)  // different -> false\n   * assert.strictEqual(isPositiveEqvEven(-2), false) // different -> false\n   * assert.strictEqual(isPositiveEqvEven(-1), true)  // both false -> true\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) === that(a))\n\n/**\n * Creates a predicate that represents a logical \"if-then\" rule.\n *\n * Think of it as a conditional promise: **\"If `antecedent` holds true, then I promise `consequent` will also be true.\"**\n *\n * This function is invaluable for defining complex validation logic where one condition dictates another.\n *\n * ### How It Works\n *\n * The rule only fails (returns `false`) when the \"if\" part is `true`, but the \"then\" part is `false`.\n * In all other cases, the promise is considered kept, and the result is `true`.\n *\n * This includes the concept of **\"vacuous truth\"**: if the \"if\" part is `false`, the rule doesn't apply,\n * so the promise isn't broken, and the result is `true`. (e.g., \"If it rains, I'll bring an umbrella.\"\n * If it doesn't rain, you haven't broken your promise, no matter what).\n *\n * ### Key Details\n *\n * - **Logical Equivalence**: `implies(p, q)` is the same as `not(p).or(q)`, or simply `!p || q`\n *   in plain JavaScript. This can be a helpful way to reason about its behavior.\n *\n * - **Type-Safety Warning**: This function always returns a `Predicate`, never a type-narrowing\n *   `Refinement`. A `true` result doesn't guarantee the `consequent` passed (it could be `true`\n *   simply because the `antecedent` was `false`), so it cannot be used to safely narrow a type.\n *\n * @example\n * ```ts\n * // Rule: A user can only be an admin if they also belong to the \"staff\" group.\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * type User = {\n *   isStaff: boolean\n *   isAdmin: boolean\n * }\n *\n * const isValidUserPermission = Predicate.implies(\n *   // antecedent: \"if\" the user is an admin...\n *   (user: User) => user.isAdmin,\n *   // consequent: \"then\" they must be staff.\n *   (user: User) => user.isStaff\n * )\n *\n * // A non-admin who is not staff. Rule doesn't apply (antecedent is false).\n * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: false }), true)\n *\n * // A staff member who is not an admin. Rule doesn't apply (antecedent is false).\n * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: false }), true)\n *\n * // An admin who is also staff. The rule was followed.\n * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: true }), true)\n *\n * // An admin who is NOT staff. The rule was broken!\n * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: true }), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const implies: {\n  /**\n   * Creates a predicate that represents a logical \"if-then\" rule.\n   *\n   * Think of it as a conditional promise: **\"If `antecedent` holds true, then I promise `consequent` will also be true.\"**\n   *\n   * This function is invaluable for defining complex validation logic where one condition dictates another.\n   *\n   * ### How It Works\n   *\n   * The rule only fails (returns `false`) when the \"if\" part is `true`, but the \"then\" part is `false`.\n   * In all other cases, the promise is considered kept, and the result is `true`.\n   *\n   * This includes the concept of **\"vacuous truth\"**: if the \"if\" part is `false`, the rule doesn't apply,\n   * so the promise isn't broken, and the result is `true`. (e.g., \"If it rains, I'll bring an umbrella.\"\n   * If it doesn't rain, you haven't broken your promise, no matter what).\n   *\n   * ### Key Details\n   *\n   * - **Logical Equivalence**: `implies(p, q)` is the same as `not(p).or(q)`, or simply `!p || q`\n   *   in plain JavaScript. This can be a helpful way to reason about its behavior.\n   *\n   * - **Type-Safety Warning**: This function always returns a `Predicate`, never a type-narrowing\n   *   `Refinement`. A `true` result doesn't guarantee the `consequent` passed (it could be `true`\n   *   simply because the `antecedent` was `false`), so it cannot be used to safely narrow a type.\n   *\n   * @example\n   * ```ts\n   * // Rule: A user can only be an admin if they also belong to the \"staff\" group.\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type User = {\n   *   isStaff: boolean\n   *   isAdmin: boolean\n   * }\n   *\n   * const isValidUserPermission = Predicate.implies(\n   *   // antecedent: \"if\" the user is an admin...\n   *   (user: User) => user.isAdmin,\n   *   // consequent: \"then\" they must be staff.\n   *   (user: User) => user.isStaff\n   * )\n   *\n   * // A non-admin who is not staff. Rule doesn't apply (antecedent is false).\n   * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: false }), true)\n   *\n   * // A staff member who is not an admin. Rule doesn't apply (antecedent is false).\n   * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: false }), true)\n   *\n   * // An admin who is also staff. The rule was followed.\n   * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: true }), true)\n   *\n   * // An admin who is NOT staff. The rule was broken!\n   * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: true }), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(consequent: Predicate<A>): (antecedent: Predicate<A>) => Predicate<A>\n  /**\n   * Creates a predicate that represents a logical \"if-then\" rule.\n   *\n   * Think of it as a conditional promise: **\"If `antecedent` holds true, then I promise `consequent` will also be true.\"**\n   *\n   * This function is invaluable for defining complex validation logic where one condition dictates another.\n   *\n   * ### How It Works\n   *\n   * The rule only fails (returns `false`) when the \"if\" part is `true`, but the \"then\" part is `false`.\n   * In all other cases, the promise is considered kept, and the result is `true`.\n   *\n   * This includes the concept of **\"vacuous truth\"**: if the \"if\" part is `false`, the rule doesn't apply,\n   * so the promise isn't broken, and the result is `true`. (e.g., \"If it rains, I'll bring an umbrella.\"\n   * If it doesn't rain, you haven't broken your promise, no matter what).\n   *\n   * ### Key Details\n   *\n   * - **Logical Equivalence**: `implies(p, q)` is the same as `not(p).or(q)`, or simply `!p || q`\n   *   in plain JavaScript. This can be a helpful way to reason about its behavior.\n   *\n   * - **Type-Safety Warning**: This function always returns a `Predicate`, never a type-narrowing\n   *   `Refinement`. A `true` result doesn't guarantee the `consequent` passed (it could be `true`\n   *   simply because the `antecedent` was `false`), so it cannot be used to safely narrow a type.\n   *\n   * @example\n   * ```ts\n   * // Rule: A user can only be an admin if they also belong to the \"staff\" group.\n   * import * as assert from \"node:assert\"\n   * import { Predicate } from \"effect\"\n   *\n   * type User = {\n   *   isStaff: boolean\n   *   isAdmin: boolean\n   * }\n   *\n   * const isValidUserPermission = Predicate.implies(\n   *   // antecedent: \"if\" the user is an admin...\n   *   (user: User) => user.isAdmin,\n   *   // consequent: \"then\" they must be staff.\n   *   (user: User) => user.isStaff\n   * )\n   *\n   * // A non-admin who is not staff. Rule doesn't apply (antecedent is false).\n   * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: false }), true)\n   *\n   * // A staff member who is not an admin. Rule doesn't apply (antecedent is false).\n   * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: false }), true)\n   *\n   * // An admin who is also staff. The rule was followed.\n   * assert.strictEqual(isValidUserPermission({ isStaff: true, isAdmin: true }), true)\n   *\n   * // An admin who is NOT staff. The rule was broken!\n   * assert.strictEqual(isValidUserPermission({ isStaff: false, isAdmin: true }), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A> => (a) => antecedent(a) ? consequent(a) : true\n)\n\n/**\n * Combines two predicates with a logical \"NOR\" (negated OR). The resulting predicate\n * returns `true` only if both predicates return `false`.\n * This is equivalent to `not(or(p, q))`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const nor: {\n  /**\n   * Combines two predicates with a logical \"NOR\" (negated OR). The resulting predicate\n   * returns `true` only if both predicates return `false`.\n   * This is equivalent to `not(or(p, q))`.\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"NOR\" (negated OR). The resulting predicate\n   * returns `true` only if both predicates return `false`.\n   * This is equivalent to `not(or(p, q))`.\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => !(self(a) || that(a))\n)\n\n/**\n * Combines two predicates with a logical \"NAND\" (negated AND). The resulting predicate\n * returns `true` if at least one of the predicates returns `false`.\n * This is equivalent to `not(and(p, q))`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const nand: {\n  /**\n   * Combines two predicates with a logical \"NAND\" (negated AND). The resulting predicate\n   * returns `true` if at least one of the predicates returns `false`.\n   * This is equivalent to `not(and(p, q))`.\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  /**\n   * Combines two predicates with a logical \"NAND\" (negated AND). The resulting predicate\n   * returns `true` if at least one of the predicates returns `false`.\n   * This is equivalent to `not(and(p, q))`.\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => !(self(a) && that(a))\n)\n\n/**\n * Takes an iterable of predicates and returns a new predicate. The new predicate\n * returns `true` if all predicates in the collection return `true` for a given value.\n *\n * This is like `Array.prototype.every` but for a collection of predicates.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isPositive = (n: number) => n > 0\n * const isEven = (n: number) => n % 2 === 0\n *\n * const isPositiveAndEven = Predicate.every([isPositive, isEven])\n *\n * assert.strictEqual(isPositiveAndEven(4), true)\n * assert.strictEqual(isPositiveAndEven(3), false)\n * assert.strictEqual(isPositiveAndEven(-2), false)\n * ```\n *\n * @category elements\n * @since 2.0.0\n * @see some\n */\nexport const every = <A>(collection: Iterable<Predicate<A>>): Predicate<A> => (a: A) => {\n  for (const p of collection) {\n    if (!p(a)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Takes an iterable of predicates and returns a new predicate. The new predicate\n * returns `true` if at least one predicate in the collection returns `true` for a given value.\n *\n * This is like `Array.prototype.some` but for a collection of predicates.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const isNegative = (n: number) => n < 0\n * const isOdd = (n: number) => n % 2 !== 0\n *\n * const isNegativeOrOdd = Predicate.some([isNegative, isOdd])\n *\n * assert.strictEqual(isNegativeOrOdd(-2), true) // isNegative is true\n * assert.strictEqual(isNegativeOrOdd(3), true)  // isOdd is true\n * assert.strictEqual(isNegativeOrOdd(4), false) // both are false\n * ```\n *\n * @category elements\n * @since 2.0.0\n * @see every\n */\nexport const some = <A>(collection: Iterable<Predicate<A>>): Predicate<A> => (a) => {\n  for (const p of collection) {\n    if (p(a)) {\n      return true\n    }\n  }\n  return false\n}\n","/**\n * @since 2.0.0\n */\nimport { identity } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport type { Kind, TypeLambda } from \"./HKT.js\"\nimport { getBugErrorMessage } from \"./internal/errors.js\"\nimport { isNullable, isObject } from \"./Predicate.js\"\nimport type * as Types from \"./Types.js\"\n\n/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 2.0.0\n */\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const GenKindTypeId: unique symbol = Symbol.for(\"effect/Gen/GenKind\")\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport type GenKindTypeId = typeof GenKindTypeId\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface GenKind<F extends TypeLambda, R, O, E, A> extends Variance<F, R, O, E> {\n  readonly value: Kind<F, R, O, E, A>\n\n  [Symbol.iterator](): IterableIterator<GenKind<F, R, O, E, A>, A>\n}\n\n/**\n * @category predicates\n * @since 3.0.6\n */\nexport const isGenKind = (u: unknown): u is GenKind<any, any, any, any, any> => isObject(u) && GenKindTypeId in u\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport class GenKindImpl<F extends TypeLambda, R, O, E, A> implements GenKind<F, R, O, E, A> {\n  constructor(\n    /**\n     * @since 2.0.0\n     */\n    readonly value: Kind<F, R, O, E, A>\n  ) {}\n\n  /**\n   * @since 2.0.0\n   */\n  get _F() {\n    return identity\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _R() {\n    return (_: R) => _\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _O() {\n    return (_: never): O => _\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  get _E() {\n    return (_: never): E => _\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  readonly [GenKindTypeId]: typeof GenKindTypeId = GenKindTypeId;\n\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator](): IterableIterator<GenKind<F, R, O, E, A>, A> {\n    return new SingleShotGen<GenKind<F, R, O, E, A>, A>(this as any)\n  }\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport class SingleShotGen<T, A> implements IterableIterator<T, A> {\n  private called = false\n\n  constructor(readonly self: T) {}\n\n  /**\n   * @since 2.0.0\n   */\n  next(a: A): IteratorResult<T, A> {\n    return this.called ?\n      ({\n        value: a,\n        done: true\n      }) :\n      (this.called = true,\n        ({\n          value: this.self,\n          done: false\n        }))\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  return(a: A): IteratorResult<T, A> {\n    return ({\n      value: a,\n      done: true\n    })\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  throw(e: unknown): IteratorResult<T, A> {\n    throw e\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator](): IterableIterator<T, A> {\n    return new SingleShotGen<T, A>(this.self)\n  }\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const makeGenKind = <F extends TypeLambda, R, O, E, A>(\n  kind: Kind<F, R, O, E, A>\n): GenKind<F, R, O, E, A> => new GenKindImpl(kind)\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Variance<in out F extends TypeLambda, in R, out O, out E> {\n  readonly [GenKindTypeId]: GenKindTypeId\n  readonly _F: Types.Invariant<F>\n  readonly _R: Types.Contravariant<R>\n  readonly _O: Types.Covariant<O>\n  readonly _E: Types.Covariant<E>\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Gen<F extends TypeLambda, Z> {\n  <Self, K extends Variance<F, any, any, any> | YieldWrap<Kind<F, any, any, any, any>>, A>(\n    ...args:\n      | [\n        self: Self,\n        body: (this: Self, resume: Z) => Generator<K, A, never>\n      ]\n      | [\n        body: (resume: Z) => Generator<K, A, never>\n      ]\n  ): Kind<\n    F,\n    [K] extends [Variance<F, infer R, any, any>] ? R\n      : [K] extends [YieldWrap<Kind<F, infer R, any, any, any>>] ? R\n      : never,\n    [K] extends [Variance<F, any, infer O, any>] ? O\n      : [K] extends [YieldWrap<Kind<F, any, infer O, any, any>>] ? O\n      : never,\n    [K] extends [Variance<F, any, any, infer E>] ? E\n      : [K] extends [YieldWrap<Kind<F, any, any, infer E, any>>] ? E\n      : never,\n    A\n  >\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Adapter<Z extends TypeLambda> {\n  <_R, _O, _E, _A>(\n    self: Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, _R, _O, _E, _A>(a: A, ab: (a: A) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>\n  <A, B, _R, _O, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: F) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n}\n\n/**\n * @category adapters\n * @since 2.0.0\n */\nexport const adapter: <F extends TypeLambda>() => Adapter<F> = () => (function() {\n  let x = arguments[0]\n  for (let i = 1; i < arguments.length; i++) {\n    x = arguments[i](x)\n  }\n  return new GenKindImpl(x) as any\n})\n\nconst defaultIncHi = 0x14057b7e\nconst defaultIncLo = 0xf767814f\nconst MUL_HI = 0x5851f42d >>> 0\nconst MUL_LO = 0x4c957f2d >>> 0\nconst BIT_53 = 9007199254740992.0\nconst BIT_27 = 134217728.0\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport type PCGRandomState = [number, number, number, number]\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport type OptionalNumber = number | null | undefined\n\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 2.0.0\n */\nexport class PCGRandom {\n  private _state!: Int32Array\n\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * - `seed` - The low 32 bits of the seed (0 is used for high 32 bits).\n   *\n   * @memberOf PCGRandom\n   */\n  constructor(seed?: OptionalNumber)\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * - `seedHi` - The high 32 bits of the seed.\n   * - `seedLo` - The low 32 bits of the seed.\n   * - `inc` - The low 32 bits of the incrementer (0 is used for high 32 bits).\n   *\n   * @memberOf PCGRandom\n   */\n  constructor(seedHi: OptionalNumber, seedLo: OptionalNumber, inc?: OptionalNumber)\n  /**\n   * Creates an instance of PCGRandom.\n   *\n   * - `seedHi` - The high 32 bits of the seed.\n   * - `seedLo` - The low 32 bits of the seed.\n   * - `incHi` - The high 32 bits of the incrementer.\n   * - `incLo` - The low 32 bits of the incrementer.\n   *\n   * @memberOf PCGRandom\n   */\n  constructor(\n    seedHi: OptionalNumber,\n    seedLo: OptionalNumber,\n    incHi: OptionalNumber,\n    incLo: OptionalNumber\n  )\n  constructor(\n    seedHi?: OptionalNumber,\n    seedLo?: OptionalNumber,\n    incHi?: OptionalNumber,\n    incLo?: OptionalNumber\n  ) {\n    if (isNullable(seedLo) && isNullable(seedHi)) {\n      seedLo = (Math.random() * 0xffffffff) >>> 0\n      seedHi = 0\n    } else if (isNullable(seedLo)) {\n      seedLo = seedHi\n      seedHi = 0\n    }\n    if (isNullable(incLo) && isNullable(incHi)) {\n      incLo = this._state ? this._state[3] : defaultIncLo\n      incHi = this._state ? this._state[2] : defaultIncHi\n    } else if (isNullable(incLo)) {\n      incLo = <number> incHi\n      incHi = 0\n    }\n\n    this._state = new Int32Array([0, 0, (<number> incHi) >>> 0, ((incLo || 0) | 1) >>> 0])\n    this._next()\n    add64(\n      this._state,\n      this._state[0]!,\n      this._state[1]!,\n      (<number> seedHi) >>> 0,\n      (<number> seedLo) >>> 0\n    )\n    this._next()\n    return this\n  }\n\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  getState(): PCGRandomState {\n    return [this._state[0]!, this._state[1]!, this._state[2]!, this._state[3]!]\n  }\n\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @since 2.0.0\n   */\n  setState(state: PCGRandomState) {\n    this._state[0] = state[0]\n    this._state[1] = state[1]\n    this._state[2] = state[2]\n    this._state[3] = state[3] | 1\n  }\n\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 2.0.0\n   */\n  integer(max: number) {\n    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max\n  }\n\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0\n    const lo = (this._next() & 0x07ffffff) * 1.0\n    return (hi * BIT_27 + lo) / BIT_53\n  }\n\n  /** @internal */\n  private _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0]! >>> 0\n    const oldLo = this._state[1]! >>> 0\n\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO)\n    add64(this._state, this._state[0]!, this._state[1]!, this._state[2]!, this._state[3]!)\n\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18\n    let xsLo = ((oldLo >>> 18) | (oldHi << 14)) >>> 0\n    xsHi = (xsHi ^ oldHi) >>> 0\n    xsLo = (xsLo ^ oldLo) >>> 0\n    const xorshifted = ((xsLo >>> 27) | (xsHi << 5)) >>> 0\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27\n    const rot2 = ((-rot >>> 0) & 31) >>> 0\n    return ((xorshifted >>> rot) | (xorshifted << rot2)) >>> 0\n  }\n}\n\nfunction mul64(\n  out: Int32Array,\n  aHi: number,\n  aLo: number,\n  bHi: number,\n  bLo: number\n): void {\n  let c1 = ((aLo >>> 16) * (bLo & 0xffff)) >>> 0\n  let c0 = ((aLo & 0xffff) * (bLo >>> 16)) >>> 0\n\n  let lo = ((aLo & 0xffff) * (bLo & 0xffff)) >>> 0\n  let hi = ((aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16))) >>> 0\n\n  c0 = (c0 << 16) >>> 0\n  lo = (lo + c0) >>> 0\n  if ((lo >>> 0) < (c0 >>> 0)) {\n    hi = (hi + 1) >>> 0\n  }\n\n  c1 = (c1 << 16) >>> 0\n  lo = (lo + c1) >>> 0\n  if ((lo >>> 0) < (c1 >>> 0)) {\n    hi = (hi + 1) >>> 0\n  }\n\n  hi = (hi + Math.imul(aLo, bHi)) >>> 0\n  hi = (hi + Math.imul(aHi, bLo)) >>> 0\n\n  out[0] = hi\n  out[1] = lo\n}\n\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(\n  out: Int32Array,\n  aHi: number,\n  aLo: number,\n  bHi: number,\n  bLo: number\n): void {\n  let hi = (aHi + bHi) >>> 0\n  const lo = (aLo + bLo) >>> 0\n  if ((lo >>> 0) < (aLo >>> 0)) {\n    hi = (hi + 1) | 0\n  }\n  out[0] = hi\n  out[1] = lo\n}\n\n/**\n * @since 3.0.6\n */\nexport const YieldWrapTypeId: unique symbol = Symbol.for(\"effect/Utils/YieldWrap\")\n\n/**\n * @since 3.0.6\n */\nexport class YieldWrap<T> {\n  /**\n   * @since 3.0.6\n   */\n  readonly #value: T\n  constructor(value: T) {\n    this.#value = value\n  }\n  /**\n   * @since 3.0.6\n   */\n  [YieldWrapTypeId](): T {\n    return this.#value\n  }\n}\n\n/**\n * @since 3.0.6\n */\nexport function yieldWrapGet<T>(self: YieldWrap<T>): T {\n  if (typeof self === \"object\" && self !== null && YieldWrapTypeId in self) {\n    return self[YieldWrapTypeId]()\n  }\n  throw new Error(getBugErrorMessage(\"yieldWrapGet\"))\n}\n\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nexport const structuralRegionState = globalValue(\n  \"effect/Utils/isStructuralRegion\",\n  (): { enabled: boolean; tester: ((a: unknown, b: unknown) => boolean) | undefined } => ({\n    enabled: false,\n    tester: undefined\n  })\n)\n\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nexport const structuralRegion = <A>(body: () => A, tester?: (a: unknown, b: unknown) => boolean): A => {\n  const current = structuralRegionState.enabled\n  const currentTester = structuralRegionState.tester\n  structuralRegionState.enabled = true\n  if (tester) {\n    structuralRegionState.tester = tester\n  }\n  try {\n    return body()\n  } finally {\n    structuralRegionState.enabled = current\n    structuralRegionState.tester = currentTester\n  }\n}\n\nconst standard = {\n  effect_internal_function: <A>(body: () => A) => {\n    return body()\n  }\n}\n\nconst forced = {\n  effect_internal_function: <A>(body: () => A) => {\n    try {\n      return body()\n    } finally {\n      //\n    }\n  }\n}\n\nconst isNotOptimizedAway =\n  standard.effect_internal_function(() => new Error().stack)?.includes(\"effect_internal_function\") === true\n\n/**\n * @since 3.2.2\n * @status experimental\n * @category tracing\n */\nexport const internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function\n\nconst genConstructor = (function*() {}).constructor\n\n/**\n * @since 3.11.0\n */\nexport const isGeneratorFunction = (u: unknown): u is (...args: Array<any>) => Generator<any, any, any> =>\n  isObject(u) && u.constructor === genConstructor\n","/**\n * @since 2.0.0\n */\nimport { pipe } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport { structuralRegionState } from \"./Utils.js\"\n\n/** @internal */\nconst randomHashCache = globalValue(\n  Symbol.for(\"effect/Hash/randomHashCache\"),\n  () => new WeakMap<object, number>()\n)\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const symbol: unique symbol = Symbol.for(\"effect/Hash\")\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Hash {\n  [symbol](): number\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const hash: <A>(self: A) => number = <A>(self: A) => {\n  if (structuralRegionState.enabled === true) {\n    return 0\n  }\n\n  switch (typeof self) {\n    case \"number\":\n      return number(self)\n    case \"bigint\":\n      return string(self.toString(10))\n    case \"boolean\":\n      return string(String(self))\n    case \"symbol\":\n      return string(String(self))\n    case \"string\":\n      return string(self)\n    case \"undefined\":\n      return string(\"undefined\")\n    case \"function\":\n    case \"object\": {\n      if (self === null) {\n        return string(\"null\")\n      } else if (self instanceof Date) {\n        return hash(self.toISOString())\n      } else if (self instanceof URL) {\n        return hash(self.href)\n      } else if (isHash(self)) {\n        return self[symbol]()\n      } else {\n        return random(self)\n      }\n    }\n    default:\n      throw new Error(\n        `BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`\n      )\n  }\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const random: <A extends object>(self: A) => number = (self) => {\n  if (!randomHashCache.has(self)) {\n    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)))\n  }\n  return randomHashCache.get(self)!\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const combine: (b: number) => (self: number) => number = (b) => (self) => (self * 53) ^ b\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const optimize = (n: number): number => (n & 0xbfffffff) | ((n >>> 1) & 0x40000000)\n\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isHash = (u: unknown): u is Hash => hasProperty(u, symbol)\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const number = (n: number) => {\n  if (n !== n || n === Infinity) {\n    return 0\n  }\n  let h = n | 0\n  if (h !== n) {\n    h ^= n * 0xffffffff\n  }\n  while (n > 0xffffffff) {\n    h ^= n /= 0xffffffff\n  }\n  return optimize(h)\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const string = (str: string) => {\n  let h = 5381, i = str.length\n  while (i) {\n    h = (h * 33) ^ str.charCodeAt(--i)\n  }\n  return optimize(h)\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const structureKeys = <A extends object>(o: A, keys: ReadonlyArray<keyof A>) => {\n  let h = 12289\n  for (let i = 0; i < keys.length; i++) {\n    h ^= pipe(string(keys[i]! as string), combine(hash((o as any)[keys[i]!])))\n  }\n  return optimize(h)\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const structure = <A extends object>(o: A) =>\n  structureKeys(o, Object.keys(o) as unknown as ReadonlyArray<keyof A>)\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const array = <A>(arr: ReadonlyArray<A>) => {\n  let h = 6151\n  for (let i = 0; i < arr.length; i++) {\n    h = pipe(h, combine(hash(arr[i])))\n  }\n  return optimize(h)\n}\n\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const cached: {\n  /**\n   * @since 2.0.0\n   * @category hashing\n   */\n  (self: object): (hash: number) => number\n  /**\n   * @since 2.0.0\n   * @category hashing\n   */\n  (self: object, hash: number): number\n} = function() {\n  if (arguments.length === 1) {\n    const self = arguments[0] as object\n    return function(hash: number) {\n      Object.defineProperty(self, symbol, {\n        value() {\n          return hash\n        },\n        enumerable: false\n      })\n      return hash\n    } as any\n  }\n  const self = arguments[0] as object\n  const hash = arguments[1] as number\n  Object.defineProperty(self, symbol, {\n    value() {\n      return hash\n    },\n    enumerable: false\n  })\n\n  return hash\n}\n","/**\n * @since 2.0.0\n */\nimport type { Equivalence } from \"./Equivalence.js\"\nimport * as Hash from \"./Hash.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport { structuralRegionState } from \"./Utils.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const symbol: unique symbol = Symbol.for(\"effect/Equal\")\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Equal extends Hash.Hash {\n  [symbol](that: Equal): boolean\n}\n\n/**\n * @since 2.0.0\n * @category equality\n */\nexport function equals<B>(that: B): <A>(self: A) => boolean\nexport function equals<A, B>(self: A, that: B): boolean\nexport function equals(): any {\n  if (arguments.length === 1) {\n    return (self: unknown) => compareBoth(self, arguments[0])\n  }\n  return compareBoth(arguments[0], arguments[1])\n}\n\nfunction compareBoth(self: unknown, that: unknown): boolean {\n  if (self === that) {\n    return true\n  }\n  const selfType = typeof self\n  if (selfType !== typeof that) {\n    return false\n  }\n  if (selfType === \"object\" || selfType === \"function\") {\n    if (self !== null && that !== null) {\n      if (isEqual(self) && isEqual(that)) {\n        if (Hash.hash(self) === Hash.hash(that) && self[symbol](that)) {\n          return true\n        } else {\n          return structuralRegionState.enabled && structuralRegionState.tester\n            ? structuralRegionState.tester(self, that)\n            : false\n        }\n      } else if (self instanceof Date && that instanceof Date) {\n        return self.toISOString() === that.toISOString()\n      } else if (self instanceof URL && that instanceof URL) {\n        return self.href === that.href\n      }\n    }\n    if (structuralRegionState.enabled) {\n      if (Array.isArray(self) && Array.isArray(that)) {\n        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]))\n      }\n      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {\n        const keysSelf = Object.keys(self as any)\n        const keysThat = Object.keys(that as any)\n        if (keysSelf.length === keysThat.length) {\n          for (const key of keysSelf) {\n            // @ts-expect-error\n            if (!(key in that && compareBoth(self[key], that[key]))) {\n              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false\n            }\n          }\n          return true\n        }\n      }\n      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false\n    }\n  }\n\n  return structuralRegionState.enabled && structuralRegionState.tester\n    ? structuralRegionState.tester(self, that)\n    : false\n}\n\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isEqual = (u: unknown): u is Equal => hasProperty(u, symbol)\n\n/**\n * @since 2.0.0\n * @category instances\n */\nexport const equivalence: <A>() => Equivalence<A> = () => equals\n","/**\n * @since 2.0.0\n */\nimport type * as FiberRefs from \"./FiberRefs.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport { hasProperty, isFunction } from \"./Predicate.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const NodeInspectSymbol = Symbol.for(\"nodejs.util.inspect.custom\")\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type NodeInspectSymbol = typeof NodeInspectSymbol\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Inspectable {\n  toString(): string\n  toJSON(): unknown\n  [NodeInspectSymbol](): unknown\n}\n\n/**\n * @since 2.0.0\n */\nexport const toJSON = (x: unknown): unknown => {\n  try {\n    if (\n      hasProperty(x, \"toJSON\") && isFunction(x[\"toJSON\"]) &&\n      x[\"toJSON\"].length === 0\n    ) {\n      return x.toJSON()\n    } else if (Array.isArray(x)) {\n      return x.map(toJSON)\n    }\n  } catch {\n    return {}\n  }\n  return redact(x)\n}\n\n/**\n * @since 2.0.0\n */\nexport const format = (x: unknown): string => JSON.stringify(x, null, 2)\n\n/**\n * @since 2.0.0\n */\nexport const BaseProto: Inspectable = {\n  toJSON() {\n    return toJSON(this)\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  toString() {\n    return format(this.toJSON())\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport abstract class Class {\n  /**\n   * @since 2.0.0\n   */\n  abstract toJSON(): unknown\n  /**\n   * @since 2.0.0\n   */\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  /**\n   * @since 2.0.0\n   */\n  toString() {\n    return format(this.toJSON())\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const toStringUnknown = (u: unknown, whitespace: number | string | undefined = 2): string => {\n  if (typeof u === \"string\") {\n    return u\n  }\n  try {\n    return typeof u === \"object\" ? stringifyCircular(u, whitespace) : String(u)\n  } catch {\n    return String(u)\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const stringifyCircular = (obj: unknown, whitespace?: number | string | undefined): string => {\n  let cache: Array<unknown> = []\n  const retVal = JSON.stringify(\n    obj,\n    (_key, value) =>\n      typeof value === \"object\" && value !== null\n        ? cache.includes(value)\n          ? undefined // circular reference\n          : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value)\n            ? value[symbolRedactable](redactableState.fiberRefs)\n            : value)\n        : value,\n    whitespace\n  )\n  ;(cache as any) = undefined\n  return retVal\n}\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport interface Redactable {\n  readonly [symbolRedactable]: (fiberRefs: FiberRefs.FiberRefs) => unknown\n}\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const symbolRedactable: unique symbol = Symbol.for(\"effect/Inspectable/Redactable\")\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const isRedactable = (u: unknown): u is Redactable =>\n  typeof u === \"object\" && u !== null && symbolRedactable in u\n\nconst redactableState = globalValue(\"effect/Inspectable/redactableState\", () => ({\n  fiberRefs: undefined as FiberRefs.FiberRefs | undefined\n}))\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const withRedactableContext = <A>(context: FiberRefs.FiberRefs, f: () => A): A => {\n  const prev = redactableState.fiberRefs\n  redactableState.fiberRefs = context\n  try {\n    return f()\n  } finally {\n    redactableState.fiberRefs = prev\n  }\n}\n\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const redact = (u: unknown): unknown => {\n  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {\n    return u[symbolRedactable](redactableState.fiberRefs)\n  }\n  return u\n}\n","/**\n * @since 2.0.0\n */\n\nimport type { Ctor } from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category Models\n */\nexport interface Pipeable {\n  pipe<A>(this: A): A\n  pipe<A, B = never>(this: A, ab: (_: A) => B): B\n  pipe<A, B = never, C = never>(this: A, ab: (_: A) => B, bc: (_: B) => C): C\n  pipe<A, B = never, C = never, D = never>(this: A, ab: (_: A) => B, bc: (_: B) => C, cd: (_: C) => D): D\n  pipe<A, B = never, C = never, D = never, E = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E\n  ): E\n  pipe<A, B = never, C = never, D = never, E = never, F = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F\n  ): F\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G\n  ): G\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H\n  ): H\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I\n  ): I\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J\n  ): J\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K\n  ): K\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L\n  ): L\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M\n  ): M\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N\n  ): N\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O\n  ): O\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P\n  ): P\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q\n  ): Q\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R\n  ): R\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S\n  ): S\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T\n  ): T\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never,\n    U = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T,\n    tu: (_: T) => U\n  ): U\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never,\n    U = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T,\n    tu: (_: T) => U\n  ): U\n}\n\n/**\n * @since 2.0.0\n */\nexport const pipeArguments = <A>(self: A, args: IArguments): unknown => {\n  switch (args.length) {\n    case 0:\n      return self\n    case 1:\n      return args[0](self)\n    case 2:\n      return args[1](args[0](self))\n    case 3:\n      return args[2](args[1](args[0](self)))\n    case 4:\n      return args[3](args[2](args[1](args[0](self))))\n    case 5:\n      return args[4](args[3](args[2](args[1](args[0](self)))))\n    case 6:\n      return args[5](args[4](args[3](args[2](args[1](args[0](self))))))\n    case 7:\n      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))\n    case 8:\n      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))))\n    case 9:\n      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))))\n    default: {\n      let ret = self\n      for (let i = 0, len = args.length; i < len; i++) {\n        ret = args[i](ret)\n      }\n      return ret\n    }\n  }\n}\n\n/**\n * @since 3.15.0\n * @category Models\n */\nexport interface PipeableConstructor {\n  new(...args: Array<any>): Pipeable\n}\n\n/**\n * @since 3.15.0\n * @category Prototypes\n */\nexport const Prototype: Pipeable = {\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst Base: PipeableConstructor = (function() {\n  function PipeableBase() {}\n  PipeableBase.prototype = Prototype\n  return PipeableBase as any\n})()\n\n/**\n * @since 3.15.0\n * @category Constructors\n */\nexport const Class: {\n  /**\n   * @since 3.15.0\n   * @category Constructors\n   */\n  (): PipeableConstructor\n  /**\n   * @since 3.15.0\n   * @category Constructors\n   */\n  <TBase extends Ctor>(klass: TBase): TBase & PipeableConstructor\n} = (klass?: Ctor) =>\n  klass ?\n    class extends klass {\n      pipe() {\n        return pipeArguments(this, arguments)\n      }\n    }\n    : Base\n","/** @internal */\nexport type OP_ASYNC = typeof OP_ASYNC\n\n/** @internal */\nexport const OP_ASYNC = \"Async\" as const\n\n/** @internal */\nexport type OP_COMMIT = typeof OP_COMMIT\n\n/** @internal */\nexport const OP_COMMIT = \"Commit\" as const\n\n/** @internal */\nexport type OP_FAILURE = typeof OP_FAILURE\n\n/** @internal */\nexport const OP_FAILURE = \"Failure\" as const\n\n/** @internal */\nexport type OP_ON_FAILURE = typeof OP_ON_FAILURE\n\n/** @internal */\nexport const OP_ON_FAILURE = \"OnFailure\" as const\n\n/** @internal */\nexport type OP_ON_SUCCESS = typeof OP_ON_SUCCESS\n\n/** @internal */\nexport const OP_ON_SUCCESS = \"OnSuccess\" as const\n\n/** @internal */\nexport type OP_ON_SUCCESS_AND_FAILURE = typeof OP_ON_SUCCESS_AND_FAILURE\n\n/** @internal */\nexport const OP_ON_SUCCESS_AND_FAILURE = \"OnSuccessAndFailure\" as const\n\n/** @internal */\nexport type OP_SUCCESS = typeof OP_SUCCESS\n\n/** @internal */\nexport const OP_SUCCESS = \"Success\" as const\n\n/** @internal */\nexport type OP_SYNC = typeof OP_SYNC\n\n/** @internal */\nexport const OP_SYNC = \"Sync\" as const\n\n/** @internal */\nexport const OP_TAG = \"Tag\" as const\n\n/** @internal */\nexport type OP_TAG = typeof OP_TAG\n\n/** @internal */\nexport type OP_UPDATE_RUNTIME_FLAGS = typeof OP_UPDATE_RUNTIME_FLAGS\n\n/** @internal */\nexport const OP_UPDATE_RUNTIME_FLAGS = \"UpdateRuntimeFlags\" as const\n\n/** @internal */\nexport type OP_WHILE = typeof OP_WHILE\n\n/** @internal */\nexport const OP_WHILE = \"While\" as const\n\n/** @internal */\nexport type OP_ITERATOR = typeof OP_ITERATOR\n\n/** @internal */\nexport const OP_ITERATOR = \"Iterator\" as const\n\n/** @internal */\nexport type OP_WITH_RUNTIME = typeof OP_WITH_RUNTIME\n\n/** @internal */\nexport const OP_WITH_RUNTIME = \"WithRuntime\" as const\n\n/** @internal */\nexport type OP_YIELD = typeof OP_YIELD\n\n/** @internal */\nexport const OP_YIELD = \"Yield\" as const\n\n/** @internal */\nexport type OP_REVERT_FLAGS = typeof OP_REVERT_FLAGS\n\n/** @internal */\nexport const OP_REVERT_FLAGS = \"RevertFlags\" as const\n","let moduleVersion = \"3.18.4\"\n\nexport const getCurrentVersion = () => moduleVersion\n\nexport const setCurrentVersion = (version: string) => {\n  moduleVersion = version\n}\n","import type * as Channel from \"../Channel.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type * as Effectable from \"../Effectable.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as Hash from \"../Hash.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type * as Sink from \"../Sink.js\"\nimport type * as Stream from \"../Stream.js\"\nimport { SingleShotGen, YieldWrap } from \"../Utils.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport * as version from \"./version.js\"\n\n/** @internal */\nexport const EffectTypeId: Effect.EffectTypeId = Symbol.for(\"effect/Effect\") as Effect.EffectTypeId\n\n/** @internal */\nexport const StreamTypeId: Stream.StreamTypeId = Symbol.for(\"effect/Stream\") as Stream.StreamTypeId\n\n/** @internal */\nexport const SinkTypeId: Sink.SinkTypeId = Symbol.for(\"effect/Sink\") as Sink.SinkTypeId\n\n/** @internal */\nexport const ChannelTypeId: Channel.ChannelTypeId = Symbol.for(\"effect/Channel\") as Channel.ChannelTypeId\n\n/** @internal */\nexport const effectVariance = {\n  /* c8 ignore next */\n  _R: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _A: (_: never) => _,\n\n  _V: version.getCurrentVersion()\n}\n\nconst sinkVariance = {\n  /* c8 ignore next */\n  _A: (_: never) => _,\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _L: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\nconst channelVariance = {\n  /* c8 ignore next */\n  _Env: (_: never) => _,\n  /* c8 ignore next */\n  _InErr: (_: unknown) => _,\n  /* c8 ignore next */\n  _InElem: (_: unknown) => _,\n  /* c8 ignore next */\n  _InDone: (_: unknown) => _,\n  /* c8 ignore next */\n  _OutErr: (_: never) => _,\n  /* c8 ignore next */\n  _OutElem: (_: never) => _,\n  /* c8 ignore next */\n  _OutDone: (_: never) => _\n}\n\n/** @internal */\nexport const EffectPrototype: Effect.Effect<never> & Equal.Equal = {\n  [EffectTypeId]: effectVariance,\n  [StreamTypeId]: effectVariance,\n  [SinkTypeId]: sinkVariance,\n  [ChannelTypeId]: channelVariance,\n  [Equal.symbol](that: any) {\n    return this === that\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.random(this))\n  },\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this)) as any\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const StructuralPrototype: Equal.Equal = {\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.structure(this))\n  },\n  [Equal.symbol](this: Equal.Equal, that: Equal.Equal) {\n    const selfKeys = Object.keys(this)\n    const thatKeys = Object.keys(that as object)\n    if (selfKeys.length !== thatKeys.length) {\n      return false\n    }\n    for (const key of selfKeys) {\n      if (!(key in (that as object) && Equal.equals((this as any)[key], (that as any)[key]))) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n/** @internal */\nexport const CommitPrototype: Effect.Effect<never> = {\n  ...EffectPrototype,\n  _op: OpCodes.OP_COMMIT\n} as any\n\n/** @internal */\nexport const StructuralCommitPrototype: Effect.Effect<never> = {\n  ...CommitPrototype,\n  ...StructuralPrototype\n} as any\n\n/** @internal */\nexport const Base: Effectable.CommitPrimitive = (function() {\n  function Base() {}\n  Base.prototype = CommitPrototype\n  return Base as any\n})()\n\n/** @internal */\nexport const StructuralBase: Effectable.CommitPrimitive = (function() {\n  function Base() {}\n  Base.prototype = StructuralCommitPrototype\n  return Base as any\n})()\n","/**\n * @since 2.0.0\n */\n\nimport * as Equal from \"../Equal.js\"\nimport * as Hash from \"../Hash.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport type * as Option from \"../Option.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport { EffectPrototype } from \"./effectable.js\"\n\nconst TypeId: Option.TypeId = Symbol.for(\"effect/Option\") as Option.TypeId\n\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _A: (_: never) => _\n  },\n  [NodeInspectSymbol]<A>(this: Option.Option<A>) {\n    return this.toJSON()\n  },\n  toString<A>(this: Option.Option<A>) {\n    return format(this.toJSON())\n  }\n}\n\nconst SomeProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"Some\",\n  _op: \"Some\",\n  [Equal.symbol]<A>(this: Option.Some<A>, that: unknown): boolean {\n    return isOption(that) && isSome(that) && Equal.equals(this.value, that.value)\n  },\n  [Hash.symbol]<A>(this: Option.Some<A>) {\n    return Hash.cached(this, Hash.combine(Hash.hash(this._tag))(Hash.hash(this.value)))\n  },\n  toJSON<A>(this: Option.Some<A>) {\n    return {\n      _id: \"Option\",\n      _tag: this._tag,\n      value: toJSON(this.value)\n    }\n  }\n})\n\nconst NoneHash = Hash.hash(\"None\")\nconst NoneProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"None\",\n  _op: \"None\",\n  [Equal.symbol]<A>(this: Option.None<A>, that: unknown): boolean {\n    return isOption(that) && isNone(that)\n  },\n  [Hash.symbol]<A>(this: Option.None<A>) {\n    return NoneHash\n  },\n  toJSON<A>(this: Option.None<A>) {\n    return {\n      _id: \"Option\",\n      _tag: this._tag\n    }\n  }\n})\n\n/** @internal */\nexport const isOption = (input: unknown): input is Option.Option<unknown> => hasProperty(input, TypeId)\n\n/** @internal */\nexport const isNone = <A>(fa: Option.Option<A>): fa is Option.None<A> => fa._tag === \"None\"\n\n/** @internal */\nexport const isSome = <A>(fa: Option.Option<A>): fa is Option.Some<A> => fa._tag === \"Some\"\n\n/** @internal */\nexport const none: Option.Option<never> = Object.create(NoneProto)\n\n/** @internal */\nexport const some = <A>(value: A): Option.Option<A> => {\n  const a = Object.create(SomeProto)\n  a.value = value\n  return a\n}\n","/**\n * @since 2.0.0\n */\n\nimport type * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport { dual } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport type { Option } from \"../Option.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport { EffectPrototype } from \"./effectable.js\"\nimport * as option from \"./option.js\"\n\n/**\n * @internal\n */\nexport const TypeId: Either.TypeId = Symbol.for(\"effect/Either\") as Either.TypeId\n\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _R: (_: never) => _\n  },\n  [NodeInspectSymbol]<L, R>(this: Either.Either<R, L>) {\n    return this.toJSON()\n  },\n  toString<L, R>(this: Either.Left<L, R>) {\n    return format(this.toJSON())\n  }\n}\n\nconst RightProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"Right\",\n  _op: \"Right\",\n  [Equal.symbol]<L, R>(this: Either.Right<L, R>, that: unknown): boolean {\n    return isEither(that) && isRight(that) && Equal.equals(this.right, that.right)\n  },\n  [Hash.symbol]<L, R>(this: Either.Right<L, R>) {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.right))\n  },\n  toJSON<L, R>(this: Either.Right<L, R>) {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      right: toJSON(this.right)\n    }\n  }\n})\n\nconst LeftProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"Left\",\n  _op: \"Left\",\n  [Equal.symbol]<L, R>(this: Either.Left<L, R>, that: unknown): boolean {\n    return isEither(that) && isLeft(that) && Equal.equals(this.left, that.left)\n  },\n  [Hash.symbol]<L, R>(this: Either.Left<L, R>) {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.left))\n  },\n  toJSON<E, A>(this: Either.Left<E, A>) {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      left: toJSON(this.left)\n    }\n  }\n})\n\n/** @internal */\nexport const isEither = (input: unknown): input is Either.Either<unknown, unknown> => hasProperty(input, TypeId)\n\n/** @internal */\nexport const isLeft = <R, L>(ma: Either.Either<R, L>): ma is Either.Left<L, R> => ma._tag === \"Left\"\n\n/** @internal */\nexport const isRight = <R, L>(ma: Either.Either<R, L>): ma is Either.Right<L, R> => ma._tag === \"Right\"\n\n/** @internal */\nexport const left = <L>(left: L): Either.Either<never, L> => {\n  const a = Object.create(LeftProto)\n  a.left = left\n  return a\n}\n\n/** @internal */\nexport const right = <R>(right: R): Either.Either<R> => {\n  const a = Object.create(RightProto)\n  a.right = right\n  return a\n}\n\n/** @internal */\nexport const getLeft = <R, L>(\n  self: Either.Either<R, L>\n): Option<L> => (isRight(self) ? option.none : option.some(self.left))\n\n/** @internal */\nexport const getRight = <R, L>(\n  self: Either.Either<R, L>\n): Option<R> => (isLeft(self) ? option.none : option.some(self.right))\n\n/** @internal */\nexport const fromOption: {\n  <L>(onNone: () => L): <R>(self: Option<R>) => Either.Either<R, L>\n  <R, L>(self: Option<R>, onNone: () => L): Either.Either<R, L>\n} = dual(\n  2,\n  <R, L>(self: Option<R>, onNone: () => L): Either.Either<R, L> =>\n    option.isNone(self) ? left(onNone()) : right(self.value)\n)\n","/**\n * @since 2.0.0\n */\n\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { constNull, constUndefined, dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as doNotation from \"./internal/doNotation.js\"\nimport * as either from \"./internal/either.js\"\nimport * as option_ from \"./internal/option.js\"\nimport type { Option } from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport { isFunction } from \"./Predicate.js\"\nimport type { Covariant, NoInfer, NotFunction } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport * as Gen from \"./Utils.js\"\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type Either<A, E = never> = Left<E, A> | Right<E, A>\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const TypeId: unique symbol = either.TypeId\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport type TypeId = typeof TypeId\n\n// TODO(4.0): flip the order of the type parameters\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Left<out E, out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Left\"\n  readonly _op: \"Left\"\n  readonly left: E\n  readonly [TypeId]: {\n    readonly _R: Covariant<A>\n    readonly _L: Covariant<E>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}\n\n// TODO(4.0): flip the order of the type parameters\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Right<out E, out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Right\"\n  readonly _op: \"Right\"\n  readonly right: A\n  readonly [TypeId]: {\n    readonly _R: Covariant<A>\n    readonly _L: Covariant<E>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface EitherUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Either?: () => A[Unify.typeSymbol] extends Either<infer R0, infer L0> | infer _ ? Either<R0, L0> : never\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface EitherUnifyIgnore {}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface EitherTypeLambda extends TypeLambda {\n  readonly type: Either<this[\"Target\"], this[\"Out1\"]>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Either {\n  /**\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Left<T extends Either<any, any>> = [T] extends [Either<infer _A, infer _E>] ? _E : never\n  /**\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Right<T extends Either<any, any>> = [T] extends [Either<infer _A, infer _E>] ? _A : never\n}\n\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const right: <A>(a: A) => Either<A> = either.right\n\nconst void_: Either<void> = right(void 0)\nexport {\n  /**\n   * @category constructors\n   * @since 3.13.0\n   */\n  void_ as void\n}\n\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const left: <E>(e: E) => Either<never, E> = either.left\n\n/**\n * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromNullable: {\n  /**\n   * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n   * the provided default as a `Left`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n   * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, E>(onNullable: (right: A) => E): (self: A) => Either<NonNullable<A>, E>\n  /**\n   * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n   * the provided default as a `Left`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n   * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, E>(self: A, onNullable: (right: A) => E): Either<NonNullable<A>, E>\n} = dual(\n  2,\n  <A, E>(self: A, onNullable: (right: A) => E): Either<NonNullable<A>, E> =>\n    self == null ? left(onNullable(self)) : right(self)\n)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromOption: {\n  /**\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n   * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <E>(onNone: () => E): <A>(self: Option<A>) => Either<A, E>\n  /**\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n   * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, E>(self: Option<A>, onNone: () => E): Either<A, E>\n} = either.fromOption\n\nconst try_: {\n  <A, E>(\n    options: {\n      readonly try: LazyArg<A>\n      readonly catch: (error: unknown) => E\n    }\n  ): Either<A, E>\n  <A>(evaluate: LazyArg<A>): Either<A, unknown>\n} = (<A, E>(\n  evaluate: LazyArg<A> | {\n    readonly try: LazyArg<A>\n    readonly catch: (error: unknown) => E\n  }\n) => {\n  if (isFunction(evaluate)) {\n    try {\n      return right(evaluate())\n    } catch (e) {\n      return left(e)\n    }\n  } else {\n    try {\n      return right(evaluate.try())\n    } catch (e) {\n      return left(evaluate.catch(e))\n    }\n  }\n}) as any\n\nexport {\n  /**\n   * Imports a synchronous side-effect into a pure `Either` value, translating any\n   * thrown exceptions into typed failed eithers creating with `Either.left`.\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  try_ as try\n}\n\n/**\n * Tests if a value is a `Either`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isEither(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isEither(Either.left(\"a\")), true)\n * assert.deepStrictEqual(Either.isEither({ right: 1 }), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEither: (input: unknown) => input is Either<unknown, unknown> = either.isEither\n\n/**\n * Determine if a `Either` is a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\n * assert.deepStrictEqual(Either.isLeft(Either.left(\"a\")), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isLeft: <A, E>(self: Either<A, E>) => self is Left<E, A> = either.isLeft\n\n/**\n * Determine if a `Either` is a `Right`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isRight(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isRight(Either.left(\"a\")), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isRight: <A, E>(self: Either<A, E>) => self is Right<E, A> = either.isRight\n\n/**\n * Converts a `Either` to an `Option` discarding the `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))\n * assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getRight: <A, E>(self: Either<A, E>) => Option<A> = either.getRight\n\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())\n * assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getLeft: <A, E>(self: Either<A, E>) => Option<E> = either.getLeft\n\n/**\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <A, E>({ left, right }: {\n  right: Equivalence.Equivalence<A>\n  left: Equivalence.Equivalence<E>\n}): Equivalence.Equivalence<Either<A, E>> =>\n  Equivalence.make((x, y) =>\n    isLeft(x) ?\n      isLeft(y) && left(x.left, y.left) :\n      isRight(y) && right(x.right, y.right)\n  )\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapBoth: {\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <E, E2, A, A2>(\n    options: {\n      readonly onLeft: (left: E) => E2\n      readonly onRight: (right: A) => A2\n    }\n  ): (self: Either<A, E>) => Either<A2, E2>\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, E, E2, A2>(\n    self: Either<A, E>,\n    options: {\n      readonly onLeft: (left: E) => E2\n      readonly onRight: (right: A) => A2\n    }\n  ): Either<A2, E2>\n} = dual(\n  2,\n  <A, E, E2, A2>(self: Either<A, E>, { onLeft, onRight }: {\n    readonly onLeft: (left: E) => E2\n    readonly onRight: (right: A) => A2\n  }): Either<A2, E2> => isLeft(self) ? left(onLeft(self.left)) : right(onRight(self.right))\n)\n\n/**\n * Maps the `Left` side of an `Either` value to a new `Either` value.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapLeft: {\n  /**\n   * Maps the `Left` side of an `Either` value to a new `Either` value.\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <E, E2>(f: (left: E) => E2): <A>(self: Either<A, E>) => Either<A, E2>\n  /**\n   * Maps the `Left` side of an `Either` value to a new `Either` value.\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, E, E2>(self: Either<A, E>, f: (left: E) => E2): Either<A, E2>\n} = dual(\n  2,\n  <A, E, E2>(self: Either<A, E>, f: (left: E) => E2): Either<A, E2> =>\n    isLeft(self) ? left(f(self.left)) : right(self.right)\n)\n\n/**\n * Maps the `Right` side of an `Either` value to a new `Either` value.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  /**\n   * Maps the `Right` side of an `Either` value to a new `Either` value.\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, A2>(f: (right: A) => A2): <E>(self: Either<A, E>) => Either<A2, E>\n  /**\n   * Maps the `Right` side of an `Either` value to a new `Either` value.\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, E, A2>(self: Either<A, E>, f: (right: A) => A2): Either<A2, E>\n} = dual(\n  2,\n  <A, E, A2>(self: Either<A, E>, f: (right: A) => A2): Either<A2, E> =>\n    isRight(self) ? right(f(self.right)) : left(self.left)\n)\n\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n * if the value is a `Right` the inner value is applied to the `onRight` function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n * assert.deepStrictEqual(\n *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n *   'strings: string 1, string 2'\n * )\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  /**\n   * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n   * if the value is a `Right` the inner value is applied to the `onRight` function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n   *\n   * const onRight = (value: number): string => `Ok: ${value}`\n   *\n   * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n   * assert.deepStrictEqual(\n   *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n   *   'strings: string 1, string 2'\n   * )\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <E, B, A, C = B>(\n    options: {\n      readonly onLeft: (left: E) => B\n      readonly onRight: (right: A) => C\n    }\n  ): (self: Either<A, E>) => B | C\n  /**\n   * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n   * if the value is a `Right` the inner value is applied to the `onRight` function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n   *\n   * const onRight = (value: number): string => `Ok: ${value}`\n   *\n   * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n   * assert.deepStrictEqual(\n   *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n   *   'strings: string 1, string 2'\n   * )\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, E, B, C = B>(\n    self: Either<A, E>,\n    options: {\n      readonly onLeft: (left: E) => B\n      readonly onRight: (right: A) => C\n    }\n  ): B | C\n} = dual(\n  2,\n  <A, E, B, C = B>(self: Either<A, E>, { onLeft, onRight }: {\n    readonly onLeft: (left: E) => B\n    readonly onRight: (right: A) => C\n  }): B | C => isLeft(self) ? onLeft(self.left) : onRight(self.right)\n)\n\n/**\n * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n * or `Left` of the result of the provided function if the predicate returns false\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n *\n * assert.deepStrictEqual(\n *   isPositiveEither(1),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   isPositiveEither(0),\n *   Either.left(\"0 is not positive\")\n * )\n * ```\n *\n * @category lifting\n * @since 3.4.0\n */\nexport const liftPredicate: {\n  /**\n   * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n   * or `Left` of the result of the provided function if the predicate returns false\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n   *\n   * assert.deepStrictEqual(\n   *   isPositiveEither(1),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   isPositiveEither(0),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @category lifting\n   * @since 3.4.0\n   */\n  <A, B extends A, E>(refinement: Refinement<A, B>, orLeftWith: (a: A) => E): (a: A) => Either<B, E>\n  /**\n   * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n   * or `Left` of the result of the provided function if the predicate returns false\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n   *\n   * assert.deepStrictEqual(\n   *   isPositiveEither(1),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   isPositiveEither(0),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @category lifting\n   * @since 3.4.0\n   */\n  <B extends A, E, A = B>(predicate: Predicate<A>, orLeftWith: (a: A) => E): (a: B) => Either<B, E>\n  /**\n   * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n   * or `Left` of the result of the provided function if the predicate returns false\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n   *\n   * assert.deepStrictEqual(\n   *   isPositiveEither(1),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   isPositiveEither(0),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @category lifting\n   * @since 3.4.0\n   */\n  <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>\n  /**\n   * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n   * or `Left` of the result of the provided function if the predicate returns false\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   * const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n   *\n   * assert.deepStrictEqual(\n   *   isPositiveEither(1),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   isPositiveEither(0),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @category lifting\n   * @since 3.4.0\n   */\n  <B extends A, E, A = B>(self: B, predicate: Predicate<A>, orLeftWith: (a: A) => E): Either<B, E>\n} = dual(\n  3,\n  <A, E>(a: A, predicate: Predicate<A>, orLeftWith: (a: A) => E): Either<A, E> =>\n    predicate(a) ? right(a) : left(orLeftWith(a))\n)\n\n/**\n * Filter the right value with the provided function.\n * If the predicate fails, set the left value with the result of the provided function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(1),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(0),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.left(\"0 is not positive\")\n * )\n * ```\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nexport const filterOrLeft: {\n  /**\n   * Filter the right value with the provided function.\n   * If the predicate fails, set the left value with the result of the provided function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(1),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(0),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering & conditionals\n   */\n  <A, B extends A, E2>(\n    refinement: Refinement<NoInfer<A>, B>,\n    orLeftWith: (right: NoInfer<A>) => E2\n  ): <E>(self: Either<A, E>) => Either<B, E2 | E>\n  /**\n   * Filter the right value with the provided function.\n   * If the predicate fails, set the left value with the result of the provided function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(1),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(0),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering & conditionals\n   */\n  <A, E2>(predicate: Predicate<NoInfer<A>>, orLeftWith: (right: NoInfer<A>) => E2): <E>(self: Either<A, E>) => Either<A, E2 | E>\n  /**\n   * Filter the right value with the provided function.\n   * If the predicate fails, set the left value with the result of the provided function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(1),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(0),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering & conditionals\n   */\n  <A, E, B extends A, E2>(\n    self: Either<A, E>,\n    refinement: Refinement<A, B>,\n    orLeftWith: (right: A) => E2\n  ): Either<B, E | E2>\n  /**\n   * Filter the right value with the provided function.\n   * If the predicate fails, set the left value with the result of the provided function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Either } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(1),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.right(1)\n   * )\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     Either.right(0),\n   *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n   *   ),\n   *   Either.left(\"0 is not positive\")\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering & conditionals\n   */\n  <A, E, E2>(self: Either<A, E>, predicate: Predicate<A>, orLeftWith: (right: A) => E2): Either<A, E | E2>\n} = dual(3, <A, E, E2>(\n  self: Either<A, E>,\n  predicate: Predicate<A>,\n  orLeftWith: (right: A) => E2\n): Either<A, E | E2> => flatMap(self, (r) => predicate(r) ? right(r) : left(orLeftWith(r))))\n\n/**\n * @category getters\n * @since 2.0.0\n */\nexport const merge: <A, E>(self: Either<A, E>) => E | A = match({\n  onLeft: identity,\n  onRight: identity\n})\n\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrElse: {\n  /**\n   * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n   * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <E, A2>(onLeft: (left: E) => A2): <A>(self: Either<A, E>) => A2 | A\n  /**\n   * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n   * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A, E, A2>(self: Either<A, E>, onLeft: (left: E) => A2): A | A2\n} = dual(\n  2,\n  <A, E, A2>(self: Either<A, E>, onLeft: (left: E) => A2): A | A2 => isLeft(self) ? onLeft(self.left) : self.right\n)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrNull: <A, E>(self: Either<A, E>) => A | null = getOrElse(constNull)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrUndefined: <A, E>(self: Either<A, E>) => A | undefined = getOrElse(constUndefined)\n\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n *   1\n * )\n * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrThrowWith: {\n  /**\n   * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n   *\n   * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n   *   1\n   * )\n   * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <E>(onLeft: (left: E) => unknown): <A>(self: Either<A, E>) => A\n  /**\n   * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n   *\n   * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n   *   1\n   * )\n   * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A, E>(self: Either<A, E>, onLeft: (left: E) => unknown): A\n} = dual(2, <A, E>(self: Either<A, E>, onLeft: (left: E) => unknown): A => {\n  if (isRight(self)) {\n    return self.right\n  }\n  throw onLeft(self.left)\n})\n\n// TODO(4.0): by default should throw `L` (i.e getOrThrowWith with the identity function)\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\n * assert.throws(() => Either.getOrThrow(Either.left(\"error\")))\n * ```\n *\n * @throws `Error(\"getOrThrow called on a Left\")`\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrThrow: <A, E>(self: Either<A, E>) => A = getOrThrowWith(() =>\n  new Error(\"getOrThrow called on a Left\")\n)\n\n/**\n * Returns `self` if it is a `Right` or `that` otherwise.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport const orElse: {\n  /**\n   * Returns `self` if it is a `Right` or `that` otherwise.\n   *\n   * @category error handling\n   * @since 2.0.0\n   */\n  <E, A2, E2>(that: (left: E) => Either<A2, E2>): <A>(self: Either<A, E>) => Either<A | A2, E2>\n  /**\n   * Returns `self` if it is a `Right` or `that` otherwise.\n   *\n   * @category error handling\n   * @since 2.0.0\n   */\n  <A, E, A2, E2>(self: Either<A, E>, that: (left: E) => Either<A2, E2>): Either<A | A2, E2>\n} = dual(\n  2,\n  <A, E, A2, E2>(self: Either<A, E>, that: (left: E) => Either<A2, E2>): Either<A | A2, E2> =>\n    isLeft(self) ? that(self.left) : right(self.right)\n)\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  /**\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, A2, E2>(f: (right: A) => Either<A2, E2>): <E>(self: Either<A, E>) => Either<A2, E | E2>\n  /**\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2>): Either<A2, E | E2>\n} = dual(\n  2,\n  <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2>): Either<A2, E | E2> =>\n    isLeft(self) ? left(self.left) : f(self.right)\n)\n\n/**\n * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const andThen: {\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, A2, E2>(f: (right: A) => Either<A2, E2>): <E>(self: Either<A, E>) => Either<A2, E | E2>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A2, E2>(f: Either<A2, E2>): <E, A>(self: Either<A, E>) => Either<A2, E | E2>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, A2>(f: (right: A) => A2): <E>(self: Either<A, E>) => Either<A2, E>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A2>(right: NotFunction<A2>): <A, E>(self: Either<A, E>) => Either<A2, E>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2>): Either<A2, E | E2>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2, E2>(self: Either<A, E>, f: Either<A2, E2>): Either<A2, E | E2>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2>(self: Either<A, E>, f: (right: A) => A2): Either<A2, E>\n  /**\n   * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, E, A2>(self: Either<A, E>, f: NotFunction<A2>): Either<A2, E>\n} = dual(\n  2,\n  <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2> | Either<A2, E2>): Either<A2, E | E2> =>\n    flatMap(self, (a) => {\n      const b = isFunction(f) ? f(a) : f\n      return isEither(b) ? b : right(b)\n    })\n)\n\n/**\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  /**\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A2, E2, A, B>(that: Either<A2, E2>, f: (right: A, right2: A2) => B): <E>(self: Either<A, E>) => Either<B, E2 | E>\n  /**\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A, E, A2, E2, B>(self: Either<A, E>, that: Either<A2, E2>, f: (right: A, right2: A2) => B): Either<B, E | E2>\n} = dual(\n  3,\n  <A, E, A2, E2, B>(self: Either<A, E>, that: Either<A2, E2>, f: (right: A, right2: A2) => B): Either<B, E | E2> =>\n    flatMap(self, (r) => map(that, (r2) => f(r, r2)))\n)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const ap: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A, E2>(that: Either<A, E2>): <A2, E>(self: Either<(right: A) => A2, E>) => Either<A2, E | E2>\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A, A2, E, E2>(self: Either<(right: A) => A2, E>, that: Either<A, E2>): Either<A2, E | E2>\n} = dual(\n  2,\n  <A, E, A2, E2>(self: Either<(right: A) => A2, E>, that: Either<A, E2>): Either<A2, E | E2> =>\n    zipWith(self, that, (f, a) => f(a))\n)\n\n/**\n * Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Either` will contain an array.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n * ```\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nexport const all: <const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(\n  input: I\n) => [I] extends [ReadonlyArray<Either<any, any>>] ? Either<\n    { -readonly [K in keyof I]: [I[K]] extends [Either<infer A, any>] ? A : never },\n    I[number] extends never ? never : [I[number]] extends [Either<any, infer E>] ? E : never\n  >\n  : [I] extends [Iterable<Either<infer A, infer E>>] ? Either<Array<A>, E>\n  : Either<\n    { -readonly [K in keyof I]: [I[K]] extends [Either<infer A, any>] ? A : never },\n    I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer E>] ? E : never\n  > = (\n    input: Iterable<Either<any, any>> | Record<string, Either<any, any>>\n  ): Either<any, any> => {\n    if (Symbol.iterator in input) {\n      const out: Array<Either<any, any>> = []\n      for (const e of input) {\n        if (isLeft(e)) {\n          return e\n        }\n        out.push(e.right)\n      }\n      return right(out)\n    }\n\n    const out: Record<string, any> = {}\n    for (const key of Object.keys(input)) {\n      const e = input[key]\n      if (isLeft(e)) {\n        return e\n      }\n      out[key] = e.right\n    }\n    return right(out)\n  }\n\n/**\n * Returns an `Either` that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const flip = <A, E>(self: Either<A, E>): Either<E, A> => isLeft(self) ? right(self.left) : left(self.right)\n\nconst adapter = Gen.adapter<EitherTypeLambda>()\n\n/**\n * @category generators\n * @since 2.0.0\n */\nexport const gen: Gen.Gen<EitherTypeLambda, Gen.Adapter<EitherTypeLambda>> = (...args) => {\n  const f = args.length === 1 ? args[0] : args[1].bind(args[0])\n  const iterator = f(adapter)\n  let state: IteratorResult<any> = iterator.next()\n  while (!state.done) {\n    const current = Gen.isGenKind(state.value)\n      ? state.value.value\n      : Gen.yieldWrapGet(state.value)\n    if (isLeft(current)) {\n      return current\n    }\n    state = iterator.next(current.right as never)\n  }\n  return right(state.value) as any\n}\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link bind}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const Do: Either<{}> = right({})\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const bind: {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  <N extends string, A extends object, B, E2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, E2>): <E>(self: Either<A, E>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E | E2>\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  <A extends object, E, N extends string, B, E2>(\n    self: Either<A, E>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => Either<B, E2>\n  ): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E | E2>\n} = doNotation.bind<EitherTypeLambda>(map, flatMap)\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const bindTo: {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  <N extends string>(name: N): <A, E>(self: Either<A, E>) => Either<{ [K in N]: A }, E>\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  <A, E, N extends string>(self: Either<A, E>, name: N): Either<{ [K in N]: A }, E>\n} = doNotation.bindTo<EitherTypeLambda>(map)\n\nconst let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (r: NoInfer<A>) => B\n  ): <E>(self: Either<A, E>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E>\n  <A extends object, E, N extends string, B>(\n    self: Either<A, E>,\n    name: Exclude<N, keyof A>,\n    f: (r: NoInfer<A>) => B\n  ): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E>\n} = doNotation.let_<EitherTypeLambda>(map)\n\nexport {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Either.Do,\n   *   Either.bind(\"x\", () => Either.right(2)),\n   *   Either.bind(\"y\", () => Either.right(3)),\n   *   Either.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link bind}\n   *\n   * @category do notation\n   * @since 2.0.0\n   */\n  let_ as let\n}\n\n/**\n * Converts an `Option` of an `Either` into an `Either` of an `Option`.\n *\n * **Details**\n *\n * This function transforms an `Option<Either<A, E>>` into an\n * `Either<Option<A>, E>`. If the `Option` is `None`, the resulting `Either`\n * will be a `Right` with a `None` value. If the `Option` is `Some`, the\n * inner `Either` will be executed, and its result wrapped in a `Some`.\n *\n * @example\n * ```ts\n * import { Effect, Either, Option } from \"effect\"\n *\n * //      ┌─── Option<Either<number, never>>\n * //      ▼\n * const maybe = Option.some(Either.right(42))\n *\n * //      ┌─── Either<Option<number>, never, never>\n * //      ▼\n * const result = Either.transposeOption(maybe)\n *\n * console.log(Effect.runSync(result))\n * // Output: { _id: 'Option', _tag: 'Some', value: 42 }\n * ```\n *\n * @since 3.14.0\n * @category Optional Wrapping & Unwrapping\n */\nexport const transposeOption = <A = never, E = never>(\n  self: Option<Either<A, E>>\n): Either<Option<A>, E> => {\n  return option_.isNone(self) ? right(option_.none) : map(self.value, option_.some)\n}\n\n/**\n * Applies an `Either` on an `Option` and transposes the result.\n *\n * **Details**\n *\n * If the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.\n * If the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.\n *\n * @example\n * ```ts\n * import { Either, Option, pipe } from \"effect\"\n *\n * //          ┌─── Either<Option<number>, never>>\n * //          ▼\n * const noneResult = pipe(\n *   Option.none(),\n *   Either.transposeMapOption(() => Either.right(42)) // will not be executed\n * )\n * console.log(noneResult)\n * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }\n *\n * //          ┌─── Either<Option<number>, never>>\n * //          ▼\n * const someRightResult = pipe(\n *   Option.some(42),\n *   Either.transposeMapOption((value) => Either.right(value * 2))\n * )\n * console.log(someRightResult)\n * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }\n * ```\n *\n * @since 3.15.0\n * @category Optional Wrapping & Unwrapping\n */\nexport const transposeMapOption = dual<\n  /**\n   * Applies an `Either` on an `Option` and transposes the result.\n   *\n   * **Details**\n   *\n   * If the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.\n   * If the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.\n   *\n   * @example\n   * ```ts\n   * import { Either, Option, pipe } from \"effect\"\n   *\n   * //          ┌─── Either<Option<number>, never>>\n   * //          ▼\n   * const noneResult = pipe(\n   *   Option.none(),\n   *   Either.transposeMapOption(() => Either.right(42)) // will not be executed\n   * )\n   * console.log(noneResult)\n   * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }\n   *\n   * //          ┌─── Either<Option<number>, never>>\n   * //          ▼\n   * const someRightResult = pipe(\n   *   Option.some(42),\n   *   Either.transposeMapOption((value) => Either.right(value * 2))\n   * )\n   * console.log(someRightResult)\n   * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }\n   * ```\n   *\n   * @since 3.15.0\n   * @category Optional Wrapping & Unwrapping\n   */\n  <A, B, E = never>(f: (self: A) => Either<B, E>) => (self: Option<A>) => Either<Option<B>, E>,\n  /**\n   * Applies an `Either` on an `Option` and transposes the result.\n   *\n   * **Details**\n   *\n   * If the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.\n   * If the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.\n   *\n   * @example\n   * ```ts\n   * import { Either, Option, pipe } from \"effect\"\n   *\n   * //          ┌─── Either<Option<number>, never>>\n   * //          ▼\n   * const noneResult = pipe(\n   *   Option.none(),\n   *   Either.transposeMapOption(() => Either.right(42)) // will not be executed\n   * )\n   * console.log(noneResult)\n   * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }\n   *\n   * //          ┌─── Either<Option<number>, never>>\n   * //          ▼\n   * const someRightResult = pipe(\n   *   Option.some(42),\n   *   Either.transposeMapOption((value) => Either.right(value * 2))\n   * )\n   * console.log(someRightResult)\n   * // Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }\n   * ```\n   *\n   * @since 3.15.0\n   * @category Optional Wrapping & Unwrapping\n   */\n  <A, B, E = never>(self: Option<A>, f: (self: A) => Either<B, E>) => Either<Option<B>, E>\n>(2, (self, f) => option_.isNone(self) ? right(option_.none) : map(f(self.value), option_.some))\n","/**\n * @since 2.0.0\n */\n\nimport type { NonEmptyArray } from \"../Array.js\"\n\n/** @internal */\nexport const isNonEmptyArray = <A>(self: ReadonlyArray<A>): self is NonEmptyArray<A> => self.length > 0\n","/**\n * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.\n * An order is defined by a relation `<=`, which obeys the following laws:\n *\n * - either `x <= y` or `y <= x` (totality)\n * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)\n * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)\n *\n * The truth table for compare is defined as follows:\n *\n * | `x <= y` | `x >= y` | Ordering |                       |\n * | -------- | -------- | -------- | --------------------- |\n * | `true`   | `true`   | `0`      | corresponds to x == y |\n * | `true`   | `false`  | `< 0`    | corresponds to x < y  |\n * | `false`  | `true`   | `> 0`    | corresponds to x > y  |\n *\n * @since 2.0.0\n */\nimport { dual } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\n\n/**\n * @category type class\n * @since 2.0.0\n */\nexport interface Order<in A> {\n  (self: A, that: A): -1 | 0 | 1\n}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface OrderTypeLambda extends TypeLambda {\n  readonly type: Order<this[\"Target\"]>\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <A>(\n  compare: (self: A, that: A) => -1 | 0 | 1\n): Order<A> =>\n(self, that) => self === that ? 0 : compare(self, that)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const string: Order<string> = make((self, that) => self < that ? -1 : 1)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const number: Order<number> = make((self, that) => self < that ? -1 : 1)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const boolean: Order<boolean> = make((self, that) => self < that ? -1 : 1)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const bigint: Order<bigint> = make((self, that) => self < that ? -1 : 1)\n\n/**\n * @since 2.0.0\n */\nexport const reverse = <A>(O: Order<A>): Order<A> => make((self, that) => O(that, self))\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combine: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(that: Order<A>): (self: Order<A>) => Order<A>\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(self: Order<A>, that: Order<A>): Order<A>\n} = dual(2, <A>(self: Order<A>, that: Order<A>): Order<A> =>\n  make((a1, a2) => {\n    const out = self(a1, a2)\n    if (out !== 0) {\n      return out\n    }\n    return that(a1, a2)\n  }))\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineMany: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(collection: Iterable<Order<A>>): (self: Order<A>) => Order<A>\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<A>\n} = dual(2, <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<A> =>\n  make((a1, a2) => {\n    let out = self(a1, a2)\n    if (out !== 0) {\n      return out\n    }\n    for (const O of collection) {\n      out = O(a1, a2)\n      if (out !== 0) {\n        return out\n      }\n    }\n    return out\n  }))\n\n/**\n * @since 2.0.0\n */\nexport const empty = <A>(): Order<A> => make(() => 0)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineAll = <A>(collection: Iterable<Order<A>>): Order<A> => combineMany(empty(), collection)\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapInput: {\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <B, A>(f: (b: B) => A): (self: Order<A>) => Order<B>\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <A, B>(self: Order<A>, f: (b: B) => A): Order<B>\n} = dual(\n  2,\n  <A, B>(self: Order<A>, f: (b: B) => A): Order<B> => make((b1, b2) => self(f(b1), f(b2)))\n)\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Date: Order<Date> = mapInput(number, (date) => date.getTime())\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const product: {\n  <B>(that: Order<B>): <A>(self: Order<A>) => Order<readonly [A, B]> // readonly because invariant\n  <A, B>(self: Order<A>, that: Order<B>): Order<readonly [A, B]> // readonly because invariant\n} = dual(2, <A, B>(self: Order<A>, that: Order<B>): Order<readonly [A, B]> =>\n  make(([xa, xb], [ya, yb]) => {\n    const o = self(xa, ya)\n    return o !== 0 ? o : that(xb, yb)\n  }))\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const all = <A>(collection: Iterable<Order<A>>): Order<ReadonlyArray<A>> => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length)\n    let collectionLength = 0\n    for (const O of collection) {\n      if (collectionLength >= len) {\n        break\n      }\n      const o = O(x[collectionLength], y[collectionLength])\n      if (o !== 0) {\n        return o\n      }\n      collectionLength++\n    }\n    return 0\n  })\n}\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const productMany: {\n  <A>(collection: Iterable<Order<A>>): (self: Order<A>) => Order<readonly [A, ...Array<A>]> // readonly because invariant\n  <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<readonly [A, ...Array<A>]> // readonly because invariant\n} = dual(2, <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<readonly [A, ...Array<A>]> => {\n  const O = all(collection)\n  return make((x, y) => {\n    const o = self(x[0], y[0])\n    return o !== 0 ? o : O(x.slice(1), y.slice(1))\n  })\n})\n\n/**\n * Similar to `Promise.all` but operates on `Order`s.\n *\n * ```\n * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const tuple = <T extends ReadonlyArray<Order<any>>>(\n  ...elements: T\n): Order<Readonly<{ [I in keyof T]: [T[I]] extends [Order<infer A>] ? A : never }>> => all(elements) as any\n\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const array = <A>(O: Order<A>): Order<ReadonlyArray<A>> =>\n  make((self, that) => {\n    const aLen = self.length\n    const bLen = that.length\n    const len = Math.min(aLen, bLen)\n    for (let i = 0; i < len; i++) {\n      const o = O(self[i], that[i])\n      if (o !== 0) {\n        return o\n      }\n    }\n    return number(aLen, bLen)\n  })\n\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const struct = <R extends { readonly [x: string]: Order<any> }>(\n  fields: R\n): Order<{ [K in keyof R]: [R[K]] extends [Order<infer A>] ? A : never }> => {\n  const keys = Object.keys(fields)\n  return make((self, that) => {\n    for (const key of keys) {\n      const o = fields[key](self[key], that[key])\n      if (o !== 0) {\n        return o\n      }\n    }\n    return 0\n  })\n}\n\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 2.0.0\n */\nexport const lessThan = <A>(O: Order<A>): {\n  (that: A): (self: A) => boolean\n  (self: A, that: A): boolean\n} => dual(2, (self: A, that: A) => O(self, that) === -1)\n\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 2.0.0\n */\nexport const greaterThan = <A>(O: Order<A>): {\n  (that: A): (self: A) => boolean\n  (self: A, that: A): boolean\n} => dual(2, (self: A, that: A) => O(self, that) === 1)\n\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 2.0.0\n */\nexport const lessThanOrEqualTo = <A>(O: Order<A>): {\n  (that: A): (self: A) => boolean\n  (self: A, that: A): boolean\n} => dual(2, (self: A, that: A) => O(self, that) !== 1)\n\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 2.0.0\n */\nexport const greaterThanOrEqualTo = <A>(O: Order<A>): {\n  (that: A): (self: A) => boolean\n  (self: A, that: A): boolean\n} => dual(2, (self: A, that: A) => O(self, that) !== -1)\n\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nexport const min = <A>(O: Order<A>): {\n  (that: A): (self: A) => A\n  (self: A, that: A): A\n} => dual(2, (self: A, that: A) => self === that || O(self, that) < 1 ? self : that)\n\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nexport const max = <A>(O: Order<A>): {\n  (that: A): (self: A) => A\n  (self: A, that: A): A\n} => dual(2, (self: A, that: A) => self === that || O(self, that) > -1 ? self : that)\n\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Order, Number } from \"effect\"\n *\n * const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })\n *\n * assert.equal(clamp(3), 3)\n * assert.equal(clamp(0), 1)\n * assert.equal(clamp(6), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const clamp = <A>(O: Order<A>): {\n  (options: {\n    minimum: A\n    maximum: A\n  }): (self: A) => A\n  (self: A, options: {\n    minimum: A\n    maximum: A\n  }): A\n} =>\n  dual(\n    2,\n    (self: A, options: {\n      minimum: A\n      maximum: A\n    }): A => min(O)(options.maximum, max(O)(options.minimum, self))\n  )\n\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 2.0.0\n */\nexport const between = <A>(O: Order<A>): {\n  (options: {\n    minimum: A\n    maximum: A\n  }): (self: A) => boolean\n  (self: A, options: {\n    minimum: A\n    maximum: A\n  }): boolean\n} =>\n  dual(\n    2,\n    (self: A, options: {\n      minimum: A\n      maximum: A\n    }): boolean => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum)\n  )\n","/**\n * @since 2.0.0\n */\nimport type { Either } from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { constNull, constUndefined, dual, identity, isFunction } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as doNotation from \"./internal/doNotation.js\"\nimport * as either from \"./internal/either.js\"\nimport * as option from \"./internal/option.js\"\nimport type { Order } from \"./Order.js\"\nimport * as order from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport type { Covariant, NoInfer, NotFunction } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport * as Gen from \"./Utils.js\"\n\n/**\n * The `Option` data type represents optional values. An `Option<A>` can either\n * be `Some<A>`, containing a value of type `A`, or `None`, representing the\n * absence of a value.\n *\n * **When to Use**\n *\n * You can use `Option` in scenarios like:\n *\n * - Using it for initial values\n * - Returning values from functions that are not defined for all possible\n *   inputs (referred to as “partial functions”)\n * - Managing optional fields in data structures\n * - Handling optional function arguments\n *\n * @category Models\n * @since 2.0.0\n */\nexport type Option<A> = None<A> | Some<A>\n\n/**\n * @category Symbols\n * @since 2.0.0\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Option\")\n\n/**\n * @category Symbols\n * @since 2.0.0\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface None<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"None\"\n  readonly _op: \"None\"\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface Some<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Some\"\n  readonly _op: \"Some\"\n  readonly value: A\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface OptionUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Option?: () => A[Unify.typeSymbol] extends Option<infer A0> | infer _ ? Option<A0> : never\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Option {\n  /**\n   * Extracts the type of the value contained in an `Option`.\n   *\n   * **Example** (Getting the Value Type of an Option)\n   *\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Declare an Option holding a string\n   * declare const myOption: Option.Option<string>\n   *\n   * // Extract the type of the value within the Option\n   * //\n   * //      ┌─── string\n   * //      ▼\n   * type MyType = Option.Option.Value<typeof myOption>\n   * ```\n   *\n   * @since 2.0.0\n   * @category Type-level Utils\n   */\n  export type Value<T extends Option<any>> = [T] extends [Option<infer _A>] ? _A : never\n}\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface OptionUnifyIgnore {}\n\n/**\n * @category Type Lambdas\n * @since 2.0.0\n */\nexport interface OptionTypeLambda extends TypeLambda {\n  readonly type: Option<this[\"Target\"]>\n}\n\n/**\n * Represents the absence of a value by creating an empty `Option`.\n *\n * `Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.\n * This means you can use it in place of any `Option<A>` regardless of the type\n * `A`.\n *\n * **Example** (Creating an Option with No Value)\n *\n * ```ts\n * import { Option } from \"effect\"\n *\n * // An Option holding no value\n * //\n * //      ┌─── Option<never>\n * //      ▼\n * const noValue = Option.none()\n *\n * console.log(noValue)\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @see {@link some} for the opposite operation.\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const none = <A = never>(): Option<A> => option.none\n\n/**\n * Wraps the given value into an `Option` to represent its presence.\n *\n * **Example** (Creating an Option with a Value)\n *\n * ```ts\n * import { Option } from \"effect\"\n *\n * // An Option holding the number 1\n * //\n * //      ┌─── Option<number>\n * //      ▼\n * const value = Option.some(1)\n *\n * console.log(value)\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @see {@link none} for the opposite operation.\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const some: <A>(value: A) => Option<A> = option.some\n\n/**\n * Determines whether the given value is an `Option`.\n *\n * **Details**\n *\n * This function checks if a value is an instance of `Option`. It returns `true`\n * if the value is either `Option.some` or `Option.none`, and `false` otherwise.\n * This is particularly useful when working with unknown values or when you need\n * to ensure type safety in your code.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isOption(Option.some(1)))\n * // Output: true\n *\n * console.log(Option.isOption(Option.none()))\n * // Output: true\n *\n * console.log(Option.isOption({}))\n * // Output: false\n * ```\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isOption: (input: unknown) => input is Option<unknown> = option.isOption\n\n/**\n * Checks whether an `Option` represents the absence of a value (`None`).\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isNone(Option.some(1)))\n * // Output: false\n *\n * console.log(Option.isNone(Option.none()))\n * // Output: true\n * ```\n *\n * @see {@link isSome} for the opposite check.\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isNone: <A>(self: Option<A>) => self is None<A> = option.isNone\n\n/**\n * Checks whether an `Option` contains a value (`Some`).\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isSome(Option.some(1)))\n * // Output: true\n *\n * console.log(Option.isSome(Option.none()))\n * // Output: false\n * ```\n *\n * @see {@link isNone} for the opposite check.\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isSome: <A>(self: Option<A>) => self is Some<A> = option.isSome\n\n/**\n * Performs pattern matching on an `Option` to handle both `Some` and `None`\n * cases.\n *\n * **Details**\n *\n * This function allows you to match against an `Option` and handle both\n * scenarios: when the `Option` is `None` (i.e., contains no value), and when\n * the `Option` is `Some` (i.e., contains a value). It executes one of the\n * provided functions based on the case:\n *\n * - If the `Option` is `None`, the `onNone` function is executed and its result\n *   is returned.\n * - If the `Option` is `Some`, the `onSome` function is executed with the\n *   contained value, and its result is returned.\n *\n * This function provides a concise and functional way to handle optional values\n * without resorting to `if` or manual checks, making your code more declarative\n * and readable.\n *\n * **Example** (Pattern Matching with Option)\n *\n * ```ts\n * import { Option } from \"effect\"\n *\n * const foo = Option.some(1)\n *\n * const message = Option.match(foo, {\n *   onNone: () => \"Option is empty\",\n *   onSome: (value) => `Option has a value: ${value}`\n * })\n *\n * console.log(message)\n * // Output: \"Option has a value: 1\"\n * ```\n *\n * @category Pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  /**\n   * Performs pattern matching on an `Option` to handle both `Some` and `None`\n   * cases.\n   *\n   * **Details**\n   *\n   * This function allows you to match against an `Option` and handle both\n   * scenarios: when the `Option` is `None` (i.e., contains no value), and when\n   * the `Option` is `Some` (i.e., contains a value). It executes one of the\n   * provided functions based on the case:\n   *\n   * - If the `Option` is `None`, the `onNone` function is executed and its result\n   *   is returned.\n   * - If the `Option` is `Some`, the `onSome` function is executed with the\n   *   contained value, and its result is returned.\n   *\n   * This function provides a concise and functional way to handle optional values\n   * without resorting to `if` or manual checks, making your code more declarative\n   * and readable.\n   *\n   * **Example** (Pattern Matching with Option)\n   *\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const foo = Option.some(1)\n   *\n   * const message = Option.match(foo, {\n   *   onNone: () => \"Option is empty\",\n   *   onSome: (value) => `Option has a value: ${value}`\n   * })\n   *\n   * console.log(message)\n   * // Output: \"Option has a value: 1\"\n   * ```\n   *\n   * @category Pattern matching\n   * @since 2.0.0\n   */\n  <B, A, C = B>(\n    options: {\n      readonly onNone: LazyArg<B>\n      readonly onSome: (a: A) => C\n    }\n  ): (self: Option<A>) => B | C\n  /**\n   * Performs pattern matching on an `Option` to handle both `Some` and `None`\n   * cases.\n   *\n   * **Details**\n   *\n   * This function allows you to match against an `Option` and handle both\n   * scenarios: when the `Option` is `None` (i.e., contains no value), and when\n   * the `Option` is `Some` (i.e., contains a value). It executes one of the\n   * provided functions based on the case:\n   *\n   * - If the `Option` is `None`, the `onNone` function is executed and its result\n   *   is returned.\n   * - If the `Option` is `Some`, the `onSome` function is executed with the\n   *   contained value, and its result is returned.\n   *\n   * This function provides a concise and functional way to handle optional values\n   * without resorting to `if` or manual checks, making your code more declarative\n   * and readable.\n   *\n   * **Example** (Pattern Matching with Option)\n   *\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const foo = Option.some(1)\n   *\n   * const message = Option.match(foo, {\n   *   onNone: () => \"Option is empty\",\n   *   onSome: (value) => `Option has a value: ${value}`\n   * })\n   *\n   * console.log(message)\n   * // Output: \"Option has a value: 1\"\n   * ```\n   *\n   * @category Pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    self: Option<A>,\n    options: {\n      readonly onNone: LazyArg<B>\n      readonly onSome: (a: A) => C\n    }\n  ): B | C\n} = dual(\n  2,\n  <A, B, C = B>(self: Option<A>, { onNone, onSome }: {\n    readonly onNone: LazyArg<B>\n    readonly onSome: (a: A) => C\n  }): B | C => isNone(self) ? onNone() : onSome(self.value)\n)\n\n/**\n * Converts an `Option`-returning function into a type guard.\n *\n * **Details**\n *\n * This function transforms a function that returns an `Option` into a type\n * guard, ensuring type safety when validating or narrowing types. The returned\n * type guard function checks whether the input satisfies the condition defined\n * in the original `Option`-returning function.\n *\n * If the original function returns `Option.some`, the type guard evaluates to\n * `true`, confirming the input is of the desired type. If the function returns\n * `Option.none`, the type guard evaluates to `false`.\n *\n * This utility is especially useful for validating types in union types,\n * filtering arrays, or ensuring safe handling of specific subtypes.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * type MyData = string | number\n *\n * const parseString = (data: MyData): Option.Option<string> =>\n *   typeof data === \"string\" ? Option.some(data) : Option.none()\n *\n * //      ┌─── (a: MyData) => a is string\n * //      ▼\n * const isString = Option.toRefinement(parseString)\n *\n * console.log(isString(\"a\"))\n * // Output: true\n *\n * console.log(isString(1))\n * // Output: false\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const toRefinement = <A, B extends A>(f: (a: A) => Option<B>): (a: A) => a is B => (a: A): a is B => isSome(f(a))\n\n/**\n * Converts an `Iterable` into an `Option`, wrapping the first element if it\n * exists.\n *\n * **Details**\n *\n * This function takes an `Iterable` (e.g., an array, a generator, or any object\n * implementing the `Iterable` interface) and returns an `Option` based on its\n * content:\n *\n * - If the `Iterable` contains at least one element, the first element is\n *   wrapped in a `Some` and returned.\n * - If the `Iterable` is empty, `None` is returned, representing the absence of\n *   a value.\n *\n * This utility is useful for safely handling collections that might be empty,\n * ensuring you explicitly handle both cases where a value exists or doesn't.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.fromIterable([1, 2, 3]))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(Option.fromIterable([]))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const fromIterable = <A>(collection: Iterable<A>): Option<A> => {\n  for (const a of collection) {\n    return some(a)\n  }\n  return none()\n}\n\n/**\n * Converts an `Either` into an `Option` by discarding the error and extracting\n * the right value.\n *\n * **Details**\n *\n * This function takes an `Either` and returns an `Option` based on its value:\n *\n * - If the `Either` is a `Right`, its value is wrapped in a `Some` and\n *   returned.\n * - If the `Either` is a `Left`, the error is discarded, and `None` is\n *   returned.\n *\n * This is particularly useful when you only care about the success case\n * (`Right`) of an `Either` and want to handle the result using `Option`. By\n * using this function, you can convert `Either` into a simpler structure for\n * cases where error handling is not required.\n *\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * console.log(Option.getRight(Either.right(\"ok\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'ok' }\n *\n * console.log(Option.getRight(Either.left(\"err\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @see {@link getLeft} for the opposite operation.\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getRight: <R, L>(self: Either<R, L>) => Option<R> = either.getRight\n\n/**\n * Converts an `Either` into an `Option` by discarding the right value and\n * extracting the left value.\n *\n * **Details**\n *\n * This function transforms an `Either` into an `Option` as follows:\n *\n * - If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.\n * - If the `Either` is a `Right`, the value is discarded, and `None` is\n *   returned.\n *\n * This utility is useful when you only care about the error case (`Left`) of an\n * `Either` and want to handle it as an `Option`. By discarding the right value,\n * it simplifies error-focused workflows.\n *\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * console.log(Option.getLeft(Either.right(\"ok\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.getLeft(Either.left(\"err\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'err' }\n * ```\n *\n * @see {@link getRight} for the opposite operation.\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getLeft: <R, L>(self: Either<R, L>) => Option<L> = either.getLeft\n\n/**\n * Returns the value contained in the `Option` if it is `Some`, otherwise\n * evaluates and returns the result of `onNone`.\n *\n * **Details**\n *\n * This function allows you to provide a fallback value or computation for when\n * an `Option` is `None`. If the `Option` contains a value (`Some`), that value\n * is returned. If it is empty (`None`), the `onNone` function is executed, and\n * its result is returned instead.\n *\n * This utility is helpful for safely handling `Option` values by ensuring you\n * always receive a meaningful result, whether or not the `Option` contains a\n * value. It is particularly useful for providing default values or alternative\n * logic when working with optional values.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n * // Output: 1\n *\n * console.log(Option.none().pipe(Option.getOrElse(() => 0)))\n * // Output: 0\n * ```\n *\n * @see {@link getOrNull} for a version that returns `null` instead of executing a function.\n * @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrElse: {\n  /**\n   * Returns the value contained in the `Option` if it is `Some`, otherwise\n   * evaluates and returns the result of `onNone`.\n   *\n   * **Details**\n   *\n   * This function allows you to provide a fallback value or computation for when\n   * an `Option` is `None`. If the `Option` contains a value (`Some`), that value\n   * is returned. If it is empty (`None`), the `onNone` function is executed, and\n   * its result is returned instead.\n   *\n   * This utility is helpful for safely handling `Option` values by ensuring you\n   * always receive a meaningful result, whether or not the `Option` contains a\n   * value. It is particularly useful for providing default values or alternative\n   * logic when working with optional values.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n   * // Output: 1\n   *\n   * console.log(Option.none().pipe(Option.getOrElse(() => 0)))\n   * // Output: 0\n   * ```\n   *\n   * @see {@link getOrNull} for a version that returns `null` instead of executing a function.\n   * @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.\n   *\n   * @category Getters\n   * @since 2.0.0\n   */\n  <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A\n  /**\n   * Returns the value contained in the `Option` if it is `Some`, otherwise\n   * evaluates and returns the result of `onNone`.\n   *\n   * **Details**\n   *\n   * This function allows you to provide a fallback value or computation for when\n   * an `Option` is `None`. If the `Option` contains a value (`Some`), that value\n   * is returned. If it is empty (`None`), the `onNone` function is executed, and\n   * its result is returned instead.\n   *\n   * This utility is helpful for safely handling `Option` values by ensuring you\n   * always receive a meaningful result, whether or not the `Option` contains a\n   * value. It is particularly useful for providing default values or alternative\n   * logic when working with optional values.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n   * // Output: 1\n   *\n   * console.log(Option.none().pipe(Option.getOrElse(() => 0)))\n   * // Output: 0\n   * ```\n   *\n   * @see {@link getOrNull} for a version that returns `null` instead of executing a function.\n   * @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.\n   *\n   * @category Getters\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B\n} = dual(\n  2,\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B => isNone(self) ? onNone() : self.value\n)\n\n/**\n * Returns the provided `Option` `that` if the current `Option` (`self`) is\n * `None`; otherwise, it returns `self`.\n *\n * **Details**\n *\n * This function provides a fallback mechanism for `Option` values. If the\n * current `Option` is `None` (i.e., it contains no value), the `that` function\n * is evaluated, and its resulting `Option` is returned. If the current `Option`\n * is `Some` (i.e., it contains a value), the original `Option` is returned\n * unchanged.\n *\n * This is particularly useful for chaining fallback values or computations,\n * allowing you to provide alternative `Option` values when the first one is\n * empty.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.none().pipe(Option.orElse(() => Option.none())))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n *\n * console.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElse: {\n  /**\n   * Returns the provided `Option` `that` if the current `Option` (`self`) is\n   * `None`; otherwise, it returns `self`.\n   *\n   * **Details**\n   *\n   * This function provides a fallback mechanism for `Option` values. If the\n   * current `Option` is `None` (i.e., it contains no value), the `that` function\n   * is evaluated, and its resulting `Option` is returned. If the current `Option`\n   * is `Some` (i.e., it contains a value), the original `Option` is returned\n   * unchanged.\n   *\n   * This is particularly useful for chaining fallback values or computations,\n   * allowing you to provide alternative `Option` values when the first one is\n   * empty.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.none().pipe(Option.orElse(() => Option.none())))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   *\n   * console.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>\n  /**\n   * Returns the provided `Option` `that` if the current `Option` (`self`) is\n   * `None`; otherwise, it returns `self`.\n   *\n   * **Details**\n   *\n   * This function provides a fallback mechanism for `Option` values. If the\n   * current `Option` is `None` (i.e., it contains no value), the `that` function\n   * is evaluated, and its resulting `Option` is returned. If the current `Option`\n   * is `Some` (i.e., it contains a value), the original `Option` is returned\n   * unchanged.\n   *\n   * This is particularly useful for chaining fallback values or computations,\n   * allowing you to provide alternative `Option` values when the first one is\n   * empty.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.none().pipe(Option.orElse(() => Option.none())))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   *\n   * console.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B> => isNone(self) ? that() : self\n)\n\n/**\n * Returns the provided default value wrapped in `Some` if the current `Option`\n * (`self`) is `None`; otherwise, returns `self`.\n *\n * **Details**\n *\n * This function provides a way to supply a default value for cases where an\n * `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\n * function is executed to compute the default value, which is then wrapped in a\n * `Some`. If the current `Option` contains a value (`Some`), it is returned as\n * is.\n *\n * This is particularly useful for handling optional values where a fallback\n * default needs to be provided explicitly in case of absence.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElseSome: {\n  /**\n   * Returns the provided default value wrapped in `Some` if the current `Option`\n   * (`self`) is `None`; otherwise, returns `self`.\n   *\n   * **Details**\n   *\n   * This function provides a way to supply a default value for cases where an\n   * `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\n   * function is executed to compute the default value, which is then wrapped in a\n   * `Some`. If the current `Option` contains a value (`Some`), it is returned as\n   * is.\n   *\n   * This is particularly useful for handling optional values where a fallback\n   * default needs to be provided explicitly in case of absence.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>\n  /**\n   * Returns the provided default value wrapped in `Some` if the current `Option`\n   * (`self`) is `None`; otherwise, returns `self`.\n   *\n   * **Details**\n   *\n   * This function provides a way to supply a default value for cases where an\n   * `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\n   * function is executed to compute the default value, which is then wrapped in a\n   * `Some`. If the current `Option` contains a value (`Some`), it is returned as\n   * is.\n   *\n   * This is particularly useful for handling optional values where a fallback\n   * default needs to be provided explicitly in case of absence.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n   *\n   * console.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B> => isNone(self) ? some(onNone()) : self\n)\n\n/**\n * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n * indicate the source of the value.\n *\n * **Details**\n *\n * This function allows you to provide a fallback `Option` in case the current\n * `Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\n * wrapped in an `Either` object, providing additional information about where\n * the value came from:\n *\n * - If the value is from the fallback `Option` (`that`), it is wrapped in an\n *   `Either.right`.\n * - If the value is from the original `Option` (`self`), it is wrapped in an\n *   `Either.left`.\n *\n * This is especially useful when you need to differentiate between values\n * originating from the primary `Option` and those coming from the fallback,\n * while still maintaining the `Option`-style handling.\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElseEither: {\n  /**\n   * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n   * indicate the source of the value.\n   *\n   * **Details**\n   *\n   * This function allows you to provide a fallback `Option` in case the current\n   * `Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\n   * wrapped in an `Either` object, providing additional information about where\n   * the value came from:\n   *\n   * - If the value is from the fallback `Option` (`that`), it is wrapped in an\n   *   `Either.right`.\n   * - If the value is from the original `Option` (`self`), it is wrapped in an\n   *   `Either.left`.\n   *\n   * This is especially useful when you need to differentiate between values\n   * originating from the primary `Option` and those coming from the fallback,\n   * while still maintaining the `Option`-style handling.\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>\n  /**\n   * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n   * indicate the source of the value.\n   *\n   * **Details**\n   *\n   * This function allows you to provide a fallback `Option` in case the current\n   * `Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\n   * wrapped in an `Either` object, providing additional information about where\n   * the value came from:\n   *\n   * - If the value is from the fallback `Option` (`that`), it is wrapped in an\n   *   `Either.right`.\n   * - If the value is from the original `Option` (`self`), it is wrapped in an\n   *   `Either.left`.\n   *\n   * This is especially useful when you need to differentiate between values\n   * originating from the primary `Option` and those coming from the fallback,\n   * while still maintaining the `Option`-style handling.\n   *\n   * @category Error handling\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>> =>\n    isNone(self) ? map(that(), either.right) : map(self, either.left)\n)\n\n/**\n * Returns the first `Some` value found in an `Iterable` collection of\n * `Option`s, or `None` if no `Some` is found.\n *\n * **Details**\n *\n * This function iterates over a collection of `Option` values and returns the\n * first `Some` it encounters. If the collection contains only `None` values,\n * the result will also be `None`. This utility is useful for efficiently\n * finding the first valid value in a sequence of potentially empty or invalid\n * options.\n *\n * The iteration stops as soon as a `Some` is found, making this function\n * efficient for large collections.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.firstSomeOf([\n *   Option.none(),\n *   Option.some(1),\n *   Option.some(2)\n * ]))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const firstSomeOf = <T, C extends Iterable<Option<T>> = Iterable<Option<T>>>(\n  collection: C\n): [C] extends [Iterable<Option<infer A>>] ? Option<A> : never => {\n  let out: Option<unknown> = none()\n  for (out of collection) {\n    if (isSome(out)) {\n      return out as any\n    }\n  }\n  return out as any\n}\n\n/**\n * Converts a nullable value into an `Option`. Returns `None` if the value is\n * `null` or `undefined`, otherwise wraps the value in a `Some`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.fromNullable(undefined))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.fromNullable(null))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.fromNullable(1))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const fromNullable = <A>(\n  nullableValue: A\n): Option<NonNullable<A>> => (nullableValue == null ? none() : some(nullableValue as NonNullable<A>))\n\n/**\n * Lifts a function that returns `null` or `undefined` into the `Option`\n * context.\n *\n * **Details**\n *\n * This function takes a function `f` that might return `null` or `undefined`\n * and transforms it into a function that returns an `Option`. The resulting\n * function will return:\n * - `Some` if the original function produces a non-null, non-undefined value.\n * - `None` if the original function produces `null` or `undefined`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = Option.liftNullable(parse)\n *\n * console.log(parseOption(\"1\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parseOption(\"not a number\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const liftNullable = <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n): (...a: A) => Option<NonNullable<B>> =>\n(...a) => fromNullable(f(...a))\n\n/**\n * Returns the value contained in the `Option` if it is `Some`; otherwise,\n * returns `null`.\n *\n * **Details**\n *\n * This function provides a way to extract the value of an `Option` while\n * falling back to `null` if the `Option` is `None`.\n *\n * It is particularly useful in scenarios where `null` is an acceptable\n * placeholder for the absence of a value, such as when interacting with APIs or\n * systems that use `null` as a default for missing values.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.getOrNull(Option.some(1)))\n * // Output: 1\n *\n * console.log(Option.getOrNull(Option.none()))\n * // Output: null\n * ```\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrNull: <A>(self: Option<A>) => A | null = getOrElse(constNull)\n\n/**\n * Returns the value contained in the `Option` if it is `Some`; otherwise,\n * returns `undefined`.\n *\n * **Details**\n *\n * This function provides a way to extract the value of an `Option` while\n * falling back to `undefined` if the `Option` is `None`.\n *\n * It is particularly useful in scenarios where `undefined` is an acceptable\n * placeholder for the absence of a value, such as when interacting with APIs or\n * systems that use `undefined` as a default for missing values.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.getOrUndefined(Option.some(1)))\n * // Output: 1\n *\n * console.log(Option.getOrUndefined(Option.none()))\n * // Output: undefined\n * ```\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrUndefined: <A>(self: Option<A>) => A | undefined = getOrElse(constUndefined)\n\n/**\n * Lifts a function that throws exceptions into a function that returns an\n * `Option`.\n *\n * **Details**\n *\n * This utility function takes a function `f` that might throw an exception and\n * transforms it into a safer function that returns an `Option`. If the original\n * function executes successfully, the result is wrapped in a `Some`. If an\n * exception is thrown, the result is `None`, allowing the developer to handle\n * errors in a functional, type-safe way.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = Option.liftThrowable(JSON.parse)\n *\n * console.log(parse(\"1\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parse(\"\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const liftThrowable = <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B\n): (...a: A) => Option<B> =>\n(...a) => {\n  try {\n    return some(f(...a))\n  } catch {\n    return none()\n  }\n}\n\n/**\n * Extracts the value of an `Option` or throws an error if the `Option` is\n * `None`, using a custom error factory.\n *\n * **Details**\n *\n * This function allows you to extract the value of an `Option` when it is\n * `Some`. If the `Option` is `None`, it throws an error generated by the\n * provided `onNone` function. This utility is particularly useful when you need\n * a fail-fast behavior for empty `Option` values and want to provide a custom\n * error message or object.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n * ```\n *\n * @see {@link getOrThrow} for a version that throws a default error.\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getOrThrowWith: {\n  /**\n   * Extracts the value of an `Option` or throws an error if the `Option` is\n   * `None`, using a custom error factory.\n   *\n   * **Details**\n   *\n   * This function allows you to extract the value of an `Option` when it is\n   * `Some`. If the `Option` is `None`, it throws an error generated by the\n   * provided `onNone` function. This utility is particularly useful when you need\n   * a fail-fast behavior for empty `Option` values and want to provide a custom\n   * error message or object.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n   *   1\n   * )\n   * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n   * ```\n   *\n   * @see {@link getOrThrow} for a version that throws a default error.\n   *\n   * @category Conversions\n   * @since 2.0.0\n   */\n  (onNone: () => unknown): <A>(self: Option<A>) => A\n  /**\n   * Extracts the value of an `Option` or throws an error if the `Option` is\n   * `None`, using a custom error factory.\n   *\n   * **Details**\n   *\n   * This function allows you to extract the value of an `Option` when it is\n   * `Some`. If the `Option` is `None`, it throws an error generated by the\n   * provided `onNone` function. This utility is particularly useful when you need\n   * a fail-fast behavior for empty `Option` values and want to provide a custom\n   * error message or object.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n   *   1\n   * )\n   * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n   * ```\n   *\n   * @see {@link getOrThrow} for a version that throws a default error.\n   *\n   * @category Conversions\n   * @since 2.0.0\n   */\n  <A>(self: Option<A>, onNone: () => unknown): A\n} = dual(2, <A>(self: Option<A>, onNone: () => unknown): A => {\n  if (isSome(self)) {\n    return self.value\n  }\n  throw onNone()\n})\n\n/**\n * Extracts the value of an `Option` or throws a default error if the `Option`\n * is `None`.\n *\n * **Details**\n *\n * This function extracts the value from an `Option` if it is `Some`. If the\n * `Option` is `None`, it throws a default error. It is useful for fail-fast\n * scenarios where the absence of a value is treated as an exceptional case and\n * a default error is sufficient.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\n * assert.throws(() => Option.getOrThrow(Option.none()))\n * ```\n *\n * @see {@link getOrThrowWith} for a version that allows you to provide a custom error.\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getOrThrow: <A>(self: Option<A>) => A = getOrThrowWith(() => new Error(\"getOrThrow called on a None\"))\n\n/**\n * Transforms the value inside a `Some` to a new value using the provided\n * function, while leaving `None` unchanged.\n *\n * **Details**\n *\n * This function applies a mapping function `f` to the value inside an `Option`\n * if it is a `Some`. If the `Option` is `None`, it remains unchanged. The\n * result is a new `Option` with the transformed value (if it was a `Some`) or\n * still `None`.\n *\n * This utility is particularly useful for chaining transformations in a\n * functional way without needing to manually handle `None` cases.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Mapping over a `Some`\n * const someValue = Option.some(2)\n *\n * console.log(Option.map(someValue, (n) => n * 2))\n * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n *\n * // Mapping over a `None`\n * const noneValue = Option.none<number>()\n *\n * console.log(Option.map(noneValue, (n) => n * 2))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const map: {\n  /**\n   * Transforms the value inside a `Some` to a new value using the provided\n   * function, while leaving `None` unchanged.\n   *\n   * **Details**\n   *\n   * This function applies a mapping function `f` to the value inside an `Option`\n   * if it is a `Some`. If the `Option` is `None`, it remains unchanged. The\n   * result is a new `Option` with the transformed value (if it was a `Some`) or\n   * still `None`.\n   *\n   * This utility is particularly useful for chaining transformations in a\n   * functional way without needing to manually handle `None` cases.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Mapping over a `Some`\n   * const someValue = Option.some(2)\n   *\n   * console.log(Option.map(someValue, (n) => n * 2))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n   *\n   * // Mapping over a `None`\n   * const noneValue = Option.none<number>()\n   *\n   * console.log(Option.map(noneValue, (n) => n * 2))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Mapping\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>\n  /**\n   * Transforms the value inside a `Some` to a new value using the provided\n   * function, while leaving `None` unchanged.\n   *\n   * **Details**\n   *\n   * This function applies a mapping function `f` to the value inside an `Option`\n   * if it is a `Some`. If the `Option` is `None`, it remains unchanged. The\n   * result is a new `Option` with the transformed value (if it was a `Some`) or\n   * still `None`.\n   *\n   * This utility is particularly useful for chaining transformations in a\n   * functional way without needing to manually handle `None` cases.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Mapping over a `Some`\n   * const someValue = Option.some(2)\n   *\n   * console.log(Option.map(someValue, (n) => n * 2))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n   *\n   * // Mapping over a `None`\n   * const noneValue = Option.none<number>()\n   *\n   * console.log(Option.map(noneValue, (n) => n * 2))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Mapping\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B> => isNone(self) ? none() : some(f(self.value))\n)\n\n/**\n * Replaces the value inside a `Some` with the specified constant value, leaving\n * `None` unchanged.\n *\n * **Details**\n *\n * This function transforms an `Option` by replacing the value inside a `Some`\n * with the given constant value `b`. If the `Option` is `None`, it remains\n * unchanged.\n *\n * This is useful when you want to preserve the presence of a value (`Some`) but\n * replace its content with a fixed value.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Replacing the value of a `Some`\n * const someValue = Option.some(42)\n *\n * console.log(Option.as(someValue, \"new value\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n *\n * // Replacing a `None` (no effect)\n * const noneValue = Option.none<number>()\n *\n * console.log(Option.as(noneValue, \"new value\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const as: {\n  /**\n   * Replaces the value inside a `Some` with the specified constant value, leaving\n   * `None` unchanged.\n   *\n   * **Details**\n   *\n   * This function transforms an `Option` by replacing the value inside a `Some`\n   * with the given constant value `b`. If the `Option` is `None`, it remains\n   * unchanged.\n   *\n   * This is useful when you want to preserve the presence of a value (`Some`) but\n   * replace its content with a fixed value.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Replacing the value of a `Some`\n   * const someValue = Option.some(42)\n   *\n   * console.log(Option.as(someValue, \"new value\"))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n   *\n   * // Replacing a `None` (no effect)\n   * const noneValue = Option.none<number>()\n   *\n   * console.log(Option.as(noneValue, \"new value\"))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Mapping\n   * @since 2.0.0\n   */\n  <B>(b: B): <X>(self: Option<X>) => Option<B>\n  /**\n   * Replaces the value inside a `Some` with the specified constant value, leaving\n   * `None` unchanged.\n   *\n   * **Details**\n   *\n   * This function transforms an `Option` by replacing the value inside a `Some`\n   * with the given constant value `b`. If the `Option` is `None`, it remains\n   * unchanged.\n   *\n   * This is useful when you want to preserve the presence of a value (`Some`) but\n   * replace its content with a fixed value.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Replacing the value of a `Some`\n   * const someValue = Option.some(42)\n   *\n   * console.log(Option.as(someValue, \"new value\"))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n   *\n   * // Replacing a `None` (no effect)\n   * const noneValue = Option.none<number>()\n   *\n   * console.log(Option.as(noneValue, \"new value\"))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Mapping\n   * @since 2.0.0\n   */\n  <X, B>(self: Option<X>, b: B): Option<B>\n} = dual(2, <X, B>(self: Option<X>, b: B): Option<B> => map(self, () => b))\n\n/**\n * Replaces the value inside a `Some` with the constant value `void`, leaving\n * `None` unchanged.\n *\n * **Details**\n *\n * This function transforms an `Option` by replacing the value inside a `Some`\n * with `void`. If the `Option` is `None`, it remains unchanged.\n *\n * This is particularly useful in scenarios where the presence or absence of a\n * value is significant, but the actual content of the value is irrelevant.\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const asVoid: <_>(self: Option<_>) => Option<void> = as(undefined)\n\nconst void_: Option<void> = some(undefined)\nexport {\n  /**\n   * @since 2.0.0\n   */\n  void_ as void\n}\n\n/**\n * Applies a function to the value of a `Some` and flattens the resulting\n * `Option`. If the input is `None`, it remains `None`.\n *\n * **Details**\n *\n * This function allows you to chain computations that return `Option` values.\n * If the input `Option` is `Some`, the provided function `f` is applied to the\n * contained value, and the resulting `Option` is returned. If the input is\n * `None`, the function is not applied, and the result remains `None`.\n *\n * This utility is particularly useful for sequencing operations that may fail\n * or produce optional results, enabling clean and concise workflows for\n * handling such cases.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * interface Address {\n *   readonly city: string\n *   readonly street: Option.Option<string>\n * }\n *\n * interface User {\n *   readonly id: number\n *   readonly username: string\n *   readonly email: Option.Option<string>\n *   readonly address: Option.Option<Address>\n * }\n *\n * const user: User = {\n *   id: 1,\n *   username: \"john_doe\",\n *   email: Option.some(\"john.doe@example.com\"),\n *   address: Option.some({\n *     city: \"New York\",\n *     street: Option.some(\"123 Main St\")\n *   })\n * }\n *\n * // Use flatMap to extract the street value\n * const street = user.address.pipe(\n *   Option.flatMap((address) => address.street)\n * )\n *\n * console.log(street)\n * // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  /**\n   * Applies a function to the value of a `Some` and flattens the resulting\n   * `Option`. If the input is `None`, it remains `None`.\n   *\n   * **Details**\n   *\n   * This function allows you to chain computations that return `Option` values.\n   * If the input `Option` is `Some`, the provided function `f` is applied to the\n   * contained value, and the resulting `Option` is returned. If the input is\n   * `None`, the function is not applied, and the result remains `None`.\n   *\n   * This utility is particularly useful for sequencing operations that may fail\n   * or produce optional results, enabling clean and concise workflows for\n   * handling such cases.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * interface Address {\n   *   readonly city: string\n   *   readonly street: Option.Option<string>\n   * }\n   *\n   * interface User {\n   *   readonly id: number\n   *   readonly username: string\n   *   readonly email: Option.Option<string>\n   *   readonly address: Option.Option<Address>\n   * }\n   *\n   * const user: User = {\n   *   id: 1,\n   *   username: \"john_doe\",\n   *   email: Option.some(\"john.doe@example.com\"),\n   *   address: Option.some({\n   *     city: \"New York\",\n   *     street: Option.some(\"123 Main St\")\n   *   })\n   * }\n   *\n   * // Use flatMap to extract the street value\n   * const street = user.address.pipe(\n   *   Option.flatMap((address) => address.street)\n   * )\n   *\n   * console.log(street)\n   * // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  /**\n   * Applies a function to the value of a `Some` and flattens the resulting\n   * `Option`. If the input is `None`, it remains `None`.\n   *\n   * **Details**\n   *\n   * This function allows you to chain computations that return `Option` values.\n   * If the input `Option` is `Some`, the provided function `f` is applied to the\n   * contained value, and the resulting `Option` is returned. If the input is\n   * `None`, the function is not applied, and the result remains `None`.\n   *\n   * This utility is particularly useful for sequencing operations that may fail\n   * or produce optional results, enabling clean and concise workflows for\n   * handling such cases.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * interface Address {\n   *   readonly city: string\n   *   readonly street: Option.Option<string>\n   * }\n   *\n   * interface User {\n   *   readonly id: number\n   *   readonly username: string\n   *   readonly email: Option.Option<string>\n   *   readonly address: Option.Option<Address>\n   * }\n   *\n   * const user: User = {\n   *   id: 1,\n   *   username: \"john_doe\",\n   *   email: Option.some(\"john.doe@example.com\"),\n   *   address: Option.some({\n   *     city: \"New York\",\n   *     street: Option.some(\"123 Main St\")\n   *   })\n   * }\n   *\n   * // Use flatMap to extract the street value\n   * const street = user.address.pipe(\n   *   Option.flatMap((address) => address.street)\n   * )\n   *\n   * console.log(street)\n   * // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B> => isNone(self) ? none() : f(self.value)\n)\n\n/**\n * Chains two `Option`s together. The second `Option` can either be a static\n * value or depend on the result of the first `Option`.\n *\n * **Details**\n *\n * This function enables sequencing of two `Option` computations. If the first\n * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n * either:\n *\n * - Be a static `Option` value.\n * - Be a function that produces an `Option`, optionally based on the value of\n *   the first `Option`.\n *\n * If the first `Option` is `None`, the function skips the evaluation of the\n * second `Option` and directly returns `None`.\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const andThen: {\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: Option<B>): Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>\n  /**\n   * Chains two `Option`s together. The second `Option` can either be a static\n   * value or depend on the result of the first `Option`.\n   *\n   * **Details**\n   *\n   * This function enables sequencing of two `Option` computations. If the first\n   * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n   * either:\n   *\n   * - Be a static `Option` value.\n   * - Be a function that produces an `Option`, optionally based on the value of\n   *   the first `Option`.\n   *\n   * If the first `Option` is `None`, the function skips the evaluation of the\n   * second `Option` and directly returns `None`.\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => Option<B> | Option<B>): Option<B> =>\n    flatMap(self, (a) => {\n      const b = isFunction(f) ? f(a) : f\n      return isOption(b) ? b : some(b)\n    })\n)\n\n/**\n * Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\n * using a function that may return `null` or `undefined`.\n *\n * **Details**\n *\n * This function applies a transformation function `f` to the value inside a\n * `Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\n * returns a value, it is wrapped in a `Some`. If `f` returns `null` or\n * `undefined`, the result is `None`. If the input `Option` is `None`, the\n * function is not applied, and `None` is returned.\n *\n * This utility is particularly useful when working with deeply nested optional\n * values or chaining computations that may result in `null` or `undefined` at\n * some point.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n *\n * // Extracting a deeply nested property\n * console.log(\n *   Option.some(employee1)\n *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n * )\n * // Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * // Property does not exist\n * console.log(\n *   Option.some(employee2)\n *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n * )\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable: {\n  /**\n   * Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\n   * using a function that may return `null` or `undefined`.\n   *\n   * **Details**\n   *\n   * This function applies a transformation function `f` to the value inside a\n   * `Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\n   * returns a value, it is wrapped in a `Some`. If `f` returns `null` or\n   * `undefined`, the result is `None`. If the input `Option` is `None`, the\n   * function is not applied, and `None` is returned.\n   *\n   * This utility is particularly useful when working with deeply nested optional\n   * values or chaining computations that may result in `null` or `undefined` at\n   * some point.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * interface Employee {\n   *   company?: {\n   *     address?: {\n   *       street?: {\n   *         name?: string\n   *       }\n   *     }\n   *   }\n   * }\n   *\n   * const employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n   *\n   * // Extracting a deeply nested property\n   * console.log(\n   *   Option.some(employee1)\n   *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n   * )\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n   *\n   * const employee2: Employee = { company: { address: { street: {} } } }\n   *\n   * // Property does not exist\n   * console.log(\n   *   Option.some(employee2)\n   *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n   * )\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>\n  /**\n   * Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\n   * using a function that may return `null` or `undefined`.\n   *\n   * **Details**\n   *\n   * This function applies a transformation function `f` to the value inside a\n   * `Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\n   * returns a value, it is wrapped in a `Some`. If `f` returns `null` or\n   * `undefined`, the result is `None`. If the input `Option` is `None`, the\n   * function is not applied, and `None` is returned.\n   *\n   * This utility is particularly useful when working with deeply nested optional\n   * values or chaining computations that may result in `null` or `undefined` at\n   * some point.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * interface Employee {\n   *   company?: {\n   *     address?: {\n   *       street?: {\n   *         name?: string\n   *       }\n   *     }\n   *   }\n   * }\n   *\n   * const employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n   *\n   * // Extracting a deeply nested property\n   * console.log(\n   *   Option.some(employee1)\n   *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n   * )\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n   *\n   * const employee2: Employee = { company: { address: { street: {} } } }\n   *\n   * // Property does not exist\n   * console.log(\n   *   Option.some(employee2)\n   *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n   * )\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>> =>\n    isNone(self) ? none() : fromNullable(f(self.value))\n)\n\n/**\n * Flattens an `Option` of `Option` into a single `Option`.\n *\n * **Details**\n *\n * This function takes an `Option` that wraps another `Option` and flattens it\n * into a single `Option`. If the outer `Option` is `Some`, the function\n * extracts the inner `Option`. If the outer `Option` is `None`, the result\n * remains `None`.\n *\n * This is useful for simplifying nested `Option` structures that may arise\n * during functional operations.\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatten: <A>(self: Option<Option<A>>) => Option<A> = flatMap(identity)\n\n/**\n * Combines two `Option`s, keeping the value from the second `Option` if both\n * are `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and returns the second one if the first is\n * `Some`. If the first `Option` is `None`, the result will also be `None`,\n * regardless of the second `Option`. It effectively \"zips\" the two `Option`s\n * while discarding the value from the first `Option`.\n *\n * This is particularly useful when sequencing computations where the result of\n * the first computation is not needed, and you only care about the result of\n * the second computation.\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipRight: {\n  /**\n   * Combines two `Option`s, keeping the value from the second `Option` if both\n   * are `Some`.\n   *\n   * **Details**\n   *\n   * This function takes two `Option`s and returns the second one if the first is\n   * `Some`. If the first `Option` is `None`, the result will also be `None`,\n   * regardless of the second `Option`. It effectively \"zips\" the two `Option`s\n   * while discarding the value from the first `Option`.\n   *\n   * This is particularly useful when sequencing computations where the result of\n   * the first computation is not needed, and you only care about the result of\n   * the second computation.\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>\n  /**\n   * Combines two `Option`s, keeping the value from the second `Option` if both\n   * are `Some`.\n   *\n   * **Details**\n   *\n   * This function takes two `Option`s and returns the second one if the first is\n   * `Some`. If the first `Option` is `None`, the result will also be `None`,\n   * regardless of the second `Option`. It effectively \"zips\" the two `Option`s\n   * while discarding the value from the first `Option`.\n   *\n   * This is particularly useful when sequencing computations where the result of\n   * the first computation is not needed, and you only care about the result of\n   * the second computation.\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <X, B>(self: Option<X>, that: Option<B>): Option<B>\n} = dual(2, <X, B>(self: Option<X>, that: Option<B>): Option<B> => flatMap(self, () => that))\n\n/**\n * Combines two `Option`s, keeping the value from the first `Option` if both are\n * `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and returns the first one if it is `Some`.\n * If either the first `Option` or the second `Option` is `None`, the result\n * will be `None`. This operation \"zips\" the two `Option`s while discarding the\n * value from the second `Option`.\n *\n * This is useful when sequencing computations where the second `Option`\n * represents a dependency or condition that must hold, but its value is\n * irrelevant.\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipLeft: {\n  /**\n   * Combines two `Option`s, keeping the value from the first `Option` if both are\n   * `Some`.\n   *\n   * **Details**\n   *\n   * This function takes two `Option`s and returns the first one if it is `Some`.\n   * If either the first `Option` or the second `Option` is `None`, the result\n   * will be `None`. This operation \"zips\" the two `Option`s while discarding the\n   * value from the second `Option`.\n   *\n   * This is useful when sequencing computations where the second `Option`\n   * represents a dependency or condition that must hold, but its value is\n   * irrelevant.\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>\n  /**\n   * Combines two `Option`s, keeping the value from the first `Option` if both are\n   * `Some`.\n   *\n   * **Details**\n   *\n   * This function takes two `Option`s and returns the first one if it is `Some`.\n   * If either the first `Option` or the second `Option` is `None`, the result\n   * will be `None`. This operation \"zips\" the two `Option`s while discarding the\n   * value from the second `Option`.\n   *\n   * This is useful when sequencing computations where the second `Option`\n   * represents a dependency or condition that must hold, but its value is\n   * irrelevant.\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <A, X>(self: Option<A>, that: Option<X>): Option<A>\n} = dual(2, <A, X>(self: Option<A>, that: Option<X>): Option<A> => tap(self, () => that))\n\n/**\n * Composes two functions that return `Option` values, creating a new function\n * that chains them together.\n *\n * **Details**\n *\n * This function allows you to compose two computations, each represented by a\n * function that returns an `Option`. The result of the first function is passed\n * to the second function if it is `Some`. If the first function returns `None`,\n * the composed function short-circuits and returns `None` without invoking the\n * second function.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n *\n * const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n *\n * const parseAndDouble = Option.composeK(parse, double)\n *\n * console.log(parseAndDouble(\"42\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n *\n * console.log(parseAndDouble(\"not a number\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const composeK: {\n  /**\n   * Composes two functions that return `Option` values, creating a new function\n   * that chains them together.\n   *\n   * **Details**\n   *\n   * This function allows you to compose two computations, each represented by a\n   * function that returns an `Option`. The result of the first function is passed\n   * to the second function if it is `Some`. If the first function returns `None`,\n   * the composed function short-circuits and returns `None` without invoking the\n   * second function.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n   *\n   * const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n   *\n   * const parseAndDouble = Option.composeK(parse, double)\n   *\n   * console.log(parseAndDouble(\"42\"))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n   *\n   * console.log(parseAndDouble(\"not a number\"))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>\n  /**\n   * Composes two functions that return `Option` values, creating a new function\n   * that chains them together.\n   *\n   * **Details**\n   *\n   * This function allows you to compose two computations, each represented by a\n   * function that returns an `Option`. The result of the first function is passed\n   * to the second function if it is `Some`. If the first function returns `None`,\n   * the composed function short-circuits and returns `None` without invoking the\n   * second function.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n   *\n   * const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n   *\n   * const parseAndDouble = Option.composeK(parse, double)\n   *\n   * console.log(parseAndDouble(\"42\"))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n   *\n   * console.log(parseAndDouble(\"not a number\"))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>\n} = dual(2, <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>) => (a: A): Option<C> => flatMap(afb(a), bfc))\n\n/**\n * Applies the provided function `f` to the value of the `Option` if it is\n * `Some` and returns the original `Option`, unless `f` returns `None`, in which\n * case it returns `None`.\n *\n * **Details**\n *\n * This function allows you to perform additional computations on the value of\n * an `Option` without modifying its original value. If the `Option` is `Some`,\n * the provided function `f` is executed with the value, and its result\n * determines whether the original `Option` is returned (`Some`) or the result\n * is `None` if `f` returns `None`. If the input `Option` is `None`, the\n * function is not executed, and `None` is returned.\n *\n * This is particularly useful for applying side conditions or performing\n * validation checks while retaining the original `Option`'s value.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n *\n * console.log(Option.tap(Option.none(), getInteger))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.tap(Option.some(1), getInteger))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(Option.tap(Option.some(1.14), getInteger))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const tap: {\n  /**\n   * Applies the provided function `f` to the value of the `Option` if it is\n   * `Some` and returns the original `Option`, unless `f` returns `None`, in which\n   * case it returns `None`.\n   *\n   * **Details**\n   *\n   * This function allows you to perform additional computations on the value of\n   * an `Option` without modifying its original value. If the `Option` is `Some`,\n   * the provided function `f` is executed with the value, and its result\n   * determines whether the original `Option` is returned (`Some`) or the result\n   * is `None` if `f` returns `None`. If the input `Option` is `None`, the\n   * function is not executed, and `None` is returned.\n   *\n   * This is particularly useful for applying side conditions or performing\n   * validation checks while retaining the original `Option`'s value.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n   *\n   * console.log(Option.tap(Option.none(), getInteger))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(Option.tap(Option.some(1), getInteger))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(Option.tap(Option.some(1.14), getInteger))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>\n  /**\n   * Applies the provided function `f` to the value of the `Option` if it is\n   * `Some` and returns the original `Option`, unless `f` returns `None`, in which\n   * case it returns `None`.\n   *\n   * **Details**\n   *\n   * This function allows you to perform additional computations on the value of\n   * an `Option` without modifying its original value. If the `Option` is `Some`,\n   * the provided function `f` is executed with the value, and its result\n   * determines whether the original `Option` is returned (`Some`) or the result\n   * is `None` if `f` returns `None`. If the input `Option` is `None`, the\n   * function is not executed, and `None` is returned.\n   *\n   * This is particularly useful for applying side conditions or performing\n   * validation checks while retaining the original `Option`'s value.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n   *\n   * console.log(Option.tap(Option.none(), getInteger))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(Option.tap(Option.some(1), getInteger))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(Option.tap(Option.some(1.14), getInteger))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Sequencing\n   * @since 2.0.0\n   */\n  <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>\n} = dual(2, <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A> => flatMap(self, (a) => map(f(a), () => a)))\n\n/**\n * Combines two `Option` values into a single `Option` containing a tuple of\n * their values if both are `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and combines their values into a tuple `[A,\n * B]` if both are `Some`. If either of the `Option`s is `None`, the result is\n * `None`. This is particularly useful for combining multiple `Option` values\n * into a single one, ensuring both contain valid values.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const product = <A, B>(self: Option<A>, that: Option<B>): Option<[A, B]> =>\n  isSome(self) && isSome(that) ? some([self.value, that.value]) : none()\n\n/**\n * Combines an `Option` with a collection of `Option`s into a single `Option`\n * containing a tuple of their values if all are `Some`.\n *\n * **Details**\n *\n * This function takes a primary `Option` and a collection of `Option`s and\n * combines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If\n * the primary `Option` or any `Option` in the collection is `None`, the result\n * is `None`.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const productMany = <A>(\n  self: Option<A>,\n  collection: Iterable<Option<A>>\n): Option<[A, ...Array<A>]> => {\n  if (isNone(self)) {\n    return none()\n  }\n  const out: [A, ...Array<A>] = [self.value]\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none()\n    }\n    out.push(o.value)\n  }\n  return some(out)\n}\n\n/**\n * Combines a structure of `Option`s into a single `Option` containing the\n * values with the same structure.\n *\n * **Details**\n *\n * This function takes a structure of `Option`s (a tuple, struct, or iterable)\n * and produces a single `Option` that contains the values from the input\n * structure if all `Option`s are `Some`. If any `Option` in the input is\n * `None`, the result is `None`. The structure of the input is preserved in the\n * output.\n *\n * - If the input is a tuple (e.g., an array), the result will be an `Option`\n *   containing a tuple with the same length.\n * - If the input is a struct (e.g., an object), the result will be an `Option`\n *   containing a struct with the same keys.\n * - If the input is an iterable, the result will be an `Option` containing an\n *   array.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * //      ┌─── Option<[string, number]>\n * //      ▼\n * const tuple = Option.all([maybeName, maybeAge])\n * console.log(tuple)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }\n *\n * //      ┌─── Option<{ name: string; age: number; }>\n * //      ▼\n * const struct = Option.all({ name: maybeName, age: maybeAge })\n * console.log(struct)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }\n * ```\n *\n * @category Combining\n * @since 2.0.0\n */\n// @ts-expect-error\nexport const all: <const I extends Iterable<Option<any>> | Record<string, Option<any>>>(\n  input: I\n) => [I] extends [ReadonlyArray<Option<any>>] ? Option<\n    { -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never }\n  >\n  : [I] extends [Iterable<Option<infer A>>] ? Option<Array<A>>\n  : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never }> = (\n    input: Iterable<Option<any>> | Record<string, Option<any>>\n  ): Option<any> => {\n    if (Symbol.iterator in input) {\n      const out: Array<Option<any>> = []\n      for (const o of (input as Iterable<Option<any>>)) {\n        if (isNone(o)) {\n          return none()\n        }\n        out.push(o.value)\n      }\n      return some(out)\n    }\n\n    const out: Record<string, any> = {}\n    for (const key of Object.keys(input)) {\n      const o = input[key]\n      if (isNone(o)) {\n        return none()\n      }\n      out[key] = o.value\n    }\n    return some(out)\n  }\n\n/**\n * Combines two `Option` values into a new `Option` by applying a provided\n * function to their values.\n *\n * **Details**\n *\n * This function takes two `Option` values (`self` and `that`) and a combining\n * function `f`. If both `Option` values are `Some`, the function `f` is applied\n * to their values, and the result is wrapped in a new `Some`. If either\n * `Option` is `None`, the result is `None`.\n *\n * This utility is useful for combining two optional computations into a single\n * result while maintaining type safety and avoiding explicit checks for `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * // Combine the name and age into a person object\n * const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n *   name: name.toUpperCase(),\n *   age\n * }))\n *\n * console.log(person)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n * ```\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  /**\n   * Combines two `Option` values into a new `Option` by applying a provided\n   * function to their values.\n   *\n   * **Details**\n   *\n   * This function takes two `Option` values (`self` and `that`) and a combining\n   * function `f`. If both `Option` values are `Some`, the function `f` is applied\n   * to their values, and the result is wrapped in a new `Some`. If either\n   * `Option` is `None`, the result is `None`.\n   *\n   * This utility is useful for combining two optional computations into a single\n   * result while maintaining type safety and avoiding explicit checks for `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const maybeName: Option.Option<string> = Option.some(\"John\")\n   * const maybeAge: Option.Option<number> = Option.some(25)\n   *\n   * // Combine the name and age into a person object\n   * const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n   *   name: name.toUpperCase(),\n   *   age\n   * }))\n   *\n   * console.log(person)\n   * // Output:\n   * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n   * ```\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>\n  /**\n   * Combines two `Option` values into a new `Option` by applying a provided\n   * function to their values.\n   *\n   * **Details**\n   *\n   * This function takes two `Option` values (`self` and `that`) and a combining\n   * function `f`. If both `Option` values are `Some`, the function `f` is applied\n   * to their values, and the result is wrapped in a new `Some`. If either\n   * `Option` is `None`, the result is `None`.\n   *\n   * This utility is useful for combining two optional computations into a single\n   * result while maintaining type safety and avoiding explicit checks for `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const maybeName: Option.Option<string> = Option.some(\"John\")\n   * const maybeAge: Option.Option<number> = Option.some(25)\n   *\n   * // Combine the name and age into a person object\n   * const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n   *   name: name.toUpperCase(),\n   *   age\n   * }))\n   *\n   * console.log(person)\n   * // Output:\n   * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n   * ```\n   *\n   * @category Zipping\n   * @since 2.0.0\n   */\n  <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>\n} = dual(\n  3,\n  <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C> =>\n    map(product(self, that), ([a, b]) => f(a, b))\n)\n\n/**\n * Applies a function inside a `Some` to a value inside another `Some`,\n * combining them into a new `Option`.\n *\n * **Details**\n *\n * This function allows you to apply a function wrapped in an `Option` (`self`)\n * to a value wrapped in another `Option` (`that`). If both `Option`s are\n * `Some`, the function is applied to the value, and the result is wrapped in a\n * new `Some`. If either `Option` is `None`, the result is `None`.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const ap: {\n  /**\n   * Applies a function inside a `Some` to a value inside another `Some`,\n   * combining them into a new `Option`.\n   *\n   * **Details**\n   *\n   * This function allows you to apply a function wrapped in an `Option` (`self`)\n   * to a value wrapped in another `Option` (`that`). If both `Option`s are\n   * `Some`, the function is applied to the value, and the result is wrapped in a\n   * new `Some`. If either `Option` is `None`, the result is `None`.\n   *\n   * @category Combining\n   * @since 2.0.0\n   */\n  <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>\n  /**\n   * Applies a function inside a `Some` to a value inside another `Some`,\n   * combining them into a new `Option`.\n   *\n   * **Details**\n   *\n   * This function allows you to apply a function wrapped in an `Option` (`self`)\n   * to a value wrapped in another `Option` (`that`). If both `Option`s are\n   * `Some`, the function is applied to the value, and the result is wrapped in a\n   * new `Some`. If either `Option` is `None`, the result is `None`.\n   *\n   * @category Combining\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>\n} = dual(2, <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B> => zipWith(self, that, (f, a) => f(a)))\n\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\n * elements that are `None`.\n *\n * **Details**\n *\n * This function takes an initial value of type `B` and a reducing function `f`\n * that combines the accumulator with values of type `A`. It processes an\n * iterable of `Option<A>`, applying `f` only to the `Some` values while\n * ignoring the `None` values. The result is a single value of type `B`.\n *\n * This utility is particularly useful for aggregating values from an iterable\n * of `Option`s while skipping the absent (`None`) values.\n *\n * @example\n * ```ts\n * import { Option, pipe } from \"effect\"\n *\n * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n *\n * console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n * // Output: 3\n * ```\n *\n * @category Reducing\n * @since 2.0.0\n */\nexport const reduceCompact: {\n  /**\n   * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\n   * elements that are `None`.\n   *\n   * **Details**\n   *\n   * This function takes an initial value of type `B` and a reducing function `f`\n   * that combines the accumulator with values of type `A`. It processes an\n   * iterable of `Option<A>`, applying `f` only to the `Some` values while\n   * ignoring the `None` values. The result is a single value of type `B`.\n   *\n   * This utility is particularly useful for aggregating values from an iterable\n   * of `Option`s while skipping the absent (`None`) values.\n   *\n   * @example\n   * ```ts\n   * import { Option, pipe } from \"effect\"\n   *\n   * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n   *\n   * console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n   * // Output: 3\n   * ```\n   *\n   * @category Reducing\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B\n  /**\n   * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\n   * elements that are `None`.\n   *\n   * **Details**\n   *\n   * This function takes an initial value of type `B` and a reducing function `f`\n   * that combines the accumulator with values of type `A`. It processes an\n   * iterable of `Option<A>`, applying `f` only to the `Some` values while\n   * ignoring the `None` values. The result is a single value of type `B`.\n   *\n   * This utility is particularly useful for aggregating values from an iterable\n   * of `Option`s while skipping the absent (`None`) values.\n   *\n   * @example\n   * ```ts\n   * import { Option, pipe } from \"effect\"\n   *\n   * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n   *\n   * console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n   * // Output: 3\n   * ```\n   *\n   * @category Reducing\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B\n} = dual(\n  3,\n  <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B => {\n    let out: B = b\n    for (const oa of self) {\n      if (isSome(oa)) {\n        out = f(out, oa.value)\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Converts an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, its value is wrapped in a single-element array.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.toArray(Option.some(1)))\n * // Output: [1]\n *\n * console.log(Option.toArray(Option.none()))\n * // Output: []\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const toArray = <A>(self: Option<A>): Array<A> => isNone(self) ? [] : [self.value]\n\n/**\n * Splits an `Option` into two `Option`s based on the result of a mapping\n * function that produces an `Either`.\n *\n * **Details**\n *\n * This function takes an `Option` and a mapping function `f` that converts its\n * value into an `Either`. It returns a tuple of two `Option`s:\n *\n * - The first `Option` (`left`) contains the value from the `Left` side of the\n *   `Either` if it exists, otherwise `None`.\n * - The second `Option` (`right`) contains the value from the `Right` side of\n *   the `Either` if it exists, otherwise `None`.\n *\n * If the input `Option` is `None`, both returned `Option`s are `None`.\n *\n * This utility is useful for filtering and categorizing the contents of an\n * `Option` based on a bifurcating computation.\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  /**\n   * Splits an `Option` into two `Option`s based on the result of a mapping\n   * function that produces an `Either`.\n   *\n   * **Details**\n   *\n   * This function takes an `Option` and a mapping function `f` that converts its\n   * value into an `Either`. It returns a tuple of two `Option`s:\n   *\n   * - The first `Option` (`left`) contains the value from the `Left` side of the\n   *   `Either` if it exists, otherwise `None`.\n   * - The second `Option` (`right`) contains the value from the `Right` side of\n   *   the `Either` if it exists, otherwise `None`.\n   *\n   * If the input `Option` is `None`, both returned `Option`s are `None`.\n   *\n   * This utility is useful for filtering and categorizing the contents of an\n   * `Option` based on a bifurcating computation.\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]\n  /**\n   * Splits an `Option` into two `Option`s based on the result of a mapping\n   * function that produces an `Either`.\n   *\n   * **Details**\n   *\n   * This function takes an `Option` and a mapping function `f` that converts its\n   * value into an `Either`. It returns a tuple of two `Option`s:\n   *\n   * - The first `Option` (`left`) contains the value from the `Left` side of the\n   *   `Either` if it exists, otherwise `None`.\n   * - The second `Option` (`right`) contains the value from the `Right` side of\n   *   the `Either` if it exists, otherwise `None`.\n   *\n   * If the input `Option` is `None`, both returned `Option`s are `None`.\n   *\n   * This utility is useful for filtering and categorizing the contents of an\n   * `Option` based on a bifurcating computation.\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]\n} = dual(2, <A, B, C>(\n  self: Option<A>,\n  f: (a: A) => Either<C, B>\n): [excluded: Option<B>, satisfying: Option<C>] => {\n  if (isNone(self)) {\n    return [none(), none()]\n  }\n  const e = f(self.value)\n  return either.isLeft(e) ? [some(e.left), none()] : [none(), some(e.right)]\n})\n\n// TODO(4.0): remove?\n/**\n * Alias of {@link flatMap}.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Transform and filter numbers\n * const transformEven = (n: Option.Option<number>): Option.Option<string> =>\n *   Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n *\n * console.log(transformEven(Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(transformEven(Option.some(1)))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(transformEven(Option.some(2)))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n * ```\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const filterMap: {\n  // TODO(4.0): remove?\n  /**\n   * Alias of {@link flatMap}.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Transform and filter numbers\n   * const transformEven = (n: Option.Option<number>): Option.Option<string> =>\n   *   Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n   *\n   * console.log(transformEven(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(transformEven(Option.some(1)))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(transformEven(Option.some(2)))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  // TODO(4.0): remove?\n  /**\n   * Alias of {@link flatMap}.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Transform and filter numbers\n   * const transformEven = (n: Option.Option<number>): Option.Option<string> =>\n   *   Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n   *\n   * console.log(transformEven(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(transformEven(Option.some(1)))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(transformEven(Option.some(2)))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n} = flatMap\n\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const removeEmptyString = (input: Option.Option<string>) =>\n *   Option.filter(input, (value) => value !== \"\")\n *\n * console.log(removeEmptyString(Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(removeEmptyString(Option.some(\"\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(removeEmptyString(Option.some(\"a\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const filter: {\n  /**\n   * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n   *\n   * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const removeEmptyString = (input: Option.Option<string>) =>\n   *   Option.filter(input, (value) => value !== \"\")\n   *\n   * console.log(removeEmptyString(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"\")))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"a\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>\n  /**\n   * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n   *\n   * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const removeEmptyString = (input: Option.Option<string>) =>\n   *   Option.filter(input, (value) => value !== \"\")\n   *\n   * console.log(removeEmptyString(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"\")))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"a\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>\n  /**\n   * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n   *\n   * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const removeEmptyString = (input: Option.Option<string>) =>\n   *   Option.filter(input, (value) => value !== \"\")\n   *\n   * console.log(removeEmptyString(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"\")))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"a\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>\n  /**\n   * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n   *\n   * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const removeEmptyString = (input: Option.Option<string>) =>\n   *   Option.filter(input, (value) => value !== \"\")\n   *\n   * console.log(removeEmptyString(Option.none()))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"\")))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * console.log(removeEmptyString(Option.some(\"a\")))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n   * ```\n   *\n   * @category Filtering\n   * @since 2.0.0\n   */\n  <A>(self: Option<A>, predicate: Predicate<A>): Option<A>\n} = dual(\n  2,\n  <A>(self: Option<A>, predicate: Predicate<A>): Option<A> =>\n    filterMap(self, (b) => (predicate(b) ? option.some(b) : option.none))\n)\n\n/**\n * Creates an `Equivalence` instance for comparing `Option` values, using a\n * provided `Equivalence` for the inner type.\n *\n * **Details**\n *\n * This function takes an `Equivalence` instance for a specific type `A` and\n * produces an `Equivalence` instance for `Option<A>`. The resulting\n * `Equivalence` determines whether two `Option` values are equivalent:\n *\n * - Two `None`s are considered equivalent.\n * - A `Some` and a `None` are not equivalent.\n * - Two `Some` values are equivalent if their inner values are equivalent\n *   according to the provided `Equivalence`.\n *\n * **Example** (Comparing Optional Numbers for Equivalence)\n *\n * ```ts\n * import { Number, Option } from \"effect\"\n *\n * const isEquivalent = Option.getEquivalence(Number.Equivalence)\n *\n * console.log(isEquivalent(Option.none(), Option.none()))\n * // Output: true\n *\n * console.log(isEquivalent(Option.none(), Option.some(1)))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.none()))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.some(2)))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.some(1)))\n * // Output: true\n * ```\n *\n * @category Equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <A>(isEquivalent: Equivalence.Equivalence<A>): Equivalence.Equivalence<Option<A>> =>\n  Equivalence.make((x, y) => isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value))\n\n/**\n * Creates an `Order` instance for comparing `Option` values, using a provided\n * `Order` for the inner type.\n *\n * **Details**\n *\n * This function produces an `Order` instance for `Option<A>`, allowing `Option`\n * values to be compared:\n *\n * - `None` is always considered less than any `Some` value.\n * - If both are `Some`, their inner values are compared using the provided\n *   `Order` instance.\n *\n * @example\n * ```ts\n * import { Number, Option } from \"effect\"\n *\n * const order = Option.getOrder(Number.Order)\n *\n * console.log(order(Option.none(), Option.none()))\n * // Output: 0\n *\n * console.log(order(Option.none(), Option.some(1)))\n * // Output: -1\n *\n * console.log(order(Option.some(1), Option.none()))\n * // Output: 1\n *\n * console.log(order(Option.some(1), Option.some(2)))\n * // Output: -1\n *\n * console.log(order(Option.some(1), Option.some(1)))\n * // Output: 0\n * ```\n *\n * @category Sorting\n * @since 2.0.0\n */\nexport const getOrder = <A>(O: Order<A>): Order<Option<A>> =>\n  order.make((self, that) => isSome(self) ? (isSome(that) ? O(self.value, that.value) : 1) : -1)\n\n/**\n * Lifts a binary function to work with `Option` values, allowing the function\n * to operate on two `Option`s.\n *\n * **Details**\n *\n * This function takes a binary function `f` and returns a new function that\n * applies `f` to the values of two `Option`s (`self` and `that`). If both\n * `Option`s are `Some`, the binary function `f` is applied to their values, and\n * the result is wrapped in a new `Some`. If either `Option` is `None`, the\n * result is `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // A binary function to add two numbers\n * const add = (a: number, b: number): number => a + b\n *\n * // Lift the `add` function to work with `Option` values\n * const addOptions = Option.lift2(add)\n *\n * // Both `Option`s are `Some`\n * console.log(addOptions(Option.some(2), Option.some(3)))\n * // Output: { _id: 'Option', _tag: 'Some', value: 5 }\n *\n * // One `Option` is `None`\n * console.log(addOptions(Option.some(2), Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Lifting\n * @since 2.0.0\n */\nexport const lift2 = <A, B, C>(f: (a: A, b: B) => C): {\n  (that: Option<B>): (self: Option<A>) => Option<C>\n  (self: Option<A>, that: Option<B>): Option<C>\n} => dual(2, (self: Option<A>, that: Option<B>): Option<C> => zipWith(self, that, f))\n\n/**\n * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n *\n * **Details**\n *\n * This function transforms a `Predicate` (or a more specific `Refinement`) into\n * a function that produces an `Option`. If the predicate evaluates to `true`,\n * the input value is wrapped in a `Some`. If the predicate evaluates to\n * `false`, the result is `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Check if a number is positive\n * const isPositive = (n: number) => n > 0\n *\n * //      ┌─── (b: number) => Option<number>\n * //      ▼\n * const parsePositive = Option.liftPredicate(isPositive)\n *\n * console.log(parsePositive(1))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parsePositive(-1))\n * // OUtput: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Lifting\n * @since 2.0.0\n */\nexport const liftPredicate: { // Note: I intentionally avoid using the NoInfer pattern here.\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>\n  /**\n   * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n   * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n   *\n   * **Details**\n   *\n   * This function transforms a `Predicate` (or a more specific `Refinement`) into\n   * a function that produces an `Option`. If the predicate evaluates to `true`,\n   * the input value is wrapped in a `Some`. If the predicate evaluates to\n   * `false`, the result is `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Check if a number is positive\n   * const isPositive = (n: number) => n > 0\n   *\n   * //      ┌─── (b: number) => Option<number>\n   * //      ▼\n   * const parsePositive = Option.liftPredicate(isPositive)\n   *\n   * console.log(parsePositive(1))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(parsePositive(-1))\n   * // OUtput: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Lifting\n   * @since 2.0.0\n   */\n  <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>\n  /**\n   * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n   * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n   *\n   * **Details**\n   *\n   * This function transforms a `Predicate` (or a more specific `Refinement`) into\n   * a function that produces an `Option`. If the predicate evaluates to `true`,\n   * the input value is wrapped in a `Some`. If the predicate evaluates to\n   * `false`, the result is `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Check if a number is positive\n   * const isPositive = (n: number) => n > 0\n   *\n   * //      ┌─── (b: number) => Option<number>\n   * //      ▼\n   * const parsePositive = Option.liftPredicate(isPositive)\n   *\n   * console.log(parsePositive(1))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(parsePositive(-1))\n   * // OUtput: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Lifting\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>\n  /**\n   * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n   * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n   *\n   * **Details**\n   *\n   * This function transforms a `Predicate` (or a more specific `Refinement`) into\n   * a function that produces an `Option`. If the predicate evaluates to `true`,\n   * the input value is wrapped in a `Some`. If the predicate evaluates to\n   * `false`, the result is `None`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * // Check if a number is positive\n   * const isPositive = (n: number) => n > 0\n   *\n   * //      ┌─── (b: number) => Option<number>\n   * //      ▼\n   * const parsePositive = Option.liftPredicate(isPositive)\n   *\n   * console.log(parsePositive(1))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n   *\n   * console.log(parsePositive(-1))\n   * // OUtput: { _id: 'Option', _tag: 'None' }\n   * ```\n   *\n   * @category Lifting\n   * @since 2.0.0\n   */\n  <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>\n} = dual(\n  2,\n  <B extends A, A = B>(b: B, predicate: Predicate<A>): Option<B> => predicate(b) ? some(b) : none()\n)\n\n/**\n * Returns a function that checks if an `Option` contains a specified value,\n * using a provided equivalence function.\n *\n * **Details**\n *\n * This function allows you to check whether an `Option` contains a specific\n * value. It uses an equivalence function `isEquivalent` to compare the value\n * inside the `Option` to the provided value. If the `Option` is `Some` and the\n * equivalence function returns `true`, the result is `true`. If the `Option` is\n * `None` or the values are not equivalent, the result is `false`.\n *\n * @example\n * ```ts\n * import { Number, Option } from \"effect\"\n *\n * const contains = Option.containsWith(Number.Equivalence)\n *\n * console.log(Option.some(2).pipe(contains(2)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(contains(2)))\n * // Output: false\n *\n * console.log(Option.none().pipe(contains(2)))\n * // Output: false\n * ```\n *\n * @see {@link contains} for a version that uses the default `Equivalence`.\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const containsWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (a: A): (self: Option<A>) => boolean\n  (self: Option<A>, a: A): boolean\n} => dual(2, (self: Option<A>, a: A): boolean => isNone(self) ? false : isEquivalent(self.value, a))\n\nconst _equivalence = Equal.equivalence()\n\n/**\n * Returns a function that checks if an `Option` contains a specified value\n * using the default `Equivalence`.\n *\n * **Details**\n *\n * This function allows you to check whether an `Option` contains a specific\n * value. It uses the default `Equivalence` for equality comparison. If the\n * `Option` is `Some` and its value is equivalent to the provided value, the\n * result is `true`. If the `Option` is `None` or the values are not equivalent,\n * the result is `false`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.some(2).pipe(Option.contains(2)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(Option.contains(2)))\n * // Output: false\n *\n * console.log(Option.none().pipe(Option.contains(2)))\n * // Output: false\n * ```\n *\n * @see {@link containsWith} for a version that allows you to specify a custom equivalence function.\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const contains: {\n  /**\n   * Returns a function that checks if an `Option` contains a specified value\n   * using the default `Equivalence`.\n   *\n   * **Details**\n   *\n   * This function allows you to check whether an `Option` contains a specific\n   * value. It uses the default `Equivalence` for equality comparison. If the\n   * `Option` is `Some` and its value is equivalent to the provided value, the\n   * result is `true`. If the `Option` is `None` or the values are not equivalent,\n   * the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.some(2).pipe(Option.contains(2)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.contains(2)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.contains(2)))\n   * // Output: false\n   * ```\n   *\n   * @see {@link containsWith} for a version that allows you to specify a custom equivalence function.\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A>(a: A): (self: Option<A>) => boolean\n  /**\n   * Returns a function that checks if an `Option` contains a specified value\n   * using the default `Equivalence`.\n   *\n   * **Details**\n   *\n   * This function allows you to check whether an `Option` contains a specific\n   * value. It uses the default `Equivalence` for equality comparison. If the\n   * `Option` is `Some` and its value is equivalent to the provided value, the\n   * result is `true`. If the `Option` is `None` or the values are not equivalent,\n   * the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * console.log(Option.some(2).pipe(Option.contains(2)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.contains(2)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.contains(2)))\n   * // Output: false\n   * ```\n   *\n   * @see {@link containsWith} for a version that allows you to specify a custom equivalence function.\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A>(self: Option<A>, a: A): boolean\n} = containsWith(_equivalence)\n\n/**\n * Checks if a value in an `Option` satisfies a given predicate or refinement.\n *\n * **Details**\n *\n * This function allows you to check if a value inside a `Some` meets a\n * specified condition. If the `Option` is `None`, the result is `false`. If the\n * `Option` is `Some`, the provided predicate or refinement is applied to the\n * value:\n *\n * - If the condition is met, the result is `true`.\n * - If the condition is not met, the result is `false`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * console.log(Option.some(2).pipe(Option.exists(isEven)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(Option.exists(isEven)))\n * // Output: false\n *\n * console.log(Option.none().pipe(Option.exists(isEven)))\n * // Output: false\n * ```\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const exists: {\n  /**\n   * Checks if a value in an `Option` satisfies a given predicate or refinement.\n   *\n   * **Details**\n   *\n   * This function allows you to check if a value inside a `Some` meets a\n   * specified condition. If the `Option` is `None`, the result is `false`. If the\n   * `Option` is `Some`, the provided predicate or refinement is applied to the\n   * value:\n   *\n   * - If the condition is met, the result is `true`.\n   * - If the condition is not met, the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * console.log(Option.some(2).pipe(Option.exists(isEven)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.exists(isEven)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.exists(isEven)))\n   * // Output: false\n   * ```\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>\n  /**\n   * Checks if a value in an `Option` satisfies a given predicate or refinement.\n   *\n   * **Details**\n   *\n   * This function allows you to check if a value inside a `Some` meets a\n   * specified condition. If the `Option` is `None`, the result is `false`. If the\n   * `Option` is `Some`, the provided predicate or refinement is applied to the\n   * value:\n   *\n   * - If the condition is met, the result is `true`.\n   * - If the condition is not met, the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * console.log(Option.some(2).pipe(Option.exists(isEven)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.exists(isEven)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.exists(isEven)))\n   * // Output: false\n   * ```\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean\n  /**\n   * Checks if a value in an `Option` satisfies a given predicate or refinement.\n   *\n   * **Details**\n   *\n   * This function allows you to check if a value inside a `Some` meets a\n   * specified condition. If the `Option` is `None`, the result is `false`. If the\n   * `Option` is `Some`, the provided predicate or refinement is applied to the\n   * value:\n   *\n   * - If the condition is met, the result is `true`.\n   * - If the condition is not met, the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * console.log(Option.some(2).pipe(Option.exists(isEven)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.exists(isEven)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.exists(isEven)))\n   * // Output: false\n   * ```\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>\n  /**\n   * Checks if a value in an `Option` satisfies a given predicate or refinement.\n   *\n   * **Details**\n   *\n   * This function allows you to check if a value inside a `Some` meets a\n   * specified condition. If the `Option` is `None`, the result is `false`. If the\n   * `Option` is `Some`, the provided predicate or refinement is applied to the\n   * value:\n   *\n   * - If the condition is met, the result is `true`.\n   * - If the condition is not met, the result is `false`.\n   *\n   * @example\n   * ```ts\n   * import { Option } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   *\n   * console.log(Option.some(2).pipe(Option.exists(isEven)))\n   * // Output: true\n   *\n   * console.log(Option.some(1).pipe(Option.exists(isEven)))\n   * // Output: false\n   *\n   * console.log(Option.none().pipe(Option.exists(isEven)))\n   * // Output: false\n   * ```\n   *\n   * @category Elements\n   * @since 2.0.0\n   */\n  <A>(self: Option<A>, predicate: Predicate<A>): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B> =>\n    isNone(self) ? false : refinement(self.value)\n)\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const bindTo: {\n  // -------------------------------------------------------------------------------------\n  // do notation\n  // -------------------------------------------------------------------------------------\n\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A }>\n  // -------------------------------------------------------------------------------------\n  // do notation\n  // -------------------------------------------------------------------------------------\n\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A }>\n} = doNotation.bindTo<OptionTypeLambda>(map)\n\nconst let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  <A extends object, N extends string, B>(\n    self: Option<A>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = doNotation.let_<OptionTypeLambda>(map)\n\nexport {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link bindTo}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  let_ as let\n}\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const bind: {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Option, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Option.Do,\n   *   Option.bind(\"x\", () => Option.some(2)),\n   *   Option.bind(\"y\", () => Option.some(3)),\n   *   Option.let(\"sum\", ({ x, y }) => x + y),\n   *   Option.filter(({ x, y }) => x * y > 5)\n   * )\n   * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <A extends object, N extends string, B>(\n    self: Option<A>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => Option<B>\n  ): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = doNotation.bind<OptionTypeLambda>(map, flatMap)\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const Do: Option<{}> = some({})\n\nconst adapter = Gen.adapter<OptionTypeLambda>()\n\n/**\n * Similar to `Effect.gen`, `Option.gen` provides a more readable,\n * generator-based syntax for working with `Option` values, making code that\n * involves `Option` easier to write and understand. This approach is similar to\n * using `async/await` but tailored for `Option`.\n *\n * **Example** (Using `Option.gen` to Create a Combined Value)\n *\n * ```ts\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * const person = Option.gen(function* () {\n *   const name = (yield* maybeName).toUpperCase()\n *   const age = yield* maybeAge\n *   return { name, age }\n * })\n *\n * console.log(person)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n * ```\n *\n * @category Generators\n * @since 2.0.0\n */\nexport const gen: Gen.Gen<OptionTypeLambda, Gen.Adapter<OptionTypeLambda>> = (...args) => {\n  const f = args.length === 1 ? args[0] : args[1].bind(args[0])\n  const iterator = f(adapter)\n  let state: IteratorResult<any> = iterator.next()\n  while (!state.done) {\n    const current = Gen.isGenKind(state.value)\n      ? state.value.value\n      : Gen.yieldWrapGet(state.value)\n    if (isNone(current)) {\n      return current\n    }\n    state = iterator.next(current.value as never)\n  }\n  return some(state.value)\n}\n\n/**\n * Merges two optional values, applying a function if both exist.\n * Unlike {@link zipWith}, this function returns `None` only if both inputs are `None`.\n *\n * @internal\n */\nexport const mergeWith = <A>(f: (a1: A, a2: A) => A) => (o1: Option<A>, o2: Option<A>): Option<A> => {\n  if (isNone(o1)) {\n    return o2\n  } else if (isNone(o2)) {\n    return o1\n  }\n  return some(f(o1.value, o2.value))\n}\n","/**\n * This module provides utility functions for working with records in TypeScript.\n *\n * @since 2.0.0\n */\n\nimport type { Either } from \"./Either.js\"\nimport * as E from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport type { Equivalence } from \"./Equivalence.js\"\nimport { dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as Option from \"./Option.js\"\nimport type { NoInfer } from \"./Types.js\"\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type ReadonlyRecord<in out K extends string | symbol, out A> = {\n  readonly [P in K]: A\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ReadonlyRecord {\n  type IsFiniteString<T extends string> = T extends \"\" ? true :\n    [T] extends [`${infer Head}${infer Rest}`]\n      ? string extends Head ? false : `${number}` extends Head ? false : Rest extends \"\" ? true : IsFiniteString<Rest>\n    : false\n\n  /**\n   * @since 2.0.0\n   */\n  export type NonLiteralKey<K extends string | symbol> = K extends string ? IsFiniteString<K> extends true ? string : K\n    : symbol\n\n  /**\n   * @since 2.0.0\n   */\n  export type IntersectKeys<K1 extends string, K2 extends string> = [string] extends [K1 | K2] ?\n    NonLiteralKey<K1> & NonLiteralKey<K2>\n    : K1 & K2\n}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface ReadonlyRecordTypeLambda<K extends string = string> extends TypeLambda {\n  readonly type: ReadonlyRecord<K, this[\"Target\"]>\n}\n\n/**\n * Creates a new, empty record.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const empty = <K extends string | symbol = never, V = never>(): Record<\n  ReadonlyRecord.NonLiteralKey<K>,\n  V\n> => ({} as any)\n\n/**\n * Determine if a record is empty.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isEmptyRecord } from \"effect/Record\"\n *\n * assert.deepStrictEqual(isEmptyRecord({}), true);\n * assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyRecord = <K extends string, A>(self: Record<K, A>): self is Record<K, never> =>\n  keys(self).length === 0\n\n/**\n * Determine if a record is empty.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isEmptyReadonlyRecord } from \"effect/Record\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\n * assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyReadonlyRecord: <K extends string, A>(\n  self: ReadonlyRecord<K, A>\n) => self is ReadonlyRecord<K, never> = isEmptyRecord\n\n/**\n * Takes an iterable and a projection function and returns a record.\n * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { fromIterableWith } from \"effect/Record\"\n *\n * const input = [1, 2, 3, 4]\n *\n * assert.deepStrictEqual(\n *   fromIterableWith(input, a => [String(a), a * 2]),\n *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n * )\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterableWith: {\n  /**\n   * Takes an iterable and a projection function and returns a record.\n   * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { fromIterableWith } from \"effect/Record\"\n   *\n   * const input = [1, 2, 3, 4]\n   *\n   * assert.deepStrictEqual(\n   *   fromIterableWith(input, a => [String(a), a * 2]),\n   *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n   * )\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, K extends string | symbol, B>(f: (a: A) => readonly [K, B]): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  /**\n   * Takes an iterable and a projection function and returns a record.\n   * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { fromIterableWith } from \"effect/Record\"\n   *\n   * const input = [1, 2, 3, 4]\n   *\n   * assert.deepStrictEqual(\n   *   fromIterableWith(input, a => [String(a), a * 2]),\n   *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n   * )\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A, K extends string | symbol, B>(self: Iterable<A>, f: (a: A) => readonly [K, B]): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n} = dual(\n  2,\n  <A, K extends string, B>(\n    self: Iterable<A>,\n    f: (a: A) => readonly [K, B]\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B> => {\n    const out: Record<string, B> = empty()\n    for (const a of self) {\n      const [k, b] = f(a)\n      out[k] = b\n    }\n    return out\n  }\n)\n\n/**\n * Creates a new record from an iterable, utilizing the provided function to determine the key for each element.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { fromIterableBy } from \"effect/Record\"\n *\n * const users = [\n *   { id: \"2\", name: \"name2\" },\n *   { id: \"1\", name: \"name1\" }\n * ]\n *\n * assert.deepStrictEqual(\n *   fromIterableBy(users, user => user.id),\n *   {\n *     \"2\": { id: \"2\", name: \"name2\" },\n *     \"1\": { id: \"1\", name: \"name1\" }\n *   }\n * )\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterableBy = <A, K extends string | symbol>(\n  items: Iterable<A>,\n  f: (a: A) => K\n): Record<ReadonlyRecord.NonLiteralKey<K>, A> => fromIterableWith(items, (a) => [f(a), a])\n\n/**\n * Builds a record from an iterable of key-value pairs.\n *\n * If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the\n * previous ones. So the resulting record will only have the value of the last occurrence of each key.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { fromEntries } from \"effect/Record\"\n *\n * const input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n *\n * assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEntries: <Entry extends readonly [string | symbol, any]>(\n  entries: Iterable<Entry>\n) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]> = Object.fromEntries\n\n/**\n * Transforms the values of a record into an `Array` with a custom mapping function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { collect } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const collect: {\n  /**\n   * Transforms the values of a record into an `Array` with a custom mapping function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { collect } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n   * ```\n   *\n   * @category conversions\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>\n  /**\n   * Transforms the values of a record into an `Array` with a custom mapping function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { collect } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n   * ```\n   *\n   * @category conversions\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>\n} = dual(\n  2,\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B> => {\n    const out: Array<B> = []\n    for (const key of keys(self)) {\n      out.push(f(key, self[key]))\n    }\n    return out\n  }\n)\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { toEntries } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]> = collect((\n  key,\n  value\n) => [key, value])\n\n/**\n * Returns the number of key/value pairs in a record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { size } from \"effect/Record\";\n *\n * assert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);\n * ```\n *\n * @since 2.0.0\n */\nexport const size = <K extends string, A>(self: ReadonlyRecord<K, A>): number => keys(self).length\n\n/**\n * Check if a given `key` exists in a record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { empty, has } from \"effect/Record\"\n *\n * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n * assert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n * ```\n *\n * @since 2.0.0\n */\nexport const has: {\n  /**\n   * Check if a given `key` exists in a record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { empty, has } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n   * assert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => boolean\n  /**\n   * Check if a given `key` exists in a record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { empty, has } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n   * assert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): boolean\n} = dual(\n  2,\n  <K extends string | symbol, A>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>\n  ): boolean => Object.prototype.hasOwnProperty.call(self, key)\n)\n\n/**\n * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record as R, Option } from \"effect\"\n *\n * const person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n *\n * assert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\n * assert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n * ```\n *\n * @since 2.0.0\n */\nexport const get: {\n  /**\n   * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * const person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n   *\n   * assert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\n   * assert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>\n  /**\n   * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * const person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n   *\n   * assert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\n   * assert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>\n} = dual(\n  2,\n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A> =>\n    has(self, key) ? Option.some(self[key]) : Option.none()\n)\n\n/**\n * Apply a function to the element at the specified key, creating a new record.\n * If the key does not exist, the record is returned unchanged.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record as R } from \"effect\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  R.modify({ a: 3 }, 'a', f),\n *  { a: 6 }\n * )\n * assert.deepStrictEqual(\n *  R.modify({ a: 3 } as Record<string, number>, 'b', f),\n *  { a: 3 }\n * )\n * ```\n *\n * @since 2.0.0\n */\nexport const modify: {\n  /**\n   * Apply a function to the element at the specified key, creating a new record.\n   * If the key does not exist, the record is returned unchanged.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R } from \"effect\"\n   *\n   * const f = (x: number) => x * 2\n   *\n   * assert.deepStrictEqual(\n   *  R.modify({ a: 3 }, 'a', f),\n   *  { a: 6 }\n   * )\n   * assert.deepStrictEqual(\n   *  R.modify({ a: 3 } as Record<string, number>, 'b', f),\n   *  { a: 3 }\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Record<K, A | B>\n  /**\n   * Apply a function to the element at the specified key, creating a new record.\n   * If the key does not exist, the record is returned unchanged.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R } from \"effect\"\n   *\n   * const f = (x: number) => x * 2\n   *\n   * assert.deepStrictEqual(\n   *  R.modify({ a: 3 }, 'a', f),\n   *  { a: 6 }\n   * )\n   * assert.deepStrictEqual(\n   *  R.modify({ a: 3 } as Record<string, number>, 'b', f),\n   *  { a: 3 }\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B> => {\n    if (!has(self, key)) {\n      return { ...self }\n    }\n    return { ...self, [key]: f(self[key]) }\n  }\n)\n\n/**\n * Apply a function to the element at the specified key, creating a new record,\n * or return `None` if the key doesn't exist.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record as R, Option } from \"effect\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  R.modifyOption({ a: 3 }, 'a', f),\n *  Option.some({ a: 6 })\n * )\n * assert.deepStrictEqual(\n *  R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n *  Option.none()\n * )\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyOption: {\n  /**\n   * Apply a function to the element at the specified key, creating a new record,\n   * or return `None` if the key doesn't exist.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * const f = (x: number) => x * 2\n   *\n   * assert.deepStrictEqual(\n   *  R.modifyOption({ a: 3 }, 'a', f),\n   *  Option.some({ a: 6 })\n   * )\n   * assert.deepStrictEqual(\n   *  R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n   *  Option.none()\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>\n  /**\n   * Apply a function to the element at the specified key, creating a new record,\n   * or return `None` if the key doesn't exist.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * const f = (x: number) => x * 2\n   *\n   * assert.deepStrictEqual(\n   *  R.modifyOption({ a: 3 }, 'a', f),\n   *  Option.some({ a: 6 })\n   * )\n   * assert.deepStrictEqual(\n   *  R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n   *  Option.none()\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Option.Option<Record<K, A | B>>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>,\n    f: (a: A) => B\n  ): Option.Option<Record<K, A | B>> => {\n    if (!has(self, key)) {\n      return Option.none()\n    }\n    return Option.some({ ...self, [key]: f(self[key]) })\n  }\n)\n\n/**\n * Replaces a value in the record with the new value passed as parameter.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n *   Option.some({ a: 10, b: 2, c: 3 })\n * )\n * assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n * ```\n *\n * @since 2.0.0\n */\nexport const replaceOption: {\n  /**\n   * Replaces a value in the record with the new value passed as parameter.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n   *   Option.some({ a: 10, b: 2, c: 3 })\n   * )\n   * assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, B>(key: NoInfer<K>, b: B): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>\n  /**\n   * Replaces a value in the record with the new value passed as parameter.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n   *   Option.some({ a: 10, b: 2, c: 3 })\n   * )\n   * assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, b: B): Option.Option<Record<K, A | B>>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>,\n    b: B\n  ): Option.Option<Record<K, A | B>> => modifyOption(self, key, () => b)\n)\n\n/**\n * If the given key exists in the record, returns a new record with the key removed,\n * otherwise returns a copy of the original record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { remove } from \"effect/Record\"\n *\n * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n * ```\n *\n * @since 2.0.0\n */\nexport const remove: {\n  /**\n   * If the given key exists in the record, returns a new record with the key removed,\n   * otherwise returns a copy of the original record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { remove } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>\n  /**\n   * If the given key exists in the record, returns a new record with the key removed,\n   * otherwise returns a copy of the original record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { remove } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>\n} = dual(\n  2,\n  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A> => {\n    if (!has(self, key)) {\n      return { ...self }\n    }\n    const out = { ...self }\n    delete out[key]\n    return out\n  }\n)\n\n/**\n * Retrieves the value of the property with the given `key` from a record and returns an `Option`\n * of a tuple with the value and the record with the removed property.\n * If the key is not present, returns `O.none`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record as R, Option } from \"effect\"\n *\n * assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\n * assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n * ```\n *\n * @category record\n * @since 2.0.0\n */\nexport const pop: {\n  /**\n   * Retrieves the value of the property with the given `key` from a record and returns an `Option`\n   * of a tuple with the value and the record with the removed property.\n   * If the key is not present, returns `O.none`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\n   * assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n   * ```\n   *\n   * @category record\n   * @since 2.0.0\n   */\n  <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>\n  /**\n   * Retrieves the value of the property with the given `key` from a record and returns an `Option`\n   * of a tuple with the value and the record with the removed property.\n   * If the key is not present, returns `O.none`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record as R, Option } from \"effect\"\n   *\n   * assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\n   * assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n   * ```\n   *\n   * @category record\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Option.Option<[A, Record<Exclude<K, X>, A>]>\n} = dual(2, <K extends string | symbol, A, X extends K>(\n  self: ReadonlyRecord<K, A>,\n  key: X\n): Option.Option<[A, Record<Exclude<K, X>, A>]> =>\n  has(self, key) ? Option.some([self[key], remove(self, key)]) : Option.none())\n\n/**\n * Maps a record into another record by applying a transformation function to each of its values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { map } from \"effect/Record\"\n *\n * const f = (n: number) => `-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n *\n * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  /**\n   * Maps a record into another record by applying a transformation function to each of its values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { map } from \"effect/Record\"\n   *\n   * const f = (n: number) => `-${n}`\n   *\n   * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n   *\n   * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n   *\n   * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>\n  /**\n   * Maps a record into another record by applying a transformation function to each of its values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { map } from \"effect/Record\"\n   *\n   * const f = (n: number) => `-${n}`\n   *\n   * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n   *\n   * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n   *\n   * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>\n} = dual(\n  2,\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B> => {\n    const out: Record<K, B> = { ...self } as any\n    for (const key of keys(self)) {\n      out[key] = f(self[key], key)\n    }\n    return out\n  }\n)\n\n/**\n * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { mapKeys } from \"effect/Record\"\n *\n * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapKeys: {\n  /**\n   * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { mapKeys } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, K2 extends string>(f: (key: K, a: A) => K2): (self: ReadonlyRecord<K, A>) => Record<K2, A>\n  /**\n   * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { mapKeys } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, K2 extends string>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => K2): Record<K2, A>\n} = dual(\n  2,\n  <K extends string, A, K2 extends string>(\n    self: ReadonlyRecord<K, A>,\n    f: (key: K, a: A) => K2\n  ): Record<K2, A> => {\n    const out: Record<K2, A> = {} as any\n    for (const key of keys(self)) {\n      const a = self[key]\n      out[f(key, a)] = a\n    }\n    return out\n  }\n)\n\n/**\n * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { mapEntries } from \"effect/Record\"\n *\n * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapEntries: {\n  /**\n   * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { mapEntries } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, K2 extends string, B>(f: (a: A, key: K) => readonly [K2, B]): (self: ReadonlyRecord<K, A>) => Record<K2, B>\n  /**\n   * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { mapEntries } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n   * ```\n   *\n   * @category mapping\n   * @since 2.0.0\n   */\n  <K extends string, A, K2 extends string, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => [K2, B]): Record<K2, B>\n} = dual(\n  2,\n  <K extends string, A, K2 extends string, B>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => [K2, B]\n  ): Record<K2, B> => {\n    const out = <Record<K2, B>> {}\n    for (const key of keys(self)) {\n      const [k, b] = f(self[key], key)\n      out[k] = b\n    }\n    return out\n  }\n)\n\n/**\n * Transforms a record into a record by applying the function `f` to each key and value in the original record.\n * If the function returns `Some`, the key-value pair is included in the output record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Option } from \"effect\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\n * assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n * ```\n *\n * @since 2.0.0\n */\nexport const filterMap: {\n  /**\n   * Transforms a record into a record by applying the function `f` to each key and value in the original record.\n   * If the function returns `Some`, the key-value pair is included in the output record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Option } from \"effect\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\n   * assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(f: (a: A, key: K) => Option.Option<B>): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  /**\n   * Transforms a record into a record by applying the function `f` to each key and value in the original record.\n   * If the function returns `Some`, the key-value pair is included in the output record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Option } from \"effect\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\n   * assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Option.Option<B>): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n} = dual(\n  2,\n  <K extends string, A, B>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => Option.Option<B>\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B> => {\n    const out: Record<string, B> = empty()\n    for (const key of keys(self)) {\n      const o = f(self[key], key)\n      if (Option.isSome(o)) {\n        out[key] = o.value\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Selects properties from a record whose values match the given predicate.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { filter } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3, d: 4 }\n * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filter: {\n  /**\n   * Selects properties from a record whose values match the given predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { filter } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3, d: 4 }\n   * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  /**\n   * Selects properties from a record whose values match the given predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { filter } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3, d: 4 }\n   * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A>(predicate: (A: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>\n  /**\n   * Selects properties from a record whose values match the given predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { filter } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3, d: 4 }\n   * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  /**\n   * Selects properties from a record whose values match the given predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { filter } from \"effect/Record\"\n   *\n   * const x = { a: 1, b: 2, c: 3, d: 4 }\n   * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): Record<ReadonlyRecord.NonLiteralKey<K>, A>\n} = dual(\n  2,\n  <K extends string, A>(\n    self: ReadonlyRecord<K, A>,\n    predicate: (a: A, key: K) => boolean\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, A> => {\n    const out: Record<string, A> = empty()\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        out[key] = self[key]\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),\n *   { a: 1, c: 2 }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getSomes: <K extends string, A>(\n  self: ReadonlyRecord<K, Option.Option<A>>\n) => Record<ReadonlyRecord.NonLiteralKey<K>, A> = filterMap(\n  identity\n)\n\n/**\n * Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getLefts({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n *   { b: \"err\" }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getLefts = <K extends string, R, L>(\n  self: ReadonlyRecord<K, Either<R, L>>\n): Record<ReadonlyRecord.NonLiteralKey<K>, L> => {\n  const out: Record<string, L> = empty()\n  for (const key of keys(self)) {\n    const value = self[key]\n    if (E.isLeft(value)) {\n      out[key] = value.left\n    }\n  }\n\n  return out\n}\n\n/**\n * Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getRights({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n *   { a: 1, c: 2 }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getRights = <K extends string, R, L>(\n  self: ReadonlyRecord<K, Either<R, L>>\n): Record<string, R> => {\n  const out: Record<string, R> = empty()\n  for (const key of keys(self)) {\n    const value = self[key]\n    if (E.isRight(value)) {\n      out[key] = value.right\n    }\n  }\n\n  return out\n}\n\n/**\n * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Either } from \"effect\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\n * assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  /**\n   * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Either } from \"effect\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\n   * assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B, C>(f: (a: A, key: K) => Either<C, B>): (\n    self: ReadonlyRecord<K, A>\n  ) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]\n  /**\n   * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record, Either } from \"effect\"\n   *\n   * const x = { a: 1, b: 2, c: 3 }\n   * const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\n   * assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B, C>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Either<C, B>): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]\n} = dual(\n  2,\n  <K extends string, A, B, C>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => Either<C, B>\n  ): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>] => {\n    const left: Record<string, B> = empty()\n    const right: Record<string, C> = empty()\n    for (const key of keys(self)) {\n      const e = f(self[key], key)\n      if (E.isLeft(e)) {\n        left[key] = e.left\n      } else {\n        right[key] = e.right\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Partitions a record of `Either` values into two separate records,\n * one with the `Left` values and one with the `Right` values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.separate({ a: Either.left(\"e\"), b: Either.right(1) }),\n *   [{ a: \"e\" }, { b: 1 }]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate: <K extends string, A, B>(\n  self: ReadonlyRecord<K, Either<B, A>>\n) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>] = partitionMap(identity)\n\n/**\n * Partitions a record into two separate records based on the result of a predicate function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { partition } from \"effect/Record\"\n *\n * assert.deepStrictEqual(\n *   partition({ a: 1, b: 3 }, (n) => n > 2),\n *   [{ a: 1 }, { b: 3 }]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition: {\n  /**\n   * Partitions a record into two separate records based on the result of a predicate function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { partition } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(\n   *   partition({ a: 1, b: 3 }, (n) => n > 2),\n   *   [{ a: 1 }, { b: 3 }]\n   * )\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (\n    self: ReadonlyRecord<K, A>\n  ) => [\n    excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>,\n    satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  ]\n  /**\n   * Partitions a record into two separate records based on the result of a predicate function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { partition } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(\n   *   partition({ a: 1, b: 3 }, (n) => n > 2),\n   *   [{ a: 1 }, { b: 3 }]\n   * )\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A>(predicate: (a: NoInfer<A>, key: K) => boolean): (\n    self: ReadonlyRecord<K, A>\n  ) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]\n  /**\n   * Partitions a record into two separate records based on the result of a predicate function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { partition } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(\n   *   partition({ a: 1, b: 3 }, (n) => n > 2),\n   *   [{ a: 1 }, { b: 3 }]\n   * )\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): [\n    excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>,\n    satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  ]\n  /**\n   * Partitions a record into two separate records based on the result of a predicate function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { partition } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(\n   *   partition({ a: 1, b: 3 }, (n) => n > 2),\n   *   [{ a: 1 }, { b: 3 }]\n   * )\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]\n} = dual(\n  2,\n  <K extends string, A>(\n    self: ReadonlyRecord<K, A>,\n    predicate: (a: A, key: K) => boolean\n  ): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>] => {\n    const left: Record<string, A> = empty()\n    const right: Record<string, A> = empty()\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        right[key] = self[key]\n      } else {\n        left[key] = self[key]\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Retrieve the keys of a given record as an array.\n *\n * @since 2.0.0\n */\nexport const keys = <K extends string | symbol, A>(self: ReadonlyRecord<K, A>): Array<K & string> =>\n  Object.keys(self) as Array<K & string>\n\n/**\n * Retrieve the values of a given record as an array.\n *\n * @since 2.0.0\n */\nexport const values = <K extends string, A>(self: ReadonlyRecord<K, A>): Array<A> => collect(self, (_, a) => a)\n\n/**\n * Add a new key-value pair or update an existing key's value in a record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { set } from \"effect/Record\"\n *\n * assert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n * ```\n *\n * @since 2.0.0\n */\nexport const set: {\n  /**\n   * Add a new key-value pair or update an existing key's value in a record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { set } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n   * assert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(key: K1, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>\n  /**\n   * Add a new key-value pair or update an existing key's value in a record.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { set } from \"effect/Record\"\n   *\n   * assert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n   * assert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(self: ReadonlyRecord<K, A>, key: K1, value: B): Record<K | K1, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(\n    self: ReadonlyRecord<K, A>,\n    key: K1,\n    value: B\n  ): Record<K | K1, A | B> => {\n    return { ...self, [key]: value } as any\n  }\n)\n\n/**\n * Replace a key's value in a record and return the updated record.\n * If the key does not exist in the record, a copy of the original record is returned.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Record } from \"effect\"\n *\n * assert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\n * assert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n * ```\n *\n * @since 2.0.0\n */\nexport const replace: {\n  /**\n   * Replace a key's value in a record and return the updated record.\n   * If the key does not exist in the record, a copy of the original record is returned.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record } from \"effect\"\n   *\n   * assert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\n   * assert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>\n  /**\n   * Replace a key's value in a record and return the updated record.\n   * If the key does not exist in the record, a copy of the original record is returned.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Record } from \"effect\"\n   *\n   * assert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\n   * assert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B> => {\n    if (has(self, key)) {\n      return { ...self, [key]: value }\n    }\n    return { ...self }\n  }\n)\n\n/**\n * Check if all the keys and values in one record are also found in another record.\n *\n * @since 2.0.0\n */\nexport const isSubrecordBy = <A>(equivalence: Equivalence<A>): {\n  <K extends string>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean\n  <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean\n} =>\n  dual(2, <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean => {\n    for (const key of keys(self)) {\n      if (!has(that, key) || !equivalence(self[key], that[key])) {\n        return false\n      }\n    }\n    return true\n  })\n\n/**\n * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\n * This comparison uses default equality checks (`Equal.equivalence()`).\n *\n * @since 2.0.0\n */\nexport const isSubrecord: {\n  /**\n   * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\n   * This comparison uses default equality checks (`Equal.equivalence()`).\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean\n  /**\n   * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\n   * This comparison uses default equality checks (`Equal.equivalence()`).\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean\n} = isSubrecordBy(Equal.equivalence())\n\n/**\n * Reduce a record to a single value by combining its entries with a specified function.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  /**\n   * Reduce a record to a single value by combining its entries with a specified function.\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <Z, V, K extends string>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: ReadonlyRecord<K, V>) => Z\n  /**\n   * Reduce a record to a single value by combining its entries with a specified function.\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <K extends string, V, Z>(\n    self: ReadonlyRecord<K, V>,\n    zero: Z,\n    f: (accumulator: Z, value: V, key: K) => Z\n  ): Z\n} = dual(\n  3,\n  <K extends string, V, Z>(\n    self: ReadonlyRecord<K, V>,\n    zero: Z,\n    f: (accumulator: Z, value: V, key: K) => Z\n  ): Z => {\n    let out: Z = zero\n    for (const key of keys(self)) {\n      out = f(out, self[key], key)\n    }\n    return out\n  }\n)\n\n/**\n * Check if all entries in a record meet a specific condition.\n *\n * @since 2.0.0\n */\nexport const every: {\n  /**\n   * Check if all entries in a record meet a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <A, K extends string, B extends A>(refinement: (value: A, key: K) => value is B): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>\n  /**\n   * Check if all entries in a record meet a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean\n  /**\n   * Check if all entries in a record meet a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <A, K extends string, B extends A>(self: ReadonlyRecord<K, A>, refinement: (value: A, key: K) => value is B): self is ReadonlyRecord<K, B>\n  /**\n   * Check if all entries in a record meet a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean\n} = dual(\n  2,\n  <A, K extends string, B extends A>(\n    self: ReadonlyRecord<K, A>,\n    refinement: (value: A, key: K) => value is B\n  ): self is ReadonlyRecord<K, B> => {\n    for (const key of keys(self)) {\n      if (!refinement(self[key], key)) {\n        return false\n      }\n    }\n    return true\n  }\n)\n\n/**\n * Check if any entry in a record meets a specific condition.\n *\n * @since 2.0.0\n */\nexport const some: {\n  /**\n   * Check if any entry in a record meets a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean\n  /**\n   * Check if any entry in a record meets a specific condition.\n   *\n   * @since 2.0.0\n   */\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean\n} = dual(\n  2,\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean => {\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        return true\n      }\n    }\n    return false\n  }\n)\n\n/**\n * Merge two records, preserving entries that exist in either of the records.\n *\n * @since 2.0.0\n */\nexport const union: {\n  /**\n   * Merge two records, preserving entries that exist in either of the records.\n   *\n   * @since 2.0.0\n   */\n  <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>\n  /**\n   * Merge two records, preserving entries that exist in either of the records.\n   *\n   * @since 2.0.0\n   */\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<K0 | K1, A | B | C>\n} = dual(\n  3,\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<K0 | K1, A | B | C> => {\n    if (isEmptyRecord(self)) {\n      return { ...that } as any\n    }\n    if (isEmptyRecord(that)) {\n      return { ...self } as any\n    }\n    const out: Record<string, A | B | C> = empty()\n    for (const key of keys(self)) {\n      if (has(that, key as any)) {\n        out[key] = combine(self[key], that[key as unknown as K1])\n      } else {\n        out[key] = self[key]\n      }\n    }\n    for (const key of keys(that)) {\n      if (!has(out, key)) {\n        out[key] = that[key]\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Merge two records, retaining only the entries that exist in both records.\n *\n * @since 2.0.0\n */\nexport const intersection: {\n  /**\n   * Merge two records, retaining only the entries that exist in both records.\n   *\n   * @since 2.0.0\n   */\n  <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>\n  /**\n   * Merge two records, retaining only the entries that exist in both records.\n   *\n   * @since 2.0.0\n   */\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>\n} = dual(\n  3,\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C> => {\n    const out: Record<string, C> = empty()\n    if (isEmptyRecord(self) || isEmptyRecord(that)) {\n      return out\n    }\n    for (const key of keys(self)) {\n      if (has(that, key as any)) {\n        out[key] = combine(self[key], that[key as unknown as K1])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Merge two records, preserving only the entries that are unique to each record.\n *\n * @since 2.0.0\n */\nexport const difference: {\n  /**\n   * Merge two records, preserving only the entries that are unique to each record.\n   *\n   * @since 2.0.0\n   */\n  <K1 extends string, B>(that: ReadonlyRecord<K1, B>): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>\n  /**\n   * Merge two records, preserving only the entries that are unique to each record.\n   *\n   * @since 2.0.0\n   */\n  <K0 extends string, A, K1 extends string, B>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>): Record<K0 | K1, A | B>\n} = dual(2, <K0 extends string, A, K1 extends string, B>(\n  self: ReadonlyRecord<K0, A>,\n  that: ReadonlyRecord<K1, B>\n): Record<K0 | K1, A | B> => {\n  if (isEmptyRecord(self)) {\n    return { ...that } as any\n  }\n  if (isEmptyRecord(that)) {\n    return { ...self } as any\n  }\n  const out = <Record<K0 | K1, A | B>> {}\n  for (const key of keys(self)) {\n    if (!has(that, key as any)) {\n      out[key] = self[key]\n    }\n  }\n  for (const key of keys(that)) {\n    if (!has(self, key as any)) {\n      out[key] = that[key]\n    }\n  }\n  return out\n})\n\n/**\n * Create an `Equivalence` for records using the provided `Equivalence` for values.\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getEquivalence = <K extends string, A>(\n  equivalence: Equivalence<A>\n): Equivalence<ReadonlyRecord<K, A>> => {\n  const is = isSubrecordBy(equivalence)\n  return (self, that) => is(self, that) && is(that, self)\n}\n\n/**\n * Create a non-empty record from a single element.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const singleton = <K extends string | symbol, A>(key: K, value: A): Record<K, A> => ({\n  [key]: value\n} as any)\n\n/**\n * Returns the first entry that satisfies the specified\n * predicate, or `None` if no such entry exists.\n *\n * @example\n * ```ts\n * import { Record, Option } from \"effect\"\n *\n * const record = { a: 1, b: 2, c: 3 }\n * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n * console.log(result) // Option.Some([\"c\", 3])\n * ```\n *\n * @category elements\n * @since 3.14.0\n */\nexport const findFirst: {\n  /**\n   * Returns the first entry that satisfies the specified\n   * predicate, or `None` if no such entry exists.\n   *\n   * @example\n   * ```ts\n   * import { Record, Option } from \"effect\"\n   *\n   * const record = { a: 1, b: 2, c: 3 }\n   * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n   * console.log(result) // Option.Some([\"c\", 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.14.0\n   */\n  <K extends string | symbol, V, V2 extends V>(refinement: (value: NoInfer<V>, key: NoInfer<K>) => value is V2): (self: ReadonlyRecord<K, V>) => Option.Option<[K, V2]>\n  /**\n   * Returns the first entry that satisfies the specified\n   * predicate, or `None` if no such entry exists.\n   *\n   * @example\n   * ```ts\n   * import { Record, Option } from \"effect\"\n   *\n   * const record = { a: 1, b: 2, c: 3 }\n   * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n   * console.log(result) // Option.Some([\"c\", 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.14.0\n   */\n  <K extends string | symbol, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): (self: ReadonlyRecord<K, V>) => Option.Option<[K, V]>\n  /**\n   * Returns the first entry that satisfies the specified\n   * predicate, or `None` if no such entry exists.\n   *\n   * @example\n   * ```ts\n   * import { Record, Option } from \"effect\"\n   *\n   * const record = { a: 1, b: 2, c: 3 }\n   * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n   * console.log(result) // Option.Some([\"c\", 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.14.0\n   */\n  <K extends string | symbol, V, V2 extends V>(\n    self: ReadonlyRecord<K, V>,\n    refinement: (value: NoInfer<V>, key: NoInfer<K>) => value is V2\n  ): Option.Option<[K, V2]>\n  /**\n   * Returns the first entry that satisfies the specified\n   * predicate, or `None` if no such entry exists.\n   *\n   * @example\n   * ```ts\n   * import { Record, Option } from \"effect\"\n   *\n   * const record = { a: 1, b: 2, c: 3 }\n   * const result = Record.findFirst(record, (value, key) => value > 1 && key !== \"b\")\n   * console.log(result) // Option.Some([\"c\", 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.14.0\n   */\n  <K extends string | symbol, V>(\n    self: ReadonlyRecord<K, V>,\n    predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean\n  ): Option.Option<[K, V]>\n} = dual(\n  2,\n  <K extends string | symbol, V>(self: ReadonlyRecord<K, V>, f: (value: V, key: K) => boolean) => {\n    const k = keys(self)\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i]\n      if (f(self[key], key)) {\n        return Option.some([key, self[key]])\n      }\n    }\n    return Option.none()\n  }\n)\n","/**\n * This module provides utility functions for working with arrays in TypeScript.\n *\n * @since 2.0.0\n */\n\nimport * as Either from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as internalArray from \"./internal/array.js\"\nimport * as internalDoNotation from \"./internal/doNotation.js\"\nimport * as moduleIterable from \"./Iterable.js\"\nimport * as Option from \"./Option.js\"\nimport * as Order from \"./Order.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport * as Record from \"./Record.js\"\nimport * as Tuple from \"./Tuple.js\"\nimport type { NoInfer } from \"./Types.js\"\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface ReadonlyArrayTypeLambda extends TypeLambda {\n  readonly type: ReadonlyArray<this[\"Target\"]>\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type NonEmptyReadonlyArray<A> = readonly [A, ...Array<A>]\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type NonEmptyArray<A> = [A, ...Array<A>]\n\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.make(1, 2, 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <Elements extends NonEmptyArray<any>>(\n  ...elements: Elements\n): NonEmptyArray<Elements[number]> => elements\n\n/**\n * Creates a new `Array` of the specified length.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.allocate<number>(3)\n * console.log(result) // [ <3 empty items> ]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const allocate = <A = never>(n: number): Array<A | undefined> => new Array(n)\n\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * **Example**\n *\n * ```ts\n * import { makeBy } from \"effect/Array\"\n *\n * const result = makeBy(5, n => n * 2)\n * console.log(result) // [0, 2, 4, 6, 8]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy: {\n  /**\n   * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { makeBy } from \"effect/Array\"\n   *\n   * const result = makeBy(5, n => n * 2)\n   * console.log(result) // [0, 2, 4, 6, 8]\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(f: (i: number) => A): (n: number) => NonEmptyArray<A>\n  /**\n   * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { makeBy } from \"effect/Array\"\n   *\n   * const result = makeBy(5, n => n * 2)\n   * console.log(result) // [0, 2, 4, 6, 8]\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(n: number, f: (i: number) => A): NonEmptyArray<A>\n} = dual(2, <A>(n: number, f: (i: number) => A) => {\n  const max = Math.max(1, Math.floor(n))\n  const out = new Array(max)\n  for (let i = 0; i < max; i++) {\n    out[i] = f(i)\n  }\n  return out as NonEmptyArray<A>\n})\n\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * **Example**\n *\n * ```ts\n * import { range } from \"effect/Array\"\n *\n * const result = range(1, 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start: number, end: number): NonEmptyArray<number> =>\n  start <= end ? makeBy(end - start + 1, (i) => start + i) : [start]\n\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replicate(\"a\", 3)\n * console.log(result) // [\"a\", \"a\", \"a\"]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const replicate: {\n  /**\n   * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replicate(\"a\", 3)\n   * console.log(result) // [\"a\", \"a\", \"a\"]\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  (n: number): <A>(a: A) => NonEmptyArray<A>\n  /**\n   * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replicate(\"a\", 3)\n   * console.log(result) // [\"a\", \"a\", \"a\"]\n   * ```\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(a: A, n: number): NonEmptyArray<A>\n} = dual(2, <A>(a: A, n: number): NonEmptyArray<A> => makeBy(n, () => a))\n\n/**\n * Creates a new `Array` from an iterable collection of values.\n * If the input is already an array, it returns the input as-is.\n * Otherwise, it converts the iterable collection to an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.fromIterable(new Set([1, 2, 3]))\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = <A>(collection: Iterable<A>): Array<A> =>\n  Array.isArray(collection) ? collection : Array.from(collection)\n\n/**\n * Creates a new `Array` from a value that might not be an iterable.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.ensure(\"a\")) // [\"a\"]\n * console.log(Array.ensure([\"a\"])) // [\"a\"]\n * console.log(Array.ensure([\"a\", \"b\", \"c\"])) // [\"a\", \"b\", \"c\"]\n * ```\n *\n * @category constructors\n * @since 3.3.0\n */\nexport const ensure = <A>(self: ReadonlyArray<A> | A): Array<A> => Array.isArray(self) ? self : [self as A]\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.fromRecord({ a: 1, b: 2, c: 3 })\n * console.log(result) // [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]> = Record.toEntries\n\n/**\n * Converts an `Option` to an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * console.log(Array.fromOption(Option.some(1))) // [1]\n * console.log(Array.fromOption(Option.none())) // []\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromOption: <A>(self: Option.Option<A>) => Array<A> = Option.toArray\n\n/**\n * Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const match = Array.match({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n * })\n * console.log(match([])) // \"empty\"\n * console.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  /**\n   * Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const match = Array.match({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n   * })\n   * console.log(match([])) // \"empty\"\n   * console.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  /**\n   * Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const match = Array.match({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n   * })\n   * console.log(match([])) // \"empty\"\n   * console.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n  }\n): B | C => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty())\n\n/**\n * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const matchLeft = Array.matchLeft({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n * })\n * console.log(matchLeft([])) // \"empty\"\n * console.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const matchLeft: {\n  /**\n   * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const matchLeft = Array.matchLeft({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n   * })\n   * console.log(matchLeft([])) // \"empty\"\n   * console.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (head: A, tail: Array<A>) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  /**\n   * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const matchLeft = Array.matchLeft({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n   * })\n   * console.log(matchLeft([])) // \"empty\"\n   * console.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (head: A, tail: Array<A>) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (head: A, tail: Array<A>) => C\n  }\n): B | C => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty())\n\n/**\n * Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const matchRight = Array.matchRight({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n * })\n * console.log(matchRight([])) // \"empty\"\n * console.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const matchRight: {\n  /**\n   * Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const matchRight = Array.matchRight({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n   * })\n   * console.log(matchRight([])) // \"empty\"\n   * console.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (init: Array<A>, last: A) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  /**\n   * Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const matchRight = Array.matchRight({\n   *   onEmpty: () => \"empty\",\n   *   onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n   * })\n   * console.log(matchRight([])) // \"empty\"\n   * console.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (init: Array<A>, last: A) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (init: Array<A>, last: A) => C\n  }\n): B | C =>\n  isNonEmptyReadonlyArray(self) ?\n    onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) :\n    onEmpty())\n\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.prepend([2, 3, 4], 1)\n * console.log(result) // [1, 2, 3, 4]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend: {\n  /**\n   * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prepend([2, 3, 4], 1)\n   * console.log(result) // [1, 2, 3, 4]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>\n  /**\n   * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prepend([2, 3, 4], 1)\n   * console.log(result) // [1, 2, 3, 4]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B> => [head, ...self])\n\n/**\n * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n * If either array is non-empty, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.prependAll([2, 3], [0, 1])\n * console.log(result) // [0, 1, 2, 3]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll: {\n  /**\n   * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prependAll([2, 3], [0, 1])\n   * console.log(result) // [0, 1, 2, 3]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  /**\n   * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prependAll([2, 3], [0, 1])\n   * console.log(result) // [0, 1, 2, 3]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  /**\n   * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prependAll([2, 3], [0, 1])\n   * console.log(result) // [0, 1, 2, 3]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>\n  /**\n   * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.prependAll([2, 3], [0, 1])\n   * console.log(result) // [0, 1, 2, 3]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(that).concat(fromIterable(self))\n)\n\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.append([1, 2, 3], 4);\n * console.log(result) // [1, 2, 3, 4]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append: {\n  /**\n   * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.append([1, 2, 3], 4);\n   * console.log(result) // [1, 2, 3, 4]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>\n  /**\n   * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.append([1, 2, 3], 4);\n   * console.log(result) // [1, 2, 3, 4]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, last: B): Array<A | B> => [...self, last])\n\n/**\n * Concatenates two arrays (or iterables), combining their elements.\n * If either array is non-empty, the result is also a non-empty array.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll: {\n  /**\n   * Concatenates two arrays (or iterables), combining their elements.\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  /**\n   * Concatenates two arrays (or iterables), combining their elements.\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  /**\n   * Concatenates two arrays (or iterables), combining their elements.\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>\n  /**\n   * Concatenates two arrays (or iterables), combining their elements.\n   * If either array is non-empty, the result is also a non-empty array.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).concat(fromIterable(that))\n)\n\n/**\n * Accumulates values from an `Iterable` starting from the left, storing\n * each intermediate result in an array. Useful for tracking the progression of\n * a value through a series of transformations.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\n * console.log(result) // [0, 1, 3, 6, 10]\n *\n * // Explanation:\n * // This function starts with the initial value (0 in this case)\n * // and adds each element of the array to this accumulator one by one,\n * // keeping track of the cumulative sum after each addition.\n * // Each of these sums is captured in the resulting array.\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scan: {\n  /**\n   * Accumulates values from an `Iterable` starting from the left, storing\n   * each intermediate result in an array. Useful for tracking the progression of\n   * a value through a series of transformations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\";\n   *\n   * const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\n   * console.log(result) // [0, 1, 3, 6, 10]\n   *\n   * // Explanation:\n   * // This function starts with the initial value (0 in this case)\n   * // and adds each element of the array to this accumulator one by one,\n   * // keeping track of the cumulative sum after each addition.\n   * // Each of these sums is captured in the resulting array.\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>\n  /**\n   * Accumulates values from an `Iterable` starting from the left, storing\n   * each intermediate result in an array. Useful for tracking the progression of\n   * a value through a series of transformations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\";\n   *\n   * const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\n   * console.log(result) // [0, 1, 3, 6, 10]\n   *\n   * // Explanation:\n   * // This function starts with the initial value (0 in this case)\n   * // and adds each element of the array to this accumulator one by one,\n   * // keeping track of the cumulative sum after each addition.\n   * // Each of these sums is captured in the resulting array.\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>\n} = dual(3, <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B> => {\n  const out: NonEmptyArray<B> = [b]\n  let i = 0\n  for (const a of self) {\n    out[i + 1] = f(out[i], a)\n    i++\n  }\n  return out\n})\n\n/**\n * Accumulates values from an `Iterable` starting from the right, storing\n * each intermediate result in an array. Useful for tracking the progression of\n * a value through a series of transformations.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\n * console.log(result) // [10, 9, 7, 4, 0]\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scanRight: {\n  /**\n   * Accumulates values from an `Iterable` starting from the right, storing\n   * each intermediate result in an array. Useful for tracking the progression of\n   * a value through a series of transformations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\";\n   *\n   * const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\n   * console.log(result) // [10, 9, 7, 4, 0]\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>\n  /**\n   * Accumulates values from an `Iterable` starting from the right, storing\n   * each intermediate result in an array. Useful for tracking the progression of\n   * a value through a series of transformations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\";\n   *\n   * const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\n   * console.log(result) // [10, 9, 7, 4, 0]\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>\n} = dual(3, <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B> => {\n  const input = fromIterable(self)\n  const out: NonEmptyArray<B> = new Array(input.length + 1) as any\n  out[input.length] = b\n  for (let i = input.length - 1; i >= 0; i--) {\n    out[i] = f(out[i + 1], input[i])\n  }\n  return out\n})\n\n/**\n * Determine if `unknown` is an Array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isArray(null)) // false\n * console.log(Array.isArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isArray: {\n  /**\n   * Determine if `unknown` is an Array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * console.log(Array.isArray(null)) // false\n   * console.log(Array.isArray([1, 2, 3])) // true\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  (self: unknown): self is Array<unknown>\n  /**\n   * Determine if `unknown` is an Array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * console.log(Array.isArray(null)) // false\n   * console.log(Array.isArray([1, 2, 3])) // true\n   * ```\n   *\n   * @category guards\n   * @since 2.0.0\n   */\n  <T>(self: T): self is Extract<T, ReadonlyArray<any>>\n} = Array.isArray\n\n/**\n * Determine if an `Array` is empty narrowing down the type to `[]`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isEmptyArray([])) // true\n * console.log(Array.isEmptyArray([1, 2, 3])) // false\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyArray = <A>(self: Array<A>): self is [] => self.length === 0\n\n/**\n * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isEmptyReadonlyArray([])) // true\n * console.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly [] = isEmptyArray as any\n\n/**\n * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n *\n * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isNonEmptyArray([])) // false\n * console.log(Array.isNonEmptyArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A> = internalArray.isNonEmptyArray\n\n/**\n * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n *\n * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isNonEmptyReadonlyArray([])) // false\n * console.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A> =\n  internalArray.isNonEmptyArray\n\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const length = <A>(self: ReadonlyArray<A>): number => self.length\n\nconst isOutOfBounds = <A>(i: number, as: ReadonlyArray<A>): boolean => i < 0 || i >= as.length\n\nconst clamp = <A>(i: number, as: ReadonlyArray<A>): number => Math.floor(Math.min(Math.max(0, i), as.length))\n\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const get: {\n  /**\n   * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (index: number): <A>(self: ReadonlyArray<A>) => Option.Option<A>\n  /**\n   * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: ReadonlyArray<A>, index: number): Option.Option<A>\n} = dual(2, <A>(self: ReadonlyArray<A>, index: number): Option.Option<A> => {\n  const i = Math.floor(index)\n  return isOutOfBounds(i, self) ? Option.none() : Option.some(self[i])\n})\n\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet: {\n  /**\n   * Gets an element unsafely, will throw on out of bounds.\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  (index: number): <A>(self: ReadonlyArray<A>) => A\n  /**\n   * Gets an element unsafely, will throw on out of bounds.\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <A>(self: ReadonlyArray<A>, index: number): A\n} = dual(2, <A>(self: ReadonlyArray<A>, index: number): A => {\n  const i = Math.floor(index)\n  if (isOutOfBounds(i, self)) {\n    throw new Error(`Index ${i} out of bounds`)\n  }\n  return self[i]\n})\n\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.unprepend([1, 2, 3, 4])\n * console.log(result) // [1, [2, 3, 4]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const unprepend = <A>(\n  self: NonEmptyReadonlyArray<A>\n): [firstElement: A, remainingElements: Array<A>] => [headNonEmpty(self), tailNonEmpty(self)]\n\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.unappend([1, 2, 3, 4])\n * console.log(result) // [[1, 2, 3], 4]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const unappend = <A>(\n  self: NonEmptyReadonlyArray<A>\n): [arrayWithoutLastElement: Array<A>, lastElement: A] => [initNonEmpty(self), lastNonEmpty(self)]\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const head: <A>(self: ReadonlyArray<A>) => Option.Option<A> = get(0)\n\n/**\n * Get the first element of a non empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.headNonEmpty([1, 2, 3, 4])\n * console.log(result) // 1\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A = unsafeGet(0)\n\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const last = <A>(self: ReadonlyArray<A>): Option.Option<A> =>\n  isNonEmptyReadonlyArray(self) ? Option.some(lastNonEmpty(self)) : Option.none()\n\n/**\n * Get the last element of a non empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.lastNonEmpty([1, 2, 3, 4])\n * console.log(result) // 4\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const lastNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): A => self[self.length - 1]\n\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const tail = <A>(self: Iterable<A>): Option.Option<Array<A>> => {\n  const input = fromIterable(self)\n  return isNonEmptyReadonlyArray(input) ? Option.some(tailNonEmpty(input)) : Option.none()\n}\n\n/**\n * Get all but the first element of a `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.tailNonEmpty([1, 2, 3, 4])\n * console.log(result) // [2, 3, 4]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const tailNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): Array<A> => self.slice(1)\n\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const init = <A>(self: Iterable<A>): Option.Option<Array<A>> => {\n  const input = fromIterable(self)\n  return isNonEmptyReadonlyArray(input) ? Option.some(initNonEmpty(input)) : Option.none()\n}\n\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.initNonEmpty([1, 2, 3, 4])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const initNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): Array<A> => self.slice(0, -1)\n\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.take([1, 2, 3, 4, 5], 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const take: {\n  /**\n   * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.take([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.take([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(0, clamp(n, input))\n})\n\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.takeRight([1, 2, 3, 4, 5], 3)\n * console.log(result) // [3, 4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeRight: {\n  /**\n   * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeRight([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [3, 4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeRight([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [3, 4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  const i = clamp(n, input)\n  return i === 0 ? [] : input.slice(-i)\n})\n\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n * console.log(result) // [1, 3, 2]\n *\n * // Explanation:\n * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n * // - The next element (`3`) is also less than `4`, so it adds `3`.\n * // - The next element (`2`) is again less than `4`, so it adds `2`.\n * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeWhile: {\n  /**\n   * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n   * console.log(result) // [1, 3, 2]\n   *\n   * // Explanation:\n   * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n   * // - The next element (`3`) is also less than `4`, so it adds `3`.\n   * // - The next element (`2`) is again less than `4`, so it adds `2`.\n   * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>\n  /**\n   * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n   * console.log(result) // [1, 3, 2]\n   *\n   * // Explanation:\n   * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n   * // - The next element (`3`) is also less than `4`, so it adds `3`.\n   * // - The next element (`2`) is again less than `4`, so it adds `2`.\n   * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  /**\n   * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n   * console.log(result) // [1, 3, 2]\n   *\n   * // Explanation:\n   * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n   * // - The next element (`3`) is also less than `4`, so it adds `3`.\n   * // - The next element (`2`) is again less than `4`, so it adds `2`.\n   * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>\n  /**\n   * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n   * console.log(result) // [1, 3, 2]\n   *\n   * // Explanation:\n   * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n   * // - The next element (`3`) is also less than `4`, so it adds `3`.\n   * // - The next element (`2`) is again less than `4`, so it adds `2`.\n   * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> => {\n  let i = 0\n  const out: Array<A> = []\n  for (const a of self) {\n    if (!predicate(a, i)) {\n      break\n    }\n    out.push(a)\n    i++\n  }\n  return out\n})\n\nconst spanIndex = <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): number => {\n  let i = 0\n  for (const a of self) {\n    if (!predicate(a, i)) {\n      break\n    }\n    i++\n  }\n  return i\n}\n\n/**\n * Split an `Iterable` into two parts:\n *\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const span: {\n  /**\n   * Split an `Iterable` into two parts:\n   *\n   * 1. the longest initial subarray for which all elements satisfy the specified predicate\n   * 2. the remaining elements\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>]\n  /**\n   * Split an `Iterable` into two parts:\n   *\n   * 1. the longest initial subarray for which all elements satisfy the specified predicate\n   * 2. the remaining elements\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>]\n  /**\n   * Split an `Iterable` into two parts:\n   *\n   * 1. the longest initial subarray for which all elements satisfy the specified predicate\n   * 2. the remaining elements\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [init: Array<B>, rest: Array<Exclude<A, B>>]\n  /**\n   * Split an `Iterable` into two parts:\n   *\n   * 1. the longest initial subarray for which all elements satisfy the specified predicate\n   * 2. the remaining elements\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>] =>\n    splitAt(self, spanIndex(self, predicate))\n)\n\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.drop([1, 2, 3, 4, 5], 2)\n * console.log(result) // [3, 4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const drop: {\n  /**\n   * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.drop([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [3, 4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.drop([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [3, 4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(clamp(n, input), input.length)\n})\n\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dropRight([1, 2, 3, 4, 5], 2)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const dropRight: {\n  /**\n   * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dropRight([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n   *\n   * **Note**. `n` is normalized to a non negative integer.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dropRight([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(0, input.length - clamp(n, input))\n})\n\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\n * console.log(result) // [4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const dropWhile: {\n  /**\n   * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\n   * console.log(result) // [4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  /**\n   * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\n   * console.log(result) // [4, 5]\n   * ```\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> =>\n    fromIterable(self).slice(spanIndex(self, predicate))\n)\n\n/**\n * Return the first index for which a predicate holds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\n * console.log(result) // Option.some(2)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirstIndex: {\n  /**\n   * Return the first index for which a predicate holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\n   * console.log(result) // Option.some(2)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>\n  /**\n   * Return the first index for which a predicate holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\n   * console.log(result) // Option.some(2)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number> => {\n  let i = 0\n  for (const a of self) {\n    if (predicate(a, i)) {\n      return Option.some(i)\n    }\n    i++\n  }\n  return Option.none()\n})\n\n/**\n * Return the last index for which a predicate holds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\n * console.log(result) // Option.some(1)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLastIndex: {\n  /**\n   * Return the last index for which a predicate holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\n   * console.log(result) // Option.some(1)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>\n  /**\n   * Return the last index for which a predicate holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\n   * console.log(result) // Option.some(1)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number> => {\n  const input = fromIterable(self)\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i], i)) {\n      return Option.some(i)\n    }\n  }\n  return Option.none()\n})\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n * console.log(result) // Option.some(4)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>\n} = moduleIterable.findFirst\n\n/**\n * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n * console.log(result) // Option.some(4)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast: {\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>\n  /**\n   * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n   * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // Option.some(4)\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>\n} = dual(\n  2,\n  <A>(\n    self: Iterable<A>,\n    f: ((a: A, i: number) => boolean) | ((a: A, i: number) => Option.Option<A>)\n  ): Option.Option<A> => {\n    const input = fromIterable(self)\n    for (let i = input.length - 1; i >= 0; i--) {\n      const a = input[i]\n      const o = f(a, i)\n      if (Predicate.isBoolean(o)) {\n        if (o) {\n          return Option.some(a)\n        }\n      } else {\n        if (Option.isSome(o)) {\n          return o\n        }\n      }\n    }\n    return Option.none()\n  }\n)\n\n/**\n * Returns a tuple of the first element that satisfies the specified\n * predicate and its index, or `None` if no such element exists.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n * console.log(result) // Option.some([4, 3])\n * ```\n *\n * @category elements\n * @since 3.17.0\n */\nexport const findFirstWithIndex: {\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<[B, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<[B, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<[A, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<[B, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<[B, number]>\n  /**\n   * Returns a tuple of the first element that satisfies the specified\n   * predicate and its index, or `None` if no such element exists.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\n   * console.log(result) // Option.some([4, 3])\n   * ```\n   *\n   * @category elements\n   * @since 3.17.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<[A, number]>\n} = dual(\n  2,\n  <A>(\n    self: Iterable<A>,\n    f: ((a: A, i: number) => boolean) | ((a: A, i: number) => Option.Option<A>)\n  ): Option.Option<[A, number]> => {\n    let i = 0\n    for (const a of self) {\n      const o = f(a, i)\n      if (Predicate.isBoolean(o)) {\n        if (o) {\n          return Option.some([a, i])\n        }\n      } else {\n        if (Option.isSome(o)) {\n          return Option.some([o.value, i])\n        }\n      }\n      i++\n    }\n    return Option.none()\n  }\n)\n\n/**\n * Counts all the element of the given array that pass the given predicate\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)\n * console.log(result) // 2\n * ```\n *\n * @category folding\n * @since 3.16.0\n */\nexport const countBy: {\n  /**\n   * Counts all the element of the given array that pass the given predicate\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // 2\n   * ```\n   *\n   * @category folding\n   * @since 3.16.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => number\n  /**\n   * Counts all the element of the given array that pass the given predicate\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)\n   * console.log(result) // 2\n   * ```\n   *\n   * @category folding\n   * @since 3.16.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): number\n} = dual(\n  2,\n  <A>(\n    self: Iterable<A>,\n    f: (a: A, i: number) => boolean\n  ): number => {\n    let count = 0\n    const as = fromIterable(self)\n    for (let i = 0; i < as.length; i++) {\n      const a = as[i]\n      if (f(a, i)) {\n        count++\n      }\n    }\n    return count\n  }\n)\n\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\n * console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n * ```\n *\n * @since 2.0.0\n */\nexport const insertAt: {\n  /**\n   * Insert an element at the specified index, creating a new `NonEmptyArray`,\n   * or return `None` if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\n   * console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A>(self: Iterable<A>) => Option.Option<NonEmptyArray<A | B>>\n  /**\n   * Insert an element at the specified index, creating a new `NonEmptyArray`,\n   * or return `None` if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\n   * console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<NonEmptyArray<A | B>>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<NonEmptyArray<A | B>> => {\n  const out: Array<A | B> = Array.from(self)\n  //             v--- `= self.length` is ok, it means inserting in last position\n  if (i < 0 || i > out.length) {\n    return Option.none()\n  }\n  out.splice(i, 0, b)\n  return Option.some(out) as any\n})\n\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\n * console.log(result) // ['a', 'z', 'c', 'd']\n * ```\n *\n * @since 2.0.0\n */\nexport const replace: {\n  /**\n   * Change the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\n   * console.log(result) // ['a', 'z', 'c', 'd']\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(\n    self: S\n  ) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n  /**\n   * Change the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\n   * console.log(result) // ['a', 'z', 'c', 'd']\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, b: B): Array<A | B> => modify(self, i, () => b))\n\n/**\n * Replaces an element in an array with the given value, returning an option of the updated array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replaceOption([1, 2, 3], 1, 4)\n * console.log(result) // Option.some([1, 4, 3])\n * ```\n *\n * @since 2.0.0\n */\nexport const replaceOption: {\n  /**\n   * Replaces an element in an array with the given value, returning an option of the updated array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replaceOption([1, 2, 3], 1, 4)\n   * console.log(result) // Option.some([1, 4, 3])\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(\n    self: S\n  ) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>\n  /**\n   * Replaces an element in an array with the given value, returning an option of the updated array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.replaceOption([1, 2, 3], 1, 4)\n   * console.log(result) // Option.some([1, 4, 3])\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<Array<A | B>> => modifyOption(self, i, () => b)\n)\n\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\n * console.log(result) // [1, 2, 6, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const modify: {\n  /**\n   * Apply a function to the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\n   * console.log(result) // [1, 2, 6, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n  /**\n   * Apply a function to the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\n   * console.log(result) // [1, 2, 6, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, i: number, f: (a: A) => B): Array<A | B> => {\n    const out: Array<A | B> = Array.from(self)\n    if (isOutOfBounds(i, out)) {\n      return out\n    }\n    const b = f(out[i] as A)\n    out[i] = b\n    return out\n  }\n)\n\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const input = [1, 2, 3, 4]\n * const result = Array.modifyOption(input, 2, (n) => n * 2)\n * console.log(result) // Option.some([1, 2, 6, 4])\n *\n * const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\n * console.log(outOfBoundsResult) // Option.none()\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyOption: {\n  /**\n   * Apply a function to the element at the specified index, creating a new `Array`,\n   * or return `None` if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const input = [1, 2, 3, 4]\n   * const result = Array.modifyOption(input, 2, (n) => n * 2)\n   * console.log(result) // Option.some([1, 2, 6, 4])\n   *\n   * const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\n   * console.log(outOfBoundsResult) // Option.none()\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>\n  /**\n   * Apply a function to the element at the specified index, creating a new `Array`,\n   * or return `None` if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const input = [1, 2, 3, 4]\n   * const result = Array.modifyOption(input, 2, (n) => n * 2)\n   * console.log(result) // Option.some([1, 2, 6, 4])\n   *\n   * const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\n   * console.log(outOfBoundsResult) // Option.none()\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, f: (a: A) => B): Option.Option<Array<A | B>> => {\n  const arr = fromIterable(self)\n  if (isOutOfBounds(i, arr)) {\n    return Option.none()\n  }\n  const out: Array<A | B> = Array.isArray(self) ? self.slice() : arr\n  const b = f(arr[i])\n  out[i] = b\n  return Option.some(out)\n})\n\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const input = [1, 2, 3, 4]\n * const result = Array.remove(input, 2)\n * console.log(result) // [1, 2, 4]\n *\n * const outOfBoundsResult = Array.remove(input, 5)\n * console.log(outOfBoundsResult) // [1, 2, 3, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const remove: {\n  /**\n   * Delete the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const input = [1, 2, 3, 4]\n   * const result = Array.remove(input, 2)\n   * console.log(result) // [1, 2, 4]\n   *\n   * const outOfBoundsResult = Array.remove(input, 5)\n   * console.log(outOfBoundsResult) // [1, 2, 3, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  (i: number): <A>(self: Iterable<A>) => Array<A>\n  /**\n   * Delete the element at the specified index, creating a new `Array`,\n   * or return a copy of the input if the index is out of bounds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const input = [1, 2, 3, 4]\n   * const result = Array.remove(input, 2)\n   * console.log(result) // [1, 2, 4]\n   *\n   * const outOfBoundsResult = Array.remove(input, 5)\n   * console.log(outOfBoundsResult) // [1, 2, 3, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, i: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, i: number): Array<A> => {\n  const out = Array.from(self)\n  if (isOutOfBounds(i, out)) {\n    return out\n  }\n  out.splice(i, 1)\n  return out\n})\n\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Array, Option } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.removeOption(numbers, 2)\n * assert.deepStrictEqual(result, Option.some([1, 2, 4]))\n *\n * const outOfBoundsResult = Array.removeOption(numbers, 5)\n * assert.deepStrictEqual(outOfBoundsResult, Option.none())\n * ```\n *\n * @since 3.16.0\n */\nexport const removeOption: {\n  /**\n   * Delete the element at the specified index, creating a new `Array`,\n   * or return `None` if the index is out of bounds.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Array, Option } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4]\n   * const result = Array.removeOption(numbers, 2)\n   * assert.deepStrictEqual(result, Option.some([1, 2, 4]))\n   *\n   * const outOfBoundsResult = Array.removeOption(numbers, 5)\n   * assert.deepStrictEqual(outOfBoundsResult, Option.none())\n   * ```\n   *\n   * @since 3.16.0\n   */\n  (i: number): <A>(self: Iterable<A>) => Option.Option<Array<A>>\n  /**\n   * Delete the element at the specified index, creating a new `Array`,\n   * or return `None` if the index is out of bounds.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Array, Option } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4]\n   * const result = Array.removeOption(numbers, 2)\n   * assert.deepStrictEqual(result, Option.some([1, 2, 4]))\n   *\n   * const outOfBoundsResult = Array.removeOption(numbers, 5)\n   * assert.deepStrictEqual(outOfBoundsResult, Option.none())\n   * ```\n   *\n   * @since 3.16.0\n   */\n  <A>(self: Iterable<A>, i: number): Option.Option<Array<A>>\n} = dual(2, <A>(self: Iterable<A>, i: number): Option.Option<Array<A>> => {\n  const arr = fromIterable(self)\n  if (isOutOfBounds(i, arr)) {\n    return Option.none()\n  }\n  const out = Array.isArray(self) ? self.slice() : arr\n  out.splice(i, 1)\n  return Option.some(out)\n})\n\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reverse([1, 2, 3, 4])\n * console.log(result) // [4, 3, 2, 1]\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const reverse = <S extends Iterable<any>>(\n  self: S\n): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never =>\n  Array.from(self).reverse() as any\n\n/**\n * Create a new array with elements sorted in increasing order based on the specified comparator.\n * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const sort: {\n  /**\n   * Create a new array with elements sorted in increasing order based on the specified comparator.\n   * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n   *\n   * @category sorting\n   * @since 2.0.0\n   */\n  <B>(O: Order.Order<B>): <A extends B, S extends Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * Create a new array with elements sorted in increasing order based on the specified comparator.\n   * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n   *\n   * @category sorting\n   * @since 2.0.0\n   */\n  <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>\n  /**\n   * Create a new array with elements sorted in increasing order based on the specified comparator.\n   * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n   *\n   * @category sorting\n   * @since 2.0.0\n   */\n  <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>\n} = dual(2, <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A> => {\n  const out = Array.from(self)\n  out.sort(O)\n  return out\n})\n\n/**\n * Sorts an array based on a provided mapping function and order. The mapping\n * function transforms the elements into a value that can be compared, and the\n * order defines how those values should be sorted.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n *\n * // Explanation:\n * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n * // converts each string into its length, and the `Order.number` specifies that the lengths should\n * // be sorted in ascending order.\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const sortWith: {\n  /**\n   * Sorts an array based on a provided mapping function and order. The mapping\n   * function transforms the elements into a value that can be compared, and the\n   * order defines how those values should be sorted.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n   * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n   *\n   * // Explanation:\n   * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n   * // converts each string into its length, and the `Order.number` specifies that the lengths should\n   * // be sorted in ascending order.\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <S extends Iterable<any>, B>(f: (a: ReadonlyArray.Infer<S>) => B, order: Order.Order<B>): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * Sorts an array based on a provided mapping function and order. The mapping\n   * function transforms the elements into a value that can be compared, and the\n   * order defines how those values should be sorted.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n   * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n   *\n   * // Explanation:\n   * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n   * // converts each string into its length, and the `Order.number` specifies that the lengths should\n   * // be sorted in ascending order.\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>\n  /**\n   * Sorts an array based on a provided mapping function and order. The mapping\n   * function transforms the elements into a value that can be compared, and the\n   * order defines how those values should be sorted.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n   * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n   *\n   * // Explanation:\n   * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n   * // converts each string into its length, and the `Order.number` specifies that the lengths should\n   * // be sorted in ascending order.\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A> =>\n    Array.from(self).map((a) => [a, f(a)] as const).sort(([, a], [, b]) => order(a, b)).map(([_]) => _)\n)\n\n/**\n * Sorts the elements of an `Iterable` in increasing order based on the provided\n * orders. The elements are compared using the first order in `orders`, then the\n * second order if the first comparison is equal, and so on.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order, pipe } from \"effect\"\n *\n * const users = [\n *   { name: \"Alice\", age: 30 },\n *   { name: \"Bob\", age: 25 },\n *   { name: \"Charlie\", age: 30 }\n * ]\n *\n * const result = pipe(\n *   users,\n *   Array.sortBy(\n *     Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n *     Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n *   )\n * )\n *\n * console.log(result)\n * // [\n * //   { name: \"Bob\", age: 25 },\n * //   { name: \"Alice\", age: 30 },\n * //   { name: \"Charlie\", age: 30 }\n * // ]\n *\n * // Explanation:\n * // The array of users is sorted first by age in ascending order. When ages are equal,\n * // the users are further sorted by name in ascending order.\n * ```\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const sortBy = <S extends Iterable<any>>(\n  ...orders: ReadonlyArray<Order.Order<ReadonlyArray.Infer<S>>>\n) => {\n  const sortByAll = sort(Order.combineAll(orders))\n  return (\n    self: S\n  ): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      return sortByAll(input) as any\n    }\n    return [] as any\n  }\n}\n\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.zip([1, 2, 3], ['a', 'b'])\n * console.log(result) // [[1, 'a'], [2, 'b']]\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zip: {\n  /**\n   * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n   * If one input `Iterable` is short, excess elements of the\n   * longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zip([1, 2, 3], ['a', 'b'])\n   * console.log(result) // [[1, 'a'], [2, 'b']]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>\n  /**\n   * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n   * If one input `Iterable` is short, excess elements of the\n   * longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zip([1, 2, 3], ['a', 'b'])\n   * console.log(result) // [[1, 'a'], [2, 'b']]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>\n  /**\n   * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n   * If one input `Iterable` is short, excess elements of the\n   * longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zip([1, 2, 3], ['a', 'b'])\n   * console.log(result) // [[1, 'a'], [2, 'b']]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>\n  /**\n   * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n   * If one input `Iterable` is short, excess elements of the\n   * longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zip([1, 2, 3], ['a', 'b'])\n   * console.log(result) // [[1, 'a'], [2, 'b']]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]> => zipWith(self, that, Tuple.make)\n)\n\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n * console.log(result) // [5, 7, 9]\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  /**\n   * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n   * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n   * console.log(result) // [5, 7, 9]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>\n  /**\n   * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n   * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n   * console.log(result) // [5, 7, 9]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>\n  /**\n   * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n   * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n   * console.log(result) // [5, 7, 9]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <A, B, C>(\n    self: NonEmptyReadonlyArray<A>,\n    that: NonEmptyReadonlyArray<B>,\n    f: (a: A, b: B) => C\n  ): NonEmptyArray<C>\n  /**\n   * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n   * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n   * console.log(result) // [5, 7, 9]\n   * ```\n   *\n   * @category zipping\n   * @since 2.0.0\n   */\n  <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>\n} = dual(3, <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C> => {\n  const as = fromIterable(self)\n  const bs = fromIterable(that)\n  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {\n    const out: NonEmptyArray<C> = [f(headNonEmpty(as), headNonEmpty(bs))]\n    const len = Math.min(as.length, bs.length)\n    for (let i = 1; i < len; i++) {\n      out[i] = f(as[i], bs[i])\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.unzip([[1, \"a\"], [2, \"b\"], [3, \"c\"]])\n * console.log(result) // [[1, 2, 3], ['a', 'b', 'c']]\n * ```\n *\n * @since 2.0.0\n */\nexport const unzip: <S extends Iterable<readonly [any, any]>>(\n  self: S\n) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]> ? [NonEmptyArray<A>, NonEmptyArray<B>]\n  : S extends Iterable<readonly [infer A, infer B]> ? [Array<A>, Array<B>]\n  : never = (<A, B>(self: Iterable<readonly [A, B]>): [Array<A>, Array<B>] => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      const fa: NonEmptyArray<A> = [input[0][0]]\n      const fb: NonEmptyArray<B> = [input[0][1]]\n      for (let i = 1; i < input.length; i++) {\n        fa[i] = input[i][0]\n        fb[i] = input[i][1]\n      }\n      return [fa, fb]\n    }\n    return [[], []]\n  }) as any\n\n/**\n * Places an element in between members of an `Iterable`.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.intersperse([1, 2, 3], 0)\n * console.log(result) // [1, 0, 2, 0, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersperse: {\n  /**\n   * Places an element in between members of an `Iterable`.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersperse([1, 2, 3], 0)\n   * console.log(result) // [1, 0, 2, 0, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n  /**\n   * Places an element in between members of an `Iterable`.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersperse([1, 2, 3], 0)\n   * console.log(result) // [1, 0, 2, 0, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>\n  /**\n   * Places an element in between members of an `Iterable`.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersperse([1, 2, 3], 0)\n   * console.log(result) // [1, 0, 2, 0, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, middle: B): Array<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, middle: B): Array<A | B> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const out: NonEmptyArray<A | B> = [headNonEmpty(input)]\n    const tail = tailNonEmpty(input)\n    for (let i = 0; i < tail.length; i++) {\n      if (i < tail.length) {\n        out.push(middle)\n      }\n      out.push(tail[i])\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\n * console.log(result) // [10, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyNonEmptyHead: {\n  /**\n   * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\n   * console.log(result) // [10, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  /**\n   * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\n   * console.log(result) // [10, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    f: (a: A) => B\n  ): NonEmptyArray<A | B> => [f(headNonEmpty(self)), ...tailNonEmpty(self)]\n)\n\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.setNonEmptyHead([1, 2, 3], 10)\n * console.log(result) // [10, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const setNonEmptyHead: {\n  /**\n   * Change the head, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.setNonEmptyHead([1, 2, 3], 10)\n   * console.log(result) // [10, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  /**\n   * Change the head, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.setNonEmptyHead([1, 2, 3], 10)\n   * console.log(result) // [10, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B> => modifyNonEmptyHead(self, () => b)\n)\n\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\n * console.log(result) // [1, 2, 6]\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyNonEmptyLast: {\n  /**\n   * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\n   * console.log(result) // [1, 2, 6]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  /**\n   * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\n   * console.log(result) // [1, 2, 6]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B> =>\n    append(initNonEmpty(self), f(lastNonEmpty(self)))\n)\n\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.setNonEmptyLast([1, 2, 3], 4)\n * console.log(result) // [1, 2, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const setNonEmptyLast: {\n  /**\n   * Change the last element, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.setNonEmptyLast([1, 2, 3], 4)\n   * console.log(result) // [1, 2, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  /**\n   * Change the last element, creating a new `NonEmptyReadonlyArray`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.setNonEmptyLast([1, 2, 3], 4)\n   * console.log(result) // [1, 2, 4]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B> => modifyNonEmptyLast(self, () => b)\n)\n\n/**\n * Rotate an `Iterable` by `n` steps.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\n * console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n * ```\n *\n * @since 2.0.0\n */\nexport const rotate: {\n  /**\n   * Rotate an `Iterable` by `n` steps.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\n   * console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * Rotate an `Iterable` by `n` steps.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\n   * console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>\n  /**\n   * Rotate an `Iterable` by `n` steps.\n   * If the input is a non-empty array, the result is also a non-empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\n   * console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const len = input.length\n    const m = Math.round(n) % len\n    if (isOutOfBounds(Math.abs(m), input) || m === 0) {\n      return copy(input)\n    }\n    if (m < 0) {\n      const [f, s] = splitNonEmptyAt(input, -m)\n      return appendAll(s, f)\n    } else {\n      return rotate(self, m - len)\n    }\n  }\n  return []\n})\n\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const isEquivalent = (a: number, b: number) => a === b\n * const containsNumber = Array.containsWith(isEquivalent)\n * const result = pipe([1, 2, 3, 4], containsNumber(3))\n * console.log(result) // true\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (a: A): (self: Iterable<A>) => boolean\n  (self: Iterable<A>, a: A): boolean\n} =>\n  dual(2, (self: Iterable<A>, a: A): boolean => {\n    for (const i of self) {\n      if (isEquivalent(a, i)) {\n        return true\n      }\n    }\n    return false\n  })\n\nconst _equivalence = Equal.equivalence()\n\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\n * console.log(result) // true\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains: {\n  /**\n   * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\n   * console.log(result) // true\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(a: A): (self: Iterable<A>) => boolean\n  /**\n   * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\n   * console.log(result) // true\n   * ```\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, a: A): boolean\n} = containsWith(_equivalence)\n\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n * console.log(result) // [2, 4, 6, 8, 10]\n *\n * // Explanation:\n * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n * // resulting in a new array `[2, 4, 6, 8, 10]`.\n * ```\n *\n * @since 2.0.0\n */\nexport const chop: {\n  /**\n   * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n   * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n   * value and the rest of the `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n   * console.log(result) // [2, 4, 6, 8, 10]\n   *\n   * // Explanation:\n   * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n   * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n   * // resulting in a new array `[2, 4, 6, 8, 10]`.\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>, B>(\n    f: (as: NonEmptyReadonlyArray<ReadonlyArray.Infer<S>>) => readonly [B, ReadonlyArray<ReadonlyArray.Infer<S>>]\n  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n   * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n   * value and the rest of the `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n   * console.log(result) // [2, 4, 6, 8, 10]\n   *\n   * // Explanation:\n   * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n   * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n   * // resulting in a new array `[2, 4, 6, 8, 10]`.\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n  ): NonEmptyArray<B>\n  /**\n   * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n   * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n   * value and the rest of the `Array`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n   * console.log(result) // [2, 4, 6, 8, 10]\n   *\n   * // Explanation:\n   * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n   * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n   * // resulting in a new array `[2, 4, 6, 8, 10]`.\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: Iterable<A>,\n    f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n  ): Array<B>\n} = dual(2, <A, B>(\n  self: Iterable<A>,\n  f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n): Array<B> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const [b, rest] = f(input)\n    const out: NonEmptyArray<B> = [b]\n    let next: ReadonlyArray<A> = rest\n    while (internalArray.isNonEmptyArray(next)) {\n      const [b, rest] = f(next)\n      out.push(b)\n      next = rest\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` can be `0`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitAt([1, 2, 3, 4, 5], 3)\n * console.log(result) // [[1, 2, 3], [4, 5]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitAt: {\n  /**\n   * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` can be `0`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitAt([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [[1, 2, 3], [4, 5]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]\n  /**\n   * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` can be `0`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitAt([1, 2, 3, 4, 5], 3)\n   * console.log(result) // [[1, 2, 3], [4, 5]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]\n} = dual(2, <A>(self: Iterable<A>, n: number): [Array<A>, Array<A>] => {\n  const input = Array.from(self)\n  const _n = Math.floor(n)\n  if (isNonEmptyReadonlyArray(input)) {\n    if (_n >= 1) {\n      return splitNonEmptyAt(input, _n)\n    }\n    return [[], input]\n  }\n  return [input, []]\n})\n\n/**\n * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\n * console.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitNonEmptyAt: {\n  /**\n   * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` must be `>= 1`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\n   * console.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]\n  /**\n   * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` must be `>= 1`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\n   * console.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, n: number): [NonEmptyArray<A>, Array<A>] => {\n  const _n = Math.max(1, Math.floor(n))\n  return _n >= self.length ?\n    [copy(self), []] :\n    [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)]\n})\n\n/**\n * Splits this iterable into `n` equally sized arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\n * console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const split: {\n  /**\n   * Splits this iterable into `n` equally sized arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\n   * console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<Array<A>>\n  /**\n   * Splits this iterable into `n` equally sized arrays.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\n   * console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  <A>(self: Iterable<A>, n: number): Array<Array<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number) => {\n  const input = fromIterable(self)\n  return chunksOf(input, Math.ceil(input.length / Math.floor(n)))\n})\n\n/**\n * Splits this iterable on the first element that matches this predicate.\n * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\n * console.log(result) // [[1, 2, 3], [4, 5]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitWhere: {\n  /**\n   * Splits this iterable on the first element that matches this predicate.\n   * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\n   * console.log(result) // [[1, 2, 3], [4, 5]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]\n  /**\n   * Splits this iterable on the first element that matches this predicate.\n   * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\n   * console.log(result) // [[1, 2, 3], [4, 5]]\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>] =>\n    span(self, (a: A, i: number) => !predicate(a, i))\n)\n\n/**\n * Copies an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.copy([1, 2, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const copy: {\n  /**\n   * Copies an array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.copy([1, 2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>\n  /**\n   * Copies an array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.copy([1, 2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: ReadonlyArray<A>): Array<A>\n} = (<A>(self: ReadonlyArray<A>): Array<A> => self.slice()) as any\n\n/**\n * Pads an array.\n * Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\n * If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\n * If `n` is less than or equal to 0, the returned array will be an empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.pad([1, 2, 3], 6, 0)\n * console.log(result) // [1, 2, 3, 0, 0, 0]\n * ```\n *\n * @since 3.8.4\n */\nexport const pad: {\n  /**\n   * Pads an array.\n   * Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\n   * If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\n   * If `n` is less than or equal to 0, the returned array will be an empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.pad([1, 2, 3], 6, 0)\n   * console.log(result) // [1, 2, 3, 0, 0, 0]\n   * ```\n   *\n   * @since 3.8.4\n   */\n  <A, T>(n: number, fill: T): (\n    self: Array<A>\n  ) => Array<A | T>\n  /**\n   * Pads an array.\n   * Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\n   * If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\n   * If `n` is less than or equal to 0, the returned array will be an empty array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.pad([1, 2, 3], 6, 0)\n   * console.log(result) // [1, 2, 3, 0, 0, 0]\n   * ```\n   *\n   * @since 3.8.4\n   */\n  <A, T>(self: Array<A>, n: number, fill: T): Array<A | T>\n} = dual(3, <A, T>(self: Array<A>, n: number, fill: T): Array<A | T> => {\n  if (self.length >= n) {\n    return take(self, n)\n  }\n  return appendAll(\n    self,\n    makeBy(n - self.length, () => fill)\n  )\n})\n\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts skip-type-checking\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n * console.log(result) // [[1, 2], [3, 4], [5]]\n *\n * // Explanation:\n * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n * // the last chunk contains the remaining elements.\n * // The result is `[[1, 2], [3, 4], [5]]`.\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const chunksOf: {\n  /**\n   * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n   * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n   * definition of `chunksOf`; it satisfies the property that\n   *\n   * ```ts skip-type-checking\n   * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n   * ```\n   *\n   * whenever `n` evenly divides the length of `self`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [[1, 2], [3, 4], [5]]\n   *\n   * // Explanation:\n   * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n   * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n   * // the last chunk contains the remaining elements.\n   * // The result is `[[1, 2], [3, 4], [5]]`.\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  (n: number): <S extends Iterable<any>>(\n    self: S\n  ) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>\n  /**\n   * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n   * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n   * definition of `chunksOf`; it satisfies the property that\n   *\n   * ```ts skip-type-checking\n   * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n   * ```\n   *\n   * whenever `n` evenly divides the length of `self`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [[1, 2], [3, 4], [5]]\n   *\n   * // Explanation:\n   * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n   * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n   * // the last chunk contains the remaining elements.\n   * // The result is `[[1, 2], [3, 4], [5]]`.\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>\n  /**\n   * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n   * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n   * definition of `chunksOf`; it satisfies the property that\n   *\n   * ```ts skip-type-checking\n   * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n   * ```\n   *\n   * whenever `n` evenly divides the length of `self`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n   * console.log(result) // [[1, 2], [3, 4], [5]]\n   *\n   * // Explanation:\n   * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n   * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n   * // the last chunk contains the remaining elements.\n   * // The result is `[[1, 2], [3, 4], [5]]`.\n   * ```\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    return chop(input, splitNonEmptyAt(n))\n  }\n  return []\n})\n\n/**\n * Creates sliding windows of size `n` from an `Iterable`.\n * If the number of elements is less than `n` or if `n` is not greater than zero,\n * an empty array is returned.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n * assert.deepStrictEqual(Array.window(numbers, 6), [])\n * ```\n *\n * @category splitting\n * @since 3.13.2\n */\nexport const window: {\n  /**\n   * Creates sliding windows of size `n` from an `Iterable`.\n   * If the number of elements is less than `n` or if `n` is not greater than zero,\n   * an empty array is returned.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Array } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5]\n   * assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n   * assert.deepStrictEqual(Array.window(numbers, 6), [])\n   * ```\n   *\n   * @category splitting\n   * @since 3.13.2\n   */\n  (n: number): <A>(self: Iterable<A>) => Array<Array<A>>\n  /**\n   * Creates sliding windows of size `n` from an `Iterable`.\n   * If the number of elements is less than `n` or if `n` is not greater than zero,\n   * an empty array is returned.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Array } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5]\n   * assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n   * assert.deepStrictEqual(Array.window(numbers, 6), [])\n   * ```\n   *\n   * @category splitting\n   * @since 3.13.2\n   */\n  <A>(self: Iterable<A>, n: number): Array<Array<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<Array<A>> => {\n  const input = fromIterable(self)\n  if (n > 0 && isNonEmptyReadonlyArray(input)) {\n    return Array.from(\n      { length: input.length - (n - 1) },\n      (_, index) => input.slice(index, index + n)\n    )\n  }\n  return []\n})\n\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\n * console.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupWith: {\n  /**\n   * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\n   * console.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n   * ```\n   *\n   * @category grouping\n   * @since 2.0.0\n   */\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>\n  /**\n   * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\n   * console.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n   * ```\n   *\n   * @category grouping\n   * @since 2.0.0\n   */\n  <A>(\n    self: NonEmptyReadonlyArray<A>,\n    isEquivalent: (self: A, that: A) => boolean\n  ): NonEmptyArray<NonEmptyArray<A>>\n} = dual(\n  2,\n  <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>> =>\n    chop(self, (as) => {\n      const h = headNonEmpty(as)\n      const out: NonEmptyArray<A> = [h]\n      let i = 1\n      for (; i < as.length; i++) {\n        const a = as[i]\n        if (isEquivalent(a, h)) {\n          out.push(a)\n        } else {\n          break\n        }\n      }\n      return [out, as.slice(i)]\n    })\n)\n\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.group([1, 1, 2, 2, 2, 3, 1])\n * console.log(result) // [[1, 1], [2, 2, 2], [3], [1]]\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>> = groupWith(\n  Equal.equivalence()\n)\n\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const people = [\n *   { name: \"Alice\", group: \"A\" },\n *   { name: \"Bob\", group: \"B\" },\n *   { name: \"Charlie\", group: \"A\" }\n * ]\n *\n * const result = Array.groupBy(people, person => person.group)\n * console.log(result)\n * // {\n * //  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n * //  B: [{ name: \"Bob\", group: \"B\" }]\n * // }\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupBy: {\n  /**\n   * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n   * function on each element, and grouping the results according to values returned\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const people = [\n   *   { name: \"Alice\", group: \"A\" },\n   *   { name: \"Bob\", group: \"B\" },\n   *   { name: \"Charlie\", group: \"A\" }\n   * ]\n   *\n   * const result = Array.groupBy(people, person => person.group)\n   * console.log(result)\n   * // {\n   * //  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n   * //  B: [{ name: \"Bob\", group: \"B\" }]\n   * // }\n   * ```\n   *\n   * @category grouping\n   * @since 2.0.0\n   */\n  <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>\n  /**\n   * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n   * function on each element, and grouping the results according to values returned\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const people = [\n   *   { name: \"Alice\", group: \"A\" },\n   *   { name: \"Bob\", group: \"B\" },\n   *   { name: \"Charlie\", group: \"A\" }\n   * ]\n   *\n   * const result = Array.groupBy(people, person => person.group)\n   * console.log(result)\n   * // {\n   * //  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n   * //  B: [{ name: \"Bob\", group: \"B\" }]\n   * // }\n   * ```\n   *\n   * @category grouping\n   * @since 2.0.0\n   */\n  <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>\n} = dual(2, <A, K extends string | symbol>(\n  self: Iterable<A>,\n  f: (a: A) => K\n): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>> => {\n  const out: Record<string | symbol, NonEmptyArray<A>> = {}\n  for (const a of self) {\n    const k = f(a)\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a)\n    } else {\n      out[k] = [a]\n    }\n  }\n  return out\n})\n\n/**\n * Calculates the union of two arrays using the provided equivalence relation.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n * console.log(union) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const unionWith: {\n  /**\n   * Calculates the union of two arrays using the provided equivalence relation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n   * console.log(union) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>, T extends Iterable<any>>(\n    that: T,\n    isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean\n  ): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  /**\n   * Calculates the union of two arrays using the provided equivalence relation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n   * console.log(union) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    that: Iterable<B>,\n    isEquivalent: (self: A, that: B) => boolean\n  ): NonEmptyArray<A | B>\n  /**\n   * Calculates the union of two arrays using the provided equivalence relation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n   * console.log(union) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: Iterable<A>,\n    that: NonEmptyReadonlyArray<B>,\n    isEquivalent: (self: A, that: B) => boolean\n  ): NonEmptyArray<A | B>\n  /**\n   * Calculates the union of two arrays using the provided equivalence relation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n   * console.log(union) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: Iterable<A>,\n    that: Iterable<B>,\n    isEquivalent: (self: A, that: B) => boolean\n  ): Array<A | B>\n} = dual(3, <A>(self: Iterable<A>, that: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n  const a = fromIterable(self)\n  const b = fromIterable(that)\n  if (isNonEmptyReadonlyArray(a)) {\n    if (isNonEmptyReadonlyArray(b)) {\n      const dedupe = dedupeWith(isEquivalent)\n      return dedupe(appendAll(a, b))\n    }\n    return a\n  }\n  return b\n})\n\n/**\n * Creates a union of two arrays, removing duplicates.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.union([1, 2], [2, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const union: {\n  /**\n   * Creates a union of two arrays, removing duplicates.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.union([1, 2], [2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <T extends Iterable<any>>(that: T): <S extends Iterable<any>>(\n    self: S\n  ) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  /**\n   * Creates a union of two arrays, removing duplicates.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.union([1, 2], [2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>\n  /**\n   * Creates a union of two arrays, removing duplicates.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.union([1, 2], [2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  /**\n   * Creates a union of two arrays, removing duplicates.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.union([1, 2], [2, 3])\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B> => unionWith(self, that, _equivalence))\n\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\n * const array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\n * const isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\n * const result = Array.intersectionWith(isEquivalent)(array2)(array1)\n * console.log(result) // [{ id: 1 }, { id: 3 }]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersectionWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  (self: Iterable<A>, that: Iterable<A>): Array<A>\n} => {\n  const has = containsWith(isEquivalent)\n  return dual(\n    2,\n    (self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).filter((a) => has(that, a))\n  )\n}\n\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.intersection([1, 2, 3], [3, 4, 1])\n * console.log(result) // [1, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersection: {\n  /**\n   * Creates an `Array` of unique values that are included in all given `Iterable`s.\n   * The order and references of result values are determined by the first `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersection([1, 2, 3], [3, 4, 1])\n   * console.log(result) // [1, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>\n  /**\n   * Creates an `Array` of unique values that are included in all given `Iterable`s.\n   * The order and references of result values are determined by the first `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.intersection([1, 2, 3], [3, 4, 1])\n   * console.log(result) // [1, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>\n} = intersectionWith(_equivalence)\n\n/**\n * Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2, 3]\n * const array2 = [2, 3, 4]\n * const difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\n * console.log(difference) // [1]\n * ```\n *\n * @since 2.0.0\n */\nexport const differenceWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  (self: Iterable<A>, that: Iterable<A>): Array<A>\n} => {\n  const has = containsWith(isEquivalent)\n  return dual(\n    2,\n    (self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).filter((a) => !has(that, a))\n  )\n}\n\n/**\n * Creates a `Array` of values not included in the other given `Iterable`.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const difference = Array.difference([1, 2, 3], [2, 3, 4])\n * console.log(difference) // [1]\n * ```\n *\n * @since 2.0.0\n */\nexport const difference: {\n  /**\n   * Creates a `Array` of values not included in the other given `Iterable`.\n   * The order and references of result values are determined by the first `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const difference = Array.difference([1, 2, 3], [2, 3, 4])\n   * console.log(difference) // [1]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  /**\n   * Creates a `Array` of values not included in the other given `Iterable`.\n   * The order and references of result values are determined by the first `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const difference = Array.difference([1, 2, 3], [2, 3, 4])\n   * console.log(difference) // [1]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A>\n} = differenceWith(_equivalence)\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty: <A = never>() => Array<A> = () => []\n\n/**\n * Constructs a new `NonEmptyArray<A>` from the specified value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = <A>(a: A): NonEmptyArray<A> => [a]\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ReadonlyArray {\n  /**\n   * @since 2.0.0\n   */\n  export type Infer<S extends Iterable<any>> = S extends ReadonlyArray<infer A> ? A\n    : S extends Iterable<infer A> ? A\n    : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type With<S extends Iterable<any>, A> = S extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type OrNonEmpty<\n    S extends Iterable<any>,\n    T extends Iterable<any>,\n    A\n  > = S extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : T extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type AndNonEmpty<\n    S extends Iterable<any>,\n    T extends Iterable<any>,\n    A\n  > = S extends NonEmptyReadonlyArray<any> ? T extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type Flatten<T extends ReadonlyArray<ReadonlyArray<any>>> = T extends\n    NonEmptyReadonlyArray<NonEmptyReadonlyArray<infer A>> ? NonEmptyArray<A>\n    : T extends ReadonlyArray<ReadonlyArray<infer A>> ? Array<A>\n    : never\n}\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <S extends ReadonlyArray<any>, B>(f: (a: ReadonlyArray.Infer<S>, i: number) => B): (self: S) => ReadonlyArray.With<S, B>\n  /**\n   * @category mapping\n   * @since 2.0.0\n   */\n  <S extends ReadonlyArray<any>, B>(self: S, f: (a: ReadonlyArray.Infer<S>, i: number) => B): ReadonlyArray.With<S, B>\n} = dual(2, <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => B): Array<B> => self.map(f))\n\n/**\n * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  /**\n   * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => T): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>\n  /**\n   * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    f: (a: A, i: number) => NonEmptyReadonlyArray<B>\n  ): NonEmptyArray<B>\n  /**\n   * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B> => {\n    if (isEmptyReadonlyArray(self)) {\n      return []\n    }\n    const out: Array<B> = []\n    for (let i = 0; i < self.length; i++) {\n      const inner = f(self[i], i)\n      for (let j = 0; j < inner.length; j++) {\n        out.push(inner[j])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Combines multiple arrays into a single array by concatenating all elements\n * from each nested array. This function ensures that the structure of nested\n * arrays is collapsed into a single, flat array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])\n * console.log(result) // [1, 2, 3, 4, 5, 6]\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S> = flatMap(\n  identity\n) as any\n\n/**\n * Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\n * This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n *\n * const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\n * console.log(result) // [4, 16]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMap: {\n  /**\n   * Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\n   * This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Option } from \"effect\"\n   *\n   * const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n   *\n   * const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\n   * console.log(result) // [4, 16]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>\n  /**\n   * Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\n   * This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Option } from \"effect\"\n   *\n   * const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n   *\n   * const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\n   * console.log(result) // [4, 16]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B> => {\n    const as = fromIterable(self)\n    const out: Array<B> = []\n    for (let i = 0; i < as.length; i++) {\n      const o = f(as[i], i)\n      if (Option.isSome(o)) {\n        out.push(o.value)\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\n * This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\n * This is useful when you need to transform an array but only up to the point where a certain condition holds true.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n *\n * const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\n * console.log(result) // [4, 16]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMapWhile: {\n  /**\n   * Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\n   * This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\n   * This is useful when you need to transform an array but only up to the point where a certain condition holds true.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Option } from \"effect\"\n   *\n   * const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n   *\n   * const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\n   * console.log(result) // [4, 16]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>\n  /**\n   * Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\n   * This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\n   * This is useful when you need to transform an array but only up to the point where a certain condition holds true.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Option } from \"effect\"\n   *\n   * const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n   *\n   * const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\n   * console.log(result) // [4, 16]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>\n} = dual(2, <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>) => {\n  let i = 0\n  const out: Array<B> = []\n  for (const a of self) {\n    const b = f(a, i)\n    if (Option.isSome(b)) {\n      out.push(b.value)\n    } else {\n      break\n    }\n    i++\n  }\n  return out\n})\n\n/**\n * Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\n * This function is particularly useful for operations where each element can result in two possible types,\n * and you want to separate these types into different collections. For instance, separating validation results\n * into successes and failures.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\";\n *\n * const isEven = (x: number) => x % 2 === 0\n *\n * const result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n *   isEven(x) ? Either.right(x) : Either.left(x)\n * )\n * console.log(result)\n * // [\n * //   [1, 3, 5],\n * //   [2, 4]\n * // ]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  /**\n   * Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\n   * This function is particularly useful for operations where each element can result in two possible types,\n   * and you want to separate these types into different collections. For instance, separating validation results\n   * into successes and failures.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Either } from \"effect\";\n   *\n   * const isEven = (x: number) => x % 2 === 0\n   *\n   * const result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n   *   isEven(x) ? Either.right(x) : Either.left(x)\n   * )\n   * console.log(result)\n   * // [\n   * //   [1, 3, 5],\n   * //   [2, 4]\n   * // ]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(f: (a: A, i: number) => Either.Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]\n  /**\n   * Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\n   * This function is particularly useful for operations where each element can result in two possible types,\n   * and you want to separate these types into different collections. For instance, separating validation results\n   * into successes and failures.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Either } from \"effect\";\n   *\n   * const isEven = (x: number) => x % 2 === 0\n   *\n   * const result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n   *   isEven(x) ? Either.right(x) : Either.left(x)\n   * )\n   * console.log(result)\n   * // [\n   * //   [1, 3, 5],\n   * //   [2, 4]\n   * // ]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either.Either<C, B>): [left: Array<B>, right: Array<C>]\n} = dual(\n  2,\n  <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either.Either<C, B>): [left: Array<B>, right: Array<C>] => {\n    const left: Array<B> = []\n    const right: Array<C> = []\n    const as = fromIterable(self)\n    for (let i = 0; i < as.length; i++) {\n      const e = f(as[i], i)\n      if (Either.isLeft(e)) {\n        left.push(e.left)\n      } else {\n        right.push(e.right)\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])\n * console.log(result) // [1, 2]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\n\nexport const getSomes: <T extends Iterable<Option.Option<X>>, X = any>(\n  self: T\n) => Array<Option.Option.Value<ReadonlyArray.Infer<T>>> = filterMap(identity as any)\n\n/**\n * Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const result = Array.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])\n * console.log(result) // [\"err\"]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getLefts = <T extends Iterable<Either.Either<any, any>>>(\n  self: T\n): Array<Either.Either.Left<ReadonlyArray.Infer<T>>> => {\n  const out: Array<any> = []\n  for (const a of self) {\n    if (Either.isLeft(a)) {\n      out.push(a.left)\n    }\n  }\n\n  return out\n}\n\n/**\n * Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const result = Array.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])\n * console.log(result) // [1, 2]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getRights = <T extends Iterable<Either.Either<any, any>>>(\n  self: T\n): Array<Either.Either.Right<ReadonlyArray.Infer<T>>> => {\n  const out: Array<any> = []\n  for (const a of self) {\n    if (Either.isRight(a)) {\n      out.push(a.right)\n    }\n  }\n\n  return out\n}\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const filter: {\n  /**\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>\n  /**\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  /**\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>\n  /**\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> => {\n    const as = fromIterable(self)\n    const out: Array<A> = []\n    for (let i = 0; i < as.length; i++) {\n      if (predicate(as[i], i)) {\n        out.push(as[i])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n * console.log(result) // [[1, 3], [2, 4]]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition: {\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n   * console.log(result) // [[1, 3], [2, 4]]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (\n    self: Iterable<A>\n  ) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n   * console.log(result) // [[1, 3], [2, 4]]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n   * console.log(result) // [[1, 3], [2, 4]]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n   * console.log(result) // [[1, 3], [2, 4]]\n   * ```\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>] => {\n    const left: Array<A> = []\n    const right: Array<A> = []\n    const as = fromIterable(self)\n    for (let i = 0; i < as.length; i++) {\n      if (predicate(as[i], i)) {\n        right.push(as[i])\n      } else {\n        left.push(as[i])\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Separates an `Iterable` into two arrays based on a predicate.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate: <T extends Iterable<Either.Either<any, any>>>(\n  self: T\n) => [Array<Either.Either.Left<ReadonlyArray.Infer<T>>>, Array<Either.Either.Right<ReadonlyArray.Infer<T>>>] =\n  partitionMap(identity)\n\n/**\n * Reduces an array from the left.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\n * console.log(result) // 6\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  /**\n   * Reduces an array from the left.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\n   * console.log(result) // 6\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B\n  /**\n   * Reduces an array from the left.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\n   * console.log(result) // 6\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = dual(\n  3,\n  <B, A>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B =>\n    fromIterable(self).reduce((b, a, i) => f(b, a, i), b)\n)\n\n/**\n * Reduces an array from the right.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\n * console.log(result) // 6\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduceRight: {\n  /**\n   * Reduces an array from the right.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\n   * console.log(result) // 6\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B\n  /**\n   * Reduces an array from the right.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\n   * console.log(result) // 6\n   * ```\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B =>\n    fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b)\n)\n\n/**\n * Lifts a predicate into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n * const to = Array.liftPredicate(isEven)\n * console.log(to(1)) // []\n * console.log(to(2)) // [2]\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */\nexport const liftPredicate: { // Note: I intentionally avoid using the NoInfer pattern here.\n  <A, B extends A>(refinement: Predicate.Refinement<A, B>): (a: A) => Array<B>\n  /**\n   * Lifts a predicate into an array.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const isEven = (n: number) => n % 2 === 0\n   * const to = Array.liftPredicate(isEven)\n   * console.log(to(1)) // []\n   * console.log(to(2)) // [2]\n   * ```\n   *\n   * @category lifting\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate.Predicate<A>): <B extends A>(b: B) => Array<B>\n} = <A>(predicate: Predicate.Predicate<A>) => <B extends A>(b: B): Array<B> => predicate(b) ? [b] : []\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftOption = <A extends Array<unknown>, B>(\n  f: (...a: A) => Option.Option<B>\n) =>\n(...a: A): Array<B> => fromOption(f(...a))\n\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport const fromNullable = <A>(a: A): Array<NonNullable<A>> => a == null ? empty() : [a as NonNullable<A>]\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftNullable = <A extends Array<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n): (...a: A) => Array<NonNullable<B>> =>\n(...a) => fromNullable(f(...a))\n\n/**\n * Maps over an array and flattens the result, removing null and undefined values.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\n * console.log(result) // [1, 3]\n *\n * // Explanation:\n * // The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n * // and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n * // to remove null values, resulting in [1, 3].\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable: {\n  /**\n   * Maps over an array and flattens the result, removing null and undefined values.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\n   * console.log(result) // [1, 3]\n   *\n   * // Explanation:\n   * // The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n   * // and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n   * // to remove null values, resulting in [1, 3].\n   * ```\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>\n  /**\n   * Maps over an array and flattens the result, removing null and undefined values.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\n   * console.log(result) // [1, 3]\n   *\n   * // Explanation:\n   * // The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n   * // and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n   * // to remove null values, resulting in [1, 3].\n   * ```\n   *\n   * @category sequencing\n   * @since 2.0.0\n   */\n  <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>> =>\n    flatMap(self, (a) => fromNullable(f(a)))\n)\n\n/**\n * Lifts a function that returns an `Either` into a function that returns an array.\n * If the `Either` is a left, it returns an empty array.\n * If the `Either` is a right, it returns an array with the right value.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const parseNumber = (s: string): Either.Either<number, Error> =>\n *   isNaN(Number(s)) ? Either.left(new Error(\"Not a number\")) : Either.right(Number(s))\n *\n * const liftedParseNumber = Array.liftEither(parseNumber)\n *\n * const result1 = liftedParseNumber(\"42\")\n * console.log(result1) // [42]\n *\n * const result2 = liftedParseNumber(\"not a number\")\n * console.log(result2) // []\n *\n * // Explanation:\n * // The function parseNumber is lifted to return an array.\n * // When parsing \"42\", it returns an Either.left with the number 42, resulting in [42].\n * // When parsing \"not a number\", it returns an Either.right with an error, resulting in an empty array [].\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */\nexport const liftEither = <A extends Array<unknown>, E, B>(\n  f: (...a: A) => Either.Either<B, E>\n) =>\n(...a: A): Array<B> => {\n  const e = f(...a)\n  return Either.isLeft(e) ? [] : [e.right]\n}\n\n/**\n * Check if a predicate holds true for every `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const every: {\n  /**\n   * Check if a predicate holds true for every `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>\n  /**\n   * Check if a predicate holds true for every `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean\n  /**\n   * Check if a predicate holds true for every `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>\n  /**\n   * Check if a predicate holds true for every `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B> =>\n    self.every(refinement)\n)\n\n/**\n * Check if a predicate holds true for some `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some: {\n  /**\n   * Check if a predicate holds true for some `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>\n  /**\n   * Check if a predicate holds true for some `ReadonlyArray` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>\n} = dual(\n  2,\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A> =>\n    self.some(predicate)\n)\n\n/**\n * Extends an array with a function that maps each subarray to a value.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.extend([1, 2, 3], as => as.length)\n * console.log(result) // [3, 2, 1]\n *\n * // Explanation:\n * // The function maps each subarray starting from each element to its length.\n * // The subarrays are: [1, 2, 3], [2, 3], [3].\n * // The lengths are: 3, 2, 1.\n * // Therefore, the result is [3, 2, 1].\n * ```\n *\n * @since 2.0.0\n */\nexport const extend: {\n  /**\n   * Extends an array with a function that maps each subarray to a value.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.extend([1, 2, 3], as => as.length)\n   * console.log(result) // [3, 2, 1]\n   *\n   * // Explanation:\n   * // The function maps each subarray starting from each element to its length.\n   * // The subarrays are: [1, 2, 3], [2, 3], [3].\n   * // The lengths are: 3, 2, 1.\n   * // Therefore, the result is [3, 2, 1].\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>\n  /**\n   * Extends an array with a function that maps each subarray to a value.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.extend([1, 2, 3], as => as.length)\n   * console.log(result) // [3, 2, 1]\n   *\n   * // Explanation:\n   * // The function maps each subarray starting from each element to its length.\n   * // The subarrays are: [1, 2, 3], [2, 3], [3].\n   * // The lengths are: 3, 2, 1.\n   * // Therefore, the result is [3, 2, 1].\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B> => self.map((_, i, as) => f(as.slice(i)))\n)\n\n/**\n * Finds the minimum element in an array based on a comparator.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.min([3, 1, 2], Order.number)\n * console.log(result) // 1\n * ```\n *\n * @since 2.0.0\n */\nexport const min: {\n  /**\n   * Finds the minimum element in an array based on a comparator.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.min([3, 1, 2], Order.number)\n   * console.log(result) // 1\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A\n  /**\n   * Finds the minimum element in an array based on a comparator.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.min([3, 1, 2], Order.number)\n   * console.log(result) // 1\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A => self.reduce(Order.min(O)))\n\n/**\n * Finds the maximum element in an array based on a comparator.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.max([3, 1, 2], Order.number)\n * console.log(result) // 3\n * ```\n *\n * @since 2.0.0\n */\nexport const max: {\n  /**\n   * Finds the maximum element in an array based on a comparator.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.max([3, 1, 2], Order.number)\n   * console.log(result) // 3\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A\n  /**\n   * Finds the maximum element in an array based on a comparator.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, Order } from \"effect\"\n   *\n   * const result = Array.max([3, 1, 2], Order.number)\n   * console.log(result) // 3\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A => self.reduce(Order.max(O)))\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unfold = <B, A>(b: B, f: (b: B) => Option.Option<readonly [A, B]>): Array<A> => {\n  const out: Array<A> = []\n  let next: B = b\n  let o: Option.Option<readonly [A, B]>\n  while (Option.isSome(o = f(next))) {\n    const [a, b] = o.value\n    out.push(a)\n    next = b\n  }\n  return out\n}\n\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>> = Order.array\n\n/**\n * Creates an equivalence relation for arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const eq = Array.getEquivalence<number>((a, b) => a === b)\n * console.log(eq([1, 2, 3], [1, 2, 3])) // true\n * ```\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getEquivalence: <A>(\n  isEquivalent: Equivalence.Equivalence<A>\n) => Equivalence.Equivalence<ReadonlyArray<A>> = Equivalence.array\n\n/**\n * Performs a side-effect for each element of the `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n * ```\n *\n * @since 2.0.0\n */\nexport const forEach: {\n  /**\n   * Performs a side-effect for each element of the `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void\n  /**\n   * Performs a side-effect for each element of the `Iterable`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, f: (a: A, i: number) => void): void\n} = dual(2, <A>(self: Iterable<A>, f: (a: A, i: number) => void): void => fromIterable(self).forEach((a, i) => f(a, i)))\n\n/**\n * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n * preserving the order of the first occurrence of each element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeWith: {\n  /**\n   * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n   * preserving the order of the first occurrence of each element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <S extends Iterable<any>>(\n    isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean\n  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  /**\n   * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n   * preserving the order of the first occurrence of each element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(\n    self: NonEmptyReadonlyArray<A>,\n    isEquivalent: (self: A, that: A) => boolean\n  ): NonEmptyArray<A>\n  /**\n   * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n   * preserving the order of the first occurrence of each element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      const out: NonEmptyArray<A> = [headNonEmpty(input)]\n      const rest = tailNonEmpty(input)\n      for (const r of rest) {\n        if (out.every((a) => !isEquivalent(r, a))) {\n          out.push(r)\n        }\n      }\n      return out\n    }\n    return []\n  }\n)\n\n/**\n * Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\n * The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.\n *\n * @since 2.0.0\n */\nexport const dedupe = <S extends Iterable<any>>(\n  self: S\n): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never =>\n  dedupeWith(self, Equal.equivalence()) as any\n\n/**\n * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacentWith: {\n  /**\n   * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Array<A>\n  /**\n   * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\n   * console.log(result) // [1, 2, 3]\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>\n} = dual(2, <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n  const out: Array<A> = []\n  let lastA: Option.Option<A> = Option.none()\n  for (const a of self) {\n    if (Option.isNone(lastA) || !isEquivalent(a, lastA.value)) {\n      out.push(a)\n      lastA = Option.some(a)\n    }\n  }\n  return out\n})\n\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A> = dedupeAdjacentWith(Equal.equivalence())\n\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const strings = [\"a\", \"b\", \"c\"]\n * const joined = Array.join(strings, \"-\")\n * console.log(joined) // \"a-b-c\"\n * ```\n *\n * @since 2.0.0\n * @category folding\n */\nexport const join: {\n  /**\n   * Joins the elements together with \"sep\" in the middle.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const strings = [\"a\", \"b\", \"c\"]\n   * const joined = Array.join(strings, \"-\")\n   * console.log(joined) // \"a-b-c\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  (sep: string): (self: Iterable<string>) => string\n  /**\n   * Joins the elements together with \"sep\" in the middle.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const strings = [\"a\", \"b\", \"c\"]\n   * const joined = Array.join(strings, \"-\")\n   * console.log(joined) // \"a-b-c\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  (self: Iterable<string>, sep: string): string\n} = dual(2, (self: Iterable<string>, sep: string): string => fromIterable(self).join(sep))\n\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\n * console.log(result) // [6, [1, 3, 6]]\n * ```\n *\n * @since 2.0.0\n * @category folding\n */\nexport const mapAccum: {\n  /**\n   * Statefully maps over the chunk, producing new elements of type `B`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\n   * console.log(result) // [6, [1, 3, 6]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <S, A, B, I extends Iterable<A> = Iterable<A>>(s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]\n  /**\n   * Statefully maps over the chunk, producing new elements of type `B`.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\n   * console.log(result) // [6, [1, 3, 6]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <S, A, B, I extends Iterable<A> = Iterable<A>>(\n    self: I,\n    s: S,\n    f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]\n  ): [state: S, mappedArray: ReadonlyArray.With<I, B>]\n} = dual(\n  3,\n  <S, A, B>(self: Iterable<A>, s: S, f: (s: S, a: A, i: number) => [S, B]): [state: S, mappedArray: Array<B>] => {\n    let i = 0\n    let s1 = s\n    const out: Array<B> = []\n    for (const a of self) {\n      const r = f(s1, a, i)\n      s1 = r[0]\n      out.push(r[1])\n      i++\n    }\n    return [s1, out]\n  }\n)\n\n/**\n * Zips this chunk crosswise with the specified chunk using the specified combiner.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\n * console.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesianWith: {\n  /**\n   * Zips this chunk crosswise with the specified chunk using the specified combiner.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\n   * console.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>\n  /**\n   * Zips this chunk crosswise with the specified chunk using the specified combiner.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\n   * console.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>\n} = dual(\n  3,\n  <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C> =>\n    flatMap(self, (a) => map(that, (b) => f(a, b)))\n)\n\n/**\n * Zips this chunk crosswise with the specified chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.cartesian([1, 2], [\"a\", \"b\"])\n * console.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesian: {\n  /**\n   * Zips this chunk crosswise with the specified chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.cartesian([1, 2], [\"a\", \"b\"])\n   * console.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>\n  /**\n   * Zips this chunk crosswise with the specified chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array } from \"effect\"\n   *\n   * const result = Array.cartesian([1, 2], [\"a\", \"b\"])\n   * console.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]> => cartesianWith(self, that, (a, b) => [a, b])\n)\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const Do: ReadonlyArray<{}> = of({})\n\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link Do}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const bind: {\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link Do}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  <A extends object, N extends string, B>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): (\n    self: ReadonlyArray<A>\n  ) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link Do}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  <A extends object, N extends string, B>(\n    self: ReadonlyArray<A>,\n    tag: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => ReadonlyArray<B>\n  ): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = internalDoNotation.bind<ReadonlyArrayTypeLambda>(map, flatMap) as any\n\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link Do}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const bindTo: {\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link Do}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  <N extends string>(tag: N): <A>(self: ReadonlyArray<A>) => Array<{ [K in N]: A }>\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link Do}\n   * @see {@link let_ let}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  <A, N extends string>(self: ReadonlyArray<A>, tag: N): Array<{ [K in N]: A }>\n} = internalDoNotation.bindTo<ReadonlyArrayTypeLambda>(map) as any\n\nconst let_: {\n  <N extends string, B, A extends object>(\n    tag: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  <N extends string, A extends object, B>(\n    self: ReadonlyArray<A>,\n    tag: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = internalDoNotation.let_<ReadonlyArrayTypeLambda>(map) as any\n\nexport {\n  /**\n   * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n   *\n   * It can be used to simulate \"array comprehension\".\n   * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   * 5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Array, pipe } from \"effect\"\n   *\n   * const doResult = pipe(\n   *   Array.Do,\n   *   Array.bind(\"x\", () => [1, 3, 5]),\n   *   Array.bind(\"y\", () => [2, 4, 6]),\n   *   Array.filter(({ x, y }) => x < y), // condition\n   *   Array.map(({ x, y }) => [x, y] as const) // transformation\n   * )\n   * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n   *\n   * // equivalent\n   * const x = [1, 3, 5],\n   *       y = [2, 4, 6],\n   *       result = [];\n   * for(let i = 0; i < x.length; i++) {\n   *   for(let j = 0; j < y.length; j++) {\n   *     const _x = x[i], _y = y[j];\n   *     if(_x < _y) result.push([_x, _y] as const)\n   *   }\n   * }\n   *\n   * ```\n   *\n   * @see {@link bindTo}\n   * @see {@link bind}\n   * @see {@link Do}\n   *\n   * @category do notation\n   * @since 3.2.0\n   */\n  let_ as let\n}\n","import * as Either from \"effect/Either\"\nimport { dual } from \"effect/Function\"\nimport type { TypeLambda } from \"effect/HKT\"\nimport * as Option from \"effect/Option\"\n\nexport class NanoTag<R> {\n  declare \"~nano.requirements\": R\n  constructor(\n    readonly key: string\n  ) {}\n}\n\nexport const Tag = <I = never>(identifier: string) => new NanoTag<I>(identifier)\n\nexport class SingleShotGen<T, A> implements IterableIterator<T, A> {\n  private called = false\n  readonly self: T\n\n  constructor(self: T) {\n    this.self = self\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  next(a: A): IteratorResult<T, A> {\n    return this.called ?\n      ({\n        value: a,\n        done: true\n      }) :\n      (this.called = true,\n        ({\n          value: this.self,\n          done: false\n        }))\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator](): IterableIterator<T, A> {\n    return new SingleShotGen<T, A>(this.self)\n  }\n}\n\nexport interface NanoIterator<T extends Nano<any, any, any>> {\n  next(...args: ReadonlyArray<any>): IteratorResult<T, T[\"~nano.success\"]>\n}\n\nexport interface NanoTypeLambda extends TypeLambda {\n  readonly type: Nano<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}\n\nconst evaluate = Symbol.for(\"Nano.evaluate\")\nconst contA = Symbol.for(\"Nano.contA\")\ntype contA = typeof contA\nconst contE = Symbol.for(\"Nano.contE\")\ntype contE = typeof contE\nconst contAll = Symbol.for(\"Nano.contAll\")\ntype contAll = typeof contAll\nconst NanoYield = Symbol.for(\"Nano.yield\")\ntype NanoYield = typeof NanoYield\nconst args = Symbol.for(\"Nano.args\")\ntype args = typeof args\n\nexport class NanoDefectException {\n  readonly _tag = \"@effect/language-service/NanoDefectException\"\n  constructor(\n    readonly message: unknown\n  ) {}\n}\n\ninterface NanoPrimitive {\n  [args]?: any\n  [contA]?: (value: any, fiber: NanoFiber) => NanoPrimitive | NanoYield\n  [contE]?: (value: any, fiber: NanoFiber) => NanoPrimitive | NanoYield\n  [contAll]?: (fiber: NanoFiber) => NanoPrimitive | NanoYield\n  [evaluate]: (fiber: NanoFiber) => NanoPrimitive | NanoYield\n  [Symbol.iterator](): NanoIterator<Nano<any, any, any>>\n}\n\ntype NanoExit =\n  & NanoPrimitive\n  & ({\n    _tag: \"Success\"\n    value: any\n  } | {\n    _tag: \"Failure\"\n    value: any\n  })\n\n/**\n * Nano is a Effect-like interface to run things.\n * It is not intended to be used by users in production.\n * It's only a mere tool to be used in the Effect dev-tools\n * to provide a familiar effect-like experience in envs\n * where using full blown Effect will cause an Effect-in-Effect issue.\n * It is supposed to be sync only and not stack-safe.\n * Thrown exceptions are catched and converted into defects,\n * so worst case scenario, you will get only standard typescript lsp.\n */\nexport interface Nano<out A = never, out E = never, out R = never> extends NanoPrimitive {\n  readonly \"~nano.success\": A\n  readonly \"~nano.error\": E\n  readonly \"~nano.requirements\": R\n  [Symbol.iterator](): NanoIterator<Nano<A, E, R>>\n}\n\nconst PrimitiveProto: Pick<NanoPrimitive, typeof Symbol.iterator> = {\n  [Symbol.iterator]() {\n    return new SingleShotGen(this as any)\n  }\n}\n\nconst SucceedProto: NanoPrimitive & NanoExit = {\n  ...PrimitiveProto,\n  _tag: \"Success\",\n  get value() {\n    return this[args]\n  },\n  [evaluate](fiber: NanoFiber) {\n    const cont = fiber.getCont(contA)\n    return cont ? cont[contA](this[args], fiber) : fiber.yieldWith(this)\n  }\n}\nexport const succeed: <A>(value: A) => Nano<A, never, never> = <A>(value: A) => {\n  const nano = Object.create(SucceedProto)\n  nano[args] = value\n  return nano\n}\n\nconst FailureProto: NanoPrimitive & NanoExit = {\n  ...PrimitiveProto,\n  _tag: \"Failure\",\n  get value() {\n    return this[args]\n  },\n  [evaluate](fiber: NanoFiber) {\n    const cont = fiber.getCont(contE)\n    return cont ? cont[contE](this[args], fiber) : fiber.yieldWith(this)\n  }\n}\nexport const fail: <E>(error: E) => Nano<never, E, never> = <E>(error: E) => {\n  const nano = Object.create(FailureProto)\n  nano[args] = error\n  return nano\n}\n\nconst SuspendProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate]() {\n    return this[args]()\n  }\n}\nexport const suspend: <A, E, R>(fn: () => Nano<A, E, R>) => Nano<A, E, R> = <A, E, R>(fn: () => Nano<A, E, R>) => {\n  const nano = Object.create(SuspendProto)\n  nano[args] = fn\n  return nano\n}\n\nclass NanoFiber {\n  readonly _stack: Array<NanoPrimitive> = []\n  _yielded: NanoExit | undefined = undefined\n  _services: Record<string, any> = {}\n  _cache: Record<string, WeakMap<any, any>> = {}\n  _perf: boolean = false\n\n  runLoop(nano: Nano<any, any, any>) {\n    let current: NanoPrimitive | NanoYield = nano\n    while (true) {\n      current = (current as any)[evaluate](this)\n      if (current === NanoYield) {\n        return this._yielded\n      }\n    }\n  }\n\n  getCont<S extends contA | contE>(this: NanoFiber, symbol: S):\n    | (NanoPrimitive & Record<S, (value: any, fiber: NanoFiber) => NanoPrimitive>)\n    | undefined\n  {\n    while (true) {\n      const op = this._stack.pop()\n      if (!op) return undefined\n      const cont = op[contAll] && op[contAll](this)\n      if (cont) return { [symbol]: cont } as any\n      if (op[symbol]) return op as any\n    }\n  }\n\n  yieldWith(this: NanoFiber, value: NanoExit): NanoYield {\n    this._yielded = value\n    return NanoYield\n  }\n}\n\nconst timings: Record<string, number> = {}\nconst timingsCount: Record<string, number> = {}\nconst WithSpanProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const [fa, name]: [Nano<any, any, any>, string] = this[args]\n    if (!fiber._perf) return fa\n    const start = performance.now()\n    timingsCount[name] = (timingsCount[name] || 0) + 1\n    return match(fa, {\n      onSuccess: (_) => {\n        const end = performance.now()\n        timings[name] = (timings[name] || 0) + (end - start)\n        return succeed(_)\n      },\n      onFailure: (_) => {\n        const end = performance.now()\n        timings[name] = (timings[name] || 0) + (end - start)\n        return fail(_)\n      }\n    })\n  }\n}\n\nexport const withSpan = (\n  name: string\n) =>\n<A, E, R>(fa: Nano<A, E, R>): Nano<A, E, R> => {\n  const nano = Object.create(WithSpanProto)\n  nano[args] = [fa, name]\n  return nano\n}\n\nexport const unsafeRun = <A, E>(nano: Nano<A, E, never>): Either.Either<A, E | NanoDefectException> => {\n  const fiber = new NanoFiber()\n  const result = fiber.runLoop(nano)!\n  if (result._tag === \"Success\") {\n    return Either.right(result.value)\n  }\n  return Either.left(result.value)\n}\n\nexport const run = <A, E>(nano: Nano<A, E, never>): Either.Either<A, E | NanoDefectException> => {\n  try {\n    return unsafeRun(nano)\n  } catch (e) {\n    return Either.left(new NanoDefectException(e))\n  }\n}\n\nconst OnSuccessProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber: NanoFiber) {\n    fiber._stack.push(this)\n    return this[args]\n  }\n}\n\nexport const flatMap: {\n  <A, B, E2, R2>(f: (a: A) => Nano<B, E2, R2>): <E, R>(fa: Nano<A, E, R>) => Nano<B, E | E2, R | R2>\n  <A, E, R, B, E2, R2>(fa: Nano<A, E, R>, f: (a: A) => Nano<B, E2, R2>): Nano<B, E | E2, R | R2>\n} = dual(2, <A, E, R, B, E2, R2>(\n  fa: Nano<A, E, R>,\n  f: (a: A) => Nano<B, E2, R2>\n) => {\n  const nano = Object.create(OnSuccessProto)\n  nano[args] = fa\n  nano[contA] = f\n  return nano\n})\n\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(fa: Nano<A, E, R>) => Nano<B, E, R>\n  <A, E, R, B>(fa: Nano<A, E, R>, f: (a: A) => B): Nano<B, E, R>\n} = dual(2, <A, E, R, B>(\n  fa: Nano<A, E, R>,\n  f: (a: A) => B\n) => flatMap(fa, (_) => succeed(f(_))))\n\nconst SyncProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const value = this[args]()\n    const cont = fiber.getCont(contA)\n    return cont\n      ? cont[contA](value, fiber)\n      : fiber.yieldWith(succeed(value) as any)\n  }\n}\n\nexport const sync = <A>(f: () => A): Nano<A, never, never> => {\n  const nano = Object.create(SyncProto)\n  nano[args] = f\n  return nano\n}\n\nexport const void_ = succeed(undefined)\n\nconst FromIteratorProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [contA](value, fiber) {\n    const state = this[args][0].next(value)\n    if (state.done) return succeed(state.value)\n    fiber._stack.push(this)\n    return state.value\n  },\n  [evaluate](this: any, fiber: NanoFiber) {\n    return this[contA](this[args][1], fiber)\n  }\n}\n\nconst unsafeFromIterator = (\n  iterator: Iterator<Nano<any, any, any>>,\n  initial?: undefined\n) => {\n  const nano = Object.create(FromIteratorProto)\n  nano[args] = [iterator, initial]\n  return nano\n}\n\nexport const gen = <Eff extends Nano<any, any, any>, AEff>(\n  ...args: [body: () => Generator<Eff, AEff, never>]\n): Nano<\n  AEff,\n  [Eff] extends [never] ? never\n    : [Eff] extends [Nano<infer _A, infer E, infer _R>] ? E\n    : never,\n  [Eff] extends [never] ? never\n    : [Eff] extends [Nano<infer _A, infer _E, infer R>] ? R\n    : never\n> => suspend(() => unsafeFromIterator(args[0]()))\n\nexport const fn = (_: string) =>\n<Eff extends Nano<any, any, any>, AEff, Args extends Array<any>>(\n  body: (...args: Args) => Generator<Eff, AEff, never>\n) =>\n(...args: Args): Nano<\n  AEff,\n  [Eff] extends [never] ? never\n    : [Eff] extends [Nano<infer _A, infer E, infer _R>] ? E\n    : never,\n  [Eff] extends [never] ? never\n    : [Eff] extends [Nano<infer _A, infer _E, infer R>] ? R\n    : never\n> => withSpan(_)(suspend(() => unsafeFromIterator(body(...args))))\n\nconst MatchProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    fiber._stack.push(this)\n    return this[args]\n  }\n}\n\nconst match = <A, B, E, R, C, E2, R2, E3, R3>(\n  fa: Nano<A, E, R>,\n  opts: {\n    onSuccess: (a: A) => Nano<B, E2, R2>\n    onFailure: (e: E | NanoDefectException) => Nano<C, E3, R3>\n  }\n): Nano<B, E | E2 | E3, R | R2 | R3> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contA] = opts.onSuccess\n  nano[contE] = opts.onFailure\n  return nano\n}\n\nexport const orElse = <E, B, E2, R2>(\n  f: (e: E) => Nano<B, E2, R2>\n) =>\n<A, R>(fa: Nano<A, E, R>): Nano<A | B, E2, R | R2> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contE] = (_: E | NanoDefectException) => _ instanceof NanoDefectException ? fail(_) : f(_)\n  return nano\n}\n\nexport const firstSuccessOf = <A extends Array<Nano<any, any, any>>>(\n  arr: A\n): Nano<A[number][\"~nano.success\"], A[number][\"~nano.error\"], A[number][\"~nano.requirements\"]> =>\n  arr.slice(1).reduce((arr, fa) => orElse(() => fa)(arr), arr[0])\n\nconst ProvideServiceProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const prevServices = fiber._services\n    const [fa, tag, value]: [Nano<any, any, any>, NanoTag<any>, any] = this[args]\n    fiber._services = {\n      ...fiber._services,\n      [tag.key]: value\n    }\n    return match(fa, {\n      onSuccess: (_) => {\n        fiber._services = prevServices\n        return succeed(_)\n      },\n      onFailure: (_) => {\n        fiber._services = prevServices\n        return fail(_)\n      }\n    })\n  }\n}\n\nexport const provideService = <I extends NanoTag<any>>(\n  tag: I,\n  value: I[\"~nano.requirements\"]\n) =>\n<A, E, R>(fa: Nano<A, E, R>): Nano<A, E, Exclude<R, I[\"~nano.requirements\"]>> => {\n  const nano = Object.create(ProvideServiceProto)\n  nano[args] = [fa, tag, value]\n  return nano\n}\n\nconst ServiceProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const tag: NanoTag<any> = this[args]\n    if (tag.key in fiber._services) {\n      const value = fiber._services[tag.key]\n      const cont = fiber.getCont(contA)\n      return cont ? cont[contA](value, fiber) : fiber.yieldWith(succeed(value) as any)\n    }\n    const cont = fiber.getCont(contE)\n    return cont\n      ? cont[contE](tag, fiber)\n      : fiber.yieldWith(fail(new NanoDefectException(`Service ${tag.key} not found`)) as any)\n  }\n}\n\nexport const service = <I extends NanoTag<any>>(\n  tag: I\n): Nano<I[\"~nano.requirements\"], never, I[\"~nano.requirements\"]> => {\n  const nano = Object.create(ServiceProto)\n  nano[args] = tag\n  return nano\n}\n\nconst CachedProto: NanoPrimitive = {\n  ...PrimitiveProto,\n  [evaluate](fiber) {\n    const [fa, type, key]: [Nano<any, any, any>, string, any] = this[args]\n    const cache = fiber._cache[type] || new WeakMap<any, any>()\n    fiber._cache[type] = cache\n    const cached = cache.get(key)\n    if (cached) return cached\n    return match(fa, {\n      onSuccess: (_) => {\n        cache.set(key, succeed(_))\n        return succeed(_)\n      },\n      onFailure: (_) => {\n        cache.set(key, fail(_))\n        return fail(_)\n      }\n    })\n  }\n}\n\nexport function cachedBy<P extends Array<any>, A, E, R>(\n  fa: (...p: P) => Nano<A, E, R>,\n  type: string,\n  lookupKey: (...p: P) => object\n) {\n  return (...p: P): Nano<A, E, R> => {\n    const nano = Object.create(CachedProto)\n    nano[args] = [fa(...p), type, lookupKey(...p)]\n    return nano\n  }\n}\n\nexport const option = <A, E, R>(fa: Nano<A, E, R>): Nano<Option.Option<A>, never, R> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contA] = (_: A) => succeed(Option.some(_))\n  nano[contE] = (_: E | NanoDefectException) => _ instanceof NanoDefectException ? fail(_) : succeed(Option.none())\n  return nano\n}\n\nexport const ignore = <A, E, R>(fa: Nano<A, E, R>): Nano<void, never, R> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contA] = (_: A) => void_\n  nano[contE] = (_: E | NanoDefectException) => _ instanceof NanoDefectException ? fail(_) : void_\n  return nano\n}\n\nexport const swap = <A, E, R>(fa: Nano<A, E, R>): Nano<E, A, R> => {\n  const nano = Object.create(MatchProto)\n  nano[args] = fa\n  nano[contA] = (_: A) => fail(_)\n  nano[contE] = (_: E | NanoDefectException) => _ instanceof NanoDefectException ? fail(_) : succeed(_)\n  return nano\n}\n\nexport const all: <A extends Array<Nano<any, any, any>>>(\n  ...args: A\n) => Nano<Array<A[number][\"~nano.success\"]>, A[number][\"~nano.error\"], A[number][\"~nano.requirements\"]> = fn(\"all\")(\n  function*<A extends Array<Nano<any, any, any>>>(\n    ...args: A\n  ) {\n    const results = [] as Array<A[number][\"~nano.success\"]>\n    for (const fa of args) {\n      const result = yield* fa\n      results.push(result)\n    }\n    return results\n  }\n)\n\nexport const getTimings = () => {\n  const result: Array<[name: string, avg: number, hits: number, total: number]> = []\n  for (const key in timings) {\n    result.push([key, timings[key] / (timingsCount[key] || 1), timingsCount[key], timings[key]])\n  }\n  result.sort((a, b) => b[3] - a[3])\n  const lines: Array<string> = []\n  for (const [name, avg, hits, total] of result) {\n    lines.push(\n      `${name.padEnd(75)} tot ${total.toFixed(2).padStart(10)}ms avg ${avg.toFixed(2).padStart(10)}ms ${\n        hits.toString().padStart(10)\n      } hits`\n    )\n  }\n  return lines\n}\n","import { isArray } from \"effect/Array\"\nimport * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport { hasProperty, isBoolean, isNumber, isObject, isRecord, isString } from \"effect/Predicate\"\nimport * as Record from \"effect/Record\"\nimport * as Nano from \"./Nano\"\n\nexport type DiagnosticSeverity = \"error\" | \"warning\" | \"message\" | \"suggestion\"\n\nexport type KeyBuilderKind = \"service\" | \"error\" | \"custom\"\n\nexport interface LanguageServicePluginOptionsKeyPattern {\n  target: KeyBuilderKind\n  pattern: \"package-identifier\" | \"default\" | \"default-hashed\"\n  skipLeadingPath: Array<string>\n}\n\nexport interface LanguageServicePluginOptions {\n  refactors: boolean\n  diagnostics: boolean\n  diagnosticSeverity: Record<string, DiagnosticSeverity | \"off\">\n  diagnosticsName: boolean\n  missingDiagnosticNextLine: DiagnosticSeverity | \"off\"\n  quickinfoEffectParameters: \"always\" | \"never\" | \"whentruncated\"\n  quickinfo: boolean\n  quickinfoMaximumLength: number\n  keyPatterns: Array<LanguageServicePluginOptionsKeyPattern>\n  extendedKeyDetection: boolean\n  completions: boolean\n  goto: boolean\n  inlays: boolean\n  allowedDuplicatedPackages: Array<string>\n  namespaceImportPackages: Array<string>\n  topLevelNamedReexports: \"ignore\" | \"follow\"\n  barrelImportPackages: Array<string>\n  importAliases: Record<string, string>\n  renames: boolean\n  noExternal: boolean\n  pipeableMinArgCount: number\n}\n\nexport const LanguageServicePluginOptions = Nano.Tag<LanguageServicePluginOptions>(\"PluginOptions\")\n\nfunction isValidSeverityLevel(value: string): value is DiagnosticSeverity | \"off\" {\n  return value === \"off\" || value === \"error\" || value === \"warning\" || value === \"message\" || value === \"suggestion\"\n}\n\nfunction parseDiagnosticSeverity(config: Record<PropertyKey, unknown>): Record<string, DiagnosticSeverity | \"off\"> {\n  if (!isRecord(config)) return {}\n  return Object.fromEntries(\n    pipe(\n      Object.entries(config),\n      Array.filter(([key, value]) => isString(key) && isString(value)),\n      Array.map(([key, value]) => [String(key).toLowerCase(), String(value).toLowerCase()]),\n      Array.filter(([_, value]) => isValidSeverityLevel(value))\n    )\n  )\n}\n\nexport const defaults: LanguageServicePluginOptions = {\n  refactors: true,\n  diagnostics: true,\n  diagnosticSeverity: {},\n  diagnosticsName: true,\n  missingDiagnosticNextLine: \"warning\",\n  quickinfo: true,\n  quickinfoEffectParameters: \"whentruncated\",\n  quickinfoMaximumLength: -1,\n  completions: true,\n  goto: true,\n  inlays: true,\n  allowedDuplicatedPackages: [],\n  namespaceImportPackages: [],\n  topLevelNamedReexports: \"ignore\",\n  barrelImportPackages: [],\n  importAliases: {},\n  renames: true,\n  noExternal: false,\n  keyPatterns: [{\n    target: \"service\",\n    pattern: \"default\",\n    skipLeadingPath: [\"src/\"]\n  }, {\n    target: \"custom\",\n    pattern: \"default\",\n    skipLeadingPath: [\"src/\"]\n  }],\n  extendedKeyDetection: false,\n  pipeableMinArgCount: 1\n}\n\nfunction parseKeyPatterns(patterns: Array<unknown>): Array<LanguageServicePluginOptionsKeyPattern> {\n  const result: Array<LanguageServicePluginOptionsKeyPattern> = []\n  for (const entry of patterns) {\n    if (!isObject(entry)) continue\n    result.push({\n      target: hasProperty(entry, \"target\") && isString(entry.target) &&\n          [\"service\", \"error\", \"custom\"].includes(entry.target.toLowerCase())\n        ? entry.target.toLowerCase() as LanguageServicePluginOptionsKeyPattern[\"target\"]\n        : \"service\",\n      pattern: hasProperty(entry, \"pattern\") && isString(entry.pattern) &&\n          [\"package-identifier\", \"default\", \"default-hashed\"].includes(entry.pattern.toLowerCase())\n        ? entry.pattern.toLowerCase() as LanguageServicePluginOptionsKeyPattern[\"pattern\"]\n        : \"default\",\n      skipLeadingPath:\n        hasProperty(entry, \"skipLeadingPath\") && isArray(entry.skipLeadingPath) && entry.skipLeadingPath.every(isString)\n          ? entry.skipLeadingPath\n          : [\"src/\"]\n    })\n  }\n  return result\n}\n\nexport function parse(config: any): LanguageServicePluginOptions {\n  return {\n    refactors: isObject(config) && hasProperty(config, \"refactors\") && isBoolean(config.refactors)\n      ? config.refactors\n      : defaults.refactors,\n    diagnostics: isObject(config) && hasProperty(config, \"diagnostics\") && isBoolean(config.diagnostics)\n      ? config.diagnostics\n      : defaults.diagnostics,\n    diagnosticSeverity:\n      isObject(config) && hasProperty(config, \"diagnosticSeverity\") && isRecord(config.diagnosticSeverity)\n        ? parseDiagnosticSeverity(config.diagnosticSeverity)\n        : defaults.diagnosticSeverity,\n    diagnosticsName: isObject(config) && hasProperty(config, \"diagnosticsName\") && isBoolean(config.diagnosticsName)\n      ? config.diagnosticsName\n      : defaults.diagnosticsName,\n    missingDiagnosticNextLine: isObject(config) && hasProperty(config, \"missingDiagnosticNextLine\") &&\n        isString(config.missingDiagnosticNextLine) && isValidSeverityLevel(config.missingDiagnosticNextLine)\n      ? config.missingDiagnosticNextLine as DiagnosticSeverity | \"off\"\n      : defaults.missingDiagnosticNextLine,\n    quickinfo: isObject(config) && hasProperty(config, \"quickinfo\") && isBoolean(config.quickinfo)\n      ? config.quickinfo\n      : defaults.quickinfo,\n    quickinfoEffectParameters: isObject(config) && hasProperty(config, \"quickinfoEffectParameters\") &&\n        isString(config.quickinfoEffectParameters) &&\n        [\"always\", \"never\", \"whentruncated\"].includes(config.quickinfoEffectParameters.toLowerCase())\n      ? config.quickinfoEffectParameters.toLowerCase() as \"always\" | \"never\" | \"whentruncated\"\n      : defaults.quickinfoEffectParameters,\n    quickinfoMaximumLength:\n      isObject(config) && hasProperty(config, \"quickinfoMaximumLength\") && isNumber(config.quickinfoMaximumLength)\n        ? config.quickinfoMaximumLength\n        : defaults.quickinfoMaximumLength,\n    completions: isObject(config) && hasProperty(config, \"completions\") && isBoolean(config.completions)\n      ? config.completions\n      : defaults.completions,\n    goto: isObject(config) && hasProperty(config, \"goto\") && isBoolean(config.goto)\n      ? config.goto\n      : defaults.goto,\n    inlays: isObject(config) && hasProperty(config, \"inlays\") && isBoolean(config.inlays)\n      ? config.inlays\n      : defaults.inlays,\n    allowedDuplicatedPackages: isObject(config) && hasProperty(config, \"allowedDuplicatedPackages\") &&\n        isArray(config.allowedDuplicatedPackages) && config.allowedDuplicatedPackages.every(isString)\n      ? config.allowedDuplicatedPackages.map((_) => _.toLowerCase())\n      : defaults.allowedDuplicatedPackages,\n    namespaceImportPackages: isObject(config) && hasProperty(config, \"namespaceImportPackages\") &&\n        isArray(config.namespaceImportPackages) && config.namespaceImportPackages.every(isString)\n      ? config.namespaceImportPackages.map((_) => _.toLowerCase())\n      : defaults.namespaceImportPackages,\n    barrelImportPackages: isObject(config) && hasProperty(config, \"barrelImportPackages\") &&\n        isArray(config.barrelImportPackages) && config.barrelImportPackages.every(isString)\n      ? config.barrelImportPackages.map((_) => _.toLowerCase())\n      : defaults.barrelImportPackages,\n    importAliases: isObject(config) && hasProperty(config, \"importAliases\") && isRecord(config.importAliases)\n      ? Record.map(config.importAliases, (value) => String(value))\n      : defaults.importAliases,\n    topLevelNamedReexports: isObject(config) && hasProperty(config, \"topLevelNamedReexports\") &&\n        isString(config.topLevelNamedReexports) &&\n        [\"ignore\", \"follow\"].includes(config.topLevelNamedReexports.toLowerCase())\n      ? config.topLevelNamedReexports.toLowerCase() as \"ignore\" | \"follow\"\n      : defaults.topLevelNamedReexports,\n    renames: isObject(config) && hasProperty(config, \"renames\") && isBoolean(config.renames)\n      ? config.renames\n      : defaults.renames,\n    noExternal: isObject(config) && hasProperty(config, \"noExternal\") && isBoolean(config.noExternal)\n      ? config.noExternal\n      : defaults.noExternal,\n    keyPatterns: isObject(config) && hasProperty(config, \"keyPatterns\") && isArray(config.keyPatterns)\n      ? parseKeyPatterns(config.keyPatterns)\n      : defaults.keyPatterns,\n    extendedKeyDetection:\n      isObject(config) && hasProperty(config, \"extendedKeyDetection\") && isBoolean(config.extendedKeyDetection)\n        ? config.extendedKeyDetection\n        : defaults.extendedKeyDetection,\n    pipeableMinArgCount:\n      isObject(config) && hasProperty(config, \"pipeableMinArgCount\") && isNumber(config.pipeableMinArgCount)\n        ? config.pipeableMinArgCount\n        : defaults.pipeableMinArgCount\n  }\n}\n","import { hasProperty, isFunction } from \"effect/Predicate\"\nimport type ts from \"typescript\"\nimport * as Nano from \"../core/Nano.js\"\n\ndeclare module \"typescript\" {\n  export function getTokenPosOfNode(node: ts.Node, sourceFile: ts.SourceFileLike, includeJsDoc?: boolean): number\n\n  export function insertImports(\n    changes: textChanges.ChangeTracker,\n    sourceFile: ts.SourceFile,\n    imports: ts.ImportDeclaration,\n    blankLineBetween: boolean,\n    preferences: ts.UserPreferences\n  ): void\n\n  const nullTransformationContext: ts.TransformationContext\n\n  export namespace formatting {\n    interface FormattingHost {\n      getNewLine?(): string\n    }\n\n    export interface FormatContext {\n      readonly options: ts.FormatCodeSettings\n      readonly getRules: unknown\n    }\n\n    function getFormatContext(options: ts.FormatCodeSettings, host: FormattingHost): FormatContext\n  }\n\n  export type TextChangesContext = any\n\n  export namespace textChanges {\n    export interface ChangeNodeOptions extends ConfigurableStartEnd, InsertNodeOptions {}\n    export enum LeadingTriviaOption {\n      /** Exclude all leading trivia (use getStart()) */\n      Exclude = 0,\n      /** Include leading trivia and,\n       * if there are no line breaks between the node and the previous token,\n       * include all trivia between the node and the previous token\n       */\n      IncludeAll = 1,\n      /**\n       * Include attached JSDoc comments\n       */\n      JSDoc = 2,\n      /**\n       * Only delete trivia on the same line as getStart().\n       * Used to avoid deleting leading comments\n       */\n      StartLine = 3\n    }\n    export enum TrailingTriviaOption {\n      /** Exclude all trailing trivia (use getEnd()) */\n      Exclude = 0,\n      /** Doesn't include whitespace, but does strip comments */\n      ExcludeWhitespace = 1,\n      /** Include trailing trivia */\n      Include = 2\n    }\n    export interface ConfigurableStart {\n      leadingTriviaOption?: LeadingTriviaOption\n    }\n    export interface ConfigurableEnd {\n      trailingTriviaOption?: TrailingTriviaOption\n    }\n    export interface InsertNodeOptions {\n      /**\n       * Text to be inserted before the new node\n       */\n      prefix?: string\n      /**\n       * Text to be inserted after the new node\n       */\n      suffix?: string\n      /**\n       * Text of inserted node will be formatted with this indentation, otherwise indentation will be inferred from the old node\n       */\n      indentation?: number\n      /**\n       * Text of inserted node will be formatted with this delta, otherwise delta will be inferred from the new node kind\n       */\n      delta?: number\n    }\n    export interface ConfigurableStartEnd extends ConfigurableStart, ConfigurableEnd {\n    }\n    export class ChangeTracker {\n      static with(\n        context: ts.TextChangesContext,\n        cb: (tracker: ChangeTracker) => void\n      ): Array<ts.FileTextChanges>\n      delete(\n        sourceFile: ts.SourceFile,\n        node: ts.Node | ts.NodeArray<ts.TypeParameterDeclaration>\n      ): void\n      deleteRange(sourceFile: ts.SourceFile, range: ts.TextRange): void\n      replaceNode(\n        sourceFile: ts.SourceFile,\n        oldNode: ts.Node,\n        newNode: ts.Node,\n        options?: ts.textChanges.ChangeNodeOptions\n      ): void\n      insertNodeAt(\n        sourceFile: ts.SourceFile,\n        pos: number,\n        newNode: ts.Node,\n        options?: ts.textChanges.InsertNodeOptions\n      ): void\n      insertNodeBefore(\n        sourceFile: ts.SourceFile,\n        before: ts.Node,\n        newNode: ts.Node,\n        blankLineBetween?: boolean,\n        options?: ConfigurableStartEnd\n      ): void\n      insertNodeAfter(sourceFile: ts.SourceFile, after: ts.Node, newNode: ts.Node): void\n      insertText(sourceFile: ts.SourceFile, pos: number, text: string): void\n      insertCommentBeforeLine(\n        sourceFile: ts.SourceFile,\n        lineNumber: number,\n        position: number,\n        commentText: string\n      ): void\n    }\n    export function applyChanges(text: string, changes: ReadonlyArray<ts.TextChange>): string\n  }\n\n  export function findPrecedingToken(\n    position: number,\n    sourceFile: ts.SourceFileLike,\n    startNode: ts.Node,\n    excludeJsdoc?: boolean\n  ): ts.Node | undefined\n  export function findPrecedingToken(\n    position: number,\n    sourceFile: ts.SourceFile,\n    startNode?: ts.Node,\n    excludeJsdoc?: boolean\n  ): ts.Node | undefined\n  function findChildOfKind<T extends ts.Node>(\n    n: ts.Node,\n    kind: T[\"kind\"],\n    sourceFile: ts.SourceFileLike\n  ): T | undefined\n\n  export interface TypeChecker {\n    getUnionType(types: ReadonlyArray<ts.Type>): ts.Type\n  }\n\n  interface Identifier {\n    /** @deprecated Use the `ts.idText(node)` method instead */\n    readonly text: string\n  }\n}\n\ntype _TypeScriptApi = typeof ts\nexport interface TypeScriptApi extends _TypeScriptApi {}\nexport const TypeScriptApi = Nano.Tag<TypeScriptApi>(\"TypeScriptApi\")\n\ntype _TypeScriptProgram = ts.Program\nexport interface TypeScriptProgram extends _TypeScriptProgram {}\nexport const TypeScriptProgram = Nano.Tag<TypeScriptProgram>(\"TypeScriptProgram\")\n\nexport const ChangeTracker = Nano.Tag<ts.textChanges.ChangeTracker>(\"ChangeTracker\")\n\n// the followin APIs are not part of the public API of TypeScript, we keep them here for internal use and tracking which ones we use\nexport interface PackageJsonInfoCache {\n  __internal: any\n}\nexport function getPackageJsonInfoCache(program: ts.Program): PackageJsonInfoCache | undefined {\n  try {\n    if (hasProperty(program, \"getModuleResolutionCache\") && isFunction(program.getModuleResolutionCache)) {\n      const moduleResolutionCache = program.getModuleResolutionCache()\n      if (\n        hasProperty(moduleResolutionCache, \"getPackageJsonInfoCache\") &&\n        isFunction(moduleResolutionCache.getPackageJsonInfoCache)\n      ) {\n        return moduleResolutionCache.getPackageJsonInfoCache()\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_) {\n    return undefined\n  }\n  return undefined\n}\n\nexport function getDirectoryPath(ts: TypeScriptApi, path: string): string {\n  try {\n    if (hasProperty(ts, \"getDirectoryPath\") && isFunction(ts.getDirectoryPath)) {\n      return ts.getDirectoryPath(path)\n    }\n    return path\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_) {\n    return path\n  }\n}\n\nexport function makeGetModuleSpecifier(ts: TypeScriptApi) {\n  if (\n    !(hasProperty(ts, \"moduleSpecifiers\") && hasProperty(ts.moduleSpecifiers, \"getModuleSpecifier\") &&\n      isFunction(ts.moduleSpecifiers.getModuleSpecifier))\n  ) return\n  const _internal = ts.moduleSpecifiers.getModuleSpecifier\n  return (\n    compilerOptions: ts.CompilerOptions,\n    importingSourceFile: ts.SourceFile,\n    importingSourceFileName: string,\n    toFileName: string,\n    host: any,\n    options?: any\n  ): string => {\n    return _internal(\n      compilerOptions,\n      importingSourceFile,\n      importingSourceFileName,\n      toFileName,\n      host,\n      options\n    )\n  }\n}\n\nexport interface ModuleResolutionState {\n  __internal: any\n}\n\nexport function makeGetTemporaryModuleResolutionState(\n  ts: TypeScriptApi\n) {\n  if (hasProperty(ts, \"getTemporaryModuleResolutionState\") && isFunction(ts.getTemporaryModuleResolutionState)) {\n    const _internal = ts.getTemporaryModuleResolutionState\n    return (\n      cache: PackageJsonInfoCache | undefined,\n      program: ts.Program,\n      compilerOptions: ts.CompilerOptions\n    ): ModuleResolutionState => _internal(cache, program, compilerOptions) as any\n  }\n  return undefined\n}\n\nexport function makeGetPackageScopeForPath(\n  ts: TypeScriptApi\n) {\n  if (hasProperty(ts, \"getPackageScopeForPath\") && isFunction(ts.getPackageScopeForPath)) {\n    const _internal = ts.getPackageScopeForPath\n    return (path: string, state: ModuleResolutionState) => _internal(path, state) as any\n  }\n}\n\nexport function makeResolvePackageNameToPackageJson(\n  ts: TypeScriptApi\n) {\n  if (hasProperty(ts, \"resolvePackageNameToPackageJson\") && isFunction(ts.resolvePackageNameToPackageJson)) {\n    const _internal = ts.resolvePackageNameToPackageJson\n    return (packageName: string, fromFileName: string, compilerOptions: ts.CompilerOptions, host: any) =>\n      _internal(packageName, fromFileName, compilerOptions, host) as any\n  }\n}\n\nexport function makeGetEntrypointsFromPackageJsonInfo(\n  ts: TypeScriptApi\n) {\n  if (hasProperty(ts, \"getEntrypointsFromPackageJsonInfo\") && isFunction(ts.getEntrypointsFromPackageJsonInfo)) {\n    const _internal = ts.getEntrypointsFromPackageJsonInfo\n    return (packageJsonInfo: any, compilerOptions: ts.CompilerOptions, host: any) =>\n      _internal(packageJsonInfo, compilerOptions, host) as any\n  }\n}\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport { hasProperty, isObject, isString } from \"effect/Predicate\"\nimport type ts from \"typescript\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport interface ModuleWithPackageInfo {\n  name: string\n  version: string\n  hasEffectInPeerDependencies: boolean\n  contents: any\n  packageDirectory: string\n  referencedPackages: Array<string>\n  exportsKeys: Array<string>\n}\n\nexport interface TypeScriptUtils {\n  parsePackageContentNameAndVersionFromScope: (v: unknown) => ModuleWithPackageInfo | undefined\n  findNodeWithLeadingCommentAtPosition: (\n    sourceFile: ts.SourceFile,\n    position: number\n  ) => { node: ts.Node; commentRange: ts.CommentRange } | undefined\n  getCommentAtPosition: (sourceFile: ts.SourceFile, pos: number) => ts.CommentRange | undefined\n  resolveModulePattern: (program: ts.Program, sourceFile: ts.SourceFile, pattern: string) => Array<string>\n  getAncestorNodesInRange: (sourceFile: ts.SourceFile, textRange: ts.TextRange) => Array<ts.Node>\n  findImportedModuleIdentifierByPackageAndNameOrBarrel: (\n    sourceFile: ts.SourceFile,\n    packageName: string,\n    moduleName: string\n  ) => string | undefined\n  simplifyTypeNode: (typeNode: ts.TypeNode) => ts.TypeNode\n  createEffectGenCallExpressionWithBlock: (\n    effectModuleIdentifierName: string,\n    statement: ts.Statement | Array<ts.Statement>\n  ) => ts.CallExpression\n  createReturnYieldStarStatement: (\n    expr: ts.Expression\n  ) => ts.ReturnStatement\n  transformAsyncAwaitToEffectFn: (\n    node: ts.FunctionDeclaration | ts.ArrowFunction | ts.FunctionExpression,\n    effectModuleName: string,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ) => ts.Node\n  createDataTaggedErrorDeclaration: (\n    dataModuleIdentifier: string,\n    name: string,\n    fields: Array<ts.TypeElement>\n  ) => ts.ClassDeclaration\n  transformAsyncAwaitToEffectGen: (\n    node: ts.FunctionDeclaration | ts.ArrowFunction | ts.FunctionExpression,\n    effectModuleName: string,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ) => ts.Node\n  tryPreserveDeclarationSemantics: (\n    nodeToReplace: ts.Node,\n    node: ts.Node,\n    dropAsync: boolean\n  ) => ts.Node\n  isNodeInRange: (textRange: ts.TextRange) => (node: ts.Node) => boolean\n  toTextRange: (position: number) => ts.TextRange\n  parseDataForExtendsClassCompletion: (sourceFile: ts.SourceFile, position: number) => {\n    accessedObject: ts.Identifier\n    classDeclaration: ts.ClassDeclaration\n    className: ts.Identifier\n    replacementSpan: ts.TextSpan\n  } | undefined\n  parseAccessedExpressionForCompletion: (sourceFile: ts.SourceFile, position: number) => {\n    accessedObject: ts.Node\n    outerNode: ts.Node\n    replacementSpan: ts.TextSpan\n  } | undefined\n  findNodeAtPositionIncludingTrivia: (\n    sourceFile: ts.SourceFile,\n    position: number\n  ) => ts.Node | undefined\n  getSourceFileOfNode: (current: ts.Node | undefined) => ts.SourceFile | undefined\n  resolveModuleWithPackageInfoFromSourceFile: (\n    program: ts.Program,\n    sourceFile: ts.SourceFile\n  ) => ModuleWithPackageInfo | undefined\n}\nexport const TypeScriptUtils = Nano.Tag<TypeScriptUtils>(\"TypeScriptUtils\")\n\nexport const nanoLayer = <A, E, R>(\n  fa: Nano.Nano<A, E, R>\n) =>\n  pipe(\n    Nano.service(TypeScriptApi.TypeScriptApi),\n    Nano.flatMap((ts) => pipe(fa, Nano.provideService(TypeScriptUtils, makeTypeScriptUtils(ts))))\n  )\n\nexport function makeTypeScriptUtils(ts: TypeScriptApi.TypeScriptApi): TypeScriptUtils {\n  const getTemporaryModuleResolutionState = TypeScriptApi.makeGetTemporaryModuleResolutionState(ts)\n  const getPackageScopeForPath = TypeScriptApi.makeGetPackageScopeForPath(ts)\n\n  /**\n   * Parse internal package info from a scope\n   */\n  function parsePackageContentNameAndVersionFromScope(v: unknown): ModuleWithPackageInfo | undefined {\n    if (!isObject(v)) return\n    if (!hasProperty(v, \"packageJsonScope\")) return\n    if (!v.packageJsonScope) return\n    const packageJsonScope = v.packageJsonScope\n    if (!hasProperty(packageJsonScope, \"contents\")) return\n    if (!hasProperty(packageJsonScope.contents, \"packageJsonContent\")) return\n    const packageJsonContent = packageJsonScope.contents.packageJsonContent\n    if (!hasProperty(packageJsonContent, \"name\")) return\n    if (!hasProperty(packageJsonScope, \"packageDirectory\")) return\n    if (!isString(packageJsonScope.packageDirectory)) return\n    const { name } = packageJsonContent\n    const version = hasProperty(packageJsonScope, \"version\") ? packageJsonScope.version : \"\"\n    if (!isString(name)) return\n    if (!isString(version)) return\n    const hasEffectInPeerDependencies = hasProperty(packageJsonContent, \"peerDependencies\") &&\n      isObject(packageJsonContent.peerDependencies) &&\n      hasProperty(packageJsonContent.peerDependencies, \"effect\")\n\n    const referencedPackages = Object.keys({\n      ...(hasProperty(packageJsonContent, \"dependencies\") && isObject(packageJsonContent.dependencies)\n        ? packageJsonContent.dependencies\n        : {}),\n      ...(hasProperty(packageJsonContent, \"peerDependencies\") && isObject(packageJsonContent.peerDependencies)\n        ? packageJsonContent.peerDependencies\n        : {}),\n      ...(hasProperty(packageJsonContent, \"devDependencies\") && isObject(packageJsonContent.devDependencies)\n        ? packageJsonContent.devDependencies\n        : {})\n    })\n\n    const exportsKeys = Object.keys(\n      hasProperty(packageJsonContent, \"exports\") && isObject(packageJsonContent.exports)\n        ? packageJsonContent.exports\n        : {}\n    )\n\n    return {\n      name: name.toLowerCase(),\n      version: version.toLowerCase(),\n      hasEffectInPeerDependencies,\n      contents: packageJsonContent,\n      packageDirectory: packageJsonScope.packageDirectory,\n      referencedPackages,\n      exportsKeys\n    }\n  }\n\n  function resolveModuleWithPackageInfoFromSourceFile(\n    program: ts.Program,\n    sourceFile: ts.SourceFile\n  ): ModuleWithPackageInfo | undefined {\n    let packageJsonScope = parsePackageContentNameAndVersionFromScope(sourceFile)\n    if (\n      !packageJsonScope && getPackageScopeForPath && getTemporaryModuleResolutionState\n    ) {\n      const packageJsonInfoCache = TypeScriptApi.getPackageJsonInfoCache(program)\n      const temporaryModuleResolutionState = getTemporaryModuleResolutionState(\n        packageJsonInfoCache,\n        program,\n        program.getCompilerOptions()\n      )\n      const directoryPath = TypeScriptApi.getDirectoryPath(ts, sourceFile.fileName)\n      packageJsonScope = parsePackageContentNameAndVersionFromScope({\n        ...sourceFile,\n        packageJsonScope: getPackageScopeForPath(directoryPath, temporaryModuleResolutionState)\n      })\n    }\n    return packageJsonScope\n  }\n\n  function resolveModulePattern(program: ts.Program, sourceFile: ts.SourceFile, pattern: string) {\n    if (pattern.indexOf(\"*\") === -1) return [pattern.toLowerCase()]\n    const packageJsonScope = resolveModuleWithPackageInfoFromSourceFile(program, sourceFile)\n    const referencedPackages: Array<string> = []\n    for (const statement of sourceFile.statements) {\n      if (ts.isImportDeclaration(statement) && ts.isStringLiteral(statement.moduleSpecifier)) {\n        const moduleSpecifier = statement.moduleSpecifier.text.toLowerCase()\n        const packageName = moduleSpecifier.startsWith(\"@\")\n          ? moduleSpecifier.split(\"/\", 2).join(\"/\")\n          : moduleSpecifier.split(\"/\", 1).join(\"/\")\n        referencedPackages.push(packageName)\n      }\n    }\n    return pipe(\n      referencedPackages.concat(packageJsonScope?.referencedPackages || []),\n      Array.dedupe,\n      Array.map((packageName) => packageName.toLowerCase()),\n      Array.filter((packageName) =>\n        pattern.endsWith(\"*\") &&\n        packageName.startsWith(pattern.toLowerCase().substring(0, pattern.length - 1))\n      )\n    )\n  }\n\n  function findNodeWithLeadingCommentAtPosition(sourceFile: ts.SourceFile, position: number) {\n    const sourceText = sourceFile.text\n    let result: { node: ts.Node; commentRange: ts.CommentRange } | undefined\n\n    function find(node: ts.Node) {\n      // Check leading comments\n      const leading = ts.getLeadingCommentRanges(sourceText, node.pos)\n      if (leading) {\n        for (const commentRange of leading) {\n          if (commentRange.pos <= position && position < commentRange.end) {\n            // we found the comment\n            result = { node, commentRange }\n            return\n          }\n        }\n      }\n      // Continue traversing only if the position is within this node\n      if (node.pos <= position && position < node.end) {\n        ts.forEachChild(node, find)\n      }\n    }\n    find(sourceFile)\n    return result\n  }\n\n  /**\n   * Collects the given node and all its ancestor nodes that fully contain the specified TextRange.\n   *\n   * This function starts from the provided node and traverses up the AST, collecting\n   * the node itself and its ancestors that encompass the given range.\n   */\n  function collectSelfAndAncestorNodesInRange(\n    node: ts.Node,\n    textRange: ts.TextRange\n  ): Array<ts.Node> {\n    let result = Array.empty<ts.Node>()\n    let parent = node\n    while (parent) {\n      if (parent.end >= textRange.end) {\n        result = pipe(result, Array.append(parent))\n      }\n      parent = parent.parent\n    }\n    return result\n  }\n\n  /**\n   * Finds the deepest AST node at the specified position within the given SourceFile.\n   *\n   * This function traverses the AST to locate the node that contains the given position.\n   * If multiple nodes overlap the position, it returns the most specific (deepest) node.\n   */\n  function findNodeAtPosition(\n    sourceFile: ts.SourceFile,\n    position: number\n  ) {\n    function find(node: ts.Node): ts.Node | undefined {\n      if (position >= ts.getTokenPosOfNode(node, sourceFile) && position < node.end) {\n        // If the position is within this node, keep traversing its children\n        return ts.forEachChild(node, find) || node\n      }\n      return undefined\n    }\n\n    return find(sourceFile)\n  }\n\n  function findNodeAtPositionIncludingTrivia(\n    sourceFile: ts.SourceFile,\n    position: number\n  ) {\n    function find(node: ts.Node): ts.Node | undefined {\n      if (position >= node.pos && position < node.end) {\n        // If the position is within this node, keep traversing its children\n        return ts.forEachChild(node, find) || node\n      }\n      return undefined\n    }\n\n    return find(sourceFile)\n  }\n\n  /**\n   * Collects the node at the given position and all its ancestor nodes\n   * that fully contain the specified TextRange.\n   *\n   * This function starts from the closest token at the given position\n   * and traverses up the AST, collecting nodes that encompass the range.\n   *\n   * @param sourceFile - The TypeScript SourceFile to search within.\n   * @param textRange - The range of text to use for filtering nodes.\n   * @returns An array of `ts.Node` containing the range.\n   */\n  function getAncestorNodesInRange(\n    sourceFile: ts.SourceFile,\n    textRange: ts.TextRange\n  ) {\n    const nodeAtPosition = findNodeAtPosition(sourceFile, textRange.pos)\n    if (!nodeAtPosition) return Array.empty<ts.Node>()\n    return collectSelfAndAncestorNodesInRange(nodeAtPosition, textRange)\n  }\n\n  function getCommentAtPosition(\n    sourceFile: ts.SourceFile,\n    pos: number\n  ) {\n    const token = findNodeAtPositionIncludingTrivia(sourceFile, pos)\n\n    if (\n      token === undefined || token.kind === ts.SyntaxKind.JsxText ||\n      pos >= token.end - (ts.tokenToString(token.kind) || \"\").length\n    ) {\n      return\n    }\n    const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || \"\").length : token.pos\n\n    const result = ts.forEachTrailingCommentRange(sourceFile.text, startPos, isCommentInRange, pos) ||\n      ts.forEachLeadingCommentRange(sourceFile.text, startPos, isCommentInRange, pos)\n\n    return result\n  }\n\n  function isCommentInRange(\n    pos: number,\n    end: number,\n    kind: ts.CommentKind,\n    _nl: boolean,\n    at: number\n  ): ts.CommentRange | undefined {\n    return at >= pos && at < end ? { pos, end, kind } : undefined\n  }\n\n  /**\n   * Ensures value is a text range\n   */\n  function toTextRange(positionOrRange: number | ts.TextRange): ts.TextRange {\n    return typeof positionOrRange === \"number\"\n      ? { end: positionOrRange, pos: positionOrRange }\n      : positionOrRange\n  }\n\n  function isNodeInRange(textRange: ts.TextRange) {\n    return (node: ts.Node) => node.pos <= textRange.pos && node.end >= textRange.end\n  }\n\n  function transformAsyncAwaitToEffectGeneratorBody(\n    body: ts.ConciseBody,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ): ts.ConciseBody {\n    function visitor(_: ts.Node): ts.Node {\n      if (ts.isAwaitExpression(_)) {\n        const expression = ts.visitEachChild(_.expression, visitor, ts.nullTransformationContext)\n\n        return ts.factory.createYieldExpression(\n          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n          onAwait(expression)\n        )\n      }\n      return ts.visitEachChild(_, visitor, ts.nullTransformationContext)\n    }\n    return visitor(body) as any\n  }\n\n  function transformAsyncAwaitToEffectFn(\n    node: ts.FunctionDeclaration | ts.ArrowFunction | ts.FunctionExpression,\n    effectModuleName: string,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ) {\n    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body!, onAwait)\n    const fnName = node.name && ts.isIdentifier(node.name)\n      ? node.name\n      : ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name) && node.parent.initializer === node\n      ? node.parent.name\n      : undefined\n\n    let fnCall: ts.Expression = ts.factory.createPropertyAccessExpression(\n      ts.factory.createIdentifier(effectModuleName),\n      \"fn\"\n    )\n    if (fnName) {\n      fnCall = ts.factory.createCallExpression(\n        fnCall,\n        undefined,\n        [ts.factory.createStringLiteral(ts.idText(fnName))]\n      )\n    }\n    return tryPreserveDeclarationSemantics(\n      node,\n      ts.factory.createCallExpression(\n        fnCall,\n        undefined,\n        [\n          ts.factory.createFunctionExpression(\n            undefined,\n            ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n            undefined,\n            node.typeParameters,\n            node.parameters,\n            undefined,\n            ts.isBlock(generatorBody)\n              ? generatorBody\n              : ts.factory.createBlock([ts.factory.createReturnStatement(generatorBody)])\n          )\n        ]\n      ),\n      true\n    )\n  }\n\n  function transformAsyncAwaitToEffectGen(\n    node: ts.FunctionDeclaration | ts.ArrowFunction | ts.FunctionExpression,\n    effectModuleName: string,\n    onAwait: (expression: ts.Expression) => ts.Expression\n  ) {\n    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body!, onAwait)\n\n    const effectGenCallExp = createEffectGenCallExpression(effectModuleName, generatorBody)\n\n    let currentFlags = ts.getCombinedModifierFlags(node)\n    currentFlags &= ~ts.ModifierFlags.Async\n    const newModifiers = ts.factory.createModifiersFromModifierFlags(currentFlags)\n\n    if (ts.isArrowFunction(node)) {\n      return ts.factory.createArrowFunction(\n        newModifiers,\n        node.typeParameters,\n        node.parameters,\n        undefined,\n        node.equalsGreaterThanToken,\n        effectGenCallExp\n      )\n    }\n\n    const newBody = ts.factory.createBlock([\n      ts.factory.createReturnStatement(effectGenCallExp)\n    ])\n\n    if (ts.isFunctionDeclaration(node)) {\n      return ts.factory.createFunctionDeclaration(\n        newModifiers,\n        node.asteriskToken,\n        node.name,\n        node.typeParameters,\n        node.parameters,\n        undefined,\n        newBody\n      )\n    }\n    return ts.factory.createFunctionExpression(\n      newModifiers,\n      node.asteriskToken,\n      node.name,\n      node.typeParameters,\n      node.parameters,\n      undefined,\n      newBody\n    )\n  }\n\n  function findImportedModuleIdentifier(\n    sourceFile: ts.SourceFile,\n    test: (\n      node: ts.Node,\n      fromModule: ts.Expression,\n      importProperty: Option.Option<ts.ModuleExportName>\n    ) => boolean\n  ) {\n    for (const statement of sourceFile.statements) {\n      if (!ts.isImportDeclaration(statement)) continue\n      const importClause = statement.importClause\n      if (!importClause) continue\n      const namedBindings = importClause.namedBindings\n      if (!namedBindings) continue\n      if (ts.isNamespaceImport(namedBindings)) {\n        if (test(namedBindings.name, statement.moduleSpecifier, Option.none())) {\n          return ts.idText(namedBindings.name)\n        }\n      } else if (ts.isNamedImports(namedBindings)) {\n        for (const importSpecifier of namedBindings.elements) {\n          const importProperty = Option.fromNullable(importSpecifier.propertyName).pipe(\n            Option.orElse(() => Option.some(importSpecifier.name))\n          )\n          if (test(importSpecifier.name, statement.moduleSpecifier, importProperty)) {\n            return ts.idText(importSpecifier.name)\n          }\n        }\n      }\n    }\n  }\n\n  function findImportedModuleIdentifierByPackageAndNameOrBarrel(\n    sourceFile: ts.SourceFile,\n    packageName: string,\n    moduleName: string\n  ) {\n    return findImportedModuleIdentifier(\n      sourceFile,\n      (_, fromModule, importProperty) => {\n        // import * as Module from \"package/module\"\n        if (\n          Option.isNone(importProperty) && ts.isStringLiteral(fromModule) &&\n          fromModule.text === packageName + \"/\" + moduleName\n        ) {\n          return true\n        }\n        // import { Module } from \"package\"\n        // or\n        // import { Module as M } from \"package\"\n        if (\n          Option.isSome(importProperty) && ts.isIdentifier(importProperty.value) &&\n          ts.idText(importProperty.value) === moduleName && ts.isStringLiteral(fromModule) &&\n          fromModule.text === packageName\n        ) {\n          return true\n        }\n        return false\n      }\n    )\n  }\n\n  function simplifyTypeNode(typeNode: ts.TypeNode) {\n    function collectCallable(\n      typeNode: ts.TypeNode\n    ): Option.Option<Array<ts.CallSignatureDeclaration>> {\n      // (() => 1) -> skip to inner node\n      if (ts.isParenthesizedTypeNode(typeNode)) return collectCallable(typeNode.type)\n      // () => 1 -> convert to call signature\n      if (ts.isFunctionTypeNode(typeNode)) {\n        return Option.some([\n          ts.factory.createCallSignature(typeNode.typeParameters, typeNode.parameters, typeNode.type)\n        ])\n      }\n      // { ... } -> if every member is callsignature, return a merge of all of those\n      if (ts.isTypeLiteralNode(typeNode)) {\n        const allCallSignatures = typeNode.members.every(ts.isCallSignatureDeclaration)\n        if (allCallSignatures) {\n          return Option.some(typeNode.members as any as Array<ts.CallSignatureDeclaration>)\n        }\n      }\n      // ... & ... -> if both are callable, return merge of both\n      if (ts.isIntersectionTypeNode(typeNode)) {\n        const members = typeNode.types.map((node) => collectCallable(node))\n        if (members.every(Option.isSome)) {\n          return Option.some(members.map((_) => Option.isSome(_) ? _.value : []).flat())\n        }\n      }\n\n      return Option.none()\n    }\n\n    const callSignatures = collectCallable(typeNode)\n    if (Option.isSome(callSignatures) && callSignatures.value.length > 1) {\n      return ts.factory.createTypeLiteralNode(callSignatures.value)\n    }\n    return typeNode\n  }\n\n  function tryPreserveDeclarationSemantics(nodeToReplace: ts.Node, node: ts.Node, dropAsync: boolean) {\n    // new node should be an expression!\n    if (!ts.isExpression(node)) return node\n    // ok, we need to replace. is that a method or a function?\n    if (ts.isFunctionDeclaration(nodeToReplace)) {\n      // I need a name!!!\n      if (!nodeToReplace.name) return node\n      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace)\n      currentFlags &= ~ts.ModifierFlags.Async\n      const newModifiers = dropAsync\n        ? ts.factory.createModifiersFromModifierFlags(currentFlags)\n        : nodeToReplace.modifiers\n      return ts.factory.createVariableStatement(\n        newModifiers,\n        ts.factory.createVariableDeclarationList(\n          [ts.factory.createVariableDeclaration(\n            nodeToReplace.name,\n            undefined,\n            undefined,\n            node\n          )],\n          ts.NodeFlags.Const\n        )\n      )\n    } else if (ts.isMethodDeclaration(nodeToReplace)) {\n      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace)\n      currentFlags &= ~ts.ModifierFlags.Async\n      const newModifiers = dropAsync\n        ? ts.factory.createModifiersFromModifierFlags(currentFlags)\n        : nodeToReplace.modifiers\n      return ts.factory.createPropertyDeclaration(\n        newModifiers,\n        nodeToReplace.name,\n        undefined,\n        undefined,\n        node\n      )\n    }\n    // I don't know what else to do!\n    return node\n  }\n\n  function parseAccessedExpressionForCompletion(\n    sourceFile: ts.SourceFile,\n    position: number\n  ) {\n    // first, we find the preceding token\n    const precedingToken = ts.findPrecedingToken(position, sourceFile, undefined, true)\n    if (!precedingToken) return\n\n    let accessedObject = precedingToken\n    let replacementSpan = ts.createTextSpan(position, 0)\n    let outerNode: ts.Node = precedingToken\n    if (\n      ts.isIdentifier(precedingToken) && precedingToken.parent &&\n      ts.isPropertyAccessExpression(precedingToken.parent)\n    ) {\n      // we are in a \"extends Schema.Tag|\"\n      const spanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile)\n      replacementSpan = ts.createTextSpan(\n        spanStart,\n        precedingToken.end - spanStart\n      )\n      accessedObject = precedingToken.parent.expression\n      outerNode = precedingToken.parent\n    } else if (\n      ts.isToken(precedingToken) && precedingToken.kind === ts.SyntaxKind.DotToken &&\n      ts.isPropertyAccessExpression(precedingToken.parent)\n    ) {\n      // we are in a \"extends Schema.|\"\n      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile)\n      replacementSpan = ts.createTextSpan(\n        precedingTokenSpanStart,\n        precedingToken.end - precedingTokenSpanStart\n      )\n      accessedObject = precedingToken.parent.expression\n      outerNode = precedingToken.parent\n    } else if (ts.isIdentifier(precedingToken) && precedingToken.parent) {\n      // we are in a \"extends Schema|\"\n      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken, sourceFile)\n      replacementSpan = ts.createTextSpan(\n        precedingTokenSpanStart,\n        precedingToken.end - precedingTokenSpanStart\n      )\n      accessedObject = precedingToken\n      outerNode = precedingToken\n    } else {\n      return\n    }\n    return { accessedObject, outerNode, replacementSpan }\n  }\n\n  function parseDataForExtendsClassCompletion(\n    sourceFile: ts.SourceFile,\n    position: number\n  ) {\n    const maybeInfos = parseAccessedExpressionForCompletion(sourceFile, position)\n    if (!maybeInfos) return\n    const { accessedObject, outerNode, replacementSpan } = maybeInfos\n\n    if (!ts.isIdentifier(accessedObject)) return\n\n    // go up allowed nodes until we find the class declaration\n    let classDeclaration: ts.Node = outerNode.parent\n    while (\n      ts.isExpressionWithTypeArguments(classDeclaration) || ts.isHeritageClause(classDeclaration)\n    ) {\n      if (!classDeclaration.parent) break\n      classDeclaration = classDeclaration.parent\n    }\n    if (!ts.isClassDeclaration(classDeclaration)) return\n\n    if (!classDeclaration.name) return\n\n    return {\n      accessedObject,\n      classDeclaration,\n      className: classDeclaration.name,\n      replacementSpan\n    } as const\n  }\n\n  function createEffectGenCallExpression(\n    effectModuleIdentifierName: string,\n    node: ts.Node\n  ) {\n    const generator = ts.factory.createFunctionExpression(\n      undefined,\n      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n      undefined,\n      [],\n      [],\n      undefined,\n      node as any // NOTE(mattia): intended, to use same routine for both ConciseBody and Body\n    )\n\n    return ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(effectModuleIdentifierName),\n        \"gen\"\n      ),\n      undefined,\n      [generator]\n    )\n  }\n\n  function createEffectGenCallExpressionWithBlock(\n    effectModuleIdentifierName: string,\n    statement: ts.Statement | Array<ts.Statement>\n  ) {\n    return createEffectGenCallExpression(\n      effectModuleIdentifierName,\n      ts.factory.createBlock(Array.isArray(statement) ? statement : [statement], false)\n    )\n  }\n\n  function createReturnYieldStarStatement(\n    expr: ts.Expression\n  ) {\n    return ts.factory.createReturnStatement(\n      ts.factory.createYieldExpression(\n        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n        expr\n      )\n    )\n  }\n\n  function createDataTaggedErrorDeclaration(\n    dataModuleIdentifier: string,\n    name: string,\n    fields: Array<ts.TypeElement>\n  ) {\n    // Data.TaggedError(\"name\")\n    const invokeTaggedError = ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(dataModuleIdentifier),\n        \"TaggedError\"\n      ),\n      undefined,\n      [\n        ts.factory.createStringLiteral(name)\n      ]\n    )\n    // Data.TaggedError(\"name\")<{...fields}>\n    const withTypeFields = ts.factory.createExpressionWithTypeArguments(\n      invokeTaggedError,\n      [\n        ts.factory.createTypeLiteralNode(fields)\n      ]\n    )\n    return ts.factory.createClassDeclaration(\n      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n      name,\n      undefined,\n      [\n        ts.factory.createHeritageClause(\n          ts.SyntaxKind.ExtendsKeyword,\n          [\n            withTypeFields\n          ]\n        )\n      ],\n      []\n    )\n  }\n\n  function getSourceFileOfNode(current: ts.Node | undefined): ts.SourceFile | undefined {\n    let node = current\n    while (node && node.kind !== ts.SyntaxKind.SourceFile) {\n      node = node.parent\n    }\n    return node as ts.SourceFile\n  }\n\n  return {\n    findNodeAtPositionIncludingTrivia,\n    parsePackageContentNameAndVersionFromScope,\n    resolveModulePattern,\n    resolveModuleWithPackageInfoFromSourceFile,\n    findNodeWithLeadingCommentAtPosition,\n    getCommentAtPosition,\n    getAncestorNodesInRange,\n    toTextRange,\n    isNodeInRange,\n    transformAsyncAwaitToEffectFn,\n    transformAsyncAwaitToEffectGen,\n    createDataTaggedErrorDeclaration,\n    findImportedModuleIdentifierByPackageAndNameOrBarrel,\n    simplifyTypeNode,\n    tryPreserveDeclarationSemantics,\n    parseDataForExtendsClassCompletion,\n    createEffectGenCallExpressionWithBlock,\n    createReturnYieldStarStatement,\n    parseAccessedExpressionForCompletion,\n    getSourceFileOfNode\n  }\n}\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport type * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport type * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport type * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\nimport * as LanguageServicePluginOptions from \"./LanguageServicePluginOptions.js\"\nimport * as Nano from \"./Nano.js\"\n\nexport class RefactorNotApplicableError {\n  readonly _tag = \"@effect/language-service/RefactorNotApplicableError\"\n}\n\nexport interface RefactorDefinition {\n  name: string\n  description: string\n  apply: (\n    sourceFile: ts.SourceFile,\n    textRange: ts.TextRange\n  ) => Nano.Nano<\n    ApplicableRefactorDefinition,\n    RefactorNotApplicableError,\n    | TypeScriptApi.TypeScriptApi\n    | TypeScriptUtils.TypeScriptUtils\n    | TypeCheckerApi.TypeCheckerApi\n    | TypeCheckerUtils.TypeCheckerUtils\n    | TypeParser.TypeParser\n    | LanguageServicePluginOptions.LanguageServicePluginOptions\n  >\n}\n\nexport interface ApplicableRefactorDefinition {\n  kind: string\n  description: string\n  apply: Nano.Nano<void, never, ts.textChanges.ChangeTracker>\n}\n\nexport function createRefactor(definition: RefactorDefinition): RefactorDefinition {\n  return definition\n}\n\nexport interface DiagnosticDefinition {\n  name: string\n  code: number\n  severity: LanguageServicePluginOptions.DiagnosticSeverity | \"off\"\n  apply: (\n    sourceFile: ts.SourceFile,\n    report: (data: {\n      location: ts.TextRange | ts.Node\n      messageText: string\n      fixes: Array<ApplicableDiagnosticDefinitionFix>\n    }) => void\n  ) => Nano.Nano<\n    void,\n    never,\n    | TypeCheckerApi.TypeCheckerApi\n    | TypeParser.TypeParser\n    | LanguageServicePluginOptions.LanguageServicePluginOptions\n    | TypeScriptApi.TypeScriptApi\n    | TypeScriptUtils.TypeScriptUtils\n    | TypeCheckerUtils.TypeCheckerUtils\n    | TypeScriptApi.TypeScriptProgram\n  >\n}\n\nexport interface ApplicableDiagnosticDefinition {\n  range: ts.TextRange\n  messageText: string\n  fixes: Array<ApplicableDiagnosticDefinitionFix>\n}\n\nexport interface ApplicableDiagnosticDefinitionFix {\n  fixName: string\n  description: string\n  apply: Nano.Nano<void, never, ts.textChanges.ChangeTracker>\n}\n\nexport interface ApplicableDiagnosticDefinitionFixWithPositionAndCode extends ApplicableDiagnosticDefinitionFix {\n  code: number\n  start: number\n  end: number\n}\n\nexport function createDiagnostic(definition: DiagnosticDefinition): DiagnosticDefinition {\n  return definition\n}\n\nexport function concatDiagnostics(fa: Array<ts.Diagnostic>, fb: Array<ts.Diagnostic>): Array<ts.Diagnostic> {\n  const result = fa.slice(0)\n  for (const b of fb) {\n    const existing = result.find((a) =>\n      a.file === b.file && a.code === b.code && a.source === b.source && a.start === b.start && a.length === b.length &&\n      a.messageText === b.messageText\n    )\n    if (!existing) {\n      result.push(b)\n    }\n  }\n  return result\n}\n\nexport interface CompletionDefinition {\n  name: string\n  apply: (\n    sourceFile: ts.SourceFile,\n    position: number,\n    options: ts.GetCompletionsAtPositionOptions | undefined,\n    formatCodeSettings: ts.FormatCodeSettings | undefined\n  ) => Nano.Nano<\n    Array<CompletionEntryDefinition>,\n    never,\n    | TypeCheckerApi.TypeCheckerApi\n    | TypeParser.TypeParser\n    | LanguageServicePluginOptions.LanguageServicePluginOptions\n    | TypeScriptApi.TypeScriptApi\n    | TypeScriptUtils.TypeScriptUtils\n    | TypeCheckerUtils.TypeCheckerUtils\n    | TypeScriptApi.TypeScriptProgram\n  >\n}\n\nexport interface CompletionEntryDefinition {\n  name: string\n  kind: ts.ScriptElementKind\n  insertText: string\n  isSnippet: true\n  replacementSpan?: ts.TextSpan\n}\n\nexport function createCompletion(definition: CompletionDefinition): CompletionDefinition {\n  return definition\n}\n\nexport class SourceFileNotFoundError {\n  readonly _tag = \"@effect/language-service/SourceFileNotFoundError\"\n  constructor(\n    readonly fileName: string\n  ) {}\n}\n\nexport const getSemanticDiagnosticsWithCodeFixes = Nano.fn(\n  \"LSP.getSemanticDiagnosticsWithCodeFixes\"\n)(function*(\n  rules: Array<DiagnosticDefinition>,\n  sourceFile: ts.SourceFile\n) {\n  let effectDiagnostics: Array<ts.Diagnostic> = []\n  let effectCodeFixes: Array<ApplicableDiagnosticDefinitionFixWithPositionAndCode> = []\n  const executor = yield* createDiagnosticExecutor(sourceFile)\n  for (const rule of rules) {\n    const { codeFixes, diagnostics } = yield* (executor.execute(rule))\n    effectDiagnostics = effectDiagnostics.concat(diagnostics)\n    effectCodeFixes = effectCodeFixes.concat(codeFixes)\n  }\n\n  return ({\n    diagnostics: effectDiagnostics,\n    codeFixes: effectCodeFixes\n  })\n})\n\nfunction refactorNameToFullyQualifiedName(name: string) {\n  return `@effect/language-service/refactors/${name}`\n}\n\nexport const getApplicableRefactors = Nano.fn(\"LSP.getApplicableRefactors\")(function*(\n  refactors: Array<RefactorDefinition>,\n  sourceFile: ts.SourceFile,\n  positionOrRange: number | ts.TextRange\n) {\n  const textRange = typeof positionOrRange === \"number\"\n    ? { pos: positionOrRange, end: positionOrRange }\n    : positionOrRange\n  const effectRefactors: Array<ts.ApplicableRefactorInfo> = []\n  for (const refactor of refactors) {\n    yield* pipe(\n      refactor.apply(sourceFile, textRange),\n      Nano.map((result) =>\n        effectRefactors.push({\n          name: refactorNameToFullyQualifiedName(refactor.name),\n          description: refactor.description,\n          actions: [{\n            name: refactorNameToFullyQualifiedName(refactor.name),\n            description: result.description,\n            kind: result.kind\n          }]\n        })\n      ),\n      Nano.ignore\n    )\n  }\n  return effectRefactors\n})\n\nexport const getEditsForRefactor = Nano.fn(\"LSP.getEditsForRefactor\")(function*(\n  refactors: Array<RefactorDefinition>,\n  sourceFile: ts.SourceFile,\n  positionOrRange: number | ts.TextRange,\n  refactorName: string\n) {\n  const refactor = refactors.find((refactor) => refactorNameToFullyQualifiedName(refactor.name) === refactorName)\n  if (!refactor) {\n    return yield* Nano.fail(new RefactorNotApplicableError())\n  }\n  const textRange = typeof positionOrRange === \"number\"\n    ? { pos: positionOrRange, end: positionOrRange }\n    : positionOrRange\n\n  return yield* refactor.apply(sourceFile, textRange)\n})\n\nexport const getCompletionsAtPosition = Nano.fn(\"LSP.getCompletionsAtPosition\")(function*(\n  completions: Array<CompletionDefinition>,\n  sourceFile: ts.SourceFile,\n  position: number,\n  options: ts.GetCompletionsAtPositionOptions | undefined,\n  formatCodeSettings: ts.FormatCodeSettings | undefined\n) {\n  let effectCompletions: Array<ts.CompletionEntry> = []\n  for (const completion of completions) {\n    const result = yield* completion.apply(sourceFile, position, options, formatCodeSettings)\n    effectCompletions = effectCompletions.concat(\n      result.map((_) => ({ sortText: \"11\", ..._ }) satisfies ts.CompletionEntry)\n    )\n  }\n  return effectCompletions\n})\n\ninterface CommentNextLineOverride {\n  pos: number\n  end: number\n  level: string\n  commentRange: ts.CommentRange\n}\n\nconst createDiagnosticExecutor = Nano.fn(\"LSP.createCommentDirectivesProcessor\")(\n  function*(sourceFile: ts.SourceFile) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const pluginOptions = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    function findParentStatementForDisableNextLine(node: ts.Node) {\n      let result: ts.Node | undefined\n\n      function find(node: ts.Node) {\n        if (ts.isStatement(node)) {\n          result = node\n          return\n        }\n        if (result) return\n        if (node.parent) find(node.parent)\n      }\n      find(node)\n      return result || node\n    }\n\n    const lineOverrides: Record<\n      string,\n      Array<CommentNextLineOverride>\n    > = {}\n    const sectionOverrides: Record<\n      string,\n      Array<{ pos: number; level: string }>\n    > = {}\n    const skippedRules: Array<string> = []\n\n    const regex =\n      /@effect-diagnostics(-next-line)?((?:\\s[a-zA-Z0-9/]+:(?:off|warning|error|message|suggestion|skip-file))+)?/gm\n    let match: RegExpExecArray | null\n    while ((match = regex.exec(sourceFile.text)) !== null) {\n      const nextLineCaptureGroup = match[1]\n      const rulesCaptureGroup = match[2]\n\n      if (rulesCaptureGroup) {\n        const trimmedRuleString = rulesCaptureGroup.trim()\n        if (trimmedRuleString) {\n          const individualRules = trimmedRuleString.split(/\\s+/)\n          for (const rulePair of individualRules) {\n            const [rawRuleName, ruleLevel] = rulePair.toLowerCase().split(\":\")\n            // NOTE: for backwards compatibility, treat \"effect/ruleName\" same as \"ruleName\"\n            const ruleName = rawRuleName.startsWith(\"effect/\")\n              ? rawRuleName.substring(\"effect/\".length)\n              : rawRuleName\n            if (ruleName && ruleLevel) {\n              if (ruleLevel === \"skip-file\") skippedRules.push(ruleName)\n              const isOverrideNextLine = nextLineCaptureGroup &&\n                nextLineCaptureGroup.trim().toLowerCase() === \"-next-line\"\n              if (isOverrideNextLine) {\n                const foundNode = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, match.index)\n                if (foundNode) {\n                  lineOverrides[ruleName] = lineOverrides[ruleName] || []\n                  lineOverrides[ruleName].unshift({\n                    pos: foundNode.node.pos,\n                    end: foundNode.node.end,\n                    level: ruleLevel,\n                    commentRange: foundNode.commentRange\n                  })\n                }\n              } else {\n                sectionOverrides[ruleName] = sectionOverrides[ruleName] || []\n                sectionOverrides[ruleName].unshift({\n                  pos: match.index,\n                  level: ruleLevel\n                })\n              }\n            }\n          }\n        }\n      }\n    }\n\n    const levelToDiagnosticCategory: Record<string, ts.DiagnosticCategory> = {\n      error: ts.DiagnosticCategory.Error,\n      warning: ts.DiagnosticCategory.Warning,\n      message: ts.DiagnosticCategory.Message,\n      suggestion: ts.DiagnosticCategory.Suggestion\n    }\n\n    const execute = (\n      rule: DiagnosticDefinition\n    ) =>\n      Nano.gen(function*() {\n        const diagnostics: Array<ts.Diagnostic> = []\n        const codeFixes: Array<ApplicableDiagnosticDefinitionFixWithPositionAndCode> = []\n        const ruleNameLowered = rule.name.toLowerCase()\n        const defaultLevel = pluginOptions.diagnosticSeverity[ruleNameLowered] || rule.severity\n        // if file is skipped entirely, do not process the rule\n        if (skippedRules.indexOf(ruleNameLowered) > -1) return { diagnostics, codeFixes }\n        // if the default level is off, and there are no overrides, do not process the rule\n        if (\n          defaultLevel === \"off\" &&\n          ((lineOverrides[ruleNameLowered] || sectionOverrides[ruleNameLowered] || []).length === 0)\n        ) {\n          return { diagnostics, codeFixes }\n        }\n        // append a rule fix to disable this check only for next line\n        const fixByDisableNextLine = (\n          node: ts.Node\n        ): ApplicableDiagnosticDefinitionFix => ({\n          fixName: rule.name + \"_skipNextLine\",\n          description: \"Disable \" + rule.name + \" for this line\",\n          apply: Nano.flatMap(\n            Nano.service(TypeScriptApi.ChangeTracker),\n            (changeTracker) =>\n              Nano.gen(function*() {\n                const disableAtNode = findParentStatementForDisableNextLine(node)\n                const start = ts.getTokenPosOfNode(disableAtNode, sourceFile)\n                const { line } = ts.getLineAndCharacterOfPosition(sourceFile, start)\n\n                changeTracker.insertCommentBeforeLine(\n                  sourceFile,\n                  line,\n                  start,\n                  ` @effect-diagnostics-next-line ${rule.name}:off`\n                )\n              })\n          )\n        })\n\n        // append a rule fix to disable this check for the entire file\n        const fixByDisableEntireFile: ApplicableDiagnosticDefinitionFix = {\n          fixName: rule.name + \"_skipFile\",\n          description: \"Disable \" + rule.name + \" for this entire file\",\n          apply: Nano.flatMap(\n            Nano.service(TypeScriptApi.ChangeTracker),\n            (changeTracker) =>\n              Nano.sync(() =>\n                changeTracker.insertText(\n                  sourceFile,\n                  0,\n                  `/** @effect-diagnostics ${rule.name}:skip-file */\\n`\n                )\n              )\n          )\n        }\n        // run the executor\n        const applicableDiagnostics: Array<ApplicableDiagnosticDefinition> = []\n        yield* rule.apply(sourceFile, (entry) => {\n          const range = \"kind\" in entry.location\n            ? { pos: ts.getTokenPosOfNode(entry.location, sourceFile), end: entry.location.end }\n            : entry.location\n          const node = \"kind\" in entry.location\n            ? entry.location\n            : tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, entry.location.pos)\n          applicableDiagnostics.push({\n            range,\n            messageText: pluginOptions.diagnosticsName\n              ? `${entry.messageText}    effect(${rule.name})`\n              : entry.messageText,\n            fixes: entry.fixes.concat(node ? [fixByDisableNextLine(node)] : []).concat([fixByDisableEntireFile])\n          })\n        })\n\n        // create a list of all the comment ranges\n        const unusedLineOverrides = new Set<CommentNextLineOverride>(lineOverrides[ruleNameLowered] || [])\n\n        // loop through rules\n        for (const emitted of applicableDiagnostics.slice(0)) {\n          // by default, use the overriden level from the plugin options\n          let newLevel: string | undefined = defaultLevel\n          // attempt with line overrides\n          const lineOverride = (lineOverrides[ruleNameLowered] || []).find((_) =>\n            _.pos < emitted.range.pos && _.end >= emitted.range.end\n          )\n          if (lineOverride) {\n            newLevel = lineOverride.level\n            unusedLineOverrides.delete(lineOverride)\n          } else {\n            // then attempt with section overrides\n            const sectionOverride = (sectionOverrides[ruleNameLowered] || []).find((_) => _.pos < emitted.range.pos)\n            if (sectionOverride) newLevel = sectionOverride.level\n          }\n          // if level is off or not a valid level, skip and no output\n          if (!(newLevel in levelToDiagnosticCategory)) continue\n          // append both diagnostic and code fix\n          diagnostics.push({\n            file: sourceFile,\n            start: emitted.range.pos,\n            length: emitted.range.end - emitted.range.pos,\n            messageText: emitted.messageText,\n            category: levelToDiagnosticCategory[newLevel],\n            code: rule.code,\n            source: \"effect\"\n          })\n          // append code fixes\n          for (const fix of emitted.fixes) {\n            codeFixes.push({\n              ...fix,\n              code: rule.code,\n              start: emitted.range.pos,\n              end: emitted.range.end\n            })\n          }\n        }\n\n        if (pluginOptions.missingDiagnosticNextLine !== \"off\" && unusedLineOverrides.size > 0) {\n          for (const unusedLineOverride of unusedLineOverrides) {\n            diagnostics.push({\n              file: sourceFile,\n              start: unusedLineOverride.commentRange.pos,\n              length: unusedLineOverride.commentRange.end - unusedLineOverride.commentRange.pos,\n              messageText:\n                `@effect-diagnostics-next-line ${rule.name}:${unusedLineOverride.level} has no effect, make sure you are suppressing the right rule.`,\n              category: levelToDiagnosticCategory[pluginOptions.missingDiagnosticNextLine],\n              code: -1,\n              source: \"effect\"\n            })\n          }\n        }\n        return { diagnostics, codeFixes }\n      })\n\n    return { execute }\n  }\n)\n\nexport const cyrb53 = (str: string, seed = 0) => {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i)\n    h1 = Math.imul(h1 ^ ch, 2654435761)\n    h2 = Math.imul(h2 ^ ch, 1597334677)\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507)\n  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507)\n  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n\n  // return 4294967296 * (2097151 & h2) + (h1 >>> 0)\n  return (h2 >>> 0).toString(16).padStart(8, \"0\") + (h1 >>> 0).toString(16).padStart(8, \"0\")\n}\n\nexport class CodegenNotApplicableError {\n  readonly _tag = \"@effect/language-service/CodegenNotApplicableError\"\n  constructor(\n    readonly cause: string\n  ) {}\n}\n\nexport interface CodegenDefinition {\n  name: string\n  apply: (\n    sourceFile: ts.SourceFile,\n    commentRange: ts.TextRange\n  ) => Nano.Nano<\n    ApplicableCodegenDefinition,\n    CodegenNotApplicableError,\n    | TypeScriptApi.TypeScriptApi\n    | TypeScriptUtils.TypeScriptUtils\n    | TypeCheckerApi.TypeCheckerApi\n    | TypeCheckerUtils.TypeCheckerUtils\n    | TypeParser.TypeParser\n    | LanguageServicePluginOptions.LanguageServicePluginOptions\n  >\n}\n\nexport interface ApplicableCodegenDefinition {\n  hash: string\n  description: string\n  apply: Nano.Nano<void, never, ts.textChanges.ChangeTracker>\n}\n\nexport function createCodegen(definition: CodegenDefinition): CodegenDefinition {\n  return definition\n}\n\nexport const getCodegensForSourceFile = Nano.fn(\"LSP.getApplicableCodegens\")(function*(\n  codegens: Array<CodegenDefinition>,\n  sourceFile: ts.SourceFile\n) {\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const result: Array<{ codegen: CodegenDefinition; hash: string; range: ts.TextRange }> = []\n\n  const regex = /@effect-codegens((?:\\s[a-zA-Z0-9]+(?::(?:[a-zA-Z0-9]+))?)+)+/gmid\n  let match: RegExpExecArray | null\n  while ((match = regex.exec(sourceFile.text)) !== null) {\n    const pos = match.indices?.[0]?.[0]\n    if (!pos) continue\n    const commentRange = tsUtils.getCommentAtPosition(sourceFile, pos)\n    if (!commentRange) continue\n    const commentText = sourceFile.text.slice(pos, commentRange.end)\n    const codegenRegex = /(\\s+)(\\w+)(?::(\\w+))?/gmi\n    let codegenMatch: RegExpExecArray | null\n    while ((codegenMatch = codegenRegex.exec(commentText)) !== null) {\n      const whitespace = codegenMatch[1] || \"\"\n      const codegenName = codegenMatch[2] || \"\"\n      const codegenHash = codegenMatch[3] || \"\"\n      const range: ts.TextRange = {\n        pos: codegenMatch.index + pos + whitespace.length,\n        end: codegenMatch.index + pos + codegenMatch[0].length\n      }\n      const codegen = codegens.find((codegen) => codegen.name === codegenName)\n      if (!codegen) continue\n      result.push({ codegen, hash: codegenHash, range })\n    }\n  }\n  return result\n})\n\nexport const getEditsForCodegen = Nano.fn(\"LSP.getEditsForCodegen\")(function*(\n  codegens: Array<CodegenDefinition>,\n  sourceFile: ts.SourceFile,\n  textRange: ts.TextRange\n) {\n  const applicableCodegens = yield* getCodegensForSourceFile(codegens, sourceFile)\n  const inRangeCodegens = applicableCodegens.filter((codegen) =>\n    codegen.range.pos <= textRange.pos && codegen.range.end >= textRange.end\n  )\n  if (inRangeCodegens.length !== 1) {\n    return yield* Nano.fail(new CodegenNotApplicableError(\"zero or multiple codegens in range\"))\n  }\n  const { codegen, range } = inRangeCodegens[0]\n  const edit = yield* codegen.apply(sourceFile, range)\n  const updateHashComment = pipe(\n    Nano.service(TypeScriptApi.ChangeTracker),\n    Nano.map((changeTracker) => {\n      changeTracker.deleteRange(sourceFile, range)\n      changeTracker.insertText(sourceFile, range.pos, `${codegen.name}:${edit.hash}`)\n    })\n  )\n  return {\n    ...edit,\n    apply: pipe(\n      edit.apply,\n      Nano.flatMap(() => updateHashComment)\n    ),\n    ignore: updateHashComment\n  } satisfies ApplicableCodegenDefinition & { ignore: Nano.Nano<void, never, ts.textChanges.ChangeTracker> }\n})\n\nexport interface EffectLspPatchSourceFileMetadata {\n  relationErrors: Array<[node: ts.Node, expectedType: ts.Type, valueNode: ts.Node, realType: ts.Type]>\n}\n\nexport const getEffectLspPatchSourceFileMetadata = (\n  sourceFile: ts.SourceFile\n): EffectLspPatchSourceFileMetadata | undefined => {\n  return (sourceFile as any)[\"@effect-lsp-patch/metadata\"]\n}\n\nexport const getOrDefaultEffectLspPatchSourceFileMetadata = (\n  sourceFile: ts.SourceFile\n): EffectLspPatchSourceFileMetadata => {\n  return getEffectLspPatchSourceFileMetadata(sourceFile) ||\n    ((sourceFile as any)[\"@effect-lsp-patch/metadata\"] = {\n      relationErrors: []\n    })\n}\n","import { isFunction } from \"effect/Function\"\nimport { hasProperty } from \"effect/Predicate\"\nimport type ts from \"typescript\"\nimport * as Nano from \"../core/Nano.js\"\n\ndeclare module \"typescript\" {\n  export interface TypeChecker {\n    getIndexType(constraint: ts.Type): ts.Type\n    getParameterType(signature: ts.Signature, parameterIndex: number): ts.Type\n  }\n}\n\nexport interface TypeCheckerApi extends ts.TypeChecker {}\nexport const TypeCheckerApi = Nano.Tag<TypeCheckerApi>(\"TypeChecker\")\n\nexport function makeResolveExternalModuleName(typeChecker: TypeCheckerApi) {\n  if (!(hasProperty(typeChecker, \"resolveExternalModuleName\") && isFunction(typeChecker.resolveExternalModuleName))) {\n    return\n  }\n  const _internal = typeChecker.resolveExternalModuleName\n  return (moduleSpecifier: ts.Expression): ts.Symbol | undefined => {\n    return _internal(moduleSpecifier)\n  }\n}\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Order from \"effect/Order\"\nimport type * as ts from \"typescript\"\nimport * as Nano from \"./Nano.js\"\nimport * as TypeCheckerApi from \"./TypeCheckerApi\"\nimport * as TypeScriptApi from \"./TypeScriptApi\"\nimport * as TypeScriptUtils from \"./TypeScriptUtils\"\n\nexport interface TypeCheckerUtils {\n  isUnion: (type: ts.Type) => type is ts.UnionType\n  getTypeParameterAtPosition: (signature: ts.Signature, pos: number) => ts.Type\n  getMissingTypeEntriesInTargetType: (realType: ts.Type, expectedType: ts.Type) => Array<ts.Type>\n  unrollUnionMembers: (type: ts.Type) => Array<ts.Type>\n  appendToUniqueTypesMap: <E, R>(\n    memory: Map<string, ts.Type>,\n    initialType: ts.Type,\n    shouldExclude: (type: ts.Type) => Nano.Nano<boolean, E, R>\n  ) => Nano.Nano<{ newIndexes: Set<string>; knownIndexes: Set<string>; allIndexes: Array<string> }, E, R>\n  deterministicTypeOrder: Order.Order<ts.Type>\n  getInferredReturnType: (declaration: ConvertibleDeclaration) => ts.Type | undefined\n  expectedAndRealType: (sourceFile: ts.SourceFile) => Array<ExpectedAndRealType>\n  typeToSimplifiedTypeNode: (\n    type: ts.Type,\n    enclosingNode: ts.Node | undefined,\n    flags: ts.NodeBuilderFlags | undefined\n  ) => ts.TypeNode | undefined\n}\n\nexport const TypeCheckerUtils = Nano.Tag<TypeCheckerUtils>(\"TypeCheckerUtils\")\n\nexport const nanoLayer = <A, E, R>(\n  fa: Nano.Nano<A, E, R>\n) =>\n  pipe(\n    Nano.service(TypeScriptApi.TypeScriptApi),\n    Nano.flatMap((ts) =>\n      Nano.flatMap(Nano.service(TypeCheckerApi.TypeCheckerApi), (typeChecker) =>\n        Nano.flatMap(Nano.service(TypeScriptUtils.TypeScriptUtils), (typeScriptUtils) =>\n          pipe(fa, Nano.provideService(TypeCheckerUtils, makeTypeCheckerUtils(ts, typeChecker, typeScriptUtils)))))\n    )\n  )\n\nexport type ExpectedAndRealType = [\n  node: ts.Node,\n  expectedType: ts.Type,\n  valueNode: ts.Node,\n  realType: ts.Type\n]\n\ntype ConvertibleDeclaration =\n  | ts.FunctionDeclaration\n  | ts.FunctionExpression\n  | ts.ArrowFunction\n  | ts.MethodDeclaration\n\nexport function makeTypeCheckerUtils(\n  ts: TypeScriptApi.TypeScriptApi,\n  typeChecker: TypeCheckerApi.TypeCheckerApi,\n  tsUtils: TypeScriptUtils.TypeScriptUtils\n): TypeCheckerUtils {\n  function isUnion(type: ts.Type): type is ts.UnionType {\n    return !!(type.flags & ts.TypeFlags.Union)\n  }\n\n  function isIndexType(type: ts.Type): type is ts.IndexType {\n    return !!(type.flags & ts.TypeFlags.Index)\n  }\n\n  function isThisTypeParameter(type: ts.Type): boolean {\n    return !!(type.flags & ts.TypeFlags.TypeParameter && (type as any).isThisType)\n  }\n\n  function getTypeParameterAtPosition(signature: ts.Signature, pos: number): ts.Type {\n    const type = typeChecker.getParameterType(signature, pos)\n    if (isIndexType(type) && isThisTypeParameter(type.type)) {\n      const constraint = typeChecker.getBaseConstraintOfType(type.type)\n      if (constraint) {\n        return typeChecker.getIndexType(constraint)\n      }\n    }\n    return type\n  }\n\n  const unrollUnionMembers = (type: ts.Type) => {\n    const result: Array<ts.Type> = []\n    let toTest: Array<ts.Type> = [type]\n    while (toTest.length > 0) {\n      const type = toTest.pop()!\n      if (isUnion(type)) {\n        toTest = toTest.concat(type.types)\n      } else {\n        result.push(type)\n      }\n    }\n    return result\n  }\n\n  const getMissingTypeEntriesInTargetType = function(realType: ts.Type, expectedType: ts.Type) {\n    if (realType === expectedType) return []\n\n    const result: Array<ts.Type> = []\n    let toTest: Array<ts.Type> = [realType]\n    while (toTest.length > 0) {\n      const type = toTest.pop()\n      if (!type) return result\n      if (isUnion(type)) {\n        toTest = toTest.concat(type.types)\n      } else {\n        const assignable = typeChecker.isTypeAssignableTo(type, expectedType)\n        if (!assignable) {\n          result.push(type)\n        }\n      }\n    }\n    return result\n  }\n\n  /**\n   * Appends a type to a map of unique types, ensuring that the type is not already in the map.\n   *\n   * @param memory - The map that will be used as memory and updated as new types are encountered.\n   * @param initialType - The type to start with, unions will be unrolled.\n   * @param shouldExclude - A function that determines if a type should be excluded from the checking\n   * @returns An object with the following properties:\n   * - newIndexes: A set of new indexes that were added to the memory.\n   * - knownIndexes: A set of indexes that were already in the memory.\n   * - allIndexes: A set of all indexes that were encountered.\n   */\n  const appendToUniqueTypesMap = Nano.fn(\n    \"TypeCheckerUtils.appendToUniqueTypesMap\"\n  )(\n    function*<E, R>(\n      memory: Map<string, ts.Type>,\n      initialType: ts.Type,\n      shouldExclude: (type: ts.Type) => Nano.Nano<boolean, E, R>\n    ) {\n      const newIndexes: Set<string> = new Set()\n      const knownIndexes: Set<string> = new Set()\n      let toTest: Array<ts.Type> = [initialType]\n      while (toTest.length > 0) {\n        const type = toTest.pop()\n        if (!type) break\n        if (yield* shouldExclude(type)) {\n          continue\n        }\n        if (isUnion(type)) {\n          toTest = toTest.concat(type.types)\n        } else {\n          const foundMatch: Array<string> = []\n          for (const [typeId, knownType] of memory.entries()) {\n            const areSame = typeChecker.isTypeAssignableTo(knownType, type) &&\n              typeChecker.isTypeAssignableTo(type, knownType)\n            if (areSame) {\n              foundMatch.push(typeId)\n              break\n            }\n          }\n          if (foundMatch.length === 0) {\n            const newId = \"t\" + (memory.size + 1)\n            memory.set(newId, type)\n            newIndexes.add(newId)\n          } else {\n            knownIndexes.add(foundMatch[0])\n          }\n        }\n      }\n      return {\n        newIndexes,\n        knownIndexes,\n        allIndexes: pipe(\n          Array.fromIterable(newIndexes),\n          Array.appendAll(Array.fromIterable(knownIndexes))\n        )\n      }\n    }\n  )\n\n  const deterministicTypeOrder = Order.make((a: ts.Type, b: ts.Type) => {\n    const aName = typeChecker.typeToString(a)\n    const bName = typeChecker.typeToString(b)\n    if (aName < bName) return -1\n    if (aName > bName) return 1\n    return 0\n  })\n\n  const getAncestorConvertibleDeclaration = (node: ts.Node) => {\n    let current: ts.Node | undefined = node\n    while (current) {\n      if (\n        ts.isFunctionDeclaration(current) ||\n        ts.isFunctionExpression(current) ||\n        ts.isArrowFunction(current) ||\n        ts.isMethodDeclaration(current)\n      ) {\n        return current\n      }\n      current = current.parent\n    }\n  }\n\n  const getInferredReturnType = (\n    declaration: ConvertibleDeclaration\n  ) => {\n    if (!declaration.body) {\n      return\n    }\n\n    let returnType: ts.Type | undefined\n\n    if (typeChecker.isImplementationOfOverload(declaration)) {\n      const signatures = typeChecker.getSignaturesOfType(\n        typeChecker.getTypeAtLocation(declaration),\n        ts.SignatureKind.Call\n      )\n      if (signatures.length > 1) {\n        returnType = typeChecker.getUnionType(\n          signatures.map((s) => typeChecker.getReturnTypeOfSignature(s)).filter((_) => !!_)\n        )\n      }\n    }\n    if (!returnType) {\n      const signature = typeChecker.getSignatureFromDeclaration(declaration)\n      if (signature) {\n        const typePredicate = typeChecker.getTypePredicateOfSignature(signature)\n        if (typePredicate && typePredicate.type) {\n          return typePredicate.type\n        } else {\n          returnType = typeChecker.getReturnTypeOfSignature(signature)\n        }\n      }\n    }\n\n    return returnType\n  }\n\n  const expectedAndRealTypeCache = new WeakMap<ts.SourceFile, Array<ExpectedAndRealType>>()\n  const expectedAndRealType = (\n    sourceFile: ts.SourceFile\n  ) => {\n    const cached = expectedAndRealTypeCache.get(sourceFile)\n    if (cached) return cached\n    const result: Array<ExpectedAndRealType> = []\n\n    const nodeToVisit: Array<ts.Node> = [sourceFile]\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      if (ts.isVariableDeclaration(node) && node.initializer) {\n        // const a: Effect<...> = node\n        const expectedType = typeChecker.getTypeAtLocation(node.name)\n        const realType = typeChecker.getTypeAtLocation(node.initializer)\n        result.push([node.name, expectedType, node.initializer, realType])\n        appendNodeToVisit(node.initializer)\n        continue\n      } else if (ts.isCallExpression(node)) {\n        // fn(a)\n        const resolvedSignature = typeChecker.getResolvedSignature(node)\n        if (resolvedSignature) {\n          resolvedSignature.parameters.map((parameter, index) => {\n            const expectedType = typeChecker.getTypeOfSymbolAtLocation(parameter, node)\n            const realType = typeChecker.getTypeAtLocation(node.arguments[index])\n            result.push([\n              node.arguments[index] as ts.Node,\n              expectedType,\n              node.arguments[index],\n              realType\n            ])\n          })\n        }\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      } else if (\n        ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node) ||\n        ts.isNoSubstitutionTemplateLiteral(node)\n      ) {\n        // { key: node } as { key: Effect<...> }\n        const parent = node.parent\n        if (ts.isObjectLiteralElement(parent)) {\n          if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {\n            const type = typeChecker.getContextualType(parent.parent)\n            if (type) {\n              const name = ts.isIdentifier(node) ? ts.idText(node) : ts.isStringLiteral(node) ? node.text : undefined\n              if (name) {\n                const symbol = typeChecker.getPropertyOfType(type, name)\n                if (symbol) {\n                  const expectedType = typeChecker.getTypeOfSymbolAtLocation(symbol, node)\n                  const realType = typeChecker.getTypeAtLocation(node)\n                  result.push([node, expectedType, node, realType])\n                }\n              }\n            }\n          }\n        }\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      } else if (\n        ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken\n      ) {\n        // var a: Effect<...> = node\n        const expectedType = typeChecker.getTypeAtLocation(node.left)\n        const realType = typeChecker.getTypeAtLocation(node.right)\n        result.push([node.left, expectedType, node.right, realType])\n        appendNodeToVisit(node.right)\n        continue\n      } else if (ts.isReturnStatement(node) && node.expression) {\n        // function(): Effect<...> { return a }\n        const parentDeclaration = getAncestorConvertibleDeclaration(node)\n        if (parentDeclaration) {\n          const expectedType = getInferredReturnType(parentDeclaration)\n          const realType = typeChecker.getTypeAtLocation(node.expression)\n          if (expectedType) {\n            result.push([node, expectedType, node, realType])\n          }\n        }\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      } else if (\n        ts.isArrowFunction(node) && (node.typeParameters || []).length === 0 &&\n        ts.isExpression(node.body)\n      ) {\n        // (): Effect<...> => node\n        const body = node.body\n        const expectedType = typeChecker.getContextualType(body)\n        const realType = typeChecker.getTypeAtLocation(body)\n        if (expectedType) {\n          result.push([body, expectedType, body, realType])\n        }\n        ts.forEachChild(body, appendNodeToVisit)\n        continue\n      } else if (\n        ts.isArrowFunction(node) && (node.typeParameters || []).length > 0 &&\n        ts.isExpression(node.body)\n      ) {\n        // <A>(): Effect<...> => node\n        const body = node.body\n        const expectedType = getInferredReturnType(node)\n        const realType = typeChecker.getTypeAtLocation(body)\n        if (expectedType) {\n          result.push([body, expectedType, body, realType])\n        }\n        ts.forEachChild(body, appendNodeToVisit)\n        continue\n      } else if (ts.isSatisfiesExpression(node)) {\n        // node as Effect<....>\n        const expectedType = typeChecker.getTypeAtLocation(node.type)\n        const realType = typeChecker.getTypeAtLocation(node.expression)\n        result.push([node.expression as ts.Node, expectedType, node.expression, realType])\n        appendNodeToVisit(node.expression)\n        continue\n      }\n\n      // no previous case has been hit, continue with childs\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n    expectedAndRealTypeCache.set(sourceFile, result)\n    return result\n  }\n\n  function typeToSimplifiedTypeNode(\n    type: ts.Type,\n    enclosingNode: ts.Node | undefined,\n    flags: ts.NodeBuilderFlags | undefined\n  ): ts.TypeNode | undefined {\n    return typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, 0)\n  }\n\n  function typeToSimplifiedTypeNodeWorker(\n    type: ts.Type,\n    enclosingNode: ts.Node | undefined,\n    flags: ts.NodeBuilderFlags | undefined,\n    depth: number\n  ): ts.TypeNode | undefined {\n    const fallbackStandard = () => {\n      const typeNode = typeChecker.typeToTypeNode(type, enclosingNode, flags)\n      if (!typeNode) return undefined\n      return tsUtils.simplifyTypeNode(typeNode)\n    }\n    // prevent infinite recursion\n    if (depth > 20) return fallbackStandard()\n\n    const members = unrollUnionMembers(type)\n    // A | B | C -> process each member\n    if (members.length > 1 && !(type.flags & ts.TypeFlags.Boolean)) {\n      const typeNodes: Array<ts.TypeNode> = []\n      members.sort(deterministicTypeOrder)\n      for (const member of members) {\n        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1)\n        if (!memberNode) return fallbackStandard()\n        typeNodes.push(memberNode)\n      }\n      return tsUtils.simplifyTypeNode(ts.factory.createUnionTypeNode(typeNodes))\n    }\n    // A & B & B -> process each member\n    if (type.flags & ts.TypeFlags.Intersection) {\n      const intersectionType = type as ts.IntersectionType\n      const typeNodes: Array<ts.TypeNode> = []\n      for (const member of intersectionType.types) {\n        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1)\n        if (!memberNode) return fallbackStandard()\n        typeNodes.push(memberNode)\n      }\n      return tsUtils.simplifyTypeNode(ts.factory.createIntersectionTypeNode(typeNodes))\n    }\n    // Effect<number, never, never> -> Effect<number>\n    if (type.flags & ts.TypeFlags.Object && (type as ts.ObjectType).objectFlags & ts.ObjectFlags.Reference) {\n      const typeReference = type as ts.TypeReference\n      // compute the standard type reference node and ensure we get the same amount of type arguments\n      const standard = fallbackStandard()\n      if (!standard) return undefined\n      if (!ts.isTypeReferenceNode(standard)) return standard\n      if (typeReference.target.typeParameters?.length !== typeReference.typeArguments?.length) return standard\n      if (standard.typeArguments?.length !== typeReference.typeArguments?.length) return standard\n      const typeParametersCount = (typeReference.target.typeParameters || []).length\n      for (let i = typeParametersCount - 1; i >= 0; i--) {\n        const typeParameter = typeReference.target.typeParameters![i]\n        const typeArgument = typeReference.typeArguments![i]\n        const defaultType = typeChecker.getDefaultFromTypeParameter(typeParameter)\n        if (defaultType !== typeArgument || i === 0) {\n          return tsUtils.simplifyTypeNode(ts.factory.updateTypeReferenceNode(\n            standard,\n            standard.typeName,\n            ts.factory.createNodeArray((standard.typeArguments || []).slice(0, Math.min(typeParametersCount, i + 1)))\n          ))\n        }\n      }\n      return standard\n    }\n    // () => Effect<number, never, never> -> () => Effect<number>\n    if (type.flags & ts.TypeFlags.Object) {\n      const standard = fallbackStandard()\n      if (!standard) return undefined\n      if (!ts.isFunctionTypeNode(standard)) return standard\n      const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n      if (signatures.length !== 1) return standard\n      const returnType = typeChecker.getReturnTypeOfSignature(signatures[0])\n      if (!returnType) return standard\n      const returnTypeNode = typeToSimplifiedTypeNodeWorker(returnType, enclosingNode, flags, depth + 1)\n      if (!returnTypeNode) return standard\n      return tsUtils.simplifyTypeNode(ts.factory.updateFunctionTypeNode(\n        standard,\n        standard.typeParameters,\n        standard.parameters,\n        returnTypeNode\n      ))\n    }\n\n    return fallbackStandard()\n  }\n\n  return {\n    isUnion,\n    getTypeParameterAtPosition,\n    getMissingTypeEntriesInTargetType,\n    unrollUnionMembers,\n    appendToUniqueTypesMap,\n    deterministicTypeOrder,\n    getInferredReturnType,\n    expectedAndRealType,\n    typeToSimplifiedTypeNode\n  }\n}\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as Nano from \"./Nano.js\"\nimport * as TypeCheckerApi from \"./TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"./TypeCheckerUtils.js\"\nimport * as TypeScriptApi from \"./TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"./TypeScriptUtils.js\"\n\nexport interface TypeParser {\n  effectType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; E: ts.Type; R: ts.Type }, TypeParserIssue>\n  strictEffectType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; E: ts.Type; R: ts.Type }, TypeParserIssue>\n  layerType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ ROut: ts.Type; E: ts.Type; RIn: ts.Type }, TypeParserIssue>\n  fiberType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; E: ts.Type; R: ts.Type }, TypeParserIssue>\n  effectSubtype: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; E: ts.Type; R: ts.Type }, TypeParserIssue>\n  importedEffectModule: (\n    node: ts.Node\n  ) => Nano.Nano<ts.Node, TypeParserIssue>\n  isNodeReferenceToEffectModuleApi: (\n    memberName: string\n  ) => (node: ts.Node) => Nano.Nano<ts.SourceFile, TypeParserIssue, never>\n  effectGen: (\n    node: ts.Node\n  ) => Nano.Nano<\n    {\n      node: ts.Node\n      effectModule: ts.Expression\n      generatorFunction: ts.FunctionExpression\n      body: ts.Block\n    },\n    TypeParserIssue\n  >\n  effectFnUntracedGen: (\n    node: ts.Node\n  ) => Nano.Nano<\n    {\n      node: ts.Node\n      effectModule: ts.Node\n      generatorFunction: ts.FunctionExpression\n      body: ts.Block\n    },\n    TypeParserIssue\n  >\n  effectFnGen: (\n    node: ts.Node\n  ) => Nano.Nano<\n    {\n      node: ts.Node\n      generatorFunction: ts.FunctionExpression\n      effectModule: ts.Node\n      body: ts.Block\n    },\n    TypeParserIssue\n  >\n  unnecessaryEffectGen: (\n    node: ts.Node\n  ) => Nano.Nano<\n    { node: ts.Node; body: ts.Block; yieldedExpression: ts.Node; replacementNode: Nano.Nano<ts.Node, never, never> },\n    TypeParserIssue\n  >\n  effectSchemaType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ A: ts.Type; I: ts.Type; R: ts.Type }, TypeParserIssue>\n  contextTag: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ Identifier: ts.Type; Service: ts.Type }, TypeParserIssue>\n  pipeableType: (type: ts.Type, atLocation: ts.Node) => Nano.Nano<ts.Type, TypeParserIssue, never>\n  pipeCall: (\n    node: ts.Node\n  ) => Nano.Nano<\n    { node: ts.CallExpression; subject: ts.Expression; args: Array<ts.Expression>; kind: \"pipe\" | \"pipeable\" },\n    TypeParserIssue,\n    never\n  >\n  scopeType: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<ts.Type, TypeParserIssue>\n  promiseLike: (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) => Nano.Nano<{ type: ts.Type }, TypeParserIssue>\n  extendsEffectService: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      args: ts.NodeArray<ts.Expression>\n      Identifier: ts.Type\n      Service: ts.Type\n      accessors: boolean | undefined\n      dependencies: ts.NodeArray<ts.Expression> | undefined\n      keyStringLiteral: ts.StringLiteral | undefined\n      options: ts.Expression\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsContextTag: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      args: ts.NodeArray<ts.Expression>\n      Identifier: ts.Type\n      keyStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsEffectTag: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      args: ts.NodeArray<ts.Expression>\n      Identifier: ts.Type\n      Service: ts.Type\n      keyStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsSchemaClass: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsSchemaTaggedClass: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      keyStringLiteral: ts.StringLiteral | undefined\n      tagStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsSchemaTaggedError: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      keyStringLiteral: ts.StringLiteral | undefined\n      tagStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsSchemaTaggedRequest: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      selfTypeNode: ts.TypeNode\n      keyStringLiteral: ts.StringLiteral | undefined\n      tagStringLiteral: ts.StringLiteral | undefined\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsDataTaggedError: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      keyStringLiteral: ts.StringLiteral | undefined\n      Data: ts.Node\n    },\n    TypeParserIssue,\n    never\n  >\n  extendsDataTaggedClass: (atLocation: ts.ClassDeclaration) => Nano.Nano<\n    {\n      className: ts.Identifier\n      keyStringLiteral: ts.StringLiteral | undefined\n      Data: ts.Node\n    },\n    TypeParserIssue,\n    never\n  >\n}\nexport const TypeParser = Nano.Tag<TypeParser>(\"@effect/language-service/TypeParser\")\n\nexport const nanoLayer = <A, E, R>(\n  fa: Nano.Nano<A, E, R>\n) =>\n  Nano.gen(function*() {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n\n    return yield* pipe(\n      fa,\n      Nano.provideService(TypeParser, make(ts, tsUtils, typeChecker, typeCheckerUtils, program))\n    )\n  })\n\nexport class TypeParserIssue {\n  readonly _tag = \"@effect/language-service/TypeParserIssue\"\n  static issue = Nano.fail(new TypeParserIssue())\n}\n\nexport function typeParserIssue(\n  _message: string,\n  _type?: ts.Type | undefined,\n  _node?: ts.Node | undefined\n): Nano.Nano<never, TypeParserIssue, never> {\n  return TypeParserIssue.issue\n}\n\nexport function make(\n  ts: TypeScriptApi.TypeScriptApi,\n  tsUtils: TypeScriptUtils.TypeScriptUtils,\n  typeChecker: TypeCheckerApi.TypeCheckerApi,\n  typeCheckerUtils: TypeCheckerUtils.TypeCheckerUtils,\n  program: TypeScriptApi.TypeScriptProgram\n): TypeParser {\n  const getSourceFilePackageInfo = Nano.cachedBy(\n    Nano.fn(\"TypeParser.getSourceFilePackageInfo\")(function*(sourceFile: ts.SourceFile) {\n      return tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile)\n    }),\n    `TypeParser.getSourceFilePackageInfo`,\n    (sourceFile) => sourceFile\n  )\n\n  const getSourceFilesDeclaringSymbolModule = (\n    packageName: string\n  ) =>\n    Nano.cachedBy(\n      Nano.fn(\"TypeParser.getSourceFilesDeclaringSymbolModule\")(function*(symbol: ts.Symbol) {\n        const result: Array<ts.SourceFile> = []\n        if (!symbol.declarations) return yield* typeParserIssue(\"Symbol has no declarations\", undefined, undefined)\n        for (const sourceFile of symbol.declarations) {\n          if (!ts.isSourceFile(sourceFile)) continue\n          const packageInfo = yield* getSourceFilePackageInfo(sourceFile)\n          if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue\n          result.push(sourceFile)\n        }\n        if (result.length > 0) {\n          return result\n        }\n        return yield* typeParserIssue(`Symbol has no source file declarations`, undefined, undefined)\n      }),\n      `TypeParser.getSourceFilesDeclaringSymbolModule(${packageName})`,\n      (symbol) => symbol\n    )\n\n  const isSymbolReferenceToPackageModule = <T, E, R>(\n    givenSymbol: ts.Symbol,\n    packageName: string,\n    checkSourceFile: (sourceFile: ts.SourceFile) => Nano.Nano<T, E, R>\n  ) => {\n    let symbol = givenSymbol\n    while (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = typeChecker.getAliasedSymbol(symbol)\n    }\n    return pipe(\n      getSourceFilesDeclaringSymbolModule(packageName)(symbol),\n      Nano.flatMap((sourceFiles) =>\n        Nano.firstSuccessOf(\n          sourceFiles.map((_) => checkSourceFile(_))\n        )\n      )\n    )\n  }\n\n  const isNodeReferenceToPackageModule = <T, E, R>(\n    givenNode: ts.Node,\n    packageName: string,\n    isCorrectSourceFile: (\n      sourceFile: ts.SourceFile\n    ) => Nano.Nano<T, E, R>\n  ) => {\n    const symbol = typeChecker.getSymbolAtLocation(givenNode)\n    if (!symbol) return typeParserIssue(\"Node has no symbol\", undefined, givenNode)\n    return isSymbolReferenceToPackageModule(symbol, packageName, isCorrectSourceFile)\n  }\n\n  const getSourceFilesDeclaringSymbolExportedUnderPackageModule = (\n    packageName: string,\n    memberName: string\n  ) =>\n    Nano.cachedBy(\n      Nano.fn(\"TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember\")(function*(symbol: ts.Symbol) {\n        const result: Array<{ memberSymbol: ts.Symbol; moduleSymbol: ts.Symbol; sourceFile: ts.SourceFile }> = []\n        if (!symbol.declarations) return yield* typeParserIssue(\"Symbol has no declarations\", undefined, undefined)\n        for (const declaration of symbol.declarations) {\n          const sourceFile = tsUtils.getSourceFileOfNode(declaration)\n          if (!sourceFile) continue\n          const packageInfo = yield* getSourceFilePackageInfo(sourceFile)\n          if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue\n          const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile)\n          if (!moduleSymbol) continue\n          const memberSymbol = typeChecker.tryGetMemberInModuleExports(memberName, moduleSymbol)\n          if (memberSymbol && memberSymbol === symbol) result.push({ memberSymbol, moduleSymbol, sourceFile })\n        }\n        if (result.length > 0) {\n          return result\n        }\n        return yield* typeParserIssue(`Symbol has no declarations`, undefined, undefined)\n      }),\n      `TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember(${packageName}, ${memberName})`,\n      (sym) => sym\n    )\n\n  const isSymbolExportOfPackageModule = <T, E, R>(\n    givenSymbol: ts.Symbol,\n    packageName: string,\n    memberName: string,\n    checkSourceFile: (sourceFile: ts.SourceFile, moduleSymbol: ts.Symbol, memberSymbol: ts.Symbol) => Nano.Nano<T, E, R>\n  ) => {\n    let symbol = givenSymbol\n    while (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = typeChecker.getAliasedSymbol(symbol)\n    }\n    return pipe(\n      getSourceFilesDeclaringSymbolExportedUnderPackageModule(packageName, memberName)(symbol),\n      Nano.flatMap((sourceFiles) =>\n        Nano.firstSuccessOf(\n          sourceFiles.map((_) => checkSourceFile(_.sourceFile, _.moduleSymbol, _.memberSymbol))\n        )\n      )\n    )\n  }\n\n  const isNodeReferenceToExportOfPackageModule = <T, E, R>(\n    givenNode: ts.Node,\n    packageName: string,\n    isCorrectSourceFile: (\n      sourceFile: ts.SourceFile,\n      moduleSymbol: ts.Symbol,\n      memberSymbol: ts.Symbol\n    ) => Nano.Nano<T, E, R>,\n    memberName: string\n  ) => {\n    const symbol = typeChecker.getSymbolAtLocation(givenNode)\n    if (!symbol) return typeParserIssue(\"Node has no symbol\", undefined, givenNode)\n    return isSymbolExportOfPackageModule(symbol, packageName, memberName, isCorrectSourceFile)\n  }\n\n  function covariantTypeArgument(type: ts.Type): Nano.Nano<ts.Type, TypeParserIssue> {\n    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n    // Covariant<A> has only 1 type signature\n    if (signatures.length !== 1) {\n      return typeParserIssue(\"Covariant type has no call signature\", type)\n    }\n    // get the return type\n    return Nano.succeed(typeChecker.getReturnTypeOfSignature(signatures[0]))\n  }\n\n  function contravariantTypeArgument(type: ts.Type): Nano.Nano<ts.Type, TypeParserIssue> {\n    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n    // Contravariant<A> has only 1 type signature\n    if (signatures.length !== 1) {\n      return typeParserIssue(\"Contravariant type has no call signature\", type)\n    }\n    // get the return type\n    return Nano.succeed(typeCheckerUtils.getTypeParameterAtPosition(signatures[0], 0))\n  }\n\n  function invariantTypeArgument(type: ts.Type): Nano.Nano<ts.Type, TypeParserIssue> {\n    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n    // Invariant<A> has only 1 type signature\n    if (signatures.length !== 1) {\n      return typeParserIssue(\"Invariant type has no call signature\", type)\n    }\n    // get the return type\n    return Nano.succeed(typeChecker.getReturnTypeOfSignature(signatures[0]))\n  }\n\n  const pipeableType = Nano.cachedBy(\n    function(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // Pipeable has a pipe property on the type\n      const pipeSymbol = typeChecker.getPropertyOfType(type, \"pipe\")\n      if (!pipeSymbol) {\n        return typeParserIssue(\"Type has no 'pipe' property\", type, atLocation)\n      }\n      // which should be callable with at least one call signature\n      const pipeType = typeChecker.getTypeOfSymbolAtLocation(pipeSymbol, atLocation)\n      const signatures = typeChecker.getSignaturesOfType(pipeType, ts.SignatureKind.Call)\n      if (signatures.length === 0) {\n        return typeParserIssue(\"'pipe' property is not callable\", type, atLocation)\n      }\n      return Nano.succeed(type)\n    },\n    \"TypeParser.pipeableType\",\n    (type) => type\n  )\n\n  const varianceStructCovariantType = <A extends string>(\n    type: ts.Type,\n    atLocation: ts.Node,\n    propertyName: A\n  ) => {\n    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName)\n    if (!propertySymbol) {\n      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation)\n    }\n    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n    return covariantTypeArgument(propertyType)\n  }\n\n  const varianceStructContravariantType = <A extends string>(\n    type: ts.Type,\n    atLocation: ts.Node,\n    propertyName: A\n  ) => {\n    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName)\n    if (!propertySymbol) {\n      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation)\n    }\n    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n    return contravariantTypeArgument(propertyType)\n  }\n\n  const varianceStructInvariantType = <A extends string>(\n    type: ts.Type,\n    atLocation: ts.Node,\n    propertyName: A\n  ) => {\n    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName)\n    if (!propertySymbol) {\n      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation)\n    }\n    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n    return invariantTypeArgument(propertyType)\n  }\n\n  const effectVarianceStruct = (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) =>\n    Nano.map(\n      Nano.all(\n        varianceStructCovariantType(type, atLocation, \"_A\"),\n        varianceStructCovariantType(type, atLocation, \"_E\"),\n        varianceStructCovariantType(type, atLocation, \"_R\")\n      ),\n      ([A, E, R]) => ({ A, E, R })\n    )\n\n  const layerVarianceStruct = (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) =>\n    Nano.map(\n      Nano.all(\n        varianceStructContravariantType(type, atLocation, \"_ROut\"),\n        varianceStructCovariantType(type, atLocation, \"_E\"),\n        varianceStructCovariantType(type, atLocation, \"_RIn\")\n      ),\n      ([ROut, E, RIn]) => ({ ROut, E, RIn })\n    )\n\n  const effectType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.effectType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      let result: Nano.Nano<\n        {\n          A: ts.Type\n          E: ts.Type\n          R: ts.Type\n        },\n        TypeParserIssue,\n        never\n      > = typeParserIssue(\"Type has no effect variance struct\", type, atLocation)\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) =>\n        ts.symbolName(b).indexOf(\"EffectTypeId\") - ts.symbolName(a).indexOf(\"EffectTypeId\")\n      )\n      // has a property symbol which is an effect variance struct\n      for (const propertySymbol of propertiesSymbols) {\n        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n        result = pipe(result, Nano.orElse(() => effectVarianceStruct(propertyType, atLocation)))\n      }\n      return yield* result\n    }),\n    \"TypeParser.effectType\",\n    (type) => type\n  )\n\n  const strictEffectType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.strictEffectType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // symbol name should be Effect\n      if (!(type.symbol && ts.symbolName(type.symbol) === \"Effect\" && !type.aliasSymbol)) {\n        return yield* typeParserIssue(\"Type name should be Effect with no alias symbol\", type, atLocation)\n      }\n      // should be an effect\n      return yield* effectType(type, atLocation)\n    }),\n    \"TypeParser.strictEffectType\",\n    (type) => type\n  )\n\n  const isEffectTypeSourceFile = Nano.cachedBy(\n    Nano.fn(\"TypeParser.isEffectTypeSourceFile\")(function*(\n      sourceFile: ts.SourceFile\n    ) {\n      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile)\n      if (!moduleSymbol) return yield* typeParserIssue(\"Node has no symbol\", undefined, sourceFile)\n      const effectTypeSymbol = typeChecker.tryGetMemberInModuleExports(\"Effect\", moduleSymbol)\n      if (!effectTypeSymbol) return yield* typeParserIssue(\"Effect type not found\", undefined, sourceFile)\n      const type = typeChecker.getDeclaredTypeOfSymbol(effectTypeSymbol)\n      yield* effectType(type, sourceFile)\n      return sourceFile\n    }),\n    \"TypeParser.isEffectTypeSourceFile\",\n    (sourceFile) => sourceFile\n  )\n\n  const isNodeReferenceToEffectModuleApi = (memberName: string) =>\n    Nano.cachedBy(\n      Nano.fn(\"TypeParser.isNodeReferenceToEffectModuleApi\")(function*(\n        node: ts.Node\n      ) {\n        return yield* isNodeReferenceToExportOfPackageModule(node, \"effect\", isEffectTypeSourceFile, memberName)\n      }),\n      `TypeParser.isNodeReferenceToEffectModuleApi(${memberName})`,\n      (node) => node\n    )\n\n  const layerType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.layerType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // should be pipeable\n      yield* pipeableType(type, atLocation)\n\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) =>\n        ts.symbolName(b).indexOf(\"LayerTypeId\") - ts.symbolName(a).indexOf(\"LayerTypeId\")\n      )\n      // has a property symbol which is a layer variance struct\n      for (const propertySymbol of propertiesSymbols) {\n        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n        const varianceArgs = yield* Nano.option(layerVarianceStruct(\n          propertyType,\n          atLocation\n        ))\n        if (Option.isSome(varianceArgs)) {\n          return varianceArgs.value\n        }\n      }\n      return yield* typeParserIssue(\"Type has no layer variance struct\", type, atLocation)\n    }),\n    \"TypeParser.layerType\",\n    (type) => type\n  )\n\n  const fiberType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.fiberType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // there is no better way to check if a type is a fiber right not\n      // so we just check for the existence of the property \"await\" and \"poll\"\n      const awaitSymbol = typeChecker.getPropertyOfType(type, \"await\")\n      const pollSymbol = typeChecker.getPropertyOfType(type, \"poll\")\n      if (!awaitSymbol || !pollSymbol) {\n        return yield* typeParserIssue(\n          \"Type is not a fiber because it does not have 'await' or 'poll' property\",\n          type,\n          atLocation\n        )\n      }\n      // and it is also an effect itself\n      return yield* effectType(type, atLocation)\n    }),\n    \"TypeParser.fiberType\",\n    (type) => type\n  )\n\n  const effectSubtype = Nano.cachedBy(\n    Nano.fn(\"TypeParser.effectSubtype\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // there is no better way to check if a type is a subtype of effect\n      // so we just check for the existence of the property \"_tag\"\n      // which is common for Option, Either, and others\n      // and other datatypes as \"Pool\" have \"get\"\n      const tagSymbol = typeChecker.getPropertyOfType(type, \"_tag\")\n      const getSymbol = typeChecker.getPropertyOfType(type, \"get\")\n      if (!(tagSymbol || getSymbol)) {\n        return yield* typeParserIssue(\n          \"Type is not a subtype of effect because it does not have '_tag' or 'get' property\",\n          type,\n          atLocation\n        )\n      }\n      // and it is also an effect itself\n      return yield* effectType(type, atLocation)\n    }),\n    \"TypeParser.effectSubtype\",\n    (type) => type\n  )\n\n  const importedContextModule = Nano.cachedBy(\n    Nano.fn(\"TypeParser.importedContextModule\")(function*(\n      node: ts.Node\n    ) {\n      const type = typeChecker.getTypeAtLocation(node)\n      // if the type has a property \"Tag\" that is a function\n      const propertySymbol = typeChecker.getPropertyOfType(type, \"Tag\")\n      if (!propertySymbol) {\n        return yield* typeParserIssue(\"Type has no 'Tag' property\", type, node)\n      }\n      // should be an expression\n      if (!ts.isIdentifier(node)) {\n        return yield* typeParserIssue(\"Node is not an identifier\", type, node)\n      }\n      const sourceFile = tsUtils.getSourceFileOfNode(node)\n      if (!sourceFile) {\n        return yield* typeParserIssue(\"Node is not in a source file\", undefined, node)\n      }\n      const contextIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n        sourceFile,\n        \"effect\",\n        \"Context\"\n      )\n      if (!contextIdentifier) {\n        return yield* typeParserIssue(\"Context module not found\", undefined, node)\n      }\n      if (ts.idText(node) !== contextIdentifier) {\n        return yield* typeParserIssue(\"Node is not a context module reference\", undefined, node)\n      }\n      // return the node itself\n      return node\n    }),\n    \"TypeParser.importedContextModule\",\n    (node) => node\n  )\n\n  const importedEffectModule = (node: ts.Node) =>\n    pipe(\n      isNodeReferenceToPackageModule(node, \"effect\", isEffectTypeSourceFile),\n      Nano.map(() => node)\n    )\n\n  const importedDataModule = Nano.cachedBy(\n    Nano.fn(\"TypeParser.importedDataModule\")(function*(\n      node: ts.Node\n    ) {\n      const type = typeChecker.getTypeAtLocation(node)\n      // if the type has a property \"TaggedError\" that is a function\n      const propertySymbol = typeChecker.getPropertyOfType(type, \"TaggedError\")\n      if (!propertySymbol) {\n        return yield* typeParserIssue(\"Type has no 'TaggedError' property\", type, node)\n      }\n      // should be an expression\n      if (!ts.isIdentifier(node)) {\n        return yield* typeParserIssue(\"Node is not an expression\", type, node)\n      }\n      const sourceFile = tsUtils.getSourceFileOfNode(node)\n      if (!sourceFile) {\n        return yield* typeParserIssue(\"Node is not in a source file\", undefined, node)\n      }\n      const dataIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n        sourceFile,\n        \"effect\",\n        \"Data\"\n      )\n      if (!dataIdentifier) {\n        return yield* typeParserIssue(\"Data module not found\", undefined, node)\n      }\n      if (ts.idText(node) !== dataIdentifier) {\n        return yield* typeParserIssue(\"Node is not a data module reference\", undefined, node)\n      }\n      // return the node itself\n      return node\n    }),\n    \"TypeParser.importedDataModule\",\n    (node) => node\n  )\n\n  const effectGen = Nano.cachedBy(\n    function(node: ts.Node) {\n      // Effect.gen(...)\n      if (!ts.isCallExpression(node)) {\n        return typeParserIssue(\"Node is not a call expression\", undefined, node)\n      }\n      // ...\n      if (node.arguments.length === 0) {\n        return typeParserIssue(\"Node has no arguments\", undefined, node)\n      }\n      // firsta argument is a generator function expression\n      const generatorFunction = node.arguments[0]\n      if (!ts.isFunctionExpression(generatorFunction)) {\n        return typeParserIssue(\"Node is not a function expression\", undefined, node)\n      }\n      if (generatorFunction.asteriskToken === undefined) {\n        return typeParserIssue(\"Node is not a generator function\", undefined, node)\n      }\n      // Effect.gen\n      if (!ts.isPropertyAccessExpression(node.expression)) {\n        return typeParserIssue(\"Node is not a property access expression\", undefined, node)\n      }\n      const propertyAccess = node.expression\n      return pipe(\n        isNodeReferenceToEffectModuleApi(\"gen\")(propertyAccess),\n        Nano.map(() => ({\n          node,\n          effectModule: propertyAccess.expression,\n          generatorFunction,\n          body: generatorFunction.body\n        }))\n      )\n    },\n    \"TypeParser.effectGen\",\n    (node) => node\n  )\n\n  const effectFnUntracedGen = Nano.cachedBy(\n    function(node: ts.Node) {\n      // Effect.gen(...)\n      if (!ts.isCallExpression(node)) {\n        return typeParserIssue(\"Node is not a call expression\", undefined, node)\n      }\n      // ...\n      if (node.arguments.length === 0) {\n        return typeParserIssue(\"Node has no arguments\", undefined, node)\n      }\n      // firsta argument is a generator function expression\n      const generatorFunction = node.arguments[0]\n      if (!ts.isFunctionExpression(generatorFunction)) {\n        return typeParserIssue(\"Node is not a function expression\", undefined, node)\n      }\n      if (generatorFunction.asteriskToken === undefined) {\n        return typeParserIssue(\n          \"Node is not a generator function\",\n          undefined,\n          node\n        )\n      }\n      // Effect.gen\n      if (!ts.isPropertyAccessExpression(node.expression)) {\n        return typeParserIssue(\n          \"Node is not a property access expression\",\n          undefined,\n          node\n        )\n      }\n      const propertyAccess = node.expression\n      return pipe(\n        isNodeReferenceToEffectModuleApi(\"fnUntraced\")(propertyAccess),\n        Nano.map(() => ({\n          node,\n          effectModule: propertyAccess.expression,\n          generatorFunction,\n          body: generatorFunction.body\n        }))\n      )\n    },\n    \"TypeParser.effectFnUntracedGen\",\n    (node) => node\n  )\n\n  const effectFnGen = Nano.cachedBy(\n    function(node: ts.Node) {\n      // Effect.fn(...)\n      if (!ts.isCallExpression(node)) {\n        return typeParserIssue(\"Node is not a call expression\", undefined, node)\n      }\n      // ...\n      if (node.arguments.length === 0) {\n        return typeParserIssue(\"Node has no arguments\", undefined, node)\n      }\n      // firsta argument is a generator function expression\n      const generatorFunction = node.arguments[0]\n      if (!ts.isFunctionExpression(generatorFunction)) {\n        return typeParserIssue(\n          \"Node is not a function expression\",\n          undefined,\n          node\n        )\n      }\n      if (generatorFunction.asteriskToken === undefined) {\n        return typeParserIssue(\n          \"Node is not a generator function\",\n          undefined,\n          node\n        )\n      }\n      // either we are using Effect.fn(\"name\")(generatorFunction) or we are using Effect.fn(generatorFunction)\n      const expressionToTest = ts.isCallExpression(node.expression)\n        ? node.expression.expression\n        : node.expression\n      if (!ts.isPropertyAccessExpression(expressionToTest)) {\n        return typeParserIssue(\n          \"Node is not a property access expression\",\n          undefined,\n          node\n        )\n      }\n      const propertyAccess = expressionToTest\n      return pipe(\n        isNodeReferenceToEffectModuleApi(\"fn\")(propertyAccess),\n        Nano.map(() => ({\n          node,\n          generatorFunction,\n          effectModule: propertyAccess.expression,\n          body: generatorFunction.body\n        }))\n      )\n    },\n    \"TypeParser.effectFnGen\",\n    (node) => node\n  )\n\n  const unnecessaryEffectGen = Nano.cachedBy(\n    Nano.fn(\"TypeParser.unnecessaryEffectGen\")(function*(\n      node: ts.Node\n    ) {\n      // ensure is an effect gen with a single statement\n      const { body } = yield* effectGen(node)\n      if (body.statements.length !== 1) {\n        return yield* typeParserIssue(\n          \"Generator body should have a single statement\",\n          undefined,\n          node\n        )\n      }\n\n      let explicitReturn = false\n      let nodeToCheck: ts.Node = body.statements[0]\n      while (nodeToCheck) {\n        // return XXX\n        if (ts.isReturnStatement(nodeToCheck) && nodeToCheck.expression) {\n          nodeToCheck = nodeToCheck.expression\n          explicitReturn = true\n          continue\n        }\n        // expression yield*\n        if (ts.isExpressionStatement(nodeToCheck)) {\n          nodeToCheck = nodeToCheck.expression\n          continue\n        }\n        // yield* XXX\n        if (ts.isYieldExpression(nodeToCheck) && nodeToCheck.asteriskToken && nodeToCheck.expression) {\n          const yieldedExpression = nodeToCheck.expression\n          const type = typeChecker.getTypeAtLocation(yieldedExpression)\n          const { A: successType } = yield* effectType(type, yieldedExpression)\n          let replacementNode: Nano.Nano<ts.Node> = Nano.succeed(yieldedExpression)\n          if (!explicitReturn && !(successType.flags & ts.TypeFlags.VoidLike)) {\n            replacementNode = pipe(\n              Nano.gen(function*() {\n                const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n                  node.getSourceFile(),\n                  \"effect\",\n                  \"Effect\"\n                ) || \"Effect\"\n\n                return ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    ts.factory.createIdentifier(effectIdentifier),\n                    \"asVoid\"\n                  ),\n                  undefined,\n                  [\n                    yieldedExpression\n                  ]\n                )\n              }),\n              Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n            )\n          }\n          return { node, body, yieldedExpression, replacementNode }\n        }\n        // fall through\n        break\n      }\n\n      // fall through case\n      return yield* typeParserIssue(\n        \"Not an handled node\",\n        undefined,\n        node\n      )\n    }),\n    \"TypeParser.unnecessaryEffectGen\",\n    (node) => node\n  )\n\n  const effectSchemaVarianceStruct = (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) =>\n    Nano.map(\n      Nano.all(\n        varianceStructInvariantType(type, atLocation, \"_A\"),\n        varianceStructInvariantType(type, atLocation, \"_I\"),\n        varianceStructCovariantType(type, atLocation, \"_R\")\n      ),\n      ([A, I, R]) => ({ A, I, R })\n    )\n\n  const effectSchemaType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.effectSchemaType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // should be pipeable\n      yield* pipeableType(type, atLocation)\n      // should have an 'ast' property\n      const ast = typeChecker.getPropertyOfType(type, \"ast\")\n      if (!ast) return yield* typeParserIssue(\"Has no 'ast' property\", type, atLocation)\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf(\"TypeId\") - ts.symbolName(a).indexOf(\"TypeId\"))\n      // has a property symbol which is an effect variance struct\n      for (const propertySymbol of propertiesSymbols) {\n        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n        const varianceArgs = yield* Nano.option(effectSchemaVarianceStruct(\n          propertyType,\n          atLocation\n        ))\n        if (Option.isSome(varianceArgs)) {\n          return varianceArgs.value\n        }\n      }\n      return yield* typeParserIssue(\"Type has no schema variance struct\", type, atLocation)\n    }),\n    \"TypeParser.effectSchemaType\",\n    (type) => type\n  )\n\n  const isEffectSchemaTypeSourceFile = Nano.cachedBy(\n    Nano.fn(\"TypeParser.isEffectSchemaTypeSourceFile\")(function*(\n      sourceFile: ts.SourceFile\n    ) {\n      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile)\n      if (!moduleSymbol) return yield* typeParserIssue(\"Node has no symbol\", undefined, sourceFile)\n      const typeSymbol = typeChecker.tryGetMemberInModuleExports(\"Schema\", moduleSymbol)\n      if (!typeSymbol) return yield* typeParserIssue(\"Schema type not found\", undefined, sourceFile)\n      const type = typeChecker.getDeclaredTypeOfSymbol(typeSymbol)\n      yield* effectSchemaType(type, sourceFile)\n      return sourceFile\n    }),\n    \"TypeParser.isEffectSchemaTypeSourceFile\",\n    (sourceFile) => sourceFile\n  )\n\n  const isNodeReferenceToEffectSchemaModuleApi = (memberName: string) =>\n    Nano.cachedBy(\n      Nano.fn(\"TypeParser.isNodeReferenceToEffectSchemaModuleApi\")(function*(\n        node: ts.Node\n      ) {\n        return yield* isNodeReferenceToExportOfPackageModule(node, \"effect\", isEffectSchemaTypeSourceFile, memberName)\n      }),\n      `TypeParser.isNodeReferenceToEffectSchemaModuleApi(${memberName})`,\n      (node) => node\n    )\n\n  const contextTagVarianceStruct = (\n    type: ts.Type,\n    atLocation: ts.Node\n  ) =>\n    Nano.map(\n      Nano.all(\n        varianceStructInvariantType(type, atLocation, \"_Identifier\"),\n        varianceStructInvariantType(type, atLocation, \"_Service\")\n      ),\n      ([Identifier, Service]) => ({ Identifier, Service })\n    )\n\n  const contextTag = Nano.cachedBy(\n    Nano.fn(\"TypeParser.contextTag\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // should be pipeable\n      yield* pipeableType(type, atLocation)\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf(\"TypeId\") - ts.symbolName(a).indexOf(\"TypeId\"))\n      // has a property symbol which is an effect variance struct\n      for (const propertySymbol of propertiesSymbols) {\n        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation)\n        const varianceArgs = yield* Nano.option(contextTagVarianceStruct(\n          propertyType,\n          atLocation\n        ))\n        if (Option.isSome(varianceArgs)) {\n          return varianceArgs.value\n        }\n      }\n      return yield* typeParserIssue(\"Type has no tag variance struct\", type, atLocation)\n    }),\n    \"TypeParser.contextTag\",\n    (type) => type\n  )\n\n  const pipeCall = Nano.cachedBy(\n    function(\n      node: ts.Node\n    ): Nano.Nano<\n      { node: ts.CallExpression; subject: ts.Expression; args: Array<ts.Expression>; kind: \"pipe\" | \"pipeable\" },\n      TypeParserIssue,\n      never\n    > {\n      // expression.pipe(.....)\n      if (\n        ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) &&\n        ts.isIdentifier(node.expression.name) &&\n        ts.idText(node.expression.name) === \"pipe\"\n      ) {\n        return Nano.succeed({\n          node,\n          subject: node.expression.expression,\n          args: Array.from(node.arguments),\n          kind: \"pipeable\"\n        })\n      }\n\n      // pipe(A, B, ...)\n      if (\n        ts.isCallExpression(node) && ts.isIdentifier(node.expression) && ts.idText(node.expression) === \"pipe\" &&\n        node.arguments.length > 0\n      ) {\n        const [subject, ...args] = node.arguments\n        return Nano.succeed({ node, subject, args, kind: \"pipe\" })\n      }\n\n      return typeParserIssue(\"Node is not a pipe call\", undefined, node)\n    },\n    \"TypeParser.pipeCall\",\n    (node) => node\n  )\n\n  const scopeType = Nano.cachedBy(\n    Nano.fn(\"TypeParser.scopeType\")(function*(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // should be pipeable\n      yield* pipeableType(type, atLocation)\n      // get the properties to check (exclude non-property and optional properties)\n      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter((_) =>\n        _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration &&\n        ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)\n      )\n      // try to put typeid first (heuristic to optimize hot path)\n      propertiesSymbols.sort((a, b) =>\n        ts.symbolName(b).indexOf(\"ScopeTypeId\") - ts.symbolName(a).indexOf(\"ScopeTypeId\")\n      )\n      // has a property scope type id\n      for (const propertySymbol of propertiesSymbols) {\n        const computedPropertyExpression: ts.ComputedPropertyName = (propertySymbol.valueDeclaration as any).name\n        const symbol = typeChecker.getSymbolAtLocation(computedPropertyExpression.expression)\n        if (symbol && ts.symbolName(symbol) === \"ScopeTypeId\") {\n          return type\n        }\n      }\n      return yield* typeParserIssue(\"Type has no scope type id\", type, atLocation)\n    }),\n    \"TypeParser.scopeType\",\n    (type) => type\n  )\n\n  const promiseLike = Nano.cachedBy(\n    function(\n      type: ts.Type,\n      atLocation: ts.Node\n    ) {\n      // maybe it is a Promise<A>?\n      const thenProperty = type.getProperty(\"then\")\n      if (!thenProperty) return typeParserIssue(\"not a promise - missing then property\", type, atLocation)\n      const thenType = typeChecker.getTypeOfSymbolAtLocation(thenProperty, atLocation)\n      if (!thenType) return typeParserIssue(\"not a promise - missing then property\", type, atLocation)\n      // .then should be callable\n      for (const callSignature of typeChecker.getSignaturesOfType(thenType, ts.SignatureKind.Call)) {\n        // take the callback argument of then\n        const parameter = callSignature.parameters[0]\n        if (!parameter) continue\n        const parameterType = typeCheckerUtils.getTypeParameterAtPosition(callSignature, 0)\n        if (!parameterType) continue\n        // it can be an union with many types\n        let callbackCallSignatures: Array<ts.Signature> = []\n        let toTest = [parameterType]\n        while (toTest.length > 0) {\n          const type = toTest.shift()\n          if (!type) continue\n          const callSignatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call)\n          callbackCallSignatures = callbackCallSignatures.concat(callSignatures)\n          if (typeCheckerUtils.isUnion(type)) {\n            toTest = toTest.concat(type.types)\n          }\n        }\n        for (const callableType of callbackCallSignatures) {\n          const callbackParameter = callableType.parameters[0]\n          if (!callbackParameter) {\n            continue\n          }\n          const callbackParameterType = typeCheckerUtils.getTypeParameterAtPosition(callableType, 0)\n          if (!callbackParameterType) {\n            continue\n          }\n          return Nano.succeed({\n            type: callbackParameterType\n          })\n        }\n      }\n      return typeParserIssue(\"not a promise\", type, atLocation)\n    },\n    \"TypeParser.promiseLike\",\n    (type) => type\n  )\n\n  const extendsSchemaClass = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsSchemaClass\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Schema.Class<T>(\"name\")({})\n              const schemaCall = expression.expression\n              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {\n                const isEffectSchemaModuleApi = yield* pipe(\n                  isNodeReferenceToEffectSchemaModuleApi(\"Class\")(schemaCall.expression),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectSchemaModuleApi)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode: schemaCall.typeArguments[0]!\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Schema.Class\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsSchemaClass\",\n    (atLocation) => atLocation\n  )\n\n  const extendsSchemaTaggedClass = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsSchemaTaggedClass\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Schema.TaggedClass<T>(\"name\")(\"tag\", {})\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression) && expression.arguments.length > 0) {\n              // Schema.TaggedClass<T>(\"name\")\n              const schemaTaggedClassTCall = expression.expression\n              if (\n                ts.isCallExpression(schemaTaggedClassTCall) && schemaTaggedClassTCall.typeArguments &&\n                schemaTaggedClassTCall.typeArguments.length > 0\n              ) {\n                const selfTypeNode = schemaTaggedClassTCall.typeArguments[0]!\n                const isEffectSchemaModuleApi = yield* pipe(\n                  isNodeReferenceToEffectSchemaModuleApi(\"TaggedClass\")(schemaTaggedClassTCall.expression),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectSchemaModuleApi)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode,\n                    keyStringLiteral: schemaTaggedClassTCall.arguments.length > 0 &&\n                        ts.isStringLiteral(schemaTaggedClassTCall.arguments[0])\n                      ? schemaTaggedClassTCall.arguments[0]\n                      : undefined,\n                    tagStringLiteral: expression.arguments.length > 0 &&\n                        ts.isStringLiteral(expression.arguments[0])\n                      ? expression.arguments[0]\n                      : undefined\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Schema.TaggedClass\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsSchemaTaggedClass\",\n    (atLocation) => atLocation\n  )\n\n  const extendsSchemaTaggedError = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsSchemaTaggedError\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Schema.TaggedError<T>(\"name\")(\"tag\", {})\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Schema.TaggedError<T>(\"name\")\n              const schemaTaggedErrorTCall = expression.expression\n              if (\n                ts.isCallExpression(schemaTaggedErrorTCall) && schemaTaggedErrorTCall.typeArguments &&\n                schemaTaggedErrorTCall.typeArguments.length > 0\n              ) {\n                const selfTypeNode = schemaTaggedErrorTCall.typeArguments[0]!\n                const isEffectSchemaModuleApi = yield* pipe(\n                  isNodeReferenceToEffectSchemaModuleApi(\"TaggedError\")(schemaTaggedErrorTCall.expression),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectSchemaModuleApi)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode,\n                    keyStringLiteral: schemaTaggedErrorTCall.arguments.length > 0 &&\n                        ts.isStringLiteral(schemaTaggedErrorTCall.arguments[0])\n                      ? schemaTaggedErrorTCall.arguments[0]\n                      : undefined,\n                    tagStringLiteral: expression.arguments.length > 0 &&\n                        ts.isStringLiteral(expression.arguments[0])\n                      ? expression.arguments[0]\n                      : undefined\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Schema.TaggedError\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsSchemaTaggedError\",\n    (atLocation) => atLocation\n  )\n\n  const extendsSchemaTaggedRequest = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsSchemaTaggedRequest\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Schema.TaggedRequest<T>(\"name\")(\"tag\", {})\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Schema.TaggedRequest<T>(\"name\")\n              const schemaTaggedRequestTCall = expression.expression\n              if (\n                ts.isCallExpression(schemaTaggedRequestTCall) &&\n                schemaTaggedRequestTCall.typeArguments &&\n                schemaTaggedRequestTCall.typeArguments.length > 0\n              ) {\n                const selfTypeNode = schemaTaggedRequestTCall.typeArguments[0]!\n                const isEffectSchemaModuleApi = yield* pipe(\n                  isNodeReferenceToEffectSchemaModuleApi(\"TaggedRequest\")(schemaTaggedRequestTCall.expression),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectSchemaModuleApi)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode,\n                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0])\n                      ? expression.arguments[0]\n                      : undefined,\n                    keyStringLiteral: schemaTaggedRequestTCall.arguments.length > 0 &&\n                        ts.isStringLiteral(schemaTaggedRequestTCall.arguments[0])\n                      ? schemaTaggedRequestTCall.arguments[0]\n                      : undefined\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Schema.TaggedRequest\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsSchemaTaggedRequest\",\n    (atLocation) => atLocation\n  )\n\n  const extendsDataTaggedError = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsDataTaggedError\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Data.TaggedError(\"name\")<{}>\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Data.TaggedError(\"name\")\n              const dataTaggedErrorCall = expression\n              // Data.TaggedError\n              const dataIdentifier = dataTaggedErrorCall.expression\n              if (\n                ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) &&\n                ts.idText(dataIdentifier.name) === \"TaggedError\"\n              ) {\n                const parsedDataModule = yield* pipe(\n                  importedDataModule(dataIdentifier.expression),\n                  Nano.option\n                )\n                if (Option.isSome(parsedDataModule)) {\n                  // For Data.TaggedError, the structure is: Data.TaggedError(\"name\")<{}>\n                  // The string literal is in the single call expression\n                  return {\n                    className: atLocation.name,\n                    keyStringLiteral: dataTaggedErrorCall.arguments.length > 0 &&\n                        ts.isStringLiteral(dataTaggedErrorCall.arguments[0])\n                      ? dataTaggedErrorCall.arguments[0]\n                      : undefined,\n                    Data: parsedDataModule.value\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Data.TaggedError\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsDataTaggedError\",\n    (atLocation) => atLocation\n  )\n\n  const extendsDataTaggedClass = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsDataTaggedClass\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            // Data.TaggedClass(\"name\")<{}>\n            const expression = typeX.expression\n            if (ts.isCallExpression(expression)) {\n              // Data.TaggedClass(\"name\")\n              const dataTaggedClassCall = expression\n              // Data.TaggedClass\n              const dataIdentifier = dataTaggedClassCall.expression\n              if (\n                ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) &&\n                ts.idText(dataIdentifier.name) === \"TaggedClass\"\n              ) {\n                const parsedDataModule = yield* pipe(\n                  importedDataModule(dataIdentifier.expression),\n                  Nano.option\n                )\n                if (Option.isSome(parsedDataModule)) {\n                  // For Data.TaggedClass, the structure is: Data.TaggedClass(\"name\")<{}>\n                  // The string literal is in the single call expression\n                  return {\n                    className: atLocation.name,\n                    keyStringLiteral: dataTaggedClassCall.arguments.length > 0 &&\n                        ts.isStringLiteral(dataTaggedClassCall.arguments[0])\n                      ? dataTaggedClassCall.arguments[0]\n                      : undefined,\n                    Data: parsedDataModule.value\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Data.TaggedClass\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsDataTaggedClass\",\n    (atLocation) => atLocation\n  )\n\n  const extendsContextTag = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsContextTag\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            const wholeCall = typeX.expression\n            if (ts.isCallExpression(wholeCall)) {\n              const contextTagCall = wholeCall.expression\n              if (\n                ts.isCallExpression(contextTagCall) &&\n                wholeCall.typeArguments && wholeCall.typeArguments.length > 0\n              ) {\n                const contextTagIdentifier = contextTagCall.expression\n                const selfTypeNode = wholeCall.typeArguments[0]!\n                if (\n                  ts.isPropertyAccessExpression(contextTagIdentifier) &&\n                  ts.isIdentifier(contextTagIdentifier.name) && ts.idText(contextTagIdentifier.name) === \"Tag\"\n                ) {\n                  const parsedContextModule = yield* pipe(\n                    importedContextModule(contextTagIdentifier.expression),\n                    Nano.option\n                  )\n                  if (Option.isSome(parsedContextModule)) {\n                    const classSym = typeChecker.getSymbolAtLocation(atLocation.name)\n                    if (!classSym) return yield* typeParserIssue(\"Class has no symbol\", undefined, atLocation)\n                    const type = typeChecker.getTypeOfSymbol(classSym)\n                    const tagType = yield* contextTag(type, atLocation)\n                    return {\n                      className: atLocation.name,\n                      selfTypeNode,\n                      keyStringLiteral: ts.isStringLiteral(contextTagCall.arguments[0])\n                        ? contextTagCall.arguments[0]\n                        : undefined,\n                      args: contextTagCall.arguments,\n                      Identifier: tagType.Identifier,\n                      Tag: parsedContextModule.value\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Context.Tag\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsContextTag\",\n    (atLocation) => atLocation\n  )\n\n  const extendsEffectTag = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsEffectTag\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      const classSym = typeChecker.getSymbolAtLocation(atLocation.name)\n      if (!classSym) return yield* typeParserIssue(\"Class has no symbol\", undefined, atLocation)\n      const type = typeChecker.getTypeOfSymbol(classSym)\n      const tagType = yield* contextTag(type, atLocation)\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            const wholeCall = typeX.expression\n            if (ts.isCallExpression(wholeCall)) {\n              const effectTagCall = wholeCall.expression\n              if (\n                ts.isCallExpression(effectTagCall) &&\n                wholeCall.typeArguments && wholeCall.typeArguments.length > 0\n              ) {\n                const effectTagIdentifier = effectTagCall.expression\n                const selfTypeNode = wholeCall.typeArguments[0]!\n                const isEffectTag = yield* pipe(\n                  isNodeReferenceToEffectModuleApi(\"Tag\")(effectTagIdentifier),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectTag)) {\n                  return {\n                    className: atLocation.name,\n                    selfTypeNode,\n                    keyStringLiteral: ts.isStringLiteral(effectTagCall.arguments[0])\n                      ? effectTagCall.arguments[0]\n                      : undefined,\n                    args: effectTagCall.arguments,\n                    Identifier: tagType.Identifier,\n                    Service: tagType.Service\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return yield* typeParserIssue(\"Class does not extend Effect.Tag\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsEffectTag\",\n    (atLocation) => atLocation\n  )\n\n  const extendsEffectService = Nano.cachedBy(\n    Nano.fn(\"TypeParser.extendsEffectService\")(function*(\n      atLocation: ts.ClassDeclaration\n    ) {\n      if (!atLocation.name) {\n        return yield* typeParserIssue(\"Class has no name\", undefined, atLocation)\n      }\n      const heritageClauses = atLocation.heritageClauses\n      if (!heritageClauses) {\n        return yield* typeParserIssue(\"Class has no heritage clauses\", undefined, atLocation)\n      }\n      for (const heritageClause of heritageClauses) {\n        for (const typeX of heritageClause.types) {\n          if (ts.isExpressionWithTypeArguments(typeX)) {\n            const wholeCall = typeX.expression\n            if (ts.isCallExpression(wholeCall)) {\n              const effectServiceCall = wholeCall.expression\n              if (\n                ts.isCallExpression(effectServiceCall) &&\n                effectServiceCall.typeArguments && effectServiceCall.typeArguments.length > 0\n              ) {\n                const effectServiceIdentifier = effectServiceCall.expression\n                const selfTypeNode = effectServiceCall.typeArguments[0]!\n                const isEffectService = yield* pipe(\n                  isNodeReferenceToEffectModuleApi(\"Service\")(effectServiceIdentifier),\n                  Nano.option\n                )\n                if (Option.isSome(isEffectService)) {\n                  const classSym = typeChecker.getSymbolAtLocation(atLocation.name)\n                  if (!classSym) return yield* typeParserIssue(\"Class has no symbol\", undefined, atLocation)\n                  const type = typeChecker.getTypeOfSymbol(classSym)\n                  const parsedContextTag = yield* pipe(\n                    contextTag(type, atLocation),\n                    Nano.option\n                  )\n                  if (Option.isSome(parsedContextTag)) {\n                    // try to parse some settings\n                    let accessors: boolean | undefined = undefined\n                    let dependencies: ts.NodeArray<ts.Expression> | undefined = undefined\n                    if (wholeCall.arguments.length >= 2) {\n                      const args = wholeCall.arguments[1]\n                      if (ts.isObjectLiteralExpression(args)) {\n                        for (const property of args.properties) {\n                          if (\n                            ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) &&\n                            ts.idText(property.name) === \"accessors\" && property.initializer &&\n                            property.initializer.kind === ts.SyntaxKind.TrueKeyword\n                          ) {\n                            accessors = true\n                          }\n                          if (\n                            ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) &&\n                            ts.idText(property.name) === \"dependencies\" && property.initializer &&\n                            ts.isArrayLiteralExpression(property.initializer)\n                          ) {\n                            dependencies = property.initializer.elements\n                          }\n                        }\n                      }\n                    }\n                    return ({\n                      ...parsedContextTag.value,\n                      className: atLocation.name,\n                      selfTypeNode,\n                      args: wholeCall.arguments,\n                      keyStringLiteral: ts.isStringLiteral(wholeCall.arguments[0])\n                        ? wholeCall.arguments[0]\n                        : undefined,\n                      options: wholeCall.arguments[1],\n                      accessors,\n                      dependencies\n                    })\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return yield* typeParserIssue(\"Class does not extend Effect.Service\", undefined, atLocation)\n    }),\n    \"TypeParser.extendsEffectService\",\n    (atLocation) => atLocation\n  )\n\n  return {\n    isNodeReferenceToEffectModuleApi,\n    effectType,\n    strictEffectType,\n    layerType,\n    fiberType,\n    effectSubtype,\n    importedEffectModule,\n    effectGen,\n    effectFnUntracedGen,\n    effectFnGen,\n    unnecessaryEffectGen,\n    effectSchemaType,\n    contextTag,\n    pipeableType,\n    pipeCall,\n    scopeType,\n    promiseLike,\n    extendsEffectTag,\n    extendsEffectService,\n    extendsContextTag,\n    extendsSchemaClass,\n    extendsSchemaTaggedClass,\n    extendsSchemaTaggedError,\n    extendsDataTaggedError,\n    extendsDataTaggedClass,\n    extendsSchemaTaggedRequest\n  }\n}\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const catchUnfailableEffect = LSP.createDiagnostic({\n  name: \"catchUnfailableEffect\",\n  code: 2,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"catchUnfailableEffect.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // Check if this is a call expression (cold expression)\n      if (ts.isCallExpression(node)) {\n        // Check if the call expression references any of the catch functions\n        const catchFunctions = [\"catchAll\", \"catch\", \"catchIf\", \"catchSome\", \"catchTag\", \"catchTags\"]\n        const isCatchCall = yield* pipe(\n          Nano.firstSuccessOf(\n            catchFunctions.map((catchFn) => typeParser.isNodeReferenceToEffectModuleApi(catchFn)(node.expression))\n          ),\n          Nano.option\n        )\n\n        if (Option.isSome(isCatchCall)) {\n          // Check if the parent is a pipe call\n          const parent = node.parent\n          if (parent && ts.isCallExpression(parent)) {\n            const pipeCallResult = yield* pipe(\n              typeParser.pipeCall(parent),\n              Nano.option\n            )\n\n            if (Option.isSome(pipeCallResult)) {\n              const { args, node: pipeCallNode, subject } = pipeCallResult.value\n\n              // Find the index of this node in the pipe arguments\n              const argIndex = args.findIndex((arg) => arg === node)\n\n              if (argIndex !== -1) {\n                let effectTypeToCheck: ts.Type | undefined\n\n                // Get the effect type based on argument index\n                if (argIndex === 0) {\n                  // If argIndex is 0, get the type from the subject\n                  effectTypeToCheck = typeChecker.getTypeAtLocation(subject)\n                } else {\n                  // If argIndex > 0, get the type from signature type arguments at argIndex\n                  const signature = typeChecker.getResolvedSignature(pipeCallNode)\n                  if (signature) {\n                    const typeArguments = typeChecker.getTypeArgumentsForResolvedSignature(signature)\n                    if (typeArguments && typeArguments.length > argIndex) {\n                      effectTypeToCheck = typeArguments[argIndex]\n                    }\n                  }\n                }\n\n                // Check if the effect type has error type never\n                if (effectTypeToCheck) {\n                  const effectType = yield* pipe(\n                    typeParser.effectType(effectTypeToCheck, node),\n                    Nano.option\n                  )\n\n                  // Only report if we successfully parsed an effect type and E is never\n                  if (Option.isSome(effectType)) {\n                    const { E } = effectType.value\n\n                    // Only report if E is exactly never\n                    if (E.flags & ts.TypeFlags.Never) {\n                      report({\n                        location: node.expression,\n                        messageText:\n                          `Looks like the previous effect never fails, so probably this error handling will never be triggered.`,\n                        fixes: []\n                      })\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const classSelfMismatch = LSP.createDiagnostic({\n  name: \"classSelfMismatch\",\n  code: 20,\n  severity: \"error\",\n  apply: Nano.fn(\"classSelfMismatch.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // Check if this is a class declaration that extends Effect.Service, Context.Tag, or Schema classes\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        // Check if this class extends a class that has a Self type parameter\n        const result = yield* pipe(\n          typeParser.extendsEffectService(node),\n          Nano.orElse(() => typeParser.extendsContextTag(node)),\n          Nano.orElse(() => typeParser.extendsEffectTag(node)),\n          Nano.orElse(() => typeParser.extendsSchemaClass(node)),\n          Nano.orElse(() => typeParser.extendsSchemaTaggedClass(node)),\n          Nano.orElse(() => typeParser.extendsSchemaTaggedError(node)),\n          Nano.orElse(() => typeParser.extendsSchemaTaggedRequest(node)),\n          Nano.orElse(() => Nano.void_)\n        )\n\n        if (result) {\n          // Both methods return { selfTypeNode, className } when they match\n          const { className, selfTypeNode } = result\n\n          // Get the actual name from the self type node\n          let actualName = sourceFile.text.substring(selfTypeNode.pos, selfTypeNode.end)\n          if (ts.isTypeReferenceNode(selfTypeNode)) {\n            if (ts.isIdentifier(selfTypeNode.typeName)) {\n              actualName = ts.idText(selfTypeNode.typeName)\n            } else if (ts.isQualifiedName(selfTypeNode.typeName)) {\n              actualName = ts.idText(selfTypeNode.typeName.right)\n            }\n          }\n\n          // Check if the self type matches the class name\n          const expectedName = ts.idText(className)\n          if (actualName !== expectedName) {\n            report({\n              location: selfTypeNode,\n              messageText: `Self type parameter should be '${expectedName}'`,\n              fixes: [{\n                fixName: \"classSelfMismatch_fix\",\n                description: `Replace '${actualName}' with '${expectedName}'`,\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  // Create a new type reference with the correct class name\n                  const typeArgs = ts.isTypeReferenceNode(selfTypeNode) ? selfTypeNode.typeArguments : undefined\n                  const newTypeReference = ts.factory.createTypeReferenceNode(\n                    ts.factory.createIdentifier(expectedName),\n                    typeArgs\n                  )\n\n                  // Replace the incorrect type reference with the correct one\n                  changeTracker.replaceNode(sourceFile, selfTypeNode, newTypeReference)\n                })\n              }]\n            })\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import type ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"./LanguageServicePluginOptions.js\"\nimport * as LSP from \"./LSP.js\"\nimport * as Nano from \"./Nano.js\"\nimport * as TypeScriptApi from \"./TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"./TypeScriptUtils.js\"\n\nexport interface KeyBuilder {\n  createString(identifier: string, kind: LanguageServicePluginOptions.KeyBuilderKind): string | undefined\n}\n\nexport const makeKeyBuilder = Nano.fn(\"KeyBuilder\")(\n  function*(sourceFile: ts.SourceFile) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n    const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    // Get package info for this source file, skip validation if not available\n    const packageInfo = tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile)\n\n    function createString(\n      classNameText: string,\n      kind: LanguageServicePluginOptions.KeyBuilderKind\n    ): string | undefined {\n      if (!packageInfo) return\n\n      for (const keyPattern of options.keyPatterns) {\n        // ensure this pattern applies for this kind\n        if (keyPattern.target !== kind) continue\n\n        // constructs the only filename of the source file\n        const lastIndex = sourceFile.fileName.lastIndexOf(\"/\")\n        let onlyFileName = lastIndex === -1 ? \"\" : sourceFile.fileName.slice(lastIndex + 1)\n        const lastExtensionIndex = onlyFileName.lastIndexOf(\".\")\n        if (lastExtensionIndex !== -1) onlyFileName = onlyFileName.slice(0, lastExtensionIndex)\n        if (onlyFileName.toLowerCase().endsWith(\"/index\")) onlyFileName = onlyFileName.slice(0, -6)\n        if (onlyFileName.startsWith(\"/\")) onlyFileName = onlyFileName.slice(1)\n\n        // constructs the subdirectory of the source file\n        let subDirectory = TypeScriptApi.getDirectoryPath(ts, sourceFile.fileName)\n        if (!subDirectory.startsWith(packageInfo.packageDirectory)) continue\n        subDirectory = subDirectory.slice(packageInfo.packageDirectory.length)\n        if (!subDirectory.endsWith(\"/\")) subDirectory = subDirectory + \"/\"\n        if (subDirectory.startsWith(\"/\")) subDirectory = subDirectory.slice(1)\n        for (const prefix of keyPattern.skipLeadingPath) {\n          if (subDirectory.startsWith(prefix)) {\n            subDirectory = subDirectory.slice(prefix.length)\n            break\n          }\n        }\n\n        // construct the parts of the expected identifier\n        let parts = [packageInfo.name, subDirectory, onlyFileName].concat(\n          onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]\n        )\n        if (keyPattern.pattern === \"package-identifier\") {\n          parts = [packageInfo.name, onlyFileName].concat(\n            onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]\n          )\n        }\n\n        // remove leading/trailing slashes\n        parts = parts.map((part) => part.startsWith(\"/\") ? part.slice(1) : part).map((part) =>\n          part.endsWith(\"/\") ? part.slice(0, -1) : part\n        )\n\n        // return them joined\n        const fullKey = parts.filter((_) => String(_).trim().length > 0).join(\"/\")\n\n        // if requested so, hash it\n        return keyPattern.pattern === \"default-hashed\" ? LSP.cyrb53(fullKey) : fullKey\n      }\n    }\n\n    return {\n      createString\n    }\n  }\n)\n\nconst keyBuilderCache = new Map<string, KeyBuilder>()\n\nexport const getOrMakeKeyBuilder = Nano.fn(\"getOrMakeKeyBuilder\")(function*(\n  sourceFile: ts.SourceFile\n) {\n  // NOTE: evict the oldest entry when the cache is full to avoid unbounded memory growth\n  while (keyBuilderCache.size > 5) {\n    const oldest = keyBuilderCache.keys().next().value\n    if (oldest) keyBuilderCache.delete(oldest)\n  }\n  const keyBuilder = keyBuilderCache.get(sourceFile.fileName) ||\n    (yield* makeKeyBuilder(sourceFile))\n  keyBuilderCache.set(sourceFile.fileName, keyBuilder)\n  return keyBuilder\n})\n\nexport function createString(\n  sourceFile: ts.SourceFile,\n  identifier: string,\n  kind: LanguageServicePluginOptions.KeyBuilderKind\n) {\n  return Nano.map(\n    getOrMakeKeyBuilder(sourceFile),\n    (identifierBuilder) => identifierBuilder.createString(identifier, kind)\n  )\n}\n","import { pipe } from \"effect\"\nimport type ts from \"typescript\"\nimport * as KeyBuilder from \"../core/KeyBuilder.js\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const deterministicKeys = LSP.createDiagnostic({\n  name: \"deterministicKeys\",\n  code: 25,\n  severity: \"off\",\n  apply: Nano.fn(\"deterministicKeys.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeScriptUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    const parseExtendsCustom = Nano.cachedBy(\n      Nano.fn(\"parseExtendsCustom\")(function*(classDeclaration: ts.ClassDeclaration) {\n        if (!options.extendedKeyDetection) {\n          return yield* TypeParser.typeParserIssue(\"Extended key detection is disabled\", undefined, classDeclaration)\n        }\n        if (!classDeclaration.name) {\n          return yield* TypeParser.typeParserIssue(\"Class has no name\", undefined, classDeclaration)\n        }\n        if (!ts.isIdentifier(classDeclaration.name)) {\n          return yield* TypeParser.typeParserIssue(\"Class name is not an identifier\", undefined, classDeclaration)\n        }\n        const heritageClauses = classDeclaration.heritageClauses\n        if (!heritageClauses) {\n          return yield* TypeParser.typeParserIssue(\"Class has no heritage clauses\", undefined, classDeclaration)\n        }\n\n        const nodeToVisit: Array<ts.Node> = [...classDeclaration.heritageClauses]\n        const appendNodeToVisit = (node: ts.Node) => {\n          nodeToVisit.push(node)\n          return undefined\n        }\n\n        while (nodeToVisit.length > 0) {\n          const node = nodeToVisit.shift()!\n          if (ts.isCallExpression(node)) {\n            for (let i = 0; i < node.arguments.length; i++) {\n              const arg = node.arguments[i]\n              if (!ts.isStringLiteral(arg)) continue\n              const resolvedSignature = typeChecker.getResolvedSignature(node)\n              if (resolvedSignature) {\n                const parameter = resolvedSignature.parameters[i]\n                if (!parameter) continue\n                if (parameter.declarations) {\n                  for (const declaration of parameter.declarations) {\n                    const parameterSourceFile = typeScriptUtils.getSourceFileOfNode(declaration)!\n                    const paramText = parameterSourceFile.text.substring(declaration.pos, declaration.end)\n                    if (paramText.toLowerCase().includes(\"@effect-identifier\")) {\n                      return { className: classDeclaration.name, keyStringLiteral: arg, target: \"custom\" as const }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          ts.forEachChild(node, appendNodeToVisit)\n        }\n\n        return yield* TypeParser.typeParserIssue(\n          \"Class does not extend any custom pattern\",\n          undefined,\n          classDeclaration\n        )\n      }),\n      \"deterministicKeys.parseExtendsCustom\",\n      (classDeclaration) => classDeclaration\n    )\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // Check if this is a class declaration that extends Effect.Service, Context.Tag, or Effect.Tag\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        // Try to parse as one of the supported tag/service types\n        // @effect-diagnostics-next-line unnecessaryPipeChain:off\n        const result = yield* pipe(\n          pipe(\n            typeParser.extendsEffectService(node),\n            Nano.orElse(() => typeParser.extendsContextTag(node)),\n            Nano.orElse(() => typeParser.extendsEffectTag(node)),\n            Nano.map(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: \"service\" as const }))\n          ),\n          Nano.orElse(() =>\n            pipe(\n              typeParser.extendsDataTaggedError(node),\n              Nano.orElse(() => typeParser.extendsSchemaTaggedError(node)),\n              Nano.map(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: \"error\" as const }))\n            )\n          ),\n          Nano.orElse(() => parseExtendsCustom(node)),\n          Nano.orElse(() => Nano.void_)\n        )\n\n        if (result && result.keyStringLiteral) {\n          const { className, keyStringLiteral, target } = result\n\n          // Get the class name text\n          const classNameText = ts.idText(className)\n\n          // build the expected identifier\n          const expectedKey = yield* KeyBuilder.createString(sourceFile, classNameText, target)\n          if (!expectedKey) continue\n\n          // Get the actual identifier from the keyStringLiteral\n          const actualIdentifier = keyStringLiteral.text\n\n          // Report diagnostic if they don't match\n          if (actualIdentifier !== expectedKey) {\n            report({\n              location: keyStringLiteral,\n              messageText: `Key should be '${expectedKey}'`,\n              fixes: [{\n                fixName: \"deterministicKeys_fix\",\n                description: `Replace '${actualIdentifier}' with '${expectedKey}'`,\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  // Create a new string literal with the correct identifier\n                  const newStringLiteral = ts.factory.createStringLiteral(expectedKey)\n\n                  // Replace the incorrect string literal with the correct one\n                  changeTracker.replaceNode(sourceFile, keyStringLiteral, newStringLiteral)\n                })\n              }]\n            })\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { hasProperty, isNumber } from \"effect/Predicate\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\ntype ResolvedPackagesCache = Record<string, Record<string, any>>\n\nconst checkedPackagesCache = new Map<string, ResolvedPackagesCache>()\nconst programResolvedCacheSize = new Map<string, number>()\n\nexport const duplicatePackage = LSP.createDiagnostic({\n  name: \"duplicatePackage\",\n  code: 6,\n  severity: \"warning\",\n  apply: Nano.fn(\"duplicatePackage.apply\")(function*(sourceFile, report) {\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    if (sourceFile.statements.length < 1) return\n\n    // whenever we detect the resolution cache size has changed, try again the check\n    // this should mitigate how frequently this rule is triggered\n    let resolvedPackages: ResolvedPackagesCache = checkedPackagesCache.get(sourceFile.fileName) ||\n      {}\n    const newResolvedModuleSize =\n      hasProperty(program, \"resolvedModules\") && hasProperty(program.resolvedModules, \"size\") &&\n        isNumber(program.resolvedModules.size) ?\n        program.resolvedModules.size :\n        0\n    const oldResolvedSize = programResolvedCacheSize.get(sourceFile.fileName) || -1\n    if (newResolvedModuleSize !== oldResolvedSize) {\n      const seenPackages = new Set<string>()\n      resolvedPackages = {}\n      program.getSourceFiles().map((_) => {\n        const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(_)\n        if (!packageInfo) return\n        const packageNameAndVersion = packageInfo.name + \"@\" + packageInfo.version\n        if (seenPackages.has(packageNameAndVersion)) return\n        seenPackages.add(packageNameAndVersion)\n        if (\n          !(packageInfo.name === \"effect\" || packageInfo.hasEffectInPeerDependencies)\n        ) return\n        if (options.allowedDuplicatedPackages.indexOf(packageInfo.name) > -1) return\n        resolvedPackages[packageInfo.name] = resolvedPackages[packageInfo.name] || {}\n        resolvedPackages[packageInfo.name][packageInfo.version] = packageInfo.packageDirectory\n      })\n      checkedPackagesCache.set(sourceFile.fileName, resolvedPackages)\n      programResolvedCacheSize.set(sourceFile.fileName, newResolvedModuleSize)\n    }\n\n    for (const packageName of Object.keys(resolvedPackages)) {\n      if (Object.keys(resolvedPackages[packageName]).length > 1) {\n        const versions = Object.keys(resolvedPackages[packageName])\n        report({\n          location: sourceFile.statements[0],\n          messageText: `Package ${packageName} is referenced multiple times with different versions (${\n            versions.join(\", \")\n          }) and may cause unexpected type errors.\\nCleanup your dependencies and your package lockfile to avoid multiple instances of this package and reload the project.\\nIf this is intended set the LSP config \"allowedDuplicatedPackages\" to ${\n            JSON.stringify(options.allowedDuplicatedPackages.concat([packageName]))\n          }.\\n\\n${\n            versions.map((version) => `- found ${version} at ${resolvedPackages[packageName][version]}`).join(\"\\n\")\n          }`,\n          fixes: []\n        })\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const effectGenUsesAdapter = LSP.createDiagnostic({\n  name: \"effectGenUsesAdapter\",\n  code: 23,\n  severity: \"warning\",\n  apply: Nano.fn(\"effectGenUsesAdapter.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(\n          typeParser.effectGen(node),\n          Nano.map(({ generatorFunction }) => {\n            // Check if the generator function has parameters and if the first parameter (adapter) is used\n            if (generatorFunction.parameters.length > 0) {\n              const adapter = generatorFunction.parameters[0]\n              // Report diagnostic at the adapter parameter location\n              report({\n                location: adapter,\n                messageText: `The adapter of Effect.gen is not required anymore, it is now just an alias of pipe.`,\n                fixes: []\n              })\n            }\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const effectInVoidSuccess = LSP.createDiagnostic({\n  name: \"effectInVoidSuccess\",\n  code: 14,\n  severity: \"warning\",\n  apply: Nano.fn(\"effectInVoidSuccess.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const checkForEffectInVoid = Nano.fn(\"effectInVoidSuccess.checkForEffectInVoid\")(function*(\n      node: ts.Node,\n      expectedType: ts.Type,\n      valueNode: ts.Node,\n      realType: ts.Type\n    ) {\n      const expectedEffect = yield* typeParser.effectType(expectedType, node)\n      const realEffect = yield* typeParser.effectType(realType, valueNode)\n      if (expectedEffect.A.flags & ts.TypeFlags.Void) {\n        const voidValueTypes = typeCheckerUtils.unrollUnionMembers(realEffect.A)\n        const voidedEffect = yield* Nano.firstSuccessOf(\n          voidValueTypes.map((_) => Nano.map(typeParser.strictEffectType(_, node), () => _))\n        )\n        return { voidedEffect }\n      }\n      return yield* Nano.fail(TypeParser.typeParserIssue(\"expectedEffect success is not void\"))\n    })\n\n    const entries = typeCheckerUtils.expectedAndRealType(sourceFile)\n    for (const [node, expectedType, valueNode, realType] of entries) {\n      if (expectedType !== realType) {\n        yield* pipe(\n          checkForEffectInVoid(\n            node,\n            expectedType,\n            valueNode,\n            realType\n          ),\n          Nano.map(({ voidedEffect }) => {\n            report(\n              {\n                location: node,\n                messageText: `There is a nested '${\n                  typeChecker.typeToString(voidedEffect)\n                }' in the 'void' success channel, beware that this could lead to nested Effect<Effect<...>> that won't be executed.`,\n                fixes: []\n              }\n            )\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const floatingEffect = LSP.createDiagnostic({\n  name: \"floatingEffect\",\n  code: 3,\n  severity: \"error\",\n  apply: Nano.fn(\"floatingEffect.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    function isFloatingExpression(node: ts.Node): node is ts.ExpressionStatement {\n      // should be an expression statement\n      if (!ts.isExpressionStatement(node)) return false\n      // parent is either block or source file\n      if (!(ts.isBlock(node.parent) || ts.isSourceFile(node.parent))) return false\n      const expression = node.expression\n      // this.variable = Effect.succeed is a valid expression\n      if (\n        ts.isBinaryExpression(expression) && expression.operatorToken &&\n        (expression.operatorToken.kind === ts.SyntaxKind.EqualsToken ||\n          expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionEqualsToken ||\n          expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandEqualsToken ||\n          expression.operatorToken.kind === ts.SyntaxKind.BarBarEqualsToken)\n      ) return false\n      return true\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (!isFloatingExpression(node)) continue\n\n      const type = typeChecker.getTypeAtLocation(node.expression)\n      // if type is an effect\n      const effect = yield* Nano.option(typeParser.effectType(type, node.expression))\n      if (Option.isSome(effect)) {\n        // and not a fiber (we consider that a valid operation)\n        const allowedFloatingEffects = yield* pipe(\n          typeParser.fiberType(type, node.expression),\n          Nano.orElse(() => typeParser.effectSubtype(type, node.expression)),\n          Nano.option\n        )\n        if (Option.isNone(allowedFloatingEffects)) {\n          // check if strictly an effect or a subtype to change the error message\n          const isStrictEffect = yield* Nano.option(typeParser.strictEffectType(type, node.expression))\n          const name = Option.isSome(isStrictEffect) ? \"Effect\" : \"Effect-able \" + typeChecker.typeToString(type)\n          report({\n            location: node,\n            messageText: `${name} must be yielded or assigned to a variable.`,\n            fixes: []\n          })\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const genericEffectServices = LSP.createDiagnostic({\n  name: \"genericEffectServices\",\n  code: 10,\n  severity: \"warning\",\n  apply: Nano.fn(\"genericEffectServices.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      const typesToCheck: Array<[ts.Type, ts.Node]> = []\n\n      if (ts.isClassDeclaration(node) && node.name && node.typeParameters && node.heritageClauses) {\n        const classSym = typeChecker.getSymbolAtLocation(node.name)\n        if (classSym) {\n          const type = typeChecker.getTypeOfSymbol(classSym)\n          typesToCheck.push([type, node.name!])\n        }\n      } else {\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      }\n\n      // check the types\n      for (const [type, reportAt] of typesToCheck) {\n        yield* pipe(\n          typeParser.contextTag(type, node),\n          Nano.map(() => {\n            report({\n              location: reportAt,\n              messageText:\n                `Effect Services with type parameters are not supported because they cannot be properly discriminated at runtime, which may cause unexpected behavior.`,\n              fixes: []\n            })\n          }),\n          Nano.orElse(() => Nano.sync(() => ts.forEachChild(node, appendNodeToVisit))),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import * as Array from \"effect/Array\"\nimport type ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const importFromBarrel = LSP.createDiagnostic({\n  name: \"importFromBarrel\",\n  code: 12,\n  severity: \"off\",\n  apply: Nano.fn(\"importFromBarrel.apply\")(function*(sourceFile, report) {\n    // requires namespaceImportPackages to be set\n    const languageServicePluginOptions = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n    if (languageServicePluginOptions.namespaceImportPackages.length === 0) return\n\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const program = yield* Nano.service(TypeScriptApi.TypeScriptProgram)\n\n    const getModuleSpecifier = TypeScriptApi.makeGetModuleSpecifier(ts)\n    const resolveExternalModuleName = TypeCheckerApi.makeResolveExternalModuleName(typeChecker)\n    const packageNamesToCheck = Array.flatten(\n      languageServicePluginOptions.namespaceImportPackages.map((packageName) =>\n        tsUtils.resolveModulePattern(program, sourceFile, packageName)\n      )\n    )\n\n    const isImportedFromBarrelExport = (\n      element: ts.ImportSpecifier\n    ) => {\n      if (!(getModuleSpecifier && resolveExternalModuleName)) return\n\n      const importDeclaration = ts.findAncestor(element, (node) => ts.isImportDeclaration(node))\n      if (!importDeclaration) return\n      if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) return\n      const importClause = importDeclaration.importClause\n      if (!importClause) return\n      const namedBindings = importClause.namedBindings\n      if (!namedBindings) return\n      if (!ts.isNamedImports(namedBindings)) return\n\n      const barrelModuleName = importDeclaration.moduleSpecifier.text\n      if (packageNamesToCheck.indexOf(barrelModuleName.toLowerCase()) === -1) return\n      const moduleSymbol = resolveExternalModuleName(importDeclaration.moduleSpecifier)\n      if (!moduleSymbol) return\n      if (!moduleSymbol.exports) return\n      const sourceFile = tsUtils.getSourceFileOfNode(importDeclaration)\n      if (!sourceFile) return\n\n      const nodeForSymbol = element.propertyName || element.name\n      const aliasSymbol = element.name || element.propertyName\n      const aliasedName = ts.idText(aliasSymbol)\n\n      // we can only check for identifiers\n      if (!ts.isIdentifier(nodeForSymbol)) return\n      const importedName = ts.idText(nodeForSymbol)\n      if (!importedName) return\n      // get the symbol of the re-export\n      const reexportedSymbol = moduleSymbol.exports.get(ts.escapeLeadingUnderscores(importedName))\n      if (!reexportedSymbol) return\n      // if we have only a declaration\n      if (!(reexportedSymbol.declarations && reexportedSymbol.declarations.length === 1)) return\n      // that should be an 'export * as X from \"module\"'\n      const namespaceExport = reexportedSymbol.declarations[0]\n      if (!ts.isNamespaceExport(namespaceExport)) return\n      // parent should be an export declaration\n      const exportDeclaration = namespaceExport.parent\n      if (!ts.isExportDeclaration(exportDeclaration)) return\n      // if we have a module specifier, resolve that symbol\n      if (!exportDeclaration.moduleSpecifier) return\n      const originalModuleSymbol = resolveExternalModuleName(exportDeclaration.moduleSpecifier)\n      if (!originalModuleSymbol) return\n      // the value declaration should be the sourcefile of the original module\n      if (!originalModuleSymbol.valueDeclaration) return\n      const originalSourceFile = tsUtils.getSourceFileOfNode(originalModuleSymbol.valueDeclaration)\n      if (!originalSourceFile) return\n      const unbarrelledFileName = getModuleSpecifier(\n        program.getCompilerOptions(),\n        sourceFile,\n        sourceFile.fileName,\n        originalSourceFile.fileName,\n        program\n      )\n      // need to start with the barrel module name, otherwise its not the same package\n      if (unbarrelledFileName.toLowerCase().indexOf(barrelModuleName.toLowerCase() + \"/\") === -1) return\n      return {\n        unbarrelledFileName,\n        importedName,\n        barrelModuleName,\n        importClause,\n        namedBindings,\n        importDeclaration,\n        aliasedName\n      }\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      const parent = node.parent\n\n      if (!(ts.isImportSpecifier(node) && ts.isNamedImports(parent))) {\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      }\n\n      const result = isImportedFromBarrelExport(node)\n      if (!result) continue\n      const {\n        aliasedName,\n        barrelModuleName,\n        importClause,\n        importDeclaration,\n        namedBindings,\n        unbarrelledFileName\n      } = result\n      // ok, I think now we can report the error\n      report({\n        location: node,\n        messageText: `Importing from barrel module ${barrelModuleName} is not allowed.`,\n        fixes: [\n          {\n            fixName: \"replaceWithUnbarrelledImport\",\n            description: `Import * as ${aliasedName} from ${unbarrelledFileName}`,\n            apply: Nano.gen(function*() {\n              const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n              const newImport = ts.factory.createImportDeclaration(\n                undefined,\n                ts.factory.createImportClause(\n                  importClause.isTypeOnly || node.isTypeOnly,\n                  undefined,\n                  ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasedName))\n                ),\n                ts.factory.createStringLiteral(unbarrelledFileName)\n              )\n\n              if (namedBindings.elements.length === 1) {\n                changeTracker.replaceNode(\n                  sourceFile,\n                  importDeclaration,\n                  newImport\n                )\n              } else {\n                changeTracker.insertNodeAfter(sourceFile, importDeclaration, newImport)\n                changeTracker.replaceNode(\n                  sourceFile,\n                  namedBindings,\n                  ts.factory.updateNamedImports(\n                    namedBindings,\n                    namedBindings.elements.filter((e) => e !== node)\n                  )\n                )\n              }\n            })\n          }\n        ]\n      })\n    }\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const leakingRequirements = LSP.createDiagnostic({\n  name: \"leakingRequirements\",\n  code: 8,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"leakingRequirements.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const parseLeakedRequirements = Nano.cachedBy(\n      Nano.fn(\"leakingServices.checkServiceLeaking\")(\n        function*(service: ts.Type, atLocation: ts.Node) {\n          const properties = typeChecker.getPropertiesOfType(service)\n          // since this is an heuristic, we require at least 2 props\n          if (properties.length < 1) return []\n          // store the accumulated services\n          const memory = new Map<string, ts.Type>()\n          let sharedRequirementsKeys: Array<string> | undefined = undefined\n          let effectMembers = 0\n          for (const property of properties) {\n            // get the context type of the property, either Effect<...> or () => Effect<...>\n            const servicePropertyType = typeChecker.getTypeOfSymbolAtLocation(property, atLocation)\n            let effectContextType: ts.Type | undefined = undefined\n            yield* pipe(\n              typeParser.effectType(servicePropertyType, atLocation),\n              Nano.map((_) => effectContextType = _.R),\n              Nano.orElse(() => {\n                const servicePropertyCallSignatures = typeChecker.getSignaturesOfType(\n                  servicePropertyType,\n                  ts.SignatureKind.Call\n                )\n                if (servicePropertyCallSignatures.length === 1) {\n                  return pipe(\n                    typeParser.effectType(\n                      typeChecker.getReturnTypeOfSignature(servicePropertyCallSignatures[0]),\n                      atLocation\n                    ),\n                    Nano.map((_) => {\n                      effectContextType = _.R\n                    })\n                  )\n                }\n                return Nano.void_\n              }),\n              Nano.ignore\n            )\n            // once we have the type, check the context for shared requirements\n            if (effectContextType) {\n              effectMembers++\n              const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(\n                memory,\n                effectContextType,\n                (type) => {\n                  // exclude never\n                  if (type.flags & ts.TypeFlags.Never) return Nano.succeed(true)\n                  // exclude scope\n                  return pipe(\n                    typeParser.scopeType(type, atLocation),\n                    Nano.map(() => true),\n                    Nano.orElse(() => Nano.succeed(false))\n                  )\n                }\n              )\n              if (!sharedRequirementsKeys) {\n                sharedRequirementsKeys = allIndexes\n              } else {\n                sharedRequirementsKeys = Array.intersection(sharedRequirementsKeys, allIndexes)\n                if (sharedRequirementsKeys.length === 0) return []\n              }\n            }\n          }\n          // ...and those at least 2 props must be or return effects\n          if (sharedRequirementsKeys && sharedRequirementsKeys.length > 0 && effectMembers >= 2) {\n            return sharedRequirementsKeys.map((key) => memory.get(key)!).filter(\n              (type) => {\n                let symbol = type.symbol\n                if (symbol && symbol.flags & ts.SymbolFlags.Alias) {\n                  symbol = typeChecker.getAliasedSymbol(symbol)!\n                }\n                return !(symbol.declarations || []).some((declaration) => {\n                  const declarationSource = tsUtils.getSourceFileOfNode(declaration)\n                  if (!declarationSource) return false\n                  return (declarationSource.text.substring(declaration.pos, declaration.end).toLowerCase().indexOf(\n                    \"@effect-leakable-service\"\n                  ) > -1)\n                })\n              }\n            )\n          }\n          return []\n        }\n      ),\n      \"leakingServices.checkServiceLeaking\",\n      (_, service) => service\n    )\n\n    function reportLeakingRequirements(node: ts.Node, requirements: Array<ts.Type>) {\n      if (requirements.length === 0) return\n      report({\n        location: node,\n        messageText: `This Service is leaking the ${\n          requirements.map((_) => typeChecker.typeToString(_)).join(\" | \")\n        } requirement.\\nIf these requirements cannot be cached and are expected to be provided per method invocation (e.g. HttpServerRequest), you can either safely disable this diagnostic for this line through quickfixes or mark the service declaration with a JSDoc @effect-leakable-service.\\nMore info at https://effect.website/docs/requirements-management/layers/#avoiding-requirement-leakage`,\n        fixes: []\n      })\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // we need to check the type of the class declaration (if any)\n      const typesToCheck: Array<[type: ts.Type, reportNode: ts.Node]> = []\n      if (\n        ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) &&\n        ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === \"GenericTag\"\n      ) {\n        typesToCheck.push([typeChecker.getTypeAtLocation(node), node])\n      } else if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        const classSym = typeChecker.getSymbolAtLocation(node.name)\n        if (classSym) {\n          const type = typeChecker.getTypeOfSymbol(classSym)\n          typesToCheck.push([type, node.name])\n        }\n      } else {\n        ts.forEachChild(node, appendNodeToVisit)\n        continue\n      }\n\n      // check the types\n      for (const [type, reportAt] of typesToCheck) {\n        yield* pipe(\n          typeParser.contextTag(type, node),\n          Nano.flatMap(({ Service }) =>\n            pipe(\n              parseLeakedRequirements(Service, node),\n              Nano.map((requirements) =>\n                reportLeakingRequirements(reportAt, Array.sort(requirements, typeCheckerUtils.deterministicTypeOrder))\n              )\n            )\n          ),\n          Nano.orElse(() => Nano.sync(() => ts.forEachChild(node, appendNodeToVisit))),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import * as Array from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LanguageServicePluginOptions from \"../core/LanguageServicePluginOptions.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const missedPipeableOpportunity = LSP.createDiagnostic({\n  name: \"missedPipeableOpportunity\",\n  code: 26,\n  severity: \"off\",\n  apply: Nano.fn(\"missedPipeableOpportunity.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const options = yield* Nano.service(LanguageServicePluginOptions.LanguageServicePluginOptions)\n\n    const nodeToVisit: Array<ts.Node> = [sourceFile]\n    const prependNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.unshift(node)\n      return undefined\n    }\n\n    const callChainNodes = new WeakMap<ts.Node, Array<ts.CallExpression>>()\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      if (ts.isCallExpression(node) && node.arguments.length === 1 && node.parent) {\n        // this node contributes to the chain.\n        const parentChain = callChainNodes.get(node.parent) || []\n        callChainNodes.set(node, parentChain.concat(node))\n      } else if (node.parent && callChainNodes.has(node.parent) && ts.isExpression(node)) {\n        // we broke the chain.\n        const parentChain: Array<ts.Expression> = callChainNodes.get(node.parent) || []\n        const originalParentChain = parentChain.slice()\n        parentChain.push(node)\n        while (parentChain.length > options.pipeableMinArgCount) {\n          const subject = parentChain.pop()!\n          const resultType = typeChecker.getTypeAtLocation(subject)\n          const pipeableType = yield* pipe(typeParser.pipeableType(resultType, subject), Nano.orElse(() => Nano.void_))\n          if (pipeableType) {\n            report({\n              location: parentChain[0],\n              messageText: `Nested function calls can be converted to pipeable style for better readability.`,\n              fixes: [{\n                fixName: \"missedPipeableOpportunity_fix\",\n                description: \"Convert to pipe style\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  // Create the new pipe call: innermostCall.pipe(c, b, a)\n                  changeTracker.replaceNode(\n                    sourceFile,\n                    parentChain[0],\n                    ts.factory.createCallExpression(\n                      ts.factory.createPropertyAccessExpression(\n                        subject,\n                        \"pipe\"\n                      ),\n                      undefined,\n                      pipe(\n                        parentChain,\n                        Array.filter(ts.isCallExpression),\n                        Array.map((call) => call.expression),\n                        Array.reverse\n                      )\n                    )\n                  )\n                })\n              }]\n            })\n            // delete the parent chain nodes that were affected by the fix, so we don't report the same issue again.\n            originalParentChain.forEach((node) => callChainNodes.delete(node))\n            break\n          }\n        }\n      }\n\n      // we always visit the children\n      ts.forEachChild(node, prependNodeToVisit)\n    }\n  })\n})\n","import * as ReadonlyArray from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\n\nexport const missingEffectContext = LSP.createDiagnostic({\n  name: \"missingEffectContext\",\n  code: 1,\n  severity: \"error\",\n  apply: Nano.fn(\"missingEffectContext.apply\")(function*(sourceFile, report) {\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const checkForMissingContextTypes = (\n      node: ts.Node,\n      expectedType: ts.Type,\n      valueNode: ts.Node,\n      realType: ts.Type\n    ) =>\n      pipe(\n        Nano.all(\n          typeParser.effectType(expectedType, node),\n          typeParser.effectType(realType, valueNode)\n        ),\n        Nano.map(([expectedEffect, realEffect]) =>\n          typeCheckerUtils.getMissingTypeEntriesInTargetType(\n            realEffect.R,\n            expectedEffect.R\n          )\n        )\n      )\n\n    const sortTypes = ReadonlyArray.sort(typeCheckerUtils.deterministicTypeOrder)\n\n    const entries = LSP.getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors ||\n      typeCheckerUtils.expectedAndRealType(sourceFile)\n    for (const [node, expectedType, valueNode, realType] of entries) {\n      // if the types are different, check for missing context types\n      if (expectedType !== realType) {\n        yield* pipe(\n          checkForMissingContextTypes(\n            node,\n            expectedType,\n            valueNode,\n            realType\n          ),\n          Nano.map((missingTypes) =>\n            missingTypes.length > 0 ?\n              report(\n                {\n                  location: node,\n                  messageText: `Missing '${\n                    sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(\" | \")\n                  }' in the expected Effect context.`,\n                  fixes: []\n                }\n              )\n              : undefined\n          ),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import * as ReadonlyArray from \"effect/Array\"\nimport { pipe } from \"effect/Function\"\nimport * as Order from \"effect/Order\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const missingEffectError = LSP.createDiagnostic({\n  name: \"missingEffectError\",\n  code: 1,\n  severity: \"error\",\n  apply: Nano.fn(\"missingEffectError.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Effect\"\n    ) || \"Effect\"\n\n    const createDieMessage = (message: string) =>\n      ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          ts.factory.createIdentifier(effectModuleIdentifier),\n          \"dieMessage\"\n        ),\n        undefined,\n        [ts.factory.createStringLiteral(message)]\n      )\n\n    const checkForMissingErrorTypes = (\n      node: ts.Node,\n      expectedType: ts.Type,\n      valueNode: ts.Node,\n      realType: ts.Type\n    ) =>\n      pipe(\n        Nano.all(\n          typeParser.effectType(expectedType, node),\n          typeParser.effectType(realType, valueNode)\n        ),\n        Nano.map(([expectedEffect, realEffect]) =>\n          pipe(\n            typeCheckerUtils.getMissingTypeEntriesInTargetType(\n              realEffect.E,\n              expectedEffect.E\n            ),\n            (missingErrorTypes) => ({ missingErrorTypes, expectedErrorType: expectedEffect.E })\n          )\n        )\n      )\n\n    const sortTypes = ReadonlyArray.sort(typeCheckerUtils.deterministicTypeOrder)\n\n    const entries = LSP.getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors ||\n      typeCheckerUtils.expectedAndRealType(sourceFile)\n    for (const [node, expectedType, valueNode, realType] of entries) {\n      // if the types are different, check for missing error types\n      if (expectedType !== realType) {\n        yield* pipe(\n          checkForMissingErrorTypes(\n            node,\n            expectedType,\n            valueNode,\n            realType\n          ),\n          Nano.map((result) => {\n            if (result.missingErrorTypes.length === 0) return\n            const fixes: Array<LSP.ApplicableDiagnosticDefinitionFix> = []\n\n            if (ts.isExpression(valueNode) && result.expectedErrorType.flags & ts.TypeFlags.Never) {\n              fixes.push({\n                fixName: \"missingEffectError_catchAll\",\n                description: \"Catch all errors with Effect.catchAll\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  changeTracker.insertText(\n                    sourceFile,\n                    ts.getTokenPosOfNode(valueNode, sourceFile),\n                    effectModuleIdentifier + \".catchAll(\"\n                  )\n                  changeTracker.insertText(sourceFile, valueNode.end, \", () => \")\n                  changeTracker.insertNodeAt(\n                    sourceFile,\n                    valueNode.end,\n                    createDieMessage(\"TODO: catchAll not implemented\")\n                  )\n                  changeTracker.insertText(sourceFile, valueNode.end, \")\")\n                })\n              })\n            }\n\n            if (ts.isExpression(valueNode)) {\n              const propertyAssignments = pipe(\n                result.missingErrorTypes,\n                ReadonlyArray.map((_) => typeChecker.getPropertyOfType(_, \"_tag\")),\n                ReadonlyArray.filter((_) => !!_),\n                ReadonlyArray.map((_) => typeChecker.getTypeOfSymbolAtLocation(_, valueNode)),\n                ReadonlyArray.filter((_) => !!(_.flags & ts.TypeFlags.Literal)),\n                ReadonlyArray.map((_) => typeChecker.typeToTypeNode(_, undefined, ts.NodeBuilderFlags.NoTruncation)),\n                ReadonlyArray.filter((_) => !!_ && ts.isLiteralTypeNode(_)),\n                ReadonlyArray.map((_) => _.literal),\n                ReadonlyArray.filter((_) => ts.isLiteralExpression(_)),\n                ReadonlyArray.map((_) => _.text),\n                ReadonlyArray.sort(Order.string),\n                ReadonlyArray.map((_) =>\n                  ts.factory.createPropertyAssignment(\n                    ts.factory.createIdentifier(_),\n                    ts.factory.createArrowFunction(\n                      undefined,\n                      undefined,\n                      [],\n                      undefined,\n                      undefined,\n                      createDieMessage(`TODO: catchTags() not implemented for ${_}`)\n                    )\n                  )\n                )\n              )\n              if (propertyAssignments.length === result.missingErrorTypes.length) {\n                fixes.push({\n                  fixName: \"missingEffectError_tagged\",\n                  description: \"Catch unexpected errors with Effect.catchTag\",\n                  apply: Nano.gen(function*() {\n                    const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                    changeTracker.insertText(\n                      sourceFile,\n                      ts.getTokenPosOfNode(valueNode, sourceFile),\n                      effectModuleIdentifier + \".catchTags(\"\n                    )\n                    changeTracker.insertText(sourceFile, valueNode.end, \", \")\n                    changeTracker.insertNodeAt(\n                      sourceFile,\n                      valueNode.end,\n                      ts.factory.createObjectLiteralExpression(propertyAssignments)\n                    )\n                    changeTracker.insertText(sourceFile, valueNode.end, \")\")\n                  })\n                })\n              }\n            }\n\n            const typeNames = sortTypes(result.missingErrorTypes).map((_) => typeChecker.typeToString(_))\n            report(\n              {\n                location: node,\n                messageText: `Missing '${typeNames.join(\" | \")}' in the expected Effect errors.`,\n                fixes\n              }\n            )\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const missingEffectServiceDependency = LSP.createDiagnostic({\n  name: \"missingEffectServiceDependency\",\n  code: 22,\n  severity: \"off\",\n  apply: Nano.fn(\"missingEffectServiceDependency.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // Check if this is a class declaration that extends Effect.Service\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        const serviceResult = yield* pipe(\n          typeParser.extendsEffectService(node),\n          Nano.orElse(() => Nano.void_)\n        )\n\n        if (serviceResult) {\n          const { className, options } = serviceResult\n\n          // Get the class symbol and its type\n          const classSymbol = typeChecker.getSymbolAtLocation(className)\n          if (classSymbol) {\n            const classType = typeChecker.getTypeOfSymbol(classSymbol)\n\n            // Try to get DefaultWithoutDependencies first, then Default\n            const defaultWithoutDepsProperty = typeChecker.getPropertyOfType(classType, \"DefaultWithoutDependencies\")\n            const defaultProperty = defaultWithoutDepsProperty || typeChecker.getPropertyOfType(classType, \"Default\")\n\n            if (defaultProperty) {\n              const defaultType = typeChecker.getTypeOfSymbolAtLocation(defaultProperty, node)\n\n              // Parse the layer type to get RIN\n              const layerResult = yield* pipe(\n                typeParser.layerType(defaultType, node),\n                Nano.orElse(() => Nano.void_)\n              )\n\n              if (layerResult) {\n                // Use a single memory map for both required and provided services\n                const servicesMemory = new Map<string, ts.Type>()\n                const excludeNever = (type: ts.Type) => Nano.succeed((type.flags & ts.TypeFlags.Never) !== 0)\n\n                // Get all required service indexes\n                const { allIndexes: requiredIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(\n                  servicesMemory,\n                  layerResult.RIn,\n                  excludeNever\n                )\n\n                // Process dependencies (treat undefined/null as empty array)\n                const providedIndexes = new Set<string>()\n\n                const optionsType = typeChecker.getTypeAtLocation(options)\n                const dependenciesProperty = typeChecker.getPropertyOfType(optionsType, \"dependencies\")\n                let types: Array<ts.Type> = []\n\n                if (dependenciesProperty) {\n                  const dependenciesTypes = typeChecker.getTypeOfSymbolAtLocation(dependenciesProperty, options)\n                  const numberIndexType = typeChecker.getIndexTypeOfType(dependenciesTypes, ts.IndexKind.Number)\n                  types = numberIndexType ? typeCheckerUtils.unrollUnionMembers(numberIndexType) : []\n                }\n\n                // Process each dependency to get what services they provide\n                for (const depType of types) {\n                  // Try to parse as layer type\n                  const depLayerResult = yield* pipe(\n                    typeParser.layerType(depType, options),\n                    Nano.orElse(() => Nano.void_)\n                  )\n\n                  if (depLayerResult) {\n                    // Add the ROut of this dependency to the same memory map\n                    const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(\n                      servicesMemory,\n                      depLayerResult.ROut,\n                      excludeNever\n                    )\n                    // Collect all provided indexes\n                    for (const index of allIndexes) {\n                      providedIndexes.add(index)\n                    }\n                  }\n                }\n\n                // Find missing services: required indexes not in provided indexes\n                const missingIndexes = requiredIndexes.filter((index) => !providedIndexes.has(index))\n\n                // Report diagnostic if there are missing dependencies\n                if (missingIndexes.length > 0) {\n                  const missingTypes = missingIndexes.map((index) => servicesMemory.get(index)!)\n                  const missingTypeNames = missingTypes.map((t) => typeChecker.typeToString(t))\n\n                  const message = missingTypeNames.length === 1\n                    ? `Service '${missingTypeNames[0]}' is required but not provided by dependencies`\n                    : `Services ${\n                      missingTypeNames.map((s) => `'${s}'`).join(\", \")\n                    } are required but not provided by dependencies`\n\n                  report({\n                    location: className,\n                    messageText: message,\n                    fixes: []\n                  })\n                }\n              }\n            }\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const missingReturnYieldStar = LSP.createDiagnostic({\n  name: \"missingReturnYieldStar\",\n  code: 7,\n  severity: \"error\",\n  apply: Nano.fn(\"missingReturnYieldStar.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // if we yield* an effect with never in success type, maybe we wanted tu return\n      if (\n        ts.isYieldExpression(node) && node.expression &&\n        node.asteriskToken\n      ) {\n        // are we returning an effect with never as success type?\n        const type = typeChecker.getTypeAtLocation(node.expression)\n        const maybeEffect = yield* Nano.option(typeParser.effectType(type, node.expression))\n\n        if (Option.isSome(maybeEffect) && maybeEffect.value.A.flags & ts.TypeFlags.Never) {\n          // go up until we meet the causing generator\n          const generatorFunctionOrReturnStatement = ts.findAncestor(\n            node,\n            (\n              _\n            ) => (ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) ||\n              ts.isReturnStatement(_) || ts.isThrowStatement(_))\n          )\n\n          // we already have a return statement\n          if (\n            generatorFunctionOrReturnStatement && !ts.isReturnStatement(generatorFunctionOrReturnStatement) &&\n            !ts.isThrowStatement(generatorFunctionOrReturnStatement)\n          ) {\n            // .gen should always be the parent ideally\n            if (generatorFunctionOrReturnStatement && generatorFunctionOrReturnStatement.parent) {\n              const effectGenNode = generatorFunctionOrReturnStatement.parent\n              // continue if we hit effect gen-like\n              const effectGenLike = yield* pipe(\n                typeParser.effectGen(effectGenNode),\n                Nano.orElse(() => typeParser.effectFnUntracedGen(effectGenNode)),\n                Nano.orElse(() => typeParser.effectFnGen(effectGenNode)),\n                Nano.option\n              )\n              if (Option.isSome(effectGenLike)) {\n                // emit diagnostic\n                const fix = node.expression ?\n                  [{\n                    fixName: \"missingReturnYieldStar_fix\",\n                    description: \"Add return statement\",\n                    apply: Nano.gen(function*() {\n                      const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                      changeTracker.replaceNode(\n                        sourceFile,\n                        node,\n                        ts.factory.createReturnStatement(\n                          node\n                        )\n                      )\n                    })\n                  }] :\n                  []\n\n                report({\n                  location: node,\n                  messageText:\n                    `It is recommended to use return yield* for Effects that never succeed to signal a definitive exit point for type narrowing and tooling support.`,\n                  fixes: fix\n                })\n              }\n            }\n          }\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const missingStarInYieldEffectGen = LSP.createDiagnostic({\n  name: \"missingStarInYieldEffectGen\",\n  code: 4,\n  severity: \"error\",\n  apply: Nano.fn(\"missingStarInYieldEffectGen.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n\n    const brokenGenerators = new Set<number>()\n    const brokenYields = new Set<ts.YieldExpression>()\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // error if yield is not followed by *\n      if (\n        ts.isYieldExpression(node) && node.expression &&\n        node.asteriskToken === undefined\n      ) {\n        // go up until we meet the causing generator\n        const functionStarNode = ts.findAncestor(\n          node,\n          (_) => (ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_))\n        )\n\n        // .gen should always be the parent ideally\n        if (functionStarNode && functionStarNode.parent) {\n          const effectGenNode = functionStarNode.parent\n          // continue if we hit effect gen-like\n          yield* pipe(\n            typeParser.effectGen(effectGenNode),\n            Nano.orElse(() => typeParser.effectFnUntracedGen(effectGenNode)),\n            Nano.orElse(() => typeParser.effectFnGen(effectGenNode)),\n            Nano.map(({ generatorFunction }) => {\n              if (generatorFunction) {\n                brokenGenerators.add(ts.getTokenPosOfNode(generatorFunction, tsUtils.getSourceFileOfNode(node)!))\n              }\n              brokenYields.add(node)\n            }),\n            Nano.ignore\n          )\n        }\n      }\n    }\n\n    // emit diagnostics\n    brokenGenerators.forEach((pos) =>\n      report({\n        location: ({ pos, end: pos + \"function\".length }),\n        messageText: `Seems like you used yield instead of yield* inside this Effect.gen.`,\n        fixes: []\n      })\n    )\n    brokenYields.forEach((node) => {\n      const fix = node.expression ?\n        [{\n          fixName: \"missingStarInYieldEffectGen_fix\",\n          description: \"Replace yield with yield*\",\n          apply: Nano.gen(function*() {\n            const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n            changeTracker.replaceNode(\n              sourceFile,\n              node,\n              ts.factory.createYieldExpression(\n                ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n                node.expression!\n              )\n            )\n          })\n        }] :\n        []\n\n      report({\n        location: node,\n        messageText: `When yielding Effects inside Effect.gen, you should use yield* instead of yield.`,\n        fixes: fix\n      })\n    })\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const multipleEffectProvide = LSP.createDiagnostic({\n  name: \"multipleEffectProvide\",\n  code: 18,\n  severity: \"warning\",\n  apply: Nano.fn(\"multipleEffectProvide.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Effect\"\n    ) || \"Effect\"\n\n    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Layer\"\n    ) || \"Layer\"\n\n    const parseEffectProvideLayer = (node: ts.Node) => {\n      if (\n        ts.isCallExpression(node) &&\n        node.arguments.length > 0\n      ) {\n        const layer = node.arguments[0]\n        const type = typeChecker.getTypeAtLocation(layer)\n        return pipe(\n          typeParser.isNodeReferenceToEffectModuleApi(\"provide\")(node.expression),\n          Nano.flatMap(() => typeParser.layerType(type, layer)),\n          Nano.map(() => ({ layer, node })),\n          Nano.orElse(() => Nano.void_)\n        )\n      }\n      return Nano.void_\n    }\n\n    const parsePipeCall = (node: ts.Node) =>\n      Nano.gen(function*() {\n        const { args } = yield* typeParser.pipeCall(node)\n        let currentChunk = 0\n        const previousLayers: Array<Array<{ layer: ts.Expression; node: ts.CallExpression }>> = [[]]\n        for (const pipeArg of args) {\n          const parsedProvide = yield* (parseEffectProvideLayer(pipeArg))\n          if (parsedProvide) {\n            previousLayers[currentChunk].push(parsedProvide)\n          } else {\n            currentChunk++\n            previousLayers.push([])\n          }\n        }\n        // report for each chunk\n        for (const chunk of previousLayers) {\n          if (chunk.length < 2) continue\n          report({\n            location: chunk[0].node,\n            messageText:\n              \"Avoid chaining Effect.provide calls, as this can lead to service lifecycle issues. Instead, merge layers and provide them in a single call.\",\n            fixes: [{\n              fixName: \"multipleEffectProvide_fix\",\n              description: \"Combine into a single provide\",\n              apply: Nano.gen(function*() {\n                const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n                changeTracker.deleteRange(sourceFile, {\n                  pos: ts.getTokenPosOfNode(chunk[0].node, sourceFile),\n                  end: chunk[chunk.length - 1].node.end\n                })\n                const newNode = ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    ts.factory.createIdentifier(effectModuleIdentifier),\n                    ts.factory.createIdentifier(\"provide\")\n                  ),\n                  undefined,\n                  [ts.factory.createCallExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      ts.factory.createIdentifier(layerModuleIdentifier),\n                      ts.factory.createIdentifier(\"mergeAll\")\n                    ),\n                    undefined,\n                    chunk.map((c) => c.layer)\n                  )]\n                )\n                changeTracker.insertNodeAt(sourceFile, ts.getTokenPosOfNode(chunk[0].node, sourceFile), newNode)\n              })\n            }]\n          })\n        }\n      })\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(parsePipeCall(node), Nano.ignore)\n      }\n    }\n  })\n})\n","import { pipe } from \"effect\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const nonObjectEffectServiceType = LSP.createDiagnostic({\n  name: \"nonObjectEffectServiceType\",\n  code: 24,\n  severity: \"error\",\n  apply: Nano.fn(\"nonObjectEffectServiceType.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    function isPrimitiveType(type: ts.Type): boolean {\n      return typeCheckerUtils.unrollUnionMembers(type).some((type) =>\n        !!(\n          type.flags & ts.TypeFlags.String ||\n          type.flags & ts.TypeFlags.Number ||\n          type.flags & ts.TypeFlags.Boolean ||\n          type.flags & ts.TypeFlags.StringLiteral ||\n          type.flags & ts.TypeFlags.NumberLiteral ||\n          type.flags & ts.TypeFlags.BooleanLiteral ||\n          type.flags & ts.TypeFlags.Undefined ||\n          type.flags & ts.TypeFlags.Null\n        )\n      )\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        const serviceResult = yield* pipe(\n          typeParser.extendsEffectService(node),\n          Nano.orElse(() => Nano.void_)\n        )\n\n        if (serviceResult && serviceResult.options && ts.isObjectLiteralExpression(serviceResult.options)) {\n          const options = serviceResult.options\n\n          for (const property of options.properties) {\n            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {\n              continue\n            }\n\n            const propertyName = ts.idText(property.name)\n            const propertyValue = property.initializer\n\n            const errorToReport = {\n              location: property.name,\n              messageText:\n                \"Effect.Service requires the service type to be an object {} and not a primitive type. \\nConsider wrapping the value in an object, or manually using Context.Tag or Effect.Tag if you want to use a primitive instead.\",\n              fixes: []\n            }\n\n            if (propertyName === \"succeed\") {\n              const valueType = typeChecker.getTypeAtLocation(propertyValue)\n              if (isPrimitiveType(valueType)) {\n                report(errorToReport)\n              }\n            } else if (propertyName === \"sync\") {\n              const valueType = typeChecker.getTypeAtLocation(propertyValue)\n              const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call)\n\n              for (const signature of signatures) {\n                const returnType = typeChecker.getReturnTypeOfSignature(signature)\n                if (isPrimitiveType(returnType)) {\n                  report(errorToReport)\n                  break\n                }\n              }\n            } else if (propertyName === \"effect\" || propertyName === \"scoped\") {\n              const valueType = typeChecker.getTypeAtLocation(propertyValue)\n\n              const effectResult = yield* pipe(\n                typeParser.effectType(valueType, propertyValue),\n                Nano.orElse(() => Nano.void_)\n              )\n\n              if (effectResult) {\n                if (isPrimitiveType(effectResult.A)) {\n                  report(errorToReport)\n                  continue\n                }\n              } else {\n                const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call)\n                for (const signature of signatures) {\n                  const returnType = typeChecker.getReturnTypeOfSignature(signature)\n\n                  const effectReturnResult = yield* pipe(\n                    typeParser.effectType(returnType, propertyValue),\n                    Nano.orElse(() => Nano.void_)\n                  )\n\n                  if (effectReturnResult && isPrimitiveType(effectReturnResult.A)) {\n                    report(errorToReport)\n                    break\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const generate = Nano.fn(\"writeTagClassAccessors.generate\")(function*(\n  sourceFile: ts.SourceFile,\n  service: ts.Type,\n  className: ts.Identifier,\n  atLocation: ts.ClassDeclaration,\n  involvedMembers: Array<{ property: ts.Symbol; propertyType: ts.Type }>\n) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n  const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n  const typeParser = yield* Nano.service(TypeParser.TypeParser)\n  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n  const insertLocation = atLocation.members.length > 0 ? atLocation.members[0].pos : atLocation.end - 1\n\n  const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n    sourceFile,\n    \"effect\",\n    \"Effect\"\n  ) || \"Effect\"\n\n  const createFunctionProperty = (\n    className: ts.Identifier,\n    propertyName: string,\n    type: ts.TypeNode,\n    forceAny: boolean\n  ) => {\n    const arrowBody = ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(\n        ts.factory.createIdentifier(effectIdentifier),\n        \"andThen\"\n      ),\n      undefined,\n      [\n        ts.factory.createIdentifier(ts.idText(className)),\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [ts.factory.createParameterDeclaration(\n            undefined,\n            undefined,\n            \"_\",\n            undefined,\n            forceAny ? ts.factory.createTypeReferenceNode(\"any\") : undefined\n          )],\n          undefined,\n          undefined,\n          ts.factory.createCallExpression(\n            ts.factory.createPropertyAccessExpression(\n              ts.factory.createIdentifier(\"_\"),\n              propertyName\n            ),\n            undefined,\n            [\n              ts.factory.createSpreadElement(ts.factory.createIdentifier(\"args\"))\n            ]\n          )\n        )\n      ]\n    )\n    return ts.factory.createPropertyDeclaration(\n      [\n        ts.factory.createModifier(ts.SyntaxKind.StaticKeyword),\n        ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword)\n      ],\n      propertyName,\n      undefined,\n      type,\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [ts.factory.createParameterDeclaration(\n          undefined,\n          ts.factory.createToken(ts.SyntaxKind.DotDotDotToken),\n          \"args\",\n          undefined,\n          forceAny ? ts.factory.createArrayTypeNode(ts.factory.createTypeReferenceNode(\"any\")) : undefined\n        )],\n        undefined,\n        undefined,\n        forceAny ? ts.factory.createAsExpression(arrowBody, ts.factory.createTypeReferenceNode(\"any\")) : arrowBody\n      )\n    )\n  }\n\n  const generateReturnType = (type: ts.Type, atLocation: ts.ClassDeclaration, className: ts.Identifier) =>\n    pipe(\n      typeParser.effectType(type, atLocation),\n      Nano.flatMap((returnedEffect) => {\n        // the type is an effect, so we just need to add the service type to the context type\n        const contextType = (returnedEffect.R.flags & ts.TypeFlags.Never) ?\n          ts.factory.createTypeReferenceNode(ts.idText(className)) :\n          ts.factory.createUnionTypeNode(\n            [\n              ts.factory.createTypeReferenceNode(ts.idText(className)),\n              typeChecker.typeToTypeNode(returnedEffect.R, atLocation, ts.NodeBuilderFlags.NoTruncation)!\n            ]\n          )\n\n        const successType = typeChecker.typeToTypeNode(\n          returnedEffect.A,\n          atLocation,\n          ts.NodeBuilderFlags.NoTruncation\n        )\n        if (!successType) return Nano.fail(\"error generating success type\")\n\n        const failureType = typeChecker.typeToTypeNode(\n          returnedEffect.E,\n          atLocation,\n          ts.NodeBuilderFlags.NoTruncation\n        )\n        if (!failureType) return Nano.fail(\"error generating failure type\")\n\n        const typeNode = ts.factory.createTypeReferenceNode(\n          ts.factory.createQualifiedName(\n            ts.factory.createIdentifier(effectIdentifier),\n            ts.factory.createIdentifier(\"Effect\")\n          ),\n          [successType, failureType, contextType]\n        )\n        return Nano.succeed(typeNode)\n      }),\n      Nano.orElse(() =>\n        pipe(\n          typeParser.promiseLike(type, atLocation),\n          Nano.flatMap(({ type }) => {\n            const successType = typeChecker.typeToTypeNode(\n              type,\n              atLocation,\n              ts.NodeBuilderFlags.NoTruncation\n            )\n            if (!successType) return Nano.fail(\"error generating success type\")\n            return Nano.succeed(ts.factory.createTypeReferenceNode(\n              ts.factory.createQualifiedName(\n                ts.factory.createIdentifier(effectIdentifier),\n                ts.factory.createIdentifier(\"Effect\")\n              ),\n              [\n                successType,\n                ts.factory.createTypeReferenceNode(\n                  ts.factory.createQualifiedName(\n                    ts.factory.createIdentifier(\"Cause\"),\n                    ts.factory.createIdentifier(\"UnknownException\")\n                  )\n                ),\n                ts.factory.createTypeReferenceNode(ts.idText(className))\n              ]\n            ))\n          })\n        )\n      ),\n      Nano.orElse(() => {\n        // fallback to just converting A into a Effect<A, never, Service>\n        const successType = typeChecker.typeToTypeNode(type, atLocation, ts.NodeBuilderFlags.NoTruncation)\n        if (!successType) return Nano.fail(\"error generating success type\")\n        const typeNode = ts.factory.createTypeReferenceNode(\n          ts.factory.createQualifiedName(\n            ts.factory.createIdentifier(effectIdentifier),\n            ts.factory.createIdentifier(\"Effect\")\n          ),\n          [\n            successType,\n            ts.factory.createTypeReferenceNode(\"never\"),\n            ts.factory.createTypeReferenceNode(ts.idText(className))\n          ]\n        )\n\n        return Nano.succeed(typeNode)\n      })\n    )\n\n  const proxySignature = (signature: ts.Signature, atLocation: ts.ClassDeclaration, className: ts.Identifier) =>\n    Nano.gen(function*() {\n      // generate the signature\n      const signatureDeclaration = typeChecker.signatureToSignatureDeclaration(\n        signature,\n        ts.SyntaxKind.FunctionType,\n        atLocation,\n        ts.NodeBuilderFlags.NoTruncation\n      )\n\n      if (!signatureDeclaration) return yield* Nano.fail(\"error generating signature\")\n\n      // wrap the return type as it would be in a Effect.andThen\n      const returnType = yield* generateReturnType(\n        typeChecker.getReturnTypeOfSignature(signature),\n        atLocation,\n        className\n      )\n\n      // construct the new signature\n      return ts.factory.createFunctionTypeNode(\n        signatureDeclaration.typeParameters,\n        signatureDeclaration.parameters,\n        returnType\n      )\n    })\n\n  for (const { property, propertyType } of involvedMembers) {\n    const callSignatures: Array<ts.FunctionTypeNode> = []\n    let propertyDeclaration: ts.PropertyDeclaration | undefined = undefined\n    for (const signature of typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)) {\n      yield* pipe(\n        proxySignature(signature, atLocation, className),\n        Nano.map((sig) => {\n          callSignatures.push(sig)\n        }),\n        Nano.ignore\n      )\n    }\n    // this is a call signature:\n    // static method: <A>(value: A) => Effect<A, never, Service> = (value) => Effect.andThen(Service, _ => _.method(value))\n    const allSignatures = ts.factory.createIntersectionTypeNode(callSignatures)\n    const type = tsUtils.simplifyTypeNode(allSignatures)\n    propertyDeclaration = createFunctionProperty(className, ts.symbolName(property), type, callSignatures.length > 1)\n\n    // then we need to delete the old property (if present)\n    const oldProperty = atLocation.members.filter(ts.isPropertyDeclaration).find((p) => {\n      const symbol = typeChecker.getSymbolAtLocation(p.name)\n      return symbol && ts.symbolName(symbol) === ts.symbolName(property)\n    })\n    if (oldProperty) {\n      const start = ts.getTokenPosOfNode(oldProperty, sourceFile)\n      changeTracker.deleteRange(sourceFile, {\n        pos: start,\n        end: oldProperty.end\n      })\n      changeTracker.insertNodeAt(sourceFile, start, propertyDeclaration)\n    } else {\n      changeTracker.insertNodeAt(sourceFile, insertLocation, propertyDeclaration, { suffix: \"\\n\" })\n    }\n  }\n})\n\nexport const parse = Nano.fn(\"writeTagClassAccessors.parse\")(function*(node: ts.Node) {\n  const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n  const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n  const typeParser = yield* Nano.service(TypeParser.TypeParser)\n  const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n  // only applicable to class declarations\n  if (!ts.isClassDeclaration(node)) return yield* Nano.fail(\"not a class declaration\")\n\n  const { Service, accessors, className } = yield* pipe(\n    typeParser.extendsEffectService(node),\n    Nano.orElse(() => Nano.map(typeParser.extendsEffectTag(node), (_) => ({ accessors: true, ..._ }))),\n    Nano.orElse(() => Nano.fail(\"not a class extending Effect.Service call\"))\n  )\n  if (accessors !== true) return yield* Nano.fail(\"accessors are not enabled in the Effect.Service call\")\n\n  const involvedMembers: Array<{ property: ts.Symbol; propertyType: ts.Type }> = []\n\n  const nonPrimitiveServices = typeCheckerUtils.unrollUnionMembers(Service).filter((_) =>\n    !((_.flags & ts.TypeFlags.Number) || (_.flags & ts.TypeFlags.String) || (_.flags & ts.TypeFlags.Boolean) ||\n      (_.flags & ts.TypeFlags.Literal))\n  )\n\n  if (nonPrimitiveServices.length === 0) return yield* Nano.fail(\"Service type is a primitive type\")\n\n  for (const serviceShape of nonPrimitiveServices) {\n    for (const property of typeChecker.getPropertiesOfType(serviceShape)) {\n      const propertyType = typeChecker.getTypeOfSymbolAtLocation(property, node)\n      const callSignatures = typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)\n      if (callSignatures.length > 0) {\n        const withTypeParameters = callSignatures.filter((_) => _.typeParameters && _.typeParameters.length > 0)\n        if (callSignatures.length > 1 || withTypeParameters.length > 0) involvedMembers.push({ property, propertyType })\n      }\n    }\n  }\n\n  const hash = involvedMembers.map(({ property, propertyType }) => {\n    return ts.symbolName(property) + \": \" + typeChecker.typeToString(propertyType)\n  }).concat([ts.idText(className)]).join(\"\\n\")\n\n  return { Service, className, atLocation: node, hash: LSP.cyrb53(hash), involvedMembers }\n})\n\nexport const writeTagClassAccessors = LSP.createRefactor({\n  name: \"writeTagClassAccessors\",\n  description: \"Implement accessors methods with generics or multiple signatures\",\n  apply: Nano.fn(\"writeTagClassAccessors.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const parseNode = (node: ts.Node) =>\n      pipe(\n        parse(node),\n        Nano.map(({ Service, atLocation, className, involvedMembers }) => ({\n          kind: \"refactor.rewrite.effect.writeTagClassAccessors\",\n          description: \"Implement Service accessors\",\n          apply: pipe(\n            generate(sourceFile, Service, className, atLocation, involvedMembers),\n            Nano.provideService(TypeScriptUtils.TypeScriptUtils, tsUtils),\n            Nano.provideService(TypeParser.TypeParser, typeParser),\n            Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker),\n            Nano.provideService(TypeScriptApi.TypeScriptApi, ts)\n          )\n        }))\n      )\n\n    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange)\n\n    return yield* pipe(\n      Nano.firstSuccessOf(parentNodes.map(parseNode)),\n      Nano.orElse(() => Nano.fail(new LSP.RefactorNotApplicableError()))\n    )\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\nimport * as refactor from \"../refactors/writeTagClassAccessors.js\"\n\nexport const accessors = LSP.createCodegen({\n  name: \"accessors\",\n  apply: Nano.fn(\"accessors.apply\")(function*(sourceFile, textRange) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos)\n    if (!nodeAndCommentRange) return yield* Nano.fail(new LSP.CodegenNotApplicableError(\"no node and comment range\"))\n\n    return yield* pipe(\n      refactor.parse(nodeAndCommentRange.node),\n      Nano.map((_) =>\n        ({\n          hash: _.hash,\n          description: \"Generate accessors for the service\",\n          apply: pipe(\n            refactor.generate(sourceFile, _.Service, _.className, _.atLocation, _.involvedMembers),\n            Nano.provideService(TypeScriptApi.TypeScriptApi, ts),\n            Nano.provideService(TypeScriptUtils.TypeScriptUtils, tsUtils),\n            Nano.provideService(TypeCheckerApi.TypeCheckerApi, typeChecker),\n            Nano.provideService(TypeParser.TypeParser, typeParser),\n            Nano.provideService(TypeCheckerUtils.TypeCheckerUtils, typeCheckerUtils)\n          )\n        }) satisfies LSP.ApplicableCodegenDefinition\n      ),\n      Nano.orElse((cause) => Nano.fail(new LSP.CodegenNotApplicableError(cause)))\n    )\n  })\n})\n","import { accessors } from \"./codegens/accessors.js\"\n\nexport const codegens = [accessors]\n","import { pipe } from \"effect/Function\"\nimport { codegens } from \"../codegens.js\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\n\nexport const outdatedEffectCodegen = LSP.createDiagnostic({\n  name: \"outdatedEffectCodegen\",\n  code: 19,\n  severity: \"warning\",\n  apply: Nano.fn(\"outdatedEffectCodegen.apply\")(function*(sourceFile, _report) {\n    const codegensWithRanges = yield* LSP.getCodegensForSourceFile(codegens, sourceFile)\n    for (const { codegen, hash, range } of codegensWithRanges) {\n      yield* pipe(\n        LSP.getEditsForCodegen([codegen], sourceFile, range),\n        Nano.map((applicable) => {\n          if (applicable.hash !== hash) {\n            _report({\n              location: range,\n              messageText: `Codegen ${codegen.name} result is outdated`,\n              fixes: [\n                {\n                  fixName: \"outdatedEffectCodegen_fix\",\n                  description: `Re-run ${codegen.name}`,\n                  apply: applicable.apply\n                },\n                {\n                  fixName: \"outdatedEffectCodegen_ignore\",\n                  description: `Ignore this ${codegen.name} update`,\n                  apply: applicable.ignore\n                }\n              ]\n            })\n          }\n        }),\n        Nano.orElse((e) =>\n          Nano.sync(() => {\n            _report({\n              location: range,\n              messageText: `Codegen ${codegen.name} is not applicable here: ${e.cause}`,\n              fixes: []\n            })\n          })\n        ),\n        Nano.ignore\n      )\n    }\n  })\n})\n","import { pipe } from \"effect\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const overriddenSchemaConstructor = LSP.createDiagnostic({\n  name: \"overriddenSchemaConstructor\",\n  code: 30,\n  severity: \"error\",\n  apply: Nano.fn(\"overriddenSchemaConstructor.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      // Check if this is a class declaration with heritage clauses\n      if (ts.isClassDeclaration(node) && node.heritageClauses) {\n        // Check if any heritage clause extends a Schema type\n        let extendsSchema = false\n\n        for (const heritageClause of node.heritageClauses) {\n          if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\n            for (const type of heritageClause.types) {\n              const typeAtLocation = typeChecker.getTypeAtLocation(type.expression)\n              // Check if this type is a valid Schema type\n              const isSchema = yield* pipe(\n                typeParser.effectSchemaType(typeAtLocation, type.expression),\n                Nano.map(() => true),\n                Nano.orElse(() => Nano.succeed(false))\n              )\n\n              if (isSchema) {\n                extendsSchema = true\n                break\n              }\n            }\n          }\n          if (extendsSchema) break\n        }\n\n        // If the class extends a Schema, check for constructor overrides\n        if (extendsSchema) {\n          const members = node.members\n          for (const member of members) {\n            if (ts.isConstructorDeclaration(member)) {\n              // fix to rewrite as a static 'new' method\n              const fixAsStaticNew = {\n                fixName: \"overriddenSchemaConstructor_static\",\n                description: \"Rewrite using the static 'new' pattern\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  const visitor: ts.Visitor = (node) => {\n                    if (\n                      ts.isExpressionStatement(node) &&\n                      ts.isCallExpression(node.expression) && ts.isToken(node.expression.expression) &&\n                      node.expression.expression.kind === ts.SyntaxKind.SuperKeyword\n                    ) {\n                      const constructThis = ts.factory.createNewExpression(\n                        ts.factory.createIdentifier(\"this\"),\n                        undefined,\n                        node.expression.arguments\n                      )\n                      return ts.factory.createVariableStatement(\n                        undefined,\n                        ts.factory.createVariableDeclarationList(\n                          [ts.factory.createVariableDeclaration(\n                            \"_this\",\n                            undefined,\n                            undefined,\n                            constructThis\n                          )],\n                          ts.NodeFlags.Const\n                        )\n                      )\n                    }\n                    if (ts.isToken(node) && node.kind === ts.SyntaxKind.ThisKeyword) {\n                      return ts.factory.createIdentifier(\"_this\")\n                    }\n                    return ts.visitEachChild(node, visitor, ts.nullTransformationContext)\n                  }\n                  const newBody = visitor(member.body!)! as ts.Block\n                  const bodyWithReturn = ts.factory.updateBlock(\n                    newBody,\n                    newBody.statements.concat([\n                      ts.factory.createReturnStatement(ts.factory.createIdentifier(\"_this\"))\n                    ])\n                  )\n\n                  const newMethod = ts.factory.createMethodDeclaration(\n                    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Public | ts.ModifierFlags.Static),\n                    undefined,\n                    \"new\",\n                    undefined,\n                    member.typeParameters,\n                    member.parameters,\n                    member.type,\n                    bodyWithReturn\n                  )\n\n                  changeTracker.replaceNode(sourceFile, member, newMethod)\n                })\n              }\n\n              // Report diagnostic at the constructor location\n              report({\n                location: member,\n                messageText:\n                  \"Classes extending Schema must not override the constructor; this is because it silently breaks the schema decoding behaviour. If that's needed, we recommend instead to use a static 'new' method that constructs the instance.\",\n                fixes: (member.body ? [fixAsStaticNew] : []).concat([{\n                  fixName: \"overriddenSchemaConstructor_fix\",\n                  description: \"Remove the constructor override\",\n                  apply: Nano.gen(function*() {\n                    const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n                    changeTracker.delete(sourceFile, member)\n                  })\n                }])\n              })\n              break\n            }\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const returnEffectInGen = LSP.createDiagnostic({\n  name: \"returnEffectInGen\",\n  code: 11,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"returnEffectInGen.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // start from the return statement\n      if (\n        ts.isReturnStatement(node) && node.expression\n      ) {\n        // fast exit\n        if (ts.isYieldExpression(node.expression)) continue\n\n        // go up until we meet the causing generator/function\n        const generatorOrRegularFunction = ts.findAncestor(\n          node,\n          (\n            _\n          ) => (ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) ||\n            ts.isArrowFunction(_) || ts.isGetAccessor(_))\n        )\n\n        if (\n          !(generatorOrRegularFunction && \"asteriskToken\" in generatorOrRegularFunction &&\n            generatorOrRegularFunction.asteriskToken)\n        ) continue // fast exit\n\n        // are we returning an effect with never as success type?\n        const type = typeChecker.getTypeAtLocation(node.expression)\n        const maybeEffect = yield* Nano.option(typeParser.strictEffectType(type, node.expression))\n\n        if (Option.isSome(maybeEffect)) {\n          // .gen should always be the parent ideally\n          if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {\n            const effectGenNode = generatorOrRegularFunction.parent\n            // continue if we hit effect gen-like\n            yield* pipe(\n              typeParser.effectGen(effectGenNode),\n              Nano.orElse(() => typeParser.effectFnUntracedGen(effectGenNode)),\n              Nano.orElse(() => typeParser.effectFnGen(effectGenNode)),\n              Nano.map(() => {\n                const fix = node.expression ?\n                  [{\n                    fixName: \"returnEffectInGen_fix\",\n                    description: \"Add yield* statement\",\n                    apply: Nano.gen(function*() {\n                      const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                      changeTracker.replaceNode(\n                        sourceFile,\n                        node.expression!,\n                        ts.factory.createYieldExpression(\n                          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),\n                          node.expression!\n                        )\n                      )\n                    })\n                  }] :\n                  []\n\n                report({\n                  location: node,\n                  messageText:\n                    `You are returning an Effect-able type inside a generator function, and will result in nested Effect<Effect<...>>.\\nMaybe you wanted to return yield* instead?\\nNested Effect-able types may be intended if you plan to later manually flatten or unwrap this Effect, if so you can safely disable this diagnostic for this line through quickfixes.`,\n                  fixes: fix\n                })\n              }),\n              Nano.ignore\n            )\n          }\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as TypeScriptUtils from \"../core/TypeScriptUtils.js\"\n\nexport const scopeInLayerEffect = LSP.createDiagnostic({\n  name: \"scopeInLayerEffect\",\n  code: 13,\n  severity: \"warning\",\n  apply: Nano.fn(\"scopeInLayerEffect.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const tsUtils = yield* Nano.service(TypeScriptUtils.TypeScriptUtils)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n\n    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(\n      sourceFile,\n      \"effect\",\n      \"Layer\"\n    ) || \"Layer\"\n\n    function parseLayerEffectApiCall(node: ts.Node): { methodIdentifier: ts.Identifier } | undefined {\n      // should be a call expression of a property access like Layer.effect\n      // we first check thats a call, then ensure that the callee is a property access\n      // and that the property is \"effect\"\n      if (!ts.isCallExpression(node)) return\n      const expression = node.expression\n      if (!ts.isPropertyAccessExpression(expression)) return\n      // we check that the api is called on the Layer module\n      const calledModule = expression.expression\n      if (!(ts.isIdentifier(calledModule) && ts.idText(calledModule) === layerModuleIdentifier)) return\n      const methodIdentifier = expression.name\n      // *.effect, *.effectContext, whatever...\n      if (!(ts.isIdentifier(methodIdentifier) && ts.idText(methodIdentifier).toLowerCase().startsWith(\"effect\"))) return\n      return { methodIdentifier }\n    }\n\n    const reportIfLayerRequireScope = (type: ts.Type, node: ts.Node, methodIdentifier: ts.Identifier | undefined) => {\n      const entries: Array<ts.Type> = typeCheckerUtils.unrollUnionMembers(type)\n      return pipe(\n        Nano.firstSuccessOf(entries.map((type) => typeParser.scopeType(type, node))),\n        Nano.map(() =>\n          report({\n            location: node,\n            messageText:\n              `Seems like you are constructing a layer with a scope in the requirements.\\nConsider using \"scoped\" instead to get rid of the scope in the requirements.`,\n            fixes: methodIdentifier ?\n              [{\n                fixName: \"scopeInLayerEffect_scoped\",\n                description: \"Use scoped for Layer creation\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  changeTracker.replaceNode(\n                    sourceFile,\n                    methodIdentifier,\n                    ts.factory.createIdentifier(\"scoped\")\n                  )\n                })\n              }] :\n              []\n          })\n        ),\n        Nano.ignore\n      )\n    }\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n\n      const layerEffectApiCall = parseLayerEffectApiCall(node)\n      if (layerEffectApiCall) {\n        const type = typeChecker.getTypeAtLocation(node)\n        yield* pipe(\n          typeParser.layerType(type, node),\n          Nano.flatMap(({ RIn }) => reportIfLayerRequireScope(RIn, node, layerEffectApiCall.methodIdentifier)),\n          Nano.ignore\n        )\n        continue\n      }\n\n      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {\n        const classSym = typeChecker.getSymbolAtLocation(node.name)\n        if (classSym) {\n          const classType = typeChecker.getTypeOfSymbol(classSym)\n          const defaultLayer = typeChecker.getPropertyOfType(classType, \"Default\")\n          if (defaultLayer) {\n            const type = typeChecker.getTypeOfSymbolAtLocation(defaultLayer, node)\n            yield* pipe(\n              typeParser.layerType(type, node),\n              Nano.flatMap(({ RIn }) => reportIfLayerRequireScope(RIn, node, undefined)),\n              Nano.ignore\n            )\n            continue\n          }\n        }\n      }\n\n      ts.forEachChild(node, appendNodeToVisit)\n    }\n  })\n})\n","import type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeCheckerUtils from \"../core/TypeCheckerUtils.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const strictBooleanExpressions = LSP.createDiagnostic({\n  name: \"strictBooleanExpressions\",\n  code: 17,\n  severity: \"off\",\n  apply: Nano.fn(\"strictBooleanExpressions.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeCheckerUtils = yield* Nano.service(TypeCheckerUtils.TypeCheckerUtils)\n    const conditionChecks = new WeakMap<ts.Node, boolean>()\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      const nodes: Array<ts.Node> = []\n      if (ts.isIfStatement(node)) {\n        conditionChecks.set(node, true)\n        nodes.push(node.expression)\n      } else if (ts.isWhileStatement(node)) {\n        conditionChecks.set(node, true)\n        nodes.push(node.expression)\n      } else if (ts.isConditionalExpression(node)) {\n        conditionChecks.set(node, true)\n        nodes.push(node.condition)\n      } else if (ts.isPrefixUnaryExpression(node) && node.operator === ts.SyntaxKind.ExclamationToken) {\n        conditionChecks.set(node, true)\n        nodes.push(node.operand)\n      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {\n        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true)\n        nodes.push(node.left)\n        nodes.push(node.right)\n      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {\n        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true)\n        nodes.push(node.left)\n        nodes.push(node.right)\n      }\n\n      for (const nodeToCheck of nodes) {\n        if (!nodeToCheck) continue\n        if (!conditionChecks.has(nodeToCheck.parent)) continue\n\n        const nodeType = typeChecker.getTypeAtLocation(nodeToCheck)\n        const constrainedType = typeChecker.getBaseConstraintOfType(nodeType)\n        let typesToCheck = [constrainedType || nodeType]\n\n        while (typesToCheck.length > 0) {\n          const type = typesToCheck.pop()!\n\n          // unroll union types\n          if (typeCheckerUtils.isUnion(type)) {\n            typesToCheck = typesToCheck.concat(type.types)\n            continue\n          }\n\n          // skip boolean and never types\n          if (type.flags & ts.TypeFlags.Boolean) continue\n          if (type.flags & ts.TypeFlags.Never) continue\n          if (type.flags & ts.TypeFlags.BooleanLiteral) continue\n\n          // report the error\n          const typeName = typeChecker.typeToString(type)\n          report({\n            location: nodeToCheck,\n            messageText: `Unexpected \\`${typeName}\\` type in condition, expected strictly a boolean instead.`,\n            fixes: []\n          })\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeCheckerApi from \"../core/TypeCheckerApi.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const strictEffectProvide = LSP.createDiagnostic({\n  name: \"strictEffectProvide\",\n  code: 27,\n  severity: \"off\",\n  apply: Nano.fn(\"strictEffectProvide.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeChecker = yield* Nano.service(TypeCheckerApi.TypeCheckerApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const parseEffectProvideWithLayer = (node: ts.Node) =>\n      Nano.gen(function*() {\n        // Check if this is a call expression: Effect.provide(...)\n        if (\n          !ts.isCallExpression(node) ||\n          node.arguments.length === 0\n        ) {\n          return yield* TypeParser.typeParserIssue(\"Not an Effect.provide call\")\n        }\n\n        // Check if the expression is from the Effect module\n        yield* typeParser.isNodeReferenceToEffectModuleApi(\"provide\")(node.expression)\n\n        // Check if any argument is a Layer using firstSuccessOf\n        return yield* Nano.firstSuccessOf(\n          node.arguments.map((arg) => {\n            const argType = typeChecker.getTypeAtLocation(arg)\n            return typeParser.layerType(argType, arg)\n          })\n        )\n      })\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        const layerCheck = yield* pipe(parseEffectProvideWithLayer(node), Nano.option)\n        if (Option.isSome(layerCheck)) {\n          report({\n            location: node,\n            messageText:\n              \"Effect.provide with a Layer should only be used at application entry points. If this is an entry point, you can safely disable this diagnostic. Otherwise, using Effect.provide may break scope lifetimes. Compose all layers at your entry point and provide them at once.\",\n            fixes: []\n          })\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const tryCatchInEffectGen = LSP.createDiagnostic({\n  name: \"tryCatchInEffectGen\",\n  code: 15,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"tryCatchInEffectGen.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // Check if this is a try statement\n      if (ts.isTryStatement(node) && node.catchClause) {\n        // Find the containing generator function\n        // go up until we meet the causing generator/function\n        const generatorOrRegularFunction = ts.findAncestor(\n          node,\n          (\n            _\n          ) => (ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) ||\n            ts.isArrowFunction(_) || ts.isGetAccessor(_) || ts.isFunctionLike(_))\n        )\n\n        if (\n          !(generatorOrRegularFunction && \"asteriskToken\" in generatorOrRegularFunction &&\n            generatorOrRegularFunction.asteriskToken)\n        ) continue // fast exit\n\n        if (!generatorOrRegularFunction) continue\n\n        // Check if we're inside Effect.gen or Effect.fn\n        if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {\n          const effectGenNode = generatorOrRegularFunction.parent\n\n          // Check if this generator is inside Effect.gen/Effect.fn\n          yield* pipe(\n            typeParser.effectGen(effectGenNode),\n            Nano.orElse(() => typeParser.effectFnUntracedGen(effectGenNode)),\n            Nano.orElse(() => typeParser.effectFnGen(effectGenNode)),\n            Nano.map(() => {\n              report({\n                location: node,\n                messageText:\n                  \"Avoid using try/catch inside Effect generators. Use Effect's error handling mechanisms instead (e.g., Effect.try, Effect.tryPromise, Effect.catchAll, Effect.catchTag).\",\n                fixes: []\n              })\n            }),\n            Nano.ignore\n          )\n        }\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const unnecessaryEffectGen = LSP.createDiagnostic({\n  name: \"unnecessaryEffectGen\",\n  code: 5,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"unnecessaryEffectGen.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(\n          typeParser.unnecessaryEffectGen(node),\n          Nano.map(({ replacementNode }) =>\n            report({\n              location: node,\n              messageText: `This Effect.gen contains a single return statement.`,\n              fixes: [{\n                fixName: \"unnecessaryEffectGen_fix\",\n                description: \"Remove the Effect.gen, and keep the body\",\n                apply: Nano.gen(function*() {\n                  const textChanges = yield* Nano.service(\n                    TypeScriptApi.ChangeTracker\n                  )\n                  textChanges.replaceNode(sourceFile, node, yield* replacementNode)\n                })\n              }]\n            })\n          ),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const unnecessaryPipe = LSP.createDiagnostic({\n  name: \"unnecessaryPipe\",\n  code: 9,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"unnecessaryPipe.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(\n          typeParser.pipeCall(node),\n          Nano.map(({ args, subject }) => {\n            if (args.length === 0) {\n              report({\n                location: node,\n                messageText: `This pipe call contains no arguments.`,\n                fixes: [{\n                  fixName: \"unnecessaryPipe_fix\",\n                  description: \"Remove the pipe call\",\n                  apply: Nano.gen(function*() {\n                    const textChanges = yield* Nano.service(\n                      TypeScriptApi.ChangeTracker\n                    )\n                    textChanges.replaceNode(sourceFile, node, subject)\n                  })\n                }]\n              })\n            }\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect/Function\"\nimport type ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeParser from \"../core/TypeParser.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\n\nexport const unnecessaryPipeChain = LSP.createDiagnostic({\n  name: \"unnecessaryPipeChain\",\n  code: 16,\n  severity: \"suggestion\",\n  apply: Nano.fn(\"unnecessaryPipeChain.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n    const typeParser = yield* Nano.service(TypeParser.TypeParser)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      if (ts.isCallExpression(node)) {\n        yield* pipe(\n          typeParser.pipeCall(node),\n          Nano.flatMap((pipeCall) =>\n            Nano.map(typeParser.pipeCall(pipeCall.subject), (innerCall) => ({ pipeCall, innerCall }))\n          ),\n          Nano.map(({ innerCall, pipeCall }) => {\n            report({\n              location: node,\n              messageText: `Chained pipe calls can be simplified to a single pipe call`,\n              fixes: [{\n                fixName: \"unnecessaryPipeChain_fix\",\n                description: \"Rewrite as single pipe call\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(\n                    TypeScriptApi.ChangeTracker\n                  )\n                  switch (innerCall.kind) {\n                    case \"pipe\": {\n                      changeTracker.replaceNode(\n                        sourceFile,\n                        node,\n                        ts.factory.createCallExpression(\n                          ts.factory.createIdentifier(\"pipe\"),\n                          undefined,\n                          [innerCall.subject, ...innerCall.args, ...pipeCall.args]\n                        )\n                      )\n                      break\n                    }\n                    case \"pipeable\": {\n                      changeTracker.replaceNode(\n                        sourceFile,\n                        node,\n                        ts.factory.createCallExpression(\n                          ts.factory.createPropertyAccessExpression(\n                            innerCall.subject,\n                            \"pipe\"\n                          ),\n                          undefined,\n                          [...innerCall.args, ...pipeCall.args]\n                        )\n                      )\n                      break\n                    }\n                  }\n                })\n              }]\n            })\n          }),\n          Nano.ignore\n        )\n      }\n    }\n  })\n})\n","import { pipe } from \"effect\"\nimport type * as ts from \"typescript\"\nimport * as LSP from \"../core/LSP.js\"\nimport * as Nano from \"../core/Nano.js\"\nimport * as TypeScriptApi from \"../core/TypeScriptApi.js\"\nimport * as writeTagClassAccessors from \"../refactors/writeTagClassAccessors.js\"\n\nexport const unsupportedServiceAccessors = LSP.createDiagnostic({\n  name: \"unsupportedServiceAccessors\",\n  code: 21,\n  severity: \"warning\",\n  apply: Nano.fn(\"unsupportedServiceAccessors.apply\")(function*(sourceFile, report) {\n    const ts = yield* Nano.service(TypeScriptApi.TypeScriptApi)\n\n    const nodeToVisit: Array<ts.Node> = []\n    const appendNodeToVisit = (node: ts.Node) => {\n      nodeToVisit.push(node)\n      return undefined\n    }\n\n    ts.forEachChild(sourceFile, appendNodeToVisit)\n    while (nodeToVisit.length > 0) {\n      const node = nodeToVisit.shift()!\n      ts.forEachChild(node, appendNodeToVisit)\n\n      // Check if this is a class declaration that might use unsupported service accessors\n      if (ts.isClassDeclaration(node)) {\n        const parseResult = yield* pipe(\n          writeTagClassAccessors.parse(node),\n          Nano.orElse(() => Nano.succeed(null))\n        )\n\n        if (parseResult && parseResult.involvedMembers.length > 0) {\n          // Get existing static members in the class\n          const existingStaticMembers = new Set<string>()\n          node.members?.forEach((member) => {\n            if (\n              ts.isPropertyDeclaration(member) &&\n              member.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.StaticKeyword)\n            ) {\n              if (member.name && ts.isIdentifier(member.name)) {\n                existingStaticMembers.add(ts.idText(member.name))\n              }\n            }\n          })\n\n          // Filter out members that already have static implementations\n          const missingMembers = parseResult.involvedMembers.filter(({ property }) =>\n            !existingStaticMembers.has(ts.symbolName(property))\n          )\n\n          if (missingMembers.length > 0) {\n            const memberNames = missingMembers.map(({ property }) => `'${ts.symbolName(property)}'`).join(\", \")\n\n            report({\n              location: parseResult.className,\n              messageText:\n                `Even if accessors are enabled, accessors for ${memberNames} won't be available because the signature have generic type parameters or multiple call signatures.`,\n              fixes: [{\n                fixName: \"unsupportedServiceAccessors_enableCodegen\",\n                description: \"Enable accessors codegen\",\n                apply: Nano.gen(function*() {\n                  const changeTracker = yield* Nano.service(TypeScriptApi.ChangeTracker)\n\n                  // Add @effect-codegens comment before the class\n                  const comment = \"// @effect-codegens accessors\\n\"\n                  changeTracker.insertText(sourceFile, ts.getTokenPosOfNode(node, sourceFile), comment)\n                })\n              }]\n            })\n          }\n        }\n      }\n    }\n  })\n})\n","import { catchUnfailableEffect } from \"./diagnostics/catchUnfailableEffect.js\"\nimport { classSelfMismatch } from \"./diagnostics/classSelfMismatch.js\"\nimport { deterministicKeys } from \"./diagnostics/deterministicKeys.js\"\nimport { duplicatePackage } from \"./diagnostics/duplicatePackage.js\"\nimport { effectGenUsesAdapter } from \"./diagnostics/effectGenUsesAdapter.js\"\nimport { effectInVoidSuccess } from \"./diagnostics/effectInVoidSuccess.js\"\nimport { floatingEffect } from \"./diagnostics/floatingEffect.js\"\nimport { genericEffectServices } from \"./diagnostics/genericEffectServices.js\"\nimport { importFromBarrel } from \"./diagnostics/importFromBarrel.js\"\nimport { leakingRequirements } from \"./diagnostics/leakingRequirements.js\"\nimport { missedPipeableOpportunity } from \"./diagnostics/missedPipeableOpportunity.js\"\nimport { missingEffectContext } from \"./diagnostics/missingEffectContext.js\"\nimport { missingEffectError } from \"./diagnostics/missingEffectError.js\"\nimport { missingEffectServiceDependency } from \"./diagnostics/missingEffectServiceDependency.js\"\nimport { missingReturnYieldStar } from \"./diagnostics/missingReturnYieldStar.js\"\nimport { missingStarInYieldEffectGen } from \"./diagnostics/missingStarInYieldEffectGen.js\"\nimport { multipleEffectProvide } from \"./diagnostics/multipleEffectProvide.js\"\nimport { nonObjectEffectServiceType } from \"./diagnostics/nonObjectEffectServiceType.js\"\nimport { outdatedEffectCodegen } from \"./diagnostics/outdatedEffectCodegen.js\"\nimport { overriddenSchemaConstructor } from \"./diagnostics/overriddenSchemaConstructor.js\"\nimport { returnEffectInGen } from \"./diagnostics/returnEffectInGen.js\"\nimport { scopeInLayerEffect } from \"./diagnostics/scopeInLayerEffect.js\"\nimport { strictBooleanExpressions } from \"./diagnostics/strictBooleanExpressions.js\"\nimport { strictEffectProvide } from \"./diagnostics/strictEffectProvide.js\"\nimport { tryCatchInEffectGen } from \"./diagnostics/tryCatchInEffectGen.js\"\nimport { unnecessaryEffectGen } from \"./diagnostics/unnecessaryEffectGen.js\"\nimport { unnecessaryPipe } from \"./diagnostics/unnecessaryPipe.js\"\nimport { unnecessaryPipeChain } from \"./diagnostics/unnecessaryPipeChain.js\"\nimport { unsupportedServiceAccessors } from \"./diagnostics/unsupportedServiceAccessors.js\"\n\nexport const diagnostics = [\n  catchUnfailableEffect,\n  classSelfMismatch,\n  duplicatePackage,\n  effectGenUsesAdapter,\n  missingEffectContext,\n  missingEffectError,\n  missingEffectServiceDependency,\n  floatingEffect,\n  missingStarInYieldEffectGen,\n  unnecessaryEffectGen,\n  missingReturnYieldStar,\n  leakingRequirements,\n  unnecessaryPipe,\n  genericEffectServices,\n  returnEffectInGen,\n  tryCatchInEffectGen,\n  importFromBarrel,\n  scopeInLayerEffect,\n  effectInVoidSuccess,\n  unnecessaryPipeChain,\n  strictBooleanExpressions,\n  multipleEffectProvide,\n  outdatedEffectCodegen,\n  overriddenSchemaConstructor,\n  unsupportedServiceAccessors,\n  nonObjectEffectServiceType,\n  deterministicKeys,\n  missedPipeableOpportunity,\n  strictEffectProvide\n]\n"],"mappings":"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","names":["isFunction","input","dual","arity","body","arguments","apply","self","RangeError","a","b","length","c","d","e","args","identity","a","pipe","a","ab","bc","cd","de","ef","fg","gh","hi","arguments","length","ret","i","globalStoreId","globalStore","globalValue","id","compute","globalThis","Map","has","set","get","isString","input","isNumber","isBoolean","isFunction","isFunction_","isRecordOrArray","input","isObject","isFunction","hasProperty","dual","self","property","isRecord","input","isRecordOrArray","Array","isArray","GenKindTypeId","Symbol","for","GenKindImpl","value","constructor","_F","identity","_R","_","_O","_E","GenKindTypeId","Symbol","iterator","SingleShotGen","self","called","next","a","done","return","throw","e","MUL_HI","MUL_LO","YieldWrapTypeId","Symbol","for","YieldWrap","constructor","value","structuralRegionState","globalValue","enabled","tester","undefined","standard","effect_internal_function","body","forced","isNotOptimizedAway","Error","stack","includes","internalCall","genConstructor","constructor","randomHashCache","globalValue","Symbol","for","WeakMap","symbol","hash","self","structuralRegionState","enabled","number","string","toString","String","Date","toISOString","URL","href","isHash","random","Error","has","set","Math","floor","Number","MAX_SAFE_INTEGER","get","combine","b","optimize","n","u","hasProperty","Infinity","h","str","i","length","charCodeAt","structureKeys","o","keys","pipe","structure","Object","cached","arguments","length","self","hash","Object","defineProperty","symbol","value","enumerable","symbol","Symbol","for","equals","arguments","length","self","compareBoth","that","selfType","isEqual","hash","structuralRegionState","enabled","tester","Date","toISOString","URL","href","Array","isArray","every","v","i","Object","getPrototypeOf","prototype","keysSelf","keys","keysThat","key","u","hasProperty","equivalence","NodeInspectSymbol","Symbol","for","toJSON","x","hasProperty","isFunction","length","Array","isArray","map","redact","format","JSON","stringify","BaseProto","toString","Class","symbolRedactable","Symbol","for","isRedactable","u","redactableState","globalValue","fiberRefs","undefined","redact","u","isRedactable","redactableState","fiberRefs","undefined","symbolRedactable","pipeArguments","self","args","length","ret","i","len","OP_COMMIT","moduleVersion","getCurrentVersion","EffectTypeId","Symbol","for","StreamTypeId","SinkTypeId","ChannelTypeId","effectVariance","_R","_","_E","_A","_V","version","getCurrentVersion","sinkVariance","_In","_L","channelVariance","_Env","_InErr","_InElem","_InDone","_OutErr","_OutElem","_OutDone","EffectPrototype","symbol","that","cached","random","iterator","SingleShotGen","YieldWrap","pipe","pipeArguments","arguments","StructuralPrototype","structure","selfKeys","Object","keys","thatKeys","length","key","equals","CommitPrototype","_op","OP_COMMIT","StructuralCommitPrototype","TypeId","Symbol","for","CommonProto","EffectPrototype","_A","_","NodeInspectSymbol","toJSON","toString","format","SomeProto","Object","assign","create","_tag","_op","symbol","that","isOption","isSome","equals","value","cached","combine","hash","_id","NoneHash","Hash","NoneProto","isNone","input","hasProperty","fa","none","some","a","TypeId","Symbol","for","CommonProto","EffectPrototype","_R","_","NodeInspectSymbol","toJSON","toString","format","RightProto","Object","assign","create","_tag","_op","symbol","that","isEither","isRight","equals","right","combine","hash","_id","LeftProto","isLeft","left","input","hasProperty","ma","a","right","left","isLeft","isRight","map","dual","self","f","isRight","right","left","getOrElse","dual","self","onLeft","isLeft","left","right","isNonEmptyArray","self","length","make","compare","self","that","string","none","some","isNone","isSome","orElse","dual","self","that","isNone","fromNullable","nullableValue","none","some","map","dual","self","f","out","key","keys","keys","self","Object","fromIterable","collection","Array","isArray","from","append","dual","self","last","appendAll","that","fromIterable","concat","isArray","Array","isEmptyArray","self","length","isEmptyReadonlyArray","isNonEmptyReadonlyArray","isNonEmptyArray","isOutOfBounds","i","as","length","unsafeGet","dual","self","index","i","Math","floor","isOutOfBounds","Error","headNonEmpty","unsafeGet","tailNonEmpty","self","slice","reverse","self","Array","from","sort","dual","O","out","containsWith","isEquivalent","dual","self","a","i","_equivalence","Equal","equivalence","intersectionWith","isEquivalent","has","containsWith","dual","self","that","fromIterable","filter","a","intersection","_equivalence","empty","map","dual","self","f","flatMap","isEmptyReadonlyArray","out","i","length","inner","j","push","flatten","identity","filter","dual","self","predicate","as","fromIterable","out","i","length","push","dedupeWith","dual","self","isEquivalent","input","fromIterable","isNonEmptyReadonlyArray","out","headNonEmpty","rest","tailNonEmpty","r","every","a","push","dedupe","equivalence","SingleShotGen","fn","symbol","right","left","flatMap","map","args","orElse","arr","cont","cached","some","none","args","map","isFunction","flatMap","map","none","some","isNone","isSome","typeNode","diagnostics","map","refactor","node","match","flatMap","codegens","codegen","nanoLayer","flatMap","type","cached","symbol","standard","nanoLayer","make","symbol","flatMap","map","orElse","isSome","unnecessaryEffectGen","args","type","accessors","isSome","args","orElse","createString","map","nodeToVisit","appendNodeToVisit","orElse","map","map","map","isSome","orElse","isNone","map","orElse","sourceFile","service","map","orElse","symbol","flatMap","orElse","map","node","map","map","string","orElse","isSome","orElse","orElse","map","flatMap","map","orElse","args","type","orElse","service","className","atLocation","flatMap","orElse","type","map","symbol","parse","accessors","hash","parse","map","orElse","hash","map","orElse","map","orElse","node","isSome","orElse","map","type","map","flatMap","isSome","orElse","map","map","map","args","flatMap","map","parse","orElse","nanoLayer","map"]}