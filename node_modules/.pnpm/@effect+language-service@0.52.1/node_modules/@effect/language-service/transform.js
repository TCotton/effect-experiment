"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/transform.ts
var transform_exports = {};
__export(transform_exports, {
  default: () => transform_default
});
module.exports = __toCommonJS(transform_exports);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var identity = (a) => a;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isFunction2 = isFunction;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && property in self);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var GenKindImpl = class {
  value;
  constructor(value) {
    this.value = value;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys2) => {
  let h = 12289;
  for (let i = 0; i < keys2.length; i++) {
    h ^= pipe(string(keys2[i]), combine(hash(o[keys2[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_COMMIT = "Commit";

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.18.4";
var getCurrentVersion = () => moduleVersion;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var isLeft2 = isLeft;
var isRight2 = isRight;
var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var getOrElse = /* @__PURE__ */ dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Order.js
var make = (compare) => (self, that) => self === that ? 0 : compare(self, that);
var string2 = /* @__PURE__ */ make((self, that) => self < that ? -1 : 1);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isNone2 = isNone;
var isSome2 = isSome;
var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Record.js
var map2 = /* @__PURE__ */ dual(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
});
var keys = (self) => Object.keys(self);

// node_modules/.pnpm/@pkg.pr.new+Effect-TS+effect@97ff1dc_6ntygjheib5kdugabxjhox4fte/node_modules/effect/dist/esm/Array.js
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var append = /* @__PURE__ */ dual(2, (self, last) => [...self, last]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var tailNonEmpty = (self) => self.slice(1);
var reverse = (self) => Array.from(self).reverse();
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var containsWith = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence = /* @__PURE__ */ equivalence();
var intersectionWith = (isEquivalent) => {
  const has = containsWith(isEquivalent);
  return dual(2, (self, that) => fromIterable(self).filter((a) => has(that, a)));
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence);
var empty = () => [];
var map3 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap(identity);
var filter = /* @__PURE__ */ dual(2, (self, predicate) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
});
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());

// src/core/Nano.ts
var NanoTag = class {
  constructor(key) {
    this.key = key;
  }
};
var Tag = (identifier) => new NanoTag(identifier);
var SingleShotGen2 = class _SingleShotGen {
  called = false;
  self;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var evaluate = Symbol.for("Nano.evaluate");
var contA = Symbol.for("Nano.contA");
var contE = Symbol.for("Nano.contE");
var contAll = Symbol.for("Nano.contAll");
var NanoYield = Symbol.for("Nano.yield");
var args = Symbol.for("Nano.args");
var NanoDefectException = class {
  constructor(message) {
    this.message = message;
  }
  _tag = "@effect/language-service/NanoDefectException";
};
var PrimitiveProto = {
  [Symbol.iterator]() {
    return new SingleShotGen2(this);
  }
};
var SucceedProto = {
  ...PrimitiveProto,
  _tag: "Success",
  get value() {
    return this[args];
  },
  [evaluate](fiber) {
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](this[args], fiber) : fiber.yieldWith(this);
  }
};
var succeed = (value) => {
  const nano = Object.create(SucceedProto);
  nano[args] = value;
  return nano;
};
var FailureProto = {
  ...PrimitiveProto,
  _tag: "Failure",
  get value() {
    return this[args];
  },
  [evaluate](fiber) {
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](this[args], fiber) : fiber.yieldWith(this);
  }
};
var fail = (error) => {
  const nano = Object.create(FailureProto);
  nano[args] = error;
  return nano;
};
var SuspendProto = {
  ...PrimitiveProto,
  [evaluate]() {
    return this[args]();
  }
};
var suspend = (fn2) => {
  const nano = Object.create(SuspendProto);
  nano[args] = fn2;
  return nano;
};
var NanoFiber = class {
  _stack = [];
  _yielded = void 0;
  _services = {};
  _cache = {};
  _perf = false;
  runLoop(nano) {
    let current = nano;
    while (true) {
      current = current[evaluate](this);
      if (current === NanoYield) {
        return this._yielded;
      }
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[contAll] && op[contAll](this);
      if (cont) return { [symbol3]: cont };
      if (op[symbol3]) return op;
    }
  }
  yieldWith(value) {
    this._yielded = value;
    return NanoYield;
  }
};
var timings = {};
var timingsCount = {};
var WithSpanProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const [fa, name] = this[args];
    if (!fiber._perf) return fa;
    const start = performance.now();
    timingsCount[name] = (timingsCount[name] || 0) + 1;
    return match(fa, {
      onSuccess: (_) => {
        const end = performance.now();
        timings[name] = (timings[name] || 0) + (end - start);
        return succeed(_);
      },
      onFailure: (_) => {
        const end = performance.now();
        timings[name] = (timings[name] || 0) + (end - start);
        return fail(_);
      }
    });
  }
};
var withSpan = (name) => (fa) => {
  const nano = Object.create(WithSpanProto);
  nano[args] = [fa, name];
  return nano;
};
var unsafeRun = (nano) => {
  const fiber = new NanoFiber();
  const result = fiber.runLoop(nano);
  if (result._tag === "Success") {
    return right2(result.value);
  }
  return left2(result.value);
};
var run = (nano) => {
  try {
    return unsafeRun(nano);
  } catch (e) {
    return left2(new NanoDefectException(e));
  }
};
var OnSuccessProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    fiber._stack.push(this);
    return this[args];
  }
};
var flatMap2 = dual(2, (fa, f) => {
  const nano = Object.create(OnSuccessProto);
  nano[args] = fa;
  nano[contA] = f;
  return nano;
});
var map4 = dual(2, (fa, f) => flatMap2(fa, (_) => succeed(f(_))));
var SyncProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const value = this[args]();
    const cont = fiber.getCont(contA);
    return cont ? cont[contA](value, fiber) : fiber.yieldWith(succeed(value));
  }
};
var sync = (f) => {
  const nano = Object.create(SyncProto);
  nano[args] = f;
  return nano;
};
var void_ = succeed(void 0);
var FromIteratorProto = {
  ...PrimitiveProto,
  [contA](value, fiber) {
    const state = this[args][0].next(value);
    if (state.done) return succeed(state.value);
    fiber._stack.push(this);
    return state.value;
  },
  [evaluate](fiber) {
    return this[contA](this[args][1], fiber);
  }
};
var unsafeFromIterator = (iterator, initial) => {
  const nano = Object.create(FromIteratorProto);
  nano[args] = [iterator, initial];
  return nano;
};
var gen = (...args2) => suspend(() => unsafeFromIterator(args2[0]()));
var fn = (_) => (body) => (...args2) => withSpan(_)(suspend(() => unsafeFromIterator(body(...args2))));
var MatchProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    fiber._stack.push(this);
    return this[args];
  }
};
var match = (fa, opts) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = opts.onSuccess;
  nano[contE] = opts.onFailure;
  return nano;
};
var orElse2 = (f) => (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : f(_);
  return nano;
};
var firstSuccessOf = (arr) => arr.slice(1).reduce((arr2, fa) => orElse2(() => fa)(arr2), arr[0]);
var ProvideServiceProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const prevServices = fiber._services;
    const [fa, tag, value] = this[args];
    fiber._services = {
      ...fiber._services,
      [tag.key]: value
    };
    return match(fa, {
      onSuccess: (_) => {
        fiber._services = prevServices;
        return succeed(_);
      },
      onFailure: (_) => {
        fiber._services = prevServices;
        return fail(_);
      }
    });
  }
};
var provideService = (tag, value) => (fa) => {
  const nano = Object.create(ProvideServiceProto);
  nano[args] = [fa, tag, value];
  return nano;
};
var ServiceProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const tag = this[args];
    if (tag.key in fiber._services) {
      const value = fiber._services[tag.key];
      const cont2 = fiber.getCont(contA);
      return cont2 ? cont2[contA](value, fiber) : fiber.yieldWith(succeed(value));
    }
    const cont = fiber.getCont(contE);
    return cont ? cont[contE](tag, fiber) : fiber.yieldWith(fail(new NanoDefectException(`Service ${tag.key} not found`)));
  }
};
var service = (tag) => {
  const nano = Object.create(ServiceProto);
  nano[args] = tag;
  return nano;
};
var CachedProto = {
  ...PrimitiveProto,
  [evaluate](fiber) {
    const [fa, type, key] = this[args];
    const cache = fiber._cache[type] || /* @__PURE__ */ new WeakMap();
    fiber._cache[type] = cache;
    const cached2 = cache.get(key);
    if (cached2) return cached2;
    return match(fa, {
      onSuccess: (_) => {
        cache.set(key, succeed(_));
        return succeed(_);
      },
      onFailure: (_) => {
        cache.set(key, fail(_));
        return fail(_);
      }
    });
  }
};
function cachedBy(fa, type, lookupKey) {
  return (...p) => {
    const nano = Object.create(CachedProto);
    nano[args] = [fa(...p), type, lookupKey(...p)];
    return nano;
  };
}
var option = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = (_) => succeed(some2(_));
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : succeed(none2());
  return nano;
};
var ignore = (fa) => {
  const nano = Object.create(MatchProto);
  nano[args] = fa;
  nano[contA] = (_) => void_;
  nano[contE] = (_) => _ instanceof NanoDefectException ? fail(_) : void_;
  return nano;
};
var all = fn("all")(
  function* (...args2) {
    const results = [];
    for (const fa of args2) {
      const result = yield* fa;
      results.push(result);
    }
    return results;
  }
);

// src/core/LanguageServicePluginOptions.ts
var LanguageServicePluginOptions = Tag("PluginOptions");
function isValidSeverityLevel(value) {
  return value === "off" || value === "error" || value === "warning" || value === "message" || value === "suggestion";
}
function parseDiagnosticSeverity(config) {
  if (!isRecord(config)) return {};
  return Object.fromEntries(
    pipe(
      Object.entries(config),
      filter(([key, value]) => isString(key) && isString(value)),
      map3(([key, value]) => [String(key).toLowerCase(), String(value).toLowerCase()]),
      filter(([_, value]) => isValidSeverityLevel(value))
    )
  );
}
var defaults = {
  refactors: true,
  diagnostics: true,
  diagnosticSeverity: {},
  diagnosticsName: true,
  missingDiagnosticNextLine: "warning",
  quickinfo: true,
  quickinfoEffectParameters: "whentruncated",
  quickinfoMaximumLength: -1,
  completions: true,
  goto: true,
  inlays: true,
  allowedDuplicatedPackages: [],
  namespaceImportPackages: [],
  topLevelNamedReexports: "ignore",
  barrelImportPackages: [],
  importAliases: {},
  renames: true,
  noExternal: false,
  keyPatterns: [{
    target: "service",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }, {
    target: "custom",
    pattern: "default",
    skipLeadingPath: ["src/"]
  }],
  extendedKeyDetection: false,
  pipeableMinArgCount: 1
};
function parseKeyPatterns(patterns) {
  const result = [];
  for (const entry of patterns) {
    if (!isObject(entry)) continue;
    result.push({
      target: hasProperty(entry, "target") && isString(entry.target) && ["service", "error", "custom"].includes(entry.target.toLowerCase()) ? entry.target.toLowerCase() : "service",
      pattern: hasProperty(entry, "pattern") && isString(entry.pattern) && ["package-identifier", "default", "default-hashed"].includes(entry.pattern.toLowerCase()) ? entry.pattern.toLowerCase() : "default",
      skipLeadingPath: hasProperty(entry, "skipLeadingPath") && isArray(entry.skipLeadingPath) && entry.skipLeadingPath.every(isString) ? entry.skipLeadingPath : ["src/"]
    });
  }
  return result;
}
function parse(config) {
  return {
    refactors: isObject(config) && hasProperty(config, "refactors") && isBoolean(config.refactors) ? config.refactors : defaults.refactors,
    diagnostics: isObject(config) && hasProperty(config, "diagnostics") && isBoolean(config.diagnostics) ? config.diagnostics : defaults.diagnostics,
    diagnosticSeverity: isObject(config) && hasProperty(config, "diagnosticSeverity") && isRecord(config.diagnosticSeverity) ? parseDiagnosticSeverity(config.diagnosticSeverity) : defaults.diagnosticSeverity,
    diagnosticsName: isObject(config) && hasProperty(config, "diagnosticsName") && isBoolean(config.diagnosticsName) ? config.diagnosticsName : defaults.diagnosticsName,
    missingDiagnosticNextLine: isObject(config) && hasProperty(config, "missingDiagnosticNextLine") && isString(config.missingDiagnosticNextLine) && isValidSeverityLevel(config.missingDiagnosticNextLine) ? config.missingDiagnosticNextLine : defaults.missingDiagnosticNextLine,
    quickinfo: isObject(config) && hasProperty(config, "quickinfo") && isBoolean(config.quickinfo) ? config.quickinfo : defaults.quickinfo,
    quickinfoEffectParameters: isObject(config) && hasProperty(config, "quickinfoEffectParameters") && isString(config.quickinfoEffectParameters) && ["always", "never", "whentruncated"].includes(config.quickinfoEffectParameters.toLowerCase()) ? config.quickinfoEffectParameters.toLowerCase() : defaults.quickinfoEffectParameters,
    quickinfoMaximumLength: isObject(config) && hasProperty(config, "quickinfoMaximumLength") && isNumber(config.quickinfoMaximumLength) ? config.quickinfoMaximumLength : defaults.quickinfoMaximumLength,
    completions: isObject(config) && hasProperty(config, "completions") && isBoolean(config.completions) ? config.completions : defaults.completions,
    goto: isObject(config) && hasProperty(config, "goto") && isBoolean(config.goto) ? config.goto : defaults.goto,
    inlays: isObject(config) && hasProperty(config, "inlays") && isBoolean(config.inlays) ? config.inlays : defaults.inlays,
    allowedDuplicatedPackages: isObject(config) && hasProperty(config, "allowedDuplicatedPackages") && isArray(config.allowedDuplicatedPackages) && config.allowedDuplicatedPackages.every(isString) ? config.allowedDuplicatedPackages.map((_) => _.toLowerCase()) : defaults.allowedDuplicatedPackages,
    namespaceImportPackages: isObject(config) && hasProperty(config, "namespaceImportPackages") && isArray(config.namespaceImportPackages) && config.namespaceImportPackages.every(isString) ? config.namespaceImportPackages.map((_) => _.toLowerCase()) : defaults.namespaceImportPackages,
    barrelImportPackages: isObject(config) && hasProperty(config, "barrelImportPackages") && isArray(config.barrelImportPackages) && config.barrelImportPackages.every(isString) ? config.barrelImportPackages.map((_) => _.toLowerCase()) : defaults.barrelImportPackages,
    importAliases: isObject(config) && hasProperty(config, "importAliases") && isRecord(config.importAliases) ? map2(config.importAliases, (value) => String(value)) : defaults.importAliases,
    topLevelNamedReexports: isObject(config) && hasProperty(config, "topLevelNamedReexports") && isString(config.topLevelNamedReexports) && ["ignore", "follow"].includes(config.topLevelNamedReexports.toLowerCase()) ? config.topLevelNamedReexports.toLowerCase() : defaults.topLevelNamedReexports,
    renames: isObject(config) && hasProperty(config, "renames") && isBoolean(config.renames) ? config.renames : defaults.renames,
    noExternal: isObject(config) && hasProperty(config, "noExternal") && isBoolean(config.noExternal) ? config.noExternal : defaults.noExternal,
    keyPatterns: isObject(config) && hasProperty(config, "keyPatterns") && isArray(config.keyPatterns) ? parseKeyPatterns(config.keyPatterns) : defaults.keyPatterns,
    extendedKeyDetection: isObject(config) && hasProperty(config, "extendedKeyDetection") && isBoolean(config.extendedKeyDetection) ? config.extendedKeyDetection : defaults.extendedKeyDetection,
    pipeableMinArgCount: isObject(config) && hasProperty(config, "pipeableMinArgCount") && isNumber(config.pipeableMinArgCount) ? config.pipeableMinArgCount : defaults.pipeableMinArgCount
  };
}

// src/core/TypeScriptApi.ts
var TypeScriptApi = Tag("TypeScriptApi");
var TypeScriptProgram = Tag("TypeScriptProgram");
var ChangeTracker = Tag("ChangeTracker");
function getPackageJsonInfoCache(program) {
  try {
    if (hasProperty(program, "getModuleResolutionCache") && isFunction2(program.getModuleResolutionCache)) {
      const moduleResolutionCache = program.getModuleResolutionCache();
      if (hasProperty(moduleResolutionCache, "getPackageJsonInfoCache") && isFunction2(moduleResolutionCache.getPackageJsonInfoCache)) {
        return moduleResolutionCache.getPackageJsonInfoCache();
      }
    }
  } catch (_) {
    return void 0;
  }
  return void 0;
}
function getDirectoryPath(ts, path) {
  try {
    if (hasProperty(ts, "getDirectoryPath") && isFunction2(ts.getDirectoryPath)) {
      return ts.getDirectoryPath(path);
    }
    return path;
  } catch (_) {
    return path;
  }
}
function makeGetModuleSpecifier(ts) {
  if (!(hasProperty(ts, "moduleSpecifiers") && hasProperty(ts.moduleSpecifiers, "getModuleSpecifier") && isFunction2(ts.moduleSpecifiers.getModuleSpecifier))) return;
  const _internal = ts.moduleSpecifiers.getModuleSpecifier;
  return (compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, options) => {
    return _internal(
      compilerOptions,
      importingSourceFile,
      importingSourceFileName,
      toFileName,
      host,
      options
    );
  };
}
function makeGetTemporaryModuleResolutionState(ts) {
  if (hasProperty(ts, "getTemporaryModuleResolutionState") && isFunction2(ts.getTemporaryModuleResolutionState)) {
    const _internal = ts.getTemporaryModuleResolutionState;
    return (cache, program, compilerOptions) => _internal(cache, program, compilerOptions);
  }
  return void 0;
}
function makeGetPackageScopeForPath(ts) {
  if (hasProperty(ts, "getPackageScopeForPath") && isFunction2(ts.getPackageScopeForPath)) {
    const _internal = ts.getPackageScopeForPath;
    return (path, state) => _internal(path, state);
  }
}

// src/core/TypeScriptUtils.ts
var TypeScriptUtils = Tag("TypeScriptUtils");
var nanoLayer = (fa) => pipe(
  service(TypeScriptApi),
  flatMap2((ts) => pipe(fa, provideService(TypeScriptUtils, makeTypeScriptUtils(ts))))
);
function makeTypeScriptUtils(ts) {
  const getTemporaryModuleResolutionState = makeGetTemporaryModuleResolutionState(ts);
  const getPackageScopeForPath = makeGetPackageScopeForPath(ts);
  function parsePackageContentNameAndVersionFromScope(v) {
    if (!isObject(v)) return;
    if (!hasProperty(v, "packageJsonScope")) return;
    if (!v.packageJsonScope) return;
    const packageJsonScope = v.packageJsonScope;
    if (!hasProperty(packageJsonScope, "contents")) return;
    if (!hasProperty(packageJsonScope.contents, "packageJsonContent")) return;
    const packageJsonContent = packageJsonScope.contents.packageJsonContent;
    if (!hasProperty(packageJsonContent, "name")) return;
    if (!hasProperty(packageJsonScope, "packageDirectory")) return;
    if (!isString(packageJsonScope.packageDirectory)) return;
    const { name } = packageJsonContent;
    const version = hasProperty(packageJsonScope, "version") ? packageJsonScope.version : "";
    if (!isString(name)) return;
    if (!isString(version)) return;
    const hasEffectInPeerDependencies = hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) && hasProperty(packageJsonContent.peerDependencies, "effect");
    const referencedPackages = Object.keys({
      ...hasProperty(packageJsonContent, "dependencies") && isObject(packageJsonContent.dependencies) ? packageJsonContent.dependencies : {},
      ...hasProperty(packageJsonContent, "peerDependencies") && isObject(packageJsonContent.peerDependencies) ? packageJsonContent.peerDependencies : {},
      ...hasProperty(packageJsonContent, "devDependencies") && isObject(packageJsonContent.devDependencies) ? packageJsonContent.devDependencies : {}
    });
    const exportsKeys = Object.keys(
      hasProperty(packageJsonContent, "exports") && isObject(packageJsonContent.exports) ? packageJsonContent.exports : {}
    );
    return {
      name: name.toLowerCase(),
      version: version.toLowerCase(),
      hasEffectInPeerDependencies,
      contents: packageJsonContent,
      packageDirectory: packageJsonScope.packageDirectory,
      referencedPackages,
      exportsKeys
    };
  }
  function resolveModuleWithPackageInfoFromSourceFile(program, sourceFile) {
    let packageJsonScope = parsePackageContentNameAndVersionFromScope(sourceFile);
    if (!packageJsonScope && getPackageScopeForPath && getTemporaryModuleResolutionState) {
      const packageJsonInfoCache = getPackageJsonInfoCache(program);
      const temporaryModuleResolutionState = getTemporaryModuleResolutionState(
        packageJsonInfoCache,
        program,
        program.getCompilerOptions()
      );
      const directoryPath = getDirectoryPath(ts, sourceFile.fileName);
      packageJsonScope = parsePackageContentNameAndVersionFromScope({
        ...sourceFile,
        packageJsonScope: getPackageScopeForPath(directoryPath, temporaryModuleResolutionState)
      });
    }
    return packageJsonScope;
  }
  function resolveModulePattern(program, sourceFile, pattern) {
    if (pattern.indexOf("*") === -1) return [pattern.toLowerCase()];
    const packageJsonScope = resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    const referencedPackages = [];
    for (const statement of sourceFile.statements) {
      if (ts.isImportDeclaration(statement) && ts.isStringLiteral(statement.moduleSpecifier)) {
        const moduleSpecifier = statement.moduleSpecifier.text.toLowerCase();
        const packageName = moduleSpecifier.startsWith("@") ? moduleSpecifier.split("/", 2).join("/") : moduleSpecifier.split("/", 1).join("/");
        referencedPackages.push(packageName);
      }
    }
    return pipe(
      referencedPackages.concat(packageJsonScope?.referencedPackages || []),
      dedupe,
      map3((packageName) => packageName.toLowerCase()),
      filter(
        (packageName) => pattern.endsWith("*") && packageName.startsWith(pattern.toLowerCase().substring(0, pattern.length - 1))
      )
    );
  }
  function findNodeWithLeadingCommentAtPosition(sourceFile, position) {
    const sourceText = sourceFile.text;
    let result;
    function find(node) {
      const leading = ts.getLeadingCommentRanges(sourceText, node.pos);
      if (leading) {
        for (const commentRange of leading) {
          if (commentRange.pos <= position && position < commentRange.end) {
            result = { node, commentRange };
            return;
          }
        }
      }
      if (node.pos <= position && position < node.end) {
        ts.forEachChild(node, find);
      }
    }
    find(sourceFile);
    return result;
  }
  function collectSelfAndAncestorNodesInRange(node, textRange) {
    let result = empty();
    let parent = node;
    while (parent) {
      if (parent.end >= textRange.end) {
        result = pipe(result, append(parent));
      }
      parent = parent.parent;
    }
    return result;
  }
  function findNodeAtPosition(sourceFile, position) {
    function find(node) {
      if (position >= ts.getTokenPosOfNode(node, sourceFile) && position < node.end) {
        return ts.forEachChild(node, find) || node;
      }
      return void 0;
    }
    return find(sourceFile);
  }
  function findNodeAtPositionIncludingTrivia(sourceFile, position) {
    function find(node) {
      if (position >= node.pos && position < node.end) {
        return ts.forEachChild(node, find) || node;
      }
      return void 0;
    }
    return find(sourceFile);
  }
  function getAncestorNodesInRange(sourceFile, textRange) {
    const nodeAtPosition = findNodeAtPosition(sourceFile, textRange.pos);
    if (!nodeAtPosition) return empty();
    return collectSelfAndAncestorNodesInRange(nodeAtPosition, textRange);
  }
  function getCommentAtPosition(sourceFile, pos) {
    const token = findNodeAtPositionIncludingTrivia(sourceFile, pos);
    if (token === void 0 || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || "").length) {
      return;
    }
    const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || "").length : token.pos;
    const result = ts.forEachTrailingCommentRange(sourceFile.text, startPos, isCommentInRange, pos) || ts.forEachLeadingCommentRange(sourceFile.text, startPos, isCommentInRange, pos);
    return result;
  }
  function isCommentInRange(pos, end, kind, _nl, at) {
    return at >= pos && at < end ? { pos, end, kind } : void 0;
  }
  function toTextRange(positionOrRange) {
    return typeof positionOrRange === "number" ? { end: positionOrRange, pos: positionOrRange } : positionOrRange;
  }
  function isNodeInRange(textRange) {
    return (node) => node.pos <= textRange.pos && node.end >= textRange.end;
  }
  function transformAsyncAwaitToEffectGeneratorBody(body, onAwait) {
    function visitor(_) {
      if (ts.isAwaitExpression(_)) {
        const expression = ts.visitEachChild(_.expression, visitor, ts.nullTransformationContext);
        return ts.factory.createYieldExpression(
          ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
          onAwait(expression)
        );
      }
      return ts.visitEachChild(_, visitor, ts.nullTransformationContext);
    }
    return visitor(body);
  }
  function transformAsyncAwaitToEffectFn(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const fnName = node.name && ts.isIdentifier(node.name) ? node.name : ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name) && node.parent.initializer === node ? node.parent.name : void 0;
    let fnCall = ts.factory.createPropertyAccessExpression(
      ts.factory.createIdentifier(effectModuleName),
      "fn"
    );
    if (fnName) {
      fnCall = ts.factory.createCallExpression(
        fnCall,
        void 0,
        [ts.factory.createStringLiteral(ts.idText(fnName))]
      );
    }
    return tryPreserveDeclarationSemantics(
      node,
      ts.factory.createCallExpression(
        fnCall,
        void 0,
        [
          ts.factory.createFunctionExpression(
            void 0,
            ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
            void 0,
            node.typeParameters,
            node.parameters,
            void 0,
            ts.isBlock(generatorBody) ? generatorBody : ts.factory.createBlock([ts.factory.createReturnStatement(generatorBody)])
          )
        ]
      ),
      true
    );
  }
  function transformAsyncAwaitToEffectGen(node, effectModuleName, onAwait) {
    const generatorBody = transformAsyncAwaitToEffectGeneratorBody(node.body, onAwait);
    const effectGenCallExp = createEffectGenCallExpression(effectModuleName, generatorBody);
    let currentFlags = ts.getCombinedModifierFlags(node);
    currentFlags &= ~ts.ModifierFlags.Async;
    const newModifiers = ts.factory.createModifiersFromModifierFlags(currentFlags);
    if (ts.isArrowFunction(node)) {
      return ts.factory.createArrowFunction(
        newModifiers,
        node.typeParameters,
        node.parameters,
        void 0,
        node.equalsGreaterThanToken,
        effectGenCallExp
      );
    }
    const newBody = ts.factory.createBlock([
      ts.factory.createReturnStatement(effectGenCallExp)
    ]);
    if (ts.isFunctionDeclaration(node)) {
      return ts.factory.createFunctionDeclaration(
        newModifiers,
        node.asteriskToken,
        node.name,
        node.typeParameters,
        node.parameters,
        void 0,
        newBody
      );
    }
    return ts.factory.createFunctionExpression(
      newModifiers,
      node.asteriskToken,
      node.name,
      node.typeParameters,
      node.parameters,
      void 0,
      newBody
    );
  }
  function findImportedModuleIdentifier(sourceFile, test) {
    for (const statement of sourceFile.statements) {
      if (!ts.isImportDeclaration(statement)) continue;
      const importClause = statement.importClause;
      if (!importClause) continue;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) continue;
      if (ts.isNamespaceImport(namedBindings)) {
        if (test(namedBindings.name, statement.moduleSpecifier, none2())) {
          return ts.idText(namedBindings.name);
        }
      } else if (ts.isNamedImports(namedBindings)) {
        for (const importSpecifier of namedBindings.elements) {
          const importProperty = fromNullable(importSpecifier.propertyName).pipe(
            orElse(() => some2(importSpecifier.name))
          );
          if (test(importSpecifier.name, statement.moduleSpecifier, importProperty)) {
            return ts.idText(importSpecifier.name);
          }
        }
      }
    }
  }
  function findImportedModuleIdentifierByPackageAndNameOrBarrel(sourceFile, packageName, moduleName) {
    return findImportedModuleIdentifier(
      sourceFile,
      (_, fromModule, importProperty) => {
        if (isNone2(importProperty) && ts.isStringLiteral(fromModule) && fromModule.text === packageName + "/" + moduleName) {
          return true;
        }
        if (isSome2(importProperty) && ts.isIdentifier(importProperty.value) && ts.idText(importProperty.value) === moduleName && ts.isStringLiteral(fromModule) && fromModule.text === packageName) {
          return true;
        }
        return false;
      }
    );
  }
  function simplifyTypeNode(typeNode) {
    function collectCallable(typeNode2) {
      if (ts.isParenthesizedTypeNode(typeNode2)) return collectCallable(typeNode2.type);
      if (ts.isFunctionTypeNode(typeNode2)) {
        return some2([
          ts.factory.createCallSignature(typeNode2.typeParameters, typeNode2.parameters, typeNode2.type)
        ]);
      }
      if (ts.isTypeLiteralNode(typeNode2)) {
        const allCallSignatures = typeNode2.members.every(ts.isCallSignatureDeclaration);
        if (allCallSignatures) {
          return some2(typeNode2.members);
        }
      }
      if (ts.isIntersectionTypeNode(typeNode2)) {
        const members = typeNode2.types.map((node) => collectCallable(node));
        if (members.every(isSome2)) {
          return some2(members.map((_) => isSome2(_) ? _.value : []).flat());
        }
      }
      return none2();
    }
    const callSignatures = collectCallable(typeNode);
    if (isSome2(callSignatures) && callSignatures.value.length > 1) {
      return ts.factory.createTypeLiteralNode(callSignatures.value);
    }
    return typeNode;
  }
  function tryPreserveDeclarationSemantics(nodeToReplace, node, dropAsync) {
    if (!ts.isExpression(node)) return node;
    if (ts.isFunctionDeclaration(nodeToReplace)) {
      if (!nodeToReplace.name) return node;
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createVariableStatement(
        newModifiers,
        ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
            nodeToReplace.name,
            void 0,
            void 0,
            node
          )],
          ts.NodeFlags.Const
        )
      );
    } else if (ts.isMethodDeclaration(nodeToReplace)) {
      let currentFlags = ts.getCombinedModifierFlags(nodeToReplace);
      currentFlags &= ~ts.ModifierFlags.Async;
      const newModifiers = dropAsync ? ts.factory.createModifiersFromModifierFlags(currentFlags) : nodeToReplace.modifiers;
      return ts.factory.createPropertyDeclaration(
        newModifiers,
        nodeToReplace.name,
        void 0,
        void 0,
        node
      );
    }
    return node;
  }
  function parseAccessedExpressionForCompletion(sourceFile, position) {
    const precedingToken = ts.findPrecedingToken(position, sourceFile, void 0, true);
    if (!precedingToken) return;
    let accessedObject = precedingToken;
    let replacementSpan = ts.createTextSpan(position, 0);
    let outerNode = precedingToken;
    if (ts.isIdentifier(precedingToken) && precedingToken.parent && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const spanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        spanStart,
        precedingToken.end - spanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isToken(precedingToken) && precedingToken.kind === ts.SyntaxKind.DotToken && ts.isPropertyAccessExpression(precedingToken.parent)) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken.parent, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken.parent.expression;
      outerNode = precedingToken.parent;
    } else if (ts.isIdentifier(precedingToken) && precedingToken.parent) {
      const precedingTokenSpanStart = ts.getTokenPosOfNode(precedingToken, sourceFile);
      replacementSpan = ts.createTextSpan(
        precedingTokenSpanStart,
        precedingToken.end - precedingTokenSpanStart
      );
      accessedObject = precedingToken;
      outerNode = precedingToken;
    } else {
      return;
    }
    return { accessedObject, outerNode, replacementSpan };
  }
  function parseDataForExtendsClassCompletion(sourceFile, position) {
    const maybeInfos = parseAccessedExpressionForCompletion(sourceFile, position);
    if (!maybeInfos) return;
    const { accessedObject, outerNode, replacementSpan } = maybeInfos;
    if (!ts.isIdentifier(accessedObject)) return;
    let classDeclaration = outerNode.parent;
    while (ts.isExpressionWithTypeArguments(classDeclaration) || ts.isHeritageClause(classDeclaration)) {
      if (!classDeclaration.parent) break;
      classDeclaration = classDeclaration.parent;
    }
    if (!ts.isClassDeclaration(classDeclaration)) return;
    if (!classDeclaration.name) return;
    return {
      accessedObject,
      classDeclaration,
      className: classDeclaration.name,
      replacementSpan
    };
  }
  function createEffectGenCallExpression(effectModuleIdentifierName, node) {
    const generator = ts.factory.createFunctionExpression(
      void 0,
      ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
      void 0,
      [],
      [],
      void 0,
      node
      // NOTE(mattia): intended, to use same routine for both ConciseBody and Body
    );
    return ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifierName),
        "gen"
      ),
      void 0,
      [generator]
    );
  }
  function createEffectGenCallExpressionWithBlock(effectModuleIdentifierName, statement) {
    return createEffectGenCallExpression(
      effectModuleIdentifierName,
      ts.factory.createBlock(isArray(statement) ? statement : [statement], false)
    );
  }
  function createReturnYieldStarStatement(expr) {
    return ts.factory.createReturnStatement(
      ts.factory.createYieldExpression(
        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
        expr
      )
    );
  }
  function createDataTaggedErrorDeclaration(dataModuleIdentifier, name, fields) {
    const invokeTaggedError = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(dataModuleIdentifier),
        "TaggedError"
      ),
      void 0,
      [
        ts.factory.createStringLiteral(name)
      ]
    );
    const withTypeFields = ts.factory.createExpressionWithTypeArguments(
      invokeTaggedError,
      [
        ts.factory.createTypeLiteralNode(fields)
      ]
    );
    return ts.factory.createClassDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      name,
      void 0,
      [
        ts.factory.createHeritageClause(
          ts.SyntaxKind.ExtendsKeyword,
          [
            withTypeFields
          ]
        )
      ],
      []
    );
  }
  function getSourceFileOfNode(current) {
    let node = current;
    while (node && node.kind !== ts.SyntaxKind.SourceFile) {
      node = node.parent;
    }
    return node;
  }
  return {
    findNodeAtPositionIncludingTrivia,
    parsePackageContentNameAndVersionFromScope,
    resolveModulePattern,
    resolveModuleWithPackageInfoFromSourceFile,
    findNodeWithLeadingCommentAtPosition,
    getCommentAtPosition,
    getAncestorNodesInRange,
    toTextRange,
    isNodeInRange,
    transformAsyncAwaitToEffectFn,
    transformAsyncAwaitToEffectGen,
    createDataTaggedErrorDeclaration,
    findImportedModuleIdentifierByPackageAndNameOrBarrel,
    simplifyTypeNode,
    tryPreserveDeclarationSemantics,
    parseDataForExtendsClassCompletion,
    createEffectGenCallExpressionWithBlock,
    createReturnYieldStarStatement,
    parseAccessedExpressionForCompletion,
    getSourceFileOfNode
  };
}

// src/core/LSP.ts
var RefactorNotApplicableError = class {
  _tag = "@effect/language-service/RefactorNotApplicableError";
};
function createRefactor(definition) {
  return definition;
}
function createDiagnostic(definition) {
  return definition;
}
var getSemanticDiagnosticsWithCodeFixes = fn(
  "LSP.getSemanticDiagnosticsWithCodeFixes"
)(function* (rules, sourceFile) {
  let effectDiagnostics = [];
  let effectCodeFixes = [];
  const executor = yield* createDiagnosticExecutor(sourceFile);
  for (const rule of rules) {
    const { codeFixes, diagnostics: diagnostics2 } = yield* executor.execute(rule);
    effectDiagnostics = effectDiagnostics.concat(diagnostics2);
    effectCodeFixes = effectCodeFixes.concat(codeFixes);
  }
  return {
    diagnostics: effectDiagnostics,
    codeFixes: effectCodeFixes
  };
});
function refactorNameToFullyQualifiedName(name) {
  return `@effect/language-service/refactors/${name}`;
}
var getApplicableRefactors = fn("LSP.getApplicableRefactors")(function* (refactors, sourceFile, positionOrRange) {
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  const effectRefactors = [];
  for (const refactor of refactors) {
    yield* pipe(
      refactor.apply(sourceFile, textRange),
      map4(
        (result) => effectRefactors.push({
          name: refactorNameToFullyQualifiedName(refactor.name),
          description: refactor.description,
          actions: [{
            name: refactorNameToFullyQualifiedName(refactor.name),
            description: result.description,
            kind: result.kind
          }]
        })
      ),
      ignore
    );
  }
  return effectRefactors;
});
var getEditsForRefactor = fn("LSP.getEditsForRefactor")(function* (refactors, sourceFile, positionOrRange, refactorName) {
  const refactor = refactors.find((refactor2) => refactorNameToFullyQualifiedName(refactor2.name) === refactorName);
  if (!refactor) {
    return yield* fail(new RefactorNotApplicableError());
  }
  const textRange = typeof positionOrRange === "number" ? { pos: positionOrRange, end: positionOrRange } : positionOrRange;
  return yield* refactor.apply(sourceFile, textRange);
});
var getCompletionsAtPosition = fn("LSP.getCompletionsAtPosition")(function* (completions, sourceFile, position, options, formatCodeSettings) {
  let effectCompletions = [];
  for (const completion of completions) {
    const result = yield* completion.apply(sourceFile, position, options, formatCodeSettings);
    effectCompletions = effectCompletions.concat(
      result.map((_) => ({ sortText: "11", ..._ }))
    );
  }
  return effectCompletions;
});
var createDiagnosticExecutor = fn("LSP.createCommentDirectivesProcessor")(
  function* (sourceFile) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const pluginOptions = yield* service(LanguageServicePluginOptions);
    function findParentStatementForDisableNextLine(node) {
      let result;
      function find(node2) {
        if (ts.isStatement(node2)) {
          result = node2;
          return;
        }
        if (result) return;
        if (node2.parent) find(node2.parent);
      }
      find(node);
      return result || node;
    }
    const lineOverrides = {};
    const sectionOverrides = {};
    const skippedRules = [];
    const regex = /@effect-diagnostics(-next-line)?((?:\s[a-zA-Z0-9/]+:(?:off|warning|error|message|suggestion|skip-file))+)?/gm;
    let match2;
    while ((match2 = regex.exec(sourceFile.text)) !== null) {
      const nextLineCaptureGroup = match2[1];
      const rulesCaptureGroup = match2[2];
      if (rulesCaptureGroup) {
        const trimmedRuleString = rulesCaptureGroup.trim();
        if (trimmedRuleString) {
          const individualRules = trimmedRuleString.split(/\s+/);
          for (const rulePair of individualRules) {
            const [rawRuleName, ruleLevel] = rulePair.toLowerCase().split(":");
            const ruleName = rawRuleName.startsWith("effect/") ? rawRuleName.substring("effect/".length) : rawRuleName;
            if (ruleName && ruleLevel) {
              if (ruleLevel === "skip-file") skippedRules.push(ruleName);
              const isOverrideNextLine = nextLineCaptureGroup && nextLineCaptureGroup.trim().toLowerCase() === "-next-line";
              if (isOverrideNextLine) {
                const foundNode = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, match2.index);
                if (foundNode) {
                  lineOverrides[ruleName] = lineOverrides[ruleName] || [];
                  lineOverrides[ruleName].unshift({
                    pos: foundNode.node.pos,
                    end: foundNode.node.end,
                    level: ruleLevel,
                    commentRange: foundNode.commentRange
                  });
                }
              } else {
                sectionOverrides[ruleName] = sectionOverrides[ruleName] || [];
                sectionOverrides[ruleName].unshift({
                  pos: match2.index,
                  level: ruleLevel
                });
              }
            }
          }
        }
      }
    }
    const levelToDiagnosticCategory = {
      error: ts.DiagnosticCategory.Error,
      warning: ts.DiagnosticCategory.Warning,
      message: ts.DiagnosticCategory.Message,
      suggestion: ts.DiagnosticCategory.Suggestion
    };
    const execute = (rule) => gen(function* () {
      const diagnostics2 = [];
      const codeFixes = [];
      const ruleNameLowered = rule.name.toLowerCase();
      const defaultLevel = pluginOptions.diagnosticSeverity[ruleNameLowered] || rule.severity;
      if (skippedRules.indexOf(ruleNameLowered) > -1) return { diagnostics: diagnostics2, codeFixes };
      if (defaultLevel === "off" && (lineOverrides[ruleNameLowered] || sectionOverrides[ruleNameLowered] || []).length === 0) {
        return { diagnostics: diagnostics2, codeFixes };
      }
      const fixByDisableNextLine = (node) => ({
        fixName: rule.name + "_skipNextLine",
        description: "Disable " + rule.name + " for this line",
        apply: flatMap2(
          service(ChangeTracker),
          (changeTracker) => gen(function* () {
            const disableAtNode = findParentStatementForDisableNextLine(node);
            const start = ts.getTokenPosOfNode(disableAtNode, sourceFile);
            const { line } = ts.getLineAndCharacterOfPosition(sourceFile, start);
            changeTracker.insertCommentBeforeLine(
              sourceFile,
              line,
              start,
              ` @effect-diagnostics-next-line ${rule.name}:off`
            );
          })
        )
      });
      const fixByDisableEntireFile = {
        fixName: rule.name + "_skipFile",
        description: "Disable " + rule.name + " for this entire file",
        apply: flatMap2(
          service(ChangeTracker),
          (changeTracker) => sync(
            () => changeTracker.insertText(
              sourceFile,
              0,
              `/** @effect-diagnostics ${rule.name}:skip-file */
`
            )
          )
        )
      };
      const applicableDiagnostics = [];
      yield* rule.apply(sourceFile, (entry) => {
        const range = "kind" in entry.location ? { pos: ts.getTokenPosOfNode(entry.location, sourceFile), end: entry.location.end } : entry.location;
        const node = "kind" in entry.location ? entry.location : tsUtils.findNodeAtPositionIncludingTrivia(sourceFile, entry.location.pos);
        applicableDiagnostics.push({
          range,
          messageText: pluginOptions.diagnosticsName ? `${entry.messageText}    effect(${rule.name})` : entry.messageText,
          fixes: entry.fixes.concat(node ? [fixByDisableNextLine(node)] : []).concat([fixByDisableEntireFile])
        });
      });
      const unusedLineOverrides = new Set(lineOverrides[ruleNameLowered] || []);
      for (const emitted of applicableDiagnostics.slice(0)) {
        let newLevel = defaultLevel;
        const lineOverride = (lineOverrides[ruleNameLowered] || []).find(
          (_) => _.pos < emitted.range.pos && _.end >= emitted.range.end
        );
        if (lineOverride) {
          newLevel = lineOverride.level;
          unusedLineOverrides.delete(lineOverride);
        } else {
          const sectionOverride = (sectionOverrides[ruleNameLowered] || []).find((_) => _.pos < emitted.range.pos);
          if (sectionOverride) newLevel = sectionOverride.level;
        }
        if (!(newLevel in levelToDiagnosticCategory)) continue;
        diagnostics2.push({
          file: sourceFile,
          start: emitted.range.pos,
          length: emitted.range.end - emitted.range.pos,
          messageText: emitted.messageText,
          category: levelToDiagnosticCategory[newLevel],
          code: rule.code,
          source: "effect"
        });
        for (const fix of emitted.fixes) {
          codeFixes.push({
            ...fix,
            code: rule.code,
            start: emitted.range.pos,
            end: emitted.range.end
          });
        }
      }
      if (pluginOptions.missingDiagnosticNextLine !== "off" && unusedLineOverrides.size > 0) {
        for (const unusedLineOverride of unusedLineOverrides) {
          diagnostics2.push({
            file: sourceFile,
            start: unusedLineOverride.commentRange.pos,
            length: unusedLineOverride.commentRange.end - unusedLineOverride.commentRange.pos,
            messageText: `@effect-diagnostics-next-line ${rule.name}:${unusedLineOverride.level} has no effect, make sure you are suppressing the right rule.`,
            category: levelToDiagnosticCategory[pluginOptions.missingDiagnosticNextLine],
            code: -1,
            source: "effect"
          });
        }
      }
      return { diagnostics: diagnostics2, codeFixes };
    });
    return { execute };
  }
);
var cyrb53 = (str, seed = 0) => {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (h2 >>> 0).toString(16).padStart(8, "0") + (h1 >>> 0).toString(16).padStart(8, "0");
};
var CodegenNotApplicableError = class {
  constructor(cause) {
    this.cause = cause;
  }
  _tag = "@effect/language-service/CodegenNotApplicableError";
};
function createCodegen(definition) {
  return definition;
}
var getCodegensForSourceFile = fn("LSP.getApplicableCodegens")(function* (codegens2, sourceFile) {
  const tsUtils = yield* service(TypeScriptUtils);
  const result = [];
  const regex = /@effect-codegens((?:\s[a-zA-Z0-9]+(?::(?:[a-zA-Z0-9]+))?)+)+/gmid;
  let match2;
  while ((match2 = regex.exec(sourceFile.text)) !== null) {
    const pos = match2.indices?.[0]?.[0];
    if (!pos) continue;
    const commentRange = tsUtils.getCommentAtPosition(sourceFile, pos);
    if (!commentRange) continue;
    const commentText = sourceFile.text.slice(pos, commentRange.end);
    const codegenRegex = /(\s+)(\w+)(?::(\w+))?/gmi;
    let codegenMatch;
    while ((codegenMatch = codegenRegex.exec(commentText)) !== null) {
      const whitespace = codegenMatch[1] || "";
      const codegenName = codegenMatch[2] || "";
      const codegenHash = codegenMatch[3] || "";
      const range = {
        pos: codegenMatch.index + pos + whitespace.length,
        end: codegenMatch.index + pos + codegenMatch[0].length
      };
      const codegen = codegens2.find((codegen2) => codegen2.name === codegenName);
      if (!codegen) continue;
      result.push({ codegen, hash: codegenHash, range });
    }
  }
  return result;
});
var getEditsForCodegen = fn("LSP.getEditsForCodegen")(function* (codegens2, sourceFile, textRange) {
  const applicableCodegens = yield* getCodegensForSourceFile(codegens2, sourceFile);
  const inRangeCodegens = applicableCodegens.filter(
    (codegen2) => codegen2.range.pos <= textRange.pos && codegen2.range.end >= textRange.end
  );
  if (inRangeCodegens.length !== 1) {
    return yield* fail(new CodegenNotApplicableError("zero or multiple codegens in range"));
  }
  const { codegen, range } = inRangeCodegens[0];
  const edit = yield* codegen.apply(sourceFile, range);
  const updateHashComment = pipe(
    service(ChangeTracker),
    map4((changeTracker) => {
      changeTracker.deleteRange(sourceFile, range);
      changeTracker.insertText(sourceFile, range.pos, `${codegen.name}:${edit.hash}`);
    })
  );
  return {
    ...edit,
    apply: pipe(
      edit.apply,
      flatMap2(() => updateHashComment)
    ),
    ignore: updateHashComment
  };
});
var getEffectLspPatchSourceFileMetadata = (sourceFile) => {
  return sourceFile["@effect-lsp-patch/metadata"];
};

// src/core/TypeCheckerApi.ts
var TypeCheckerApi = Tag("TypeChecker");
function makeResolveExternalModuleName(typeChecker) {
  if (!(hasProperty(typeChecker, "resolveExternalModuleName") && isFunction(typeChecker.resolveExternalModuleName))) {
    return;
  }
  const _internal = typeChecker.resolveExternalModuleName;
  return (moduleSpecifier) => {
    return _internal(moduleSpecifier);
  };
}

// src/core/TypeCheckerUtils.ts
var TypeCheckerUtils = Tag("TypeCheckerUtils");
var nanoLayer2 = (fa) => pipe(
  service(TypeScriptApi),
  flatMap2(
    (ts) => flatMap2(service(TypeCheckerApi), (typeChecker) => flatMap2(service(TypeScriptUtils), (typeScriptUtils) => pipe(fa, provideService(TypeCheckerUtils, makeTypeCheckerUtils(ts, typeChecker, typeScriptUtils)))))
  )
);
function makeTypeCheckerUtils(ts, typeChecker, tsUtils) {
  function isUnion(type) {
    return !!(type.flags & ts.TypeFlags.Union);
  }
  function isIndexType(type) {
    return !!(type.flags & ts.TypeFlags.Index);
  }
  function isThisTypeParameter(type) {
    return !!(type.flags & ts.TypeFlags.TypeParameter && type.isThisType);
  }
  function getTypeParameterAtPosition(signature, pos) {
    const type = typeChecker.getParameterType(signature, pos);
    if (isIndexType(type) && isThisTypeParameter(type.type)) {
      const constraint = typeChecker.getBaseConstraintOfType(type.type);
      if (constraint) {
        return typeChecker.getIndexType(constraint);
      }
    }
    return type;
  }
  const unrollUnionMembers = (type) => {
    const result = [];
    let toTest = [type];
    while (toTest.length > 0) {
      const type2 = toTest.pop();
      if (isUnion(type2)) {
        toTest = toTest.concat(type2.types);
      } else {
        result.push(type2);
      }
    }
    return result;
  };
  const getMissingTypeEntriesInTargetType = function(realType, expectedType) {
    if (realType === expectedType) return [];
    const result = [];
    let toTest = [realType];
    while (toTest.length > 0) {
      const type = toTest.pop();
      if (!type) return result;
      if (isUnion(type)) {
        toTest = toTest.concat(type.types);
      } else {
        const assignable = typeChecker.isTypeAssignableTo(type, expectedType);
        if (!assignable) {
          result.push(type);
        }
      }
    }
    return result;
  };
  const appendToUniqueTypesMap = fn(
    "TypeCheckerUtils.appendToUniqueTypesMap"
  )(
    function* (memory, initialType, shouldExclude) {
      const newIndexes = /* @__PURE__ */ new Set();
      const knownIndexes = /* @__PURE__ */ new Set();
      let toTest = [initialType];
      while (toTest.length > 0) {
        const type = toTest.pop();
        if (!type) break;
        if (yield* shouldExclude(type)) {
          continue;
        }
        if (isUnion(type)) {
          toTest = toTest.concat(type.types);
        } else {
          const foundMatch = [];
          for (const [typeId, knownType] of memory.entries()) {
            const areSame = typeChecker.isTypeAssignableTo(knownType, type) && typeChecker.isTypeAssignableTo(type, knownType);
            if (areSame) {
              foundMatch.push(typeId);
              break;
            }
          }
          if (foundMatch.length === 0) {
            const newId = "t" + (memory.size + 1);
            memory.set(newId, type);
            newIndexes.add(newId);
          } else {
            knownIndexes.add(foundMatch[0]);
          }
        }
      }
      return {
        newIndexes,
        knownIndexes,
        allIndexes: pipe(
          fromIterable(newIndexes),
          appendAll(fromIterable(knownIndexes))
        )
      };
    }
  );
  const deterministicTypeOrder = make((a, b) => {
    const aName = typeChecker.typeToString(a);
    const bName = typeChecker.typeToString(b);
    if (aName < bName) return -1;
    if (aName > bName) return 1;
    return 0;
  });
  const getAncestorConvertibleDeclaration = (node) => {
    let current = node;
    while (current) {
      if (ts.isFunctionDeclaration(current) || ts.isFunctionExpression(current) || ts.isArrowFunction(current) || ts.isMethodDeclaration(current)) {
        return current;
      }
      current = current.parent;
    }
  };
  const getInferredReturnType = (declaration) => {
    if (!declaration.body) {
      return;
    }
    let returnType;
    if (typeChecker.isImplementationOfOverload(declaration)) {
      const signatures = typeChecker.getSignaturesOfType(
        typeChecker.getTypeAtLocation(declaration),
        ts.SignatureKind.Call
      );
      if (signatures.length > 1) {
        returnType = typeChecker.getUnionType(
          signatures.map((s) => typeChecker.getReturnTypeOfSignature(s)).filter((_) => !!_)
        );
      }
    }
    if (!returnType) {
      const signature = typeChecker.getSignatureFromDeclaration(declaration);
      if (signature) {
        const typePredicate = typeChecker.getTypePredicateOfSignature(signature);
        if (typePredicate && typePredicate.type) {
          return typePredicate.type;
        } else {
          returnType = typeChecker.getReturnTypeOfSignature(signature);
        }
      }
    }
    return returnType;
  };
  const expectedAndRealTypeCache = /* @__PURE__ */ new WeakMap();
  const expectedAndRealType = (sourceFile) => {
    const cached2 = expectedAndRealTypeCache.get(sourceFile);
    if (cached2) return cached2;
    const result = [];
    const nodeToVisit = [sourceFile];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isVariableDeclaration(node) && node.initializer) {
        const expectedType = typeChecker.getTypeAtLocation(node.name);
        const realType = typeChecker.getTypeAtLocation(node.initializer);
        result.push([node.name, expectedType, node.initializer, realType]);
        appendNodeToVisit(node.initializer);
        continue;
      } else if (ts.isCallExpression(node)) {
        const resolvedSignature = typeChecker.getResolvedSignature(node);
        if (resolvedSignature) {
          resolvedSignature.parameters.map((parameter, index) => {
            const expectedType = typeChecker.getTypeOfSymbolAtLocation(parameter, node);
            const realType = typeChecker.getTypeAtLocation(node.arguments[index]);
            result.push([
              node.arguments[index],
              expectedType,
              node.arguments[index],
              realType
            ]);
          });
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node)) {
        const parent = node.parent;
        if (ts.isObjectLiteralElement(parent)) {
          if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {
            const type = typeChecker.getContextualType(parent.parent);
            if (type) {
              const name = ts.isIdentifier(node) ? ts.idText(node) : ts.isStringLiteral(node) ? node.text : void 0;
              if (name) {
                const symbol3 = typeChecker.getPropertyOfType(type, name);
                if (symbol3) {
                  const expectedType = typeChecker.getTypeOfSymbolAtLocation(symbol3, node);
                  const realType = typeChecker.getTypeAtLocation(node);
                  result.push([node, expectedType, node, realType]);
                }
              }
            }
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
        const expectedType = typeChecker.getTypeAtLocation(node.left);
        const realType = typeChecker.getTypeAtLocation(node.right);
        result.push([node.left, expectedType, node.right, realType]);
        appendNodeToVisit(node.right);
        continue;
      } else if (ts.isReturnStatement(node) && node.expression) {
        const parentDeclaration = getAncestorConvertibleDeclaration(node);
        if (parentDeclaration) {
          const expectedType = getInferredReturnType(parentDeclaration);
          const realType = typeChecker.getTypeAtLocation(node.expression);
          if (expectedType) {
            result.push([node, expectedType, node, realType]);
          }
        }
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length === 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = typeChecker.getContextualType(body);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isArrowFunction(node) && (node.typeParameters || []).length > 0 && ts.isExpression(node.body)) {
        const body = node.body;
        const expectedType = getInferredReturnType(node);
        const realType = typeChecker.getTypeAtLocation(body);
        if (expectedType) {
          result.push([body, expectedType, body, realType]);
        }
        ts.forEachChild(body, appendNodeToVisit);
        continue;
      } else if (ts.isSatisfiesExpression(node)) {
        const expectedType = typeChecker.getTypeAtLocation(node.type);
        const realType = typeChecker.getTypeAtLocation(node.expression);
        result.push([node.expression, expectedType, node.expression, realType]);
        appendNodeToVisit(node.expression);
        continue;
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
    expectedAndRealTypeCache.set(sourceFile, result);
    return result;
  };
  function typeToSimplifiedTypeNode(type, enclosingNode, flags) {
    return typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, 0);
  }
  function typeToSimplifiedTypeNodeWorker(type, enclosingNode, flags, depth) {
    const fallbackStandard = () => {
      const typeNode = typeChecker.typeToTypeNode(type, enclosingNode, flags);
      if (!typeNode) return void 0;
      return tsUtils.simplifyTypeNode(typeNode);
    };
    if (depth > 20) return fallbackStandard();
    const members = unrollUnionMembers(type);
    if (members.length > 1 && !(type.flags & ts.TypeFlags.Boolean)) {
      const typeNodes = [];
      members.sort(deterministicTypeOrder);
      for (const member of members) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createUnionTypeNode(typeNodes));
    }
    if (type.flags & ts.TypeFlags.Intersection) {
      const intersectionType = type;
      const typeNodes = [];
      for (const member of intersectionType.types) {
        const memberNode = typeToSimplifiedTypeNodeWorker(member, enclosingNode, flags, depth + 1);
        if (!memberNode) return fallbackStandard();
        typeNodes.push(memberNode);
      }
      return tsUtils.simplifyTypeNode(ts.factory.createIntersectionTypeNode(typeNodes));
    }
    if (type.flags & ts.TypeFlags.Object && type.objectFlags & ts.ObjectFlags.Reference) {
      const typeReference = type;
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isTypeReferenceNode(standard2)) return standard2;
      if (typeReference.target.typeParameters?.length !== typeReference.typeArguments?.length) return standard2;
      if (standard2.typeArguments?.length !== typeReference.typeArguments?.length) return standard2;
      const typeParametersCount = (typeReference.target.typeParameters || []).length;
      for (let i = typeParametersCount - 1; i >= 0; i--) {
        const typeParameter = typeReference.target.typeParameters[i];
        const typeArgument = typeReference.typeArguments[i];
        const defaultType = typeChecker.getDefaultFromTypeParameter(typeParameter);
        if (defaultType !== typeArgument || i === 0) {
          return tsUtils.simplifyTypeNode(ts.factory.updateTypeReferenceNode(
            standard2,
            standard2.typeName,
            ts.factory.createNodeArray((standard2.typeArguments || []).slice(0, Math.min(typeParametersCount, i + 1)))
          ));
        }
      }
      return standard2;
    }
    if (type.flags & ts.TypeFlags.Object) {
      const standard2 = fallbackStandard();
      if (!standard2) return void 0;
      if (!ts.isFunctionTypeNode(standard2)) return standard2;
      const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
      if (signatures.length !== 1) return standard2;
      const returnType = typeChecker.getReturnTypeOfSignature(signatures[0]);
      if (!returnType) return standard2;
      const returnTypeNode = typeToSimplifiedTypeNodeWorker(returnType, enclosingNode, flags, depth + 1);
      if (!returnTypeNode) return standard2;
      return tsUtils.simplifyTypeNode(ts.factory.updateFunctionTypeNode(
        standard2,
        standard2.typeParameters,
        standard2.parameters,
        returnTypeNode
      ));
    }
    return fallbackStandard();
  }
  return {
    isUnion,
    getTypeParameterAtPosition,
    getMissingTypeEntriesInTargetType,
    unrollUnionMembers,
    appendToUniqueTypesMap,
    deterministicTypeOrder,
    getInferredReturnType,
    expectedAndRealType,
    typeToSimplifiedTypeNode
  };
}

// src/core/TypeParser.ts
var TypeParser = Tag("@effect/language-service/TypeParser");
var nanoLayer3 = (fa) => gen(function* () {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  const program = yield* service(TypeScriptProgram);
  return yield* pipe(
    fa,
    provideService(TypeParser, make2(ts, tsUtils, typeChecker, typeCheckerUtils, program))
  );
});
var TypeParserIssue = class _TypeParserIssue {
  _tag = "@effect/language-service/TypeParserIssue";
  static issue = fail(new _TypeParserIssue());
};
function typeParserIssue(_message, _type, _node) {
  return TypeParserIssue.issue;
}
function make2(ts, tsUtils, typeChecker, typeCheckerUtils, program) {
  const getSourceFilePackageInfo = cachedBy(
    fn("TypeParser.getSourceFilePackageInfo")(function* (sourceFile) {
      return tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    }),
    `TypeParser.getSourceFilePackageInfo`,
    (sourceFile) => sourceFile
  );
  const getSourceFilesDeclaringSymbolModule = (packageName) => cachedBy(
    fn("TypeParser.getSourceFilesDeclaringSymbolModule")(function* (symbol3) {
      const result = [];
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const sourceFile of symbol3.declarations) {
        if (!ts.isSourceFile(sourceFile)) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        result.push(sourceFile);
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no source file declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolModule(${packageName})`,
    (symbol3) => symbol3
  );
  const isSymbolReferenceToPackageModule = (givenSymbol, packageName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolModule(packageName)(symbol3),
      flatMap2(
        (sourceFiles) => firstSuccessOf(
          sourceFiles.map((_) => checkSourceFile(_))
        )
      )
    );
  };
  const isNodeReferenceToPackageModule = (givenNode, packageName, isCorrectSourceFile) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolReferenceToPackageModule(symbol3, packageName, isCorrectSourceFile);
  };
  const getSourceFilesDeclaringSymbolExportedUnderPackageModule = (packageName, memberName) => cachedBy(
    fn("TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember")(function* (symbol3) {
      const result = [];
      if (!symbol3.declarations) return yield* typeParserIssue("Symbol has no declarations", void 0, void 0);
      for (const declaration of symbol3.declarations) {
        const sourceFile = tsUtils.getSourceFileOfNode(declaration);
        if (!sourceFile) continue;
        const packageInfo = yield* getSourceFilePackageInfo(sourceFile);
        if (!packageInfo || packageInfo.name.toLowerCase() !== packageName.toLowerCase()) continue;
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) continue;
        const memberSymbol = typeChecker.tryGetMemberInModuleExports(memberName, moduleSymbol);
        if (memberSymbol && memberSymbol === symbol3) result.push({ memberSymbol, moduleSymbol, sourceFile });
      }
      if (result.length > 0) {
        return result;
      }
      return yield* typeParserIssue(`Symbol has no declarations`, void 0, void 0);
    }),
    `TypeParser.getSourceFilesDeclaringSymbolUnderPackageExportedMember(${packageName}, ${memberName})`,
    (sym) => sym
  );
  const isSymbolExportOfPackageModule = (givenSymbol, packageName, memberName, checkSourceFile) => {
    let symbol3 = givenSymbol;
    while (symbol3.flags & ts.SymbolFlags.Alias) {
      symbol3 = typeChecker.getAliasedSymbol(symbol3);
    }
    return pipe(
      getSourceFilesDeclaringSymbolExportedUnderPackageModule(packageName, memberName)(symbol3),
      flatMap2(
        (sourceFiles) => firstSuccessOf(
          sourceFiles.map((_) => checkSourceFile(_.sourceFile, _.moduleSymbol, _.memberSymbol))
        )
      )
    );
  };
  const isNodeReferenceToExportOfPackageModule = (givenNode, packageName, isCorrectSourceFile, memberName) => {
    const symbol3 = typeChecker.getSymbolAtLocation(givenNode);
    if (!symbol3) return typeParserIssue("Node has no symbol", void 0, givenNode);
    return isSymbolExportOfPackageModule(symbol3, packageName, memberName, isCorrectSourceFile);
  };
  function covariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Covariant type has no call signature", type);
    }
    return succeed(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  function contravariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Contravariant type has no call signature", type);
    }
    return succeed(typeCheckerUtils.getTypeParameterAtPosition(signatures[0], 0));
  }
  function invariantTypeArgument(type) {
    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length !== 1) {
      return typeParserIssue("Invariant type has no call signature", type);
    }
    return succeed(typeChecker.getReturnTypeOfSignature(signatures[0]));
  }
  const pipeableType = cachedBy(
    function(type, atLocation) {
      const pipeSymbol = typeChecker.getPropertyOfType(type, "pipe");
      if (!pipeSymbol) {
        return typeParserIssue("Type has no 'pipe' property", type, atLocation);
      }
      const pipeType = typeChecker.getTypeOfSymbolAtLocation(pipeSymbol, atLocation);
      const signatures = typeChecker.getSignaturesOfType(pipeType, ts.SignatureKind.Call);
      if (signatures.length === 0) {
        return typeParserIssue("'pipe' property is not callable", type, atLocation);
      }
      return succeed(type);
    },
    "TypeParser.pipeableType",
    (type) => type
  );
  const varianceStructCovariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return covariantTypeArgument(propertyType);
  };
  const varianceStructContravariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return contravariantTypeArgument(propertyType);
  };
  const varianceStructInvariantType = (type, atLocation, propertyName) => {
    const propertySymbol = typeChecker.getPropertyOfType(type, propertyName);
    if (!propertySymbol) {
      return typeParserIssue(`Type has no '${propertyName}' property`, type, atLocation);
    }
    const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
    return invariantTypeArgument(propertyType);
  };
  const effectVarianceStruct = (type, atLocation) => map4(
    all(
      varianceStructCovariantType(type, atLocation, "_A"),
      varianceStructCovariantType(type, atLocation, "_E"),
      varianceStructCovariantType(type, atLocation, "_R")
    ),
    ([A, E, R]) => ({ A, E, R })
  );
  const layerVarianceStruct = (type, atLocation) => map4(
    all(
      varianceStructContravariantType(type, atLocation, "_ROut"),
      varianceStructCovariantType(type, atLocation, "_E"),
      varianceStructCovariantType(type, atLocation, "_RIn")
    ),
    ([ROut, E, RIn]) => ({ ROut, E, RIn })
  );
  const effectType = cachedBy(
    fn("TypeParser.effectType")(function* (type, atLocation) {
      let result = typeParserIssue("Type has no effect variance struct", type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("EffectTypeId") - ts.symbolName(a).indexOf("EffectTypeId")
      );
      for (const propertySymbol of propertiesSymbols) {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        result = pipe(result, orElse2(() => effectVarianceStruct(propertyType, atLocation)));
      }
      return yield* result;
    }),
    "TypeParser.effectType",
    (type) => type
  );
  const strictEffectType = cachedBy(
    fn("TypeParser.strictEffectType")(function* (type, atLocation) {
      if (!(type.symbol && ts.symbolName(type.symbol) === "Effect" && !type.aliasSymbol)) {
        return yield* typeParserIssue("Type name should be Effect with no alias symbol", type, atLocation);
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.strictEffectType",
    (type) => type
  );
  const isEffectTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const effectTypeSymbol = typeChecker.tryGetMemberInModuleExports("Effect", moduleSymbol);
      if (!effectTypeSymbol) return yield* typeParserIssue("Effect type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(effectTypeSymbol);
      yield* effectType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectModuleApi(${memberName})`,
    (node) => node
  );
  const layerType = cachedBy(
    fn("TypeParser.layerType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("LayerTypeId") - ts.symbolName(a).indexOf("LayerTypeId")
      );
      for (const propertySymbol of propertiesSymbols) {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        const varianceArgs = yield* option(layerVarianceStruct(
          propertyType,
          atLocation
        ));
        if (isSome2(varianceArgs)) {
          return varianceArgs.value;
        }
      }
      return yield* typeParserIssue("Type has no layer variance struct", type, atLocation);
    }),
    "TypeParser.layerType",
    (type) => type
  );
  const fiberType = cachedBy(
    fn("TypeParser.fiberType")(function* (type, atLocation) {
      const awaitSymbol = typeChecker.getPropertyOfType(type, "await");
      const pollSymbol = typeChecker.getPropertyOfType(type, "poll");
      if (!awaitSymbol || !pollSymbol) {
        return yield* typeParserIssue(
          "Type is not a fiber because it does not have 'await' or 'poll' property",
          type,
          atLocation
        );
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.fiberType",
    (type) => type
  );
  const effectSubtype = cachedBy(
    fn("TypeParser.effectSubtype")(function* (type, atLocation) {
      const tagSymbol = typeChecker.getPropertyOfType(type, "_tag");
      const getSymbol = typeChecker.getPropertyOfType(type, "get");
      if (!(tagSymbol || getSymbol)) {
        return yield* typeParserIssue(
          "Type is not a subtype of effect because it does not have '_tag' or 'get' property",
          type,
          atLocation
        );
      }
      return yield* effectType(type, atLocation);
    }),
    "TypeParser.effectSubtype",
    (type) => type
  );
  const importedContextModule = cachedBy(
    fn("TypeParser.importedContextModule")(function* (node) {
      const type = typeChecker.getTypeAtLocation(node);
      const propertySymbol = typeChecker.getPropertyOfType(type, "Tag");
      if (!propertySymbol) {
        return yield* typeParserIssue("Type has no 'Tag' property", type, node);
      }
      if (!ts.isIdentifier(node)) {
        return yield* typeParserIssue("Node is not an identifier", type, node);
      }
      const sourceFile = tsUtils.getSourceFileOfNode(node);
      if (!sourceFile) {
        return yield* typeParserIssue("Node is not in a source file", void 0, node);
      }
      const contextIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
        sourceFile,
        "effect",
        "Context"
      );
      if (!contextIdentifier) {
        return yield* typeParserIssue("Context module not found", void 0, node);
      }
      if (ts.idText(node) !== contextIdentifier) {
        return yield* typeParserIssue("Node is not a context module reference", void 0, node);
      }
      return node;
    }),
    "TypeParser.importedContextModule",
    (node) => node
  );
  const importedEffectModule = (node) => pipe(
    isNodeReferenceToPackageModule(node, "effect", isEffectTypeSourceFile),
    map4(() => node)
  );
  const importedDataModule = cachedBy(
    fn("TypeParser.importedDataModule")(function* (node) {
      const type = typeChecker.getTypeAtLocation(node);
      const propertySymbol = typeChecker.getPropertyOfType(type, "TaggedError");
      if (!propertySymbol) {
        return yield* typeParserIssue("Type has no 'TaggedError' property", type, node);
      }
      if (!ts.isIdentifier(node)) {
        return yield* typeParserIssue("Node is not an expression", type, node);
      }
      const sourceFile = tsUtils.getSourceFileOfNode(node);
      if (!sourceFile) {
        return yield* typeParserIssue("Node is not in a source file", void 0, node);
      }
      const dataIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
        sourceFile,
        "effect",
        "Data"
      );
      if (!dataIdentifier) {
        return yield* typeParserIssue("Data module not found", void 0, node);
      }
      if (ts.idText(node) !== dataIdentifier) {
        return yield* typeParserIssue("Node is not a data module reference", void 0, node);
      }
      return node;
    }),
    "TypeParser.importedDataModule",
    (node) => node
  );
  const effectGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue("Node is not a generator function", void 0, node);
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue("Node is not a property access expression", void 0, node);
      }
      const propertyAccess = node.expression;
      return pipe(
        isNodeReferenceToEffectModuleApi("gen")(propertyAccess),
        map4(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectGen",
    (node) => node
  );
  const effectFnUntracedGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue("Node is not a function expression", void 0, node);
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      if (!ts.isPropertyAccessExpression(node.expression)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const propertyAccess = node.expression;
      return pipe(
        isNodeReferenceToEffectModuleApi("fnUntraced")(propertyAccess),
        map4(() => ({
          node,
          effectModule: propertyAccess.expression,
          generatorFunction,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectFnUntracedGen",
    (node) => node
  );
  const effectFnGen = cachedBy(
    function(node) {
      if (!ts.isCallExpression(node)) {
        return typeParserIssue("Node is not a call expression", void 0, node);
      }
      if (node.arguments.length === 0) {
        return typeParserIssue("Node has no arguments", void 0, node);
      }
      const generatorFunction = node.arguments[0];
      if (!ts.isFunctionExpression(generatorFunction)) {
        return typeParserIssue(
          "Node is not a function expression",
          void 0,
          node
        );
      }
      if (generatorFunction.asteriskToken === void 0) {
        return typeParserIssue(
          "Node is not a generator function",
          void 0,
          node
        );
      }
      const expressionToTest = ts.isCallExpression(node.expression) ? node.expression.expression : node.expression;
      if (!ts.isPropertyAccessExpression(expressionToTest)) {
        return typeParserIssue(
          "Node is not a property access expression",
          void 0,
          node
        );
      }
      const propertyAccess = expressionToTest;
      return pipe(
        isNodeReferenceToEffectModuleApi("fn")(propertyAccess),
        map4(() => ({
          node,
          generatorFunction,
          effectModule: propertyAccess.expression,
          body: generatorFunction.body
        }))
      );
    },
    "TypeParser.effectFnGen",
    (node) => node
  );
  const unnecessaryEffectGen2 = cachedBy(
    fn("TypeParser.unnecessaryEffectGen")(function* (node) {
      const { body } = yield* effectGen(node);
      if (body.statements.length !== 1) {
        return yield* typeParserIssue(
          "Generator body should have a single statement",
          void 0,
          node
        );
      }
      let explicitReturn = false;
      let nodeToCheck = body.statements[0];
      while (nodeToCheck) {
        if (ts.isReturnStatement(nodeToCheck) && nodeToCheck.expression) {
          nodeToCheck = nodeToCheck.expression;
          explicitReturn = true;
          continue;
        }
        if (ts.isExpressionStatement(nodeToCheck)) {
          nodeToCheck = nodeToCheck.expression;
          continue;
        }
        if (ts.isYieldExpression(nodeToCheck) && nodeToCheck.asteriskToken && nodeToCheck.expression) {
          const yieldedExpression = nodeToCheck.expression;
          const type = typeChecker.getTypeAtLocation(yieldedExpression);
          const { A: successType } = yield* effectType(type, yieldedExpression);
          let replacementNode = succeed(yieldedExpression);
          if (!explicitReturn && !(successType.flags & ts.TypeFlags.VoidLike)) {
            replacementNode = pipe(
              gen(function* () {
                const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
                  node.getSourceFile(),
                  "effect",
                  "Effect"
                ) || "Effect";
                return ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(effectIdentifier),
                    "asVoid"
                  ),
                  void 0,
                  [
                    yieldedExpression
                  ]
                );
              }),
              provideService(TypeScriptApi, ts)
            );
          }
          return { node, body, yieldedExpression, replacementNode };
        }
        break;
      }
      return yield* typeParserIssue(
        "Not an handled node",
        void 0,
        node
      );
    }),
    "TypeParser.unnecessaryEffectGen",
    (node) => node
  );
  const effectSchemaVarianceStruct = (type, atLocation) => map4(
    all(
      varianceStructInvariantType(type, atLocation, "_A"),
      varianceStructInvariantType(type, atLocation, "_I"),
      varianceStructCovariantType(type, atLocation, "_R")
    ),
    ([A, I, R]) => ({ A, I, R })
  );
  const effectSchemaType = cachedBy(
    fn("TypeParser.effectSchemaType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const ast = typeChecker.getPropertyOfType(type, "ast");
      if (!ast) return yield* typeParserIssue("Has no 'ast' property", type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      for (const propertySymbol of propertiesSymbols) {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        const varianceArgs = yield* option(effectSchemaVarianceStruct(
          propertyType,
          atLocation
        ));
        if (isSome2(varianceArgs)) {
          return varianceArgs.value;
        }
      }
      return yield* typeParserIssue("Type has no schema variance struct", type, atLocation);
    }),
    "TypeParser.effectSchemaType",
    (type) => type
  );
  const isEffectSchemaTypeSourceFile = cachedBy(
    fn("TypeParser.isEffectSchemaTypeSourceFile")(function* (sourceFile) {
      const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
      if (!moduleSymbol) return yield* typeParserIssue("Node has no symbol", void 0, sourceFile);
      const typeSymbol = typeChecker.tryGetMemberInModuleExports("Schema", moduleSymbol);
      if (!typeSymbol) return yield* typeParserIssue("Schema type not found", void 0, sourceFile);
      const type = typeChecker.getDeclaredTypeOfSymbol(typeSymbol);
      yield* effectSchemaType(type, sourceFile);
      return sourceFile;
    }),
    "TypeParser.isEffectSchemaTypeSourceFile",
    (sourceFile) => sourceFile
  );
  const isNodeReferenceToEffectSchemaModuleApi = (memberName) => cachedBy(
    fn("TypeParser.isNodeReferenceToEffectSchemaModuleApi")(function* (node) {
      return yield* isNodeReferenceToExportOfPackageModule(node, "effect", isEffectSchemaTypeSourceFile, memberName);
    }),
    `TypeParser.isNodeReferenceToEffectSchemaModuleApi(${memberName})`,
    (node) => node
  );
  const contextTagVarianceStruct = (type, atLocation) => map4(
    all(
      varianceStructInvariantType(type, atLocation, "_Identifier"),
      varianceStructInvariantType(type, atLocation, "_Service")
    ),
    ([Identifier, Service]) => ({ Identifier, Service })
  );
  const contextTag = cachedBy(
    fn("TypeParser.contextTag")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort((a, b) => ts.symbolName(b).indexOf("TypeId") - ts.symbolName(a).indexOf("TypeId"));
      for (const propertySymbol of propertiesSymbols) {
        const propertyType = typeChecker.getTypeOfSymbolAtLocation(propertySymbol, atLocation);
        const varianceArgs = yield* option(contextTagVarianceStruct(
          propertyType,
          atLocation
        ));
        if (isSome2(varianceArgs)) {
          return varianceArgs.value;
        }
      }
      return yield* typeParserIssue("Type has no tag variance struct", type, atLocation);
    }),
    "TypeParser.contextTag",
    (type) => type
  );
  const pipeCall = cachedBy(
    function(node) {
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "pipe") {
        return succeed({
          node,
          subject: node.expression.expression,
          args: Array.from(node.arguments),
          kind: "pipeable"
        });
      }
      if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && ts.idText(node.expression) === "pipe" && node.arguments.length > 0) {
        const [subject, ...args2] = node.arguments;
        return succeed({ node, subject, args: args2, kind: "pipe" });
      }
      return typeParserIssue("Node is not a pipe call", void 0, node);
    },
    "TypeParser.pipeCall",
    (node) => node
  );
  const scopeType = cachedBy(
    fn("TypeParser.scopeType")(function* (type, atLocation) {
      yield* pipeableType(type, atLocation);
      const propertiesSymbols = typeChecker.getPropertiesOfType(type).filter(
        (_) => _.flags & ts.SymbolFlags.Property && !(_.flags & ts.SymbolFlags.Optional) && _.valueDeclaration && ts.isPropertySignature(_.valueDeclaration) && ts.isComputedPropertyName(_.valueDeclaration.name)
      );
      propertiesSymbols.sort(
        (a, b) => ts.symbolName(b).indexOf("ScopeTypeId") - ts.symbolName(a).indexOf("ScopeTypeId")
      );
      for (const propertySymbol of propertiesSymbols) {
        const computedPropertyExpression = propertySymbol.valueDeclaration.name;
        const symbol3 = typeChecker.getSymbolAtLocation(computedPropertyExpression.expression);
        if (symbol3 && ts.symbolName(symbol3) === "ScopeTypeId") {
          return type;
        }
      }
      return yield* typeParserIssue("Type has no scope type id", type, atLocation);
    }),
    "TypeParser.scopeType",
    (type) => type
  );
  const promiseLike = cachedBy(
    function(type, atLocation) {
      const thenProperty = type.getProperty("then");
      if (!thenProperty) return typeParserIssue("not a promise - missing then property", type, atLocation);
      const thenType = typeChecker.getTypeOfSymbolAtLocation(thenProperty, atLocation);
      if (!thenType) return typeParserIssue("not a promise - missing then property", type, atLocation);
      for (const callSignature of typeChecker.getSignaturesOfType(thenType, ts.SignatureKind.Call)) {
        const parameter = callSignature.parameters[0];
        if (!parameter) continue;
        const parameterType = typeCheckerUtils.getTypeParameterAtPosition(callSignature, 0);
        if (!parameterType) continue;
        let callbackCallSignatures = [];
        let toTest = [parameterType];
        while (toTest.length > 0) {
          const type2 = toTest.shift();
          if (!type2) continue;
          const callSignatures = typeChecker.getSignaturesOfType(type2, ts.SignatureKind.Call);
          callbackCallSignatures = callbackCallSignatures.concat(callSignatures);
          if (typeCheckerUtils.isUnion(type2)) {
            toTest = toTest.concat(type2.types);
          }
        }
        for (const callableType of callbackCallSignatures) {
          const callbackParameter = callableType.parameters[0];
          if (!callbackParameter) {
            continue;
          }
          const callbackParameterType = typeCheckerUtils.getTypeParameterAtPosition(callableType, 0);
          if (!callbackParameterType) {
            continue;
          }
          return succeed({
            type: callbackParameterType
          });
        }
      }
      return typeParserIssue("not a promise", type, atLocation);
    },
    "TypeParser.promiseLike",
    (type) => type
  );
  const extendsSchemaClass = cachedBy(
    fn("TypeParser.extendsSchemaClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaCall = expression.expression;
              if (ts.isCallExpression(schemaCall) && schemaCall.typeArguments && schemaCall.typeArguments.length > 0) {
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("Class")(schemaCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode: schemaCall.typeArguments[0]
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.Class", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedClass = cachedBy(
    fn("TypeParser.extendsSchemaTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression) && expression.arguments.length > 0) {
              const schemaTaggedClassTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedClassTCall) && schemaTaggedClassTCall.typeArguments && schemaTaggedClassTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedClassTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedClass")(schemaTaggedClassTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedClassTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedClassTCall.arguments[0]) ? schemaTaggedClassTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedClass",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedError = cachedBy(
    fn("TypeParser.extendsSchemaTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedErrorTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedErrorTCall) && schemaTaggedErrorTCall.typeArguments && schemaTaggedErrorTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedErrorTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedError")(schemaTaggedErrorTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: schemaTaggedErrorTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedErrorTCall.arguments[0]) ? schemaTaggedErrorTCall.arguments[0] : void 0,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedError",
    (atLocation) => atLocation
  );
  const extendsSchemaTaggedRequest = cachedBy(
    fn("TypeParser.extendsSchemaTaggedRequest")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const schemaTaggedRequestTCall = expression.expression;
              if (ts.isCallExpression(schemaTaggedRequestTCall) && schemaTaggedRequestTCall.typeArguments && schemaTaggedRequestTCall.typeArguments.length > 0) {
                const selfTypeNode = schemaTaggedRequestTCall.typeArguments[0];
                const isEffectSchemaModuleApi = yield* pipe(
                  isNodeReferenceToEffectSchemaModuleApi("TaggedRequest")(schemaTaggedRequestTCall.expression),
                  option
                );
                if (isSome2(isEffectSchemaModuleApi)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    tagStringLiteral: expression.arguments.length > 0 && ts.isStringLiteral(expression.arguments[0]) ? expression.arguments[0] : void 0,
                    keyStringLiteral: schemaTaggedRequestTCall.arguments.length > 0 && ts.isStringLiteral(schemaTaggedRequestTCall.arguments[0]) ? schemaTaggedRequestTCall.arguments[0] : void 0
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Schema.TaggedRequest", void 0, atLocation);
    }),
    "TypeParser.extendsSchemaTaggedRequest",
    (atLocation) => atLocation
  );
  const extendsDataTaggedError = cachedBy(
    fn("TypeParser.extendsDataTaggedError")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedErrorCall = expression;
              const dataIdentifier = dataTaggedErrorCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedError") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedErrorCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedErrorCall.arguments[0]) ? dataTaggedErrorCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedError", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedError",
    (atLocation) => atLocation
  );
  const extendsDataTaggedClass = cachedBy(
    fn("TypeParser.extendsDataTaggedClass")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const expression = typeX.expression;
            if (ts.isCallExpression(expression)) {
              const dataTaggedClassCall = expression;
              const dataIdentifier = dataTaggedClassCall.expression;
              if (ts.isPropertyAccessExpression(dataIdentifier) && ts.isIdentifier(dataIdentifier.name) && ts.idText(dataIdentifier.name) === "TaggedClass") {
                const parsedDataModule = yield* pipe(
                  importedDataModule(dataIdentifier.expression),
                  option
                );
                if (isSome2(parsedDataModule)) {
                  return {
                    className: atLocation.name,
                    keyStringLiteral: dataTaggedClassCall.arguments.length > 0 && ts.isStringLiteral(dataTaggedClassCall.arguments[0]) ? dataTaggedClassCall.arguments[0] : void 0,
                    Data: parsedDataModule.value
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Data.TaggedClass", void 0, atLocation);
    }),
    "TypeParser.extendsDataTaggedClass",
    (atLocation) => atLocation
  );
  const extendsContextTag = cachedBy(
    fn("TypeParser.extendsContextTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const contextTagCall = wholeCall.expression;
              if (ts.isCallExpression(contextTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const contextTagIdentifier = contextTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                if (ts.isPropertyAccessExpression(contextTagIdentifier) && ts.isIdentifier(contextTagIdentifier.name) && ts.idText(contextTagIdentifier.name) === "Tag") {
                  const parsedContextModule = yield* pipe(
                    importedContextModule(contextTagIdentifier.expression),
                    option
                  );
                  if (isSome2(parsedContextModule)) {
                    const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                    if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                    const type = typeChecker.getTypeOfSymbol(classSym);
                    const tagType = yield* contextTag(type, atLocation);
                    return {
                      className: atLocation.name,
                      selfTypeNode,
                      keyStringLiteral: ts.isStringLiteral(contextTagCall.arguments[0]) ? contextTagCall.arguments[0] : void 0,
                      args: contextTagCall.arguments,
                      Identifier: tagType.Identifier,
                      Tag: parsedContextModule.value
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Context.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsContextTag",
    (atLocation) => atLocation
  );
  const extendsEffectTag = cachedBy(
    fn("TypeParser.extendsEffectTag")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
      if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
      const type = typeChecker.getTypeOfSymbol(classSym);
      const tagType = yield* contextTag(type, atLocation);
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectTagCall = wholeCall.expression;
              if (ts.isCallExpression(effectTagCall) && wholeCall.typeArguments && wholeCall.typeArguments.length > 0) {
                const effectTagIdentifier = effectTagCall.expression;
                const selfTypeNode = wholeCall.typeArguments[0];
                const isEffectTag = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Tag")(effectTagIdentifier),
                  option
                );
                if (isSome2(isEffectTag)) {
                  return {
                    className: atLocation.name,
                    selfTypeNode,
                    keyStringLiteral: ts.isStringLiteral(effectTagCall.arguments[0]) ? effectTagCall.arguments[0] : void 0,
                    args: effectTagCall.arguments,
                    Identifier: tagType.Identifier,
                    Service: tagType.Service
                  };
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Tag", void 0, atLocation);
    }),
    "TypeParser.extendsEffectTag",
    (atLocation) => atLocation
  );
  const extendsEffectService = cachedBy(
    fn("TypeParser.extendsEffectService")(function* (atLocation) {
      if (!atLocation.name) {
        return yield* typeParserIssue("Class has no name", void 0, atLocation);
      }
      const heritageClauses = atLocation.heritageClauses;
      if (!heritageClauses) {
        return yield* typeParserIssue("Class has no heritage clauses", void 0, atLocation);
      }
      for (const heritageClause of heritageClauses) {
        for (const typeX of heritageClause.types) {
          if (ts.isExpressionWithTypeArguments(typeX)) {
            const wholeCall = typeX.expression;
            if (ts.isCallExpression(wholeCall)) {
              const effectServiceCall = wholeCall.expression;
              if (ts.isCallExpression(effectServiceCall) && effectServiceCall.typeArguments && effectServiceCall.typeArguments.length > 0) {
                const effectServiceIdentifier = effectServiceCall.expression;
                const selfTypeNode = effectServiceCall.typeArguments[0];
                const isEffectService = yield* pipe(
                  isNodeReferenceToEffectModuleApi("Service")(effectServiceIdentifier),
                  option
                );
                if (isSome2(isEffectService)) {
                  const classSym = typeChecker.getSymbolAtLocation(atLocation.name);
                  if (!classSym) return yield* typeParserIssue("Class has no symbol", void 0, atLocation);
                  const type = typeChecker.getTypeOfSymbol(classSym);
                  const parsedContextTag = yield* pipe(
                    contextTag(type, atLocation),
                    option
                  );
                  if (isSome2(parsedContextTag)) {
                    let accessors2 = void 0;
                    let dependencies = void 0;
                    if (wholeCall.arguments.length >= 2) {
                      const args2 = wholeCall.arguments[1];
                      if (ts.isObjectLiteralExpression(args2)) {
                        for (const property of args2.properties) {
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "accessors" && property.initializer && property.initializer.kind === ts.SyntaxKind.TrueKeyword) {
                            accessors2 = true;
                          }
                          if (ts.isPropertyAssignment(property) && property.name && ts.isIdentifier(property.name) && ts.idText(property.name) === "dependencies" && property.initializer && ts.isArrayLiteralExpression(property.initializer)) {
                            dependencies = property.initializer.elements;
                          }
                        }
                      }
                    }
                    return {
                      ...parsedContextTag.value,
                      className: atLocation.name,
                      selfTypeNode,
                      args: wholeCall.arguments,
                      keyStringLiteral: ts.isStringLiteral(wholeCall.arguments[0]) ? wholeCall.arguments[0] : void 0,
                      options: wholeCall.arguments[1],
                      accessors: accessors2,
                      dependencies
                    };
                  }
                }
              }
            }
          }
        }
      }
      return yield* typeParserIssue("Class does not extend Effect.Service", void 0, atLocation);
    }),
    "TypeParser.extendsEffectService",
    (atLocation) => atLocation
  );
  return {
    isNodeReferenceToEffectModuleApi,
    effectType,
    strictEffectType,
    layerType,
    fiberType,
    effectSubtype,
    importedEffectModule,
    effectGen,
    effectFnUntracedGen,
    effectFnGen,
    unnecessaryEffectGen: unnecessaryEffectGen2,
    effectSchemaType,
    contextTag,
    pipeableType,
    pipeCall,
    scopeType,
    promiseLike,
    extendsEffectTag,
    extendsEffectService,
    extendsContextTag,
    extendsSchemaClass,
    extendsSchemaTaggedClass,
    extendsSchemaTaggedError,
    extendsDataTaggedError,
    extendsDataTaggedClass,
    extendsSchemaTaggedRequest
  };
}

// src/diagnostics/catchUnfailableEffect.ts
var catchUnfailableEffect = createDiagnostic({
  name: "catchUnfailableEffect",
  code: 2,
  severity: "suggestion",
  apply: fn("catchUnfailableEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const catchFunctions = ["catchAll", "catch", "catchIf", "catchSome", "catchTag", "catchTags"];
        const isCatchCall = yield* pipe(
          firstSuccessOf(
            catchFunctions.map((catchFn) => typeParser.isNodeReferenceToEffectModuleApi(catchFn)(node.expression))
          ),
          option
        );
        if (isSome2(isCatchCall)) {
          const parent = node.parent;
          if (parent && ts.isCallExpression(parent)) {
            const pipeCallResult = yield* pipe(
              typeParser.pipeCall(parent),
              option
            );
            if (isSome2(pipeCallResult)) {
              const { args: args2, node: pipeCallNode, subject } = pipeCallResult.value;
              const argIndex = args2.findIndex((arg) => arg === node);
              if (argIndex !== -1) {
                let effectTypeToCheck;
                if (argIndex === 0) {
                  effectTypeToCheck = typeChecker.getTypeAtLocation(subject);
                } else {
                  const signature = typeChecker.getResolvedSignature(pipeCallNode);
                  if (signature) {
                    const typeArguments = typeChecker.getTypeArgumentsForResolvedSignature(signature);
                    if (typeArguments && typeArguments.length > argIndex) {
                      effectTypeToCheck = typeArguments[argIndex];
                    }
                  }
                }
                if (effectTypeToCheck) {
                  const effectType = yield* pipe(
                    typeParser.effectType(effectTypeToCheck, node),
                    option
                  );
                  if (isSome2(effectType)) {
                    const { E } = effectType.value;
                    if (E.flags & ts.TypeFlags.Never) {
                      report({
                        location: node.expression,
                        messageText: `Looks like the previous effect never fails, so probably this error handling will never be triggered.`,
                        fixes: []
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/classSelfMismatch.ts
var classSelfMismatch = createDiagnostic({
  name: "classSelfMismatch",
  code: 20,
  severity: "error",
  apply: fn("classSelfMismatch.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => typeParser.extendsContextTag(node)),
          orElse2(() => typeParser.extendsEffectTag(node)),
          orElse2(() => typeParser.extendsSchemaClass(node)),
          orElse2(() => typeParser.extendsSchemaTaggedClass(node)),
          orElse2(() => typeParser.extendsSchemaTaggedError(node)),
          orElse2(() => typeParser.extendsSchemaTaggedRequest(node)),
          orElse2(() => void_)
        );
        if (result) {
          const { className, selfTypeNode } = result;
          let actualName = sourceFile.text.substring(selfTypeNode.pos, selfTypeNode.end);
          if (ts.isTypeReferenceNode(selfTypeNode)) {
            if (ts.isIdentifier(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName);
            } else if (ts.isQualifiedName(selfTypeNode.typeName)) {
              actualName = ts.idText(selfTypeNode.typeName.right);
            }
          }
          const expectedName = ts.idText(className);
          if (actualName !== expectedName) {
            report({
              location: selfTypeNode,
              messageText: `Self type parameter should be '${expectedName}'`,
              fixes: [{
                fixName: "classSelfMismatch_fix",
                description: `Replace '${actualName}' with '${expectedName}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const typeArgs = ts.isTypeReferenceNode(selfTypeNode) ? selfTypeNode.typeArguments : void 0;
                  const newTypeReference = ts.factory.createTypeReferenceNode(
                    ts.factory.createIdentifier(expectedName),
                    typeArgs
                  );
                  changeTracker.replaceNode(sourceFile, selfTypeNode, newTypeReference);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/core/KeyBuilder.ts
var makeKeyBuilder = fn("KeyBuilder")(
  function* (sourceFile) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const program = yield* service(TypeScriptProgram);
    const options = yield* service(LanguageServicePluginOptions);
    const packageInfo = tsUtils.resolveModuleWithPackageInfoFromSourceFile(program, sourceFile);
    function createString2(classNameText, kind) {
      if (!packageInfo) return;
      for (const keyPattern of options.keyPatterns) {
        if (keyPattern.target !== kind) continue;
        const lastIndex = sourceFile.fileName.lastIndexOf("/");
        let onlyFileName = lastIndex === -1 ? "" : sourceFile.fileName.slice(lastIndex + 1);
        const lastExtensionIndex = onlyFileName.lastIndexOf(".");
        if (lastExtensionIndex !== -1) onlyFileName = onlyFileName.slice(0, lastExtensionIndex);
        if (onlyFileName.toLowerCase().endsWith("/index")) onlyFileName = onlyFileName.slice(0, -6);
        if (onlyFileName.startsWith("/")) onlyFileName = onlyFileName.slice(1);
        let subDirectory = getDirectoryPath(ts, sourceFile.fileName);
        if (!subDirectory.startsWith(packageInfo.packageDirectory)) continue;
        subDirectory = subDirectory.slice(packageInfo.packageDirectory.length);
        if (!subDirectory.endsWith("/")) subDirectory = subDirectory + "/";
        if (subDirectory.startsWith("/")) subDirectory = subDirectory.slice(1);
        for (const prefix of keyPattern.skipLeadingPath) {
          if (subDirectory.startsWith(prefix)) {
            subDirectory = subDirectory.slice(prefix.length);
            break;
          }
        }
        let parts = [packageInfo.name, subDirectory, onlyFileName].concat(
          onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
        );
        if (keyPattern.pattern === "package-identifier") {
          parts = [packageInfo.name, onlyFileName].concat(
            onlyFileName.toLowerCase() === classNameText.toLowerCase() ? [] : [classNameText]
          );
        }
        parts = parts.map((part) => part.startsWith("/") ? part.slice(1) : part).map(
          (part) => part.endsWith("/") ? part.slice(0, -1) : part
        );
        const fullKey = parts.filter((_) => String(_).trim().length > 0).join("/");
        return keyPattern.pattern === "default-hashed" ? cyrb53(fullKey) : fullKey;
      }
    }
    return {
      createString: createString2
    };
  }
);
var keyBuilderCache = /* @__PURE__ */ new Map();
var getOrMakeKeyBuilder = fn("getOrMakeKeyBuilder")(function* (sourceFile) {
  while (keyBuilderCache.size > 5) {
    const oldest = keyBuilderCache.keys().next().value;
    if (oldest) keyBuilderCache.delete(oldest);
  }
  const keyBuilder = keyBuilderCache.get(sourceFile.fileName) || (yield* makeKeyBuilder(sourceFile));
  keyBuilderCache.set(sourceFile.fileName, keyBuilder);
  return keyBuilder;
});
function createString(sourceFile, identifier, kind) {
  return map4(
    getOrMakeKeyBuilder(sourceFile),
    (identifierBuilder) => identifierBuilder.createString(identifier, kind)
  );
}

// src/diagnostics/deterministicKeys.ts
var deterministicKeys = createDiagnostic({
  name: "deterministicKeys",
  code: 25,
  severity: "off",
  apply: fn("deterministicKeys.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeScriptUtils = yield* service(TypeScriptUtils);
    const options = yield* service(LanguageServicePluginOptions);
    const parseExtendsCustom = cachedBy(
      fn("parseExtendsCustom")(function* (classDeclaration) {
        if (!options.extendedKeyDetection) {
          return yield* typeParserIssue("Extended key detection is disabled", void 0, classDeclaration);
        }
        if (!classDeclaration.name) {
          return yield* typeParserIssue("Class has no name", void 0, classDeclaration);
        }
        if (!ts.isIdentifier(classDeclaration.name)) {
          return yield* typeParserIssue("Class name is not an identifier", void 0, classDeclaration);
        }
        const heritageClauses = classDeclaration.heritageClauses;
        if (!heritageClauses) {
          return yield* typeParserIssue("Class has no heritage clauses", void 0, classDeclaration);
        }
        const nodeToVisit2 = [...classDeclaration.heritageClauses];
        const appendNodeToVisit2 = (node) => {
          nodeToVisit2.push(node);
          return void 0;
        };
        while (nodeToVisit2.length > 0) {
          const node = nodeToVisit2.shift();
          if (ts.isCallExpression(node)) {
            for (let i = 0; i < node.arguments.length; i++) {
              const arg = node.arguments[i];
              if (!ts.isStringLiteral(arg)) continue;
              const resolvedSignature = typeChecker.getResolvedSignature(node);
              if (resolvedSignature) {
                const parameter = resolvedSignature.parameters[i];
                if (!parameter) continue;
                if (parameter.declarations) {
                  for (const declaration of parameter.declarations) {
                    const parameterSourceFile = typeScriptUtils.getSourceFileOfNode(declaration);
                    const paramText = parameterSourceFile.text.substring(declaration.pos, declaration.end);
                    if (paramText.toLowerCase().includes("@effect-identifier")) {
                      return { className: classDeclaration.name, keyStringLiteral: arg, target: "custom" };
                    }
                  }
                }
              }
            }
          }
          ts.forEachChild(node, appendNodeToVisit2);
        }
        return yield* typeParserIssue(
          "Class does not extend any custom pattern",
          void 0,
          classDeclaration
        );
      }),
      "deterministicKeys.parseExtendsCustom",
      (classDeclaration) => classDeclaration
    );
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const result = yield* pipe(
          pipe(
            typeParser.extendsEffectService(node),
            orElse2(() => typeParser.extendsContextTag(node)),
            orElse2(() => typeParser.extendsEffectTag(node)),
            map4(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "service" }))
          ),
          orElse2(
            () => pipe(
              typeParser.extendsDataTaggedError(node),
              orElse2(() => typeParser.extendsSchemaTaggedError(node)),
              map4(({ className, keyStringLiteral }) => ({ keyStringLiteral, className, target: "error" }))
            )
          ),
          orElse2(() => parseExtendsCustom(node)),
          orElse2(() => void_)
        );
        if (result && result.keyStringLiteral) {
          const { className, keyStringLiteral, target } = result;
          const classNameText = ts.idText(className);
          const expectedKey = yield* createString(sourceFile, classNameText, target);
          if (!expectedKey) continue;
          const actualIdentifier = keyStringLiteral.text;
          if (actualIdentifier !== expectedKey) {
            report({
              location: keyStringLiteral,
              messageText: `Key should be '${expectedKey}'`,
              fixes: [{
                fixName: "deterministicKeys_fix",
                description: `Replace '${actualIdentifier}' with '${expectedKey}'`,
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const newStringLiteral = ts.factory.createStringLiteral(expectedKey);
                  changeTracker.replaceNode(sourceFile, keyStringLiteral, newStringLiteral);
                })
              }]
            });
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/duplicatePackage.ts
var checkedPackagesCache = /* @__PURE__ */ new Map();
var programResolvedCacheSize = /* @__PURE__ */ new Map();
var duplicatePackage = createDiagnostic({
  name: "duplicatePackage",
  code: 6,
  severity: "warning",
  apply: fn("duplicatePackage.apply")(function* (sourceFile, report) {
    const program = yield* service(TypeScriptProgram);
    const tsUtils = yield* service(TypeScriptUtils);
    const options = yield* service(LanguageServicePluginOptions);
    if (sourceFile.statements.length < 1) return;
    let resolvedPackages = checkedPackagesCache.get(sourceFile.fileName) || {};
    const newResolvedModuleSize = hasProperty(program, "resolvedModules") && hasProperty(program.resolvedModules, "size") && isNumber(program.resolvedModules.size) ? program.resolvedModules.size : 0;
    const oldResolvedSize = programResolvedCacheSize.get(sourceFile.fileName) || -1;
    if (newResolvedModuleSize !== oldResolvedSize) {
      const seenPackages = /* @__PURE__ */ new Set();
      resolvedPackages = {};
      program.getSourceFiles().map((_) => {
        const packageInfo = tsUtils.parsePackageContentNameAndVersionFromScope(_);
        if (!packageInfo) return;
        const packageNameAndVersion = packageInfo.name + "@" + packageInfo.version;
        if (seenPackages.has(packageNameAndVersion)) return;
        seenPackages.add(packageNameAndVersion);
        if (!(packageInfo.name === "effect" || packageInfo.hasEffectInPeerDependencies)) return;
        if (options.allowedDuplicatedPackages.indexOf(packageInfo.name) > -1) return;
        resolvedPackages[packageInfo.name] = resolvedPackages[packageInfo.name] || {};
        resolvedPackages[packageInfo.name][packageInfo.version] = packageInfo.packageDirectory;
      });
      checkedPackagesCache.set(sourceFile.fileName, resolvedPackages);
      programResolvedCacheSize.set(sourceFile.fileName, newResolvedModuleSize);
    }
    for (const packageName of Object.keys(resolvedPackages)) {
      if (Object.keys(resolvedPackages[packageName]).length > 1) {
        const versions = Object.keys(resolvedPackages[packageName]);
        report({
          location: sourceFile.statements[0],
          messageText: `Package ${packageName} is referenced multiple times with different versions (${versions.join(", ")}) and may cause unexpected type errors.
Cleanup your dependencies and your package lockfile to avoid multiple instances of this package and reload the project.
If this is intended set the LSP config "allowedDuplicatedPackages" to ${JSON.stringify(options.allowedDuplicatedPackages.concat([packageName]))}.

${versions.map((version) => `- found ${version} at ${resolvedPackages[packageName][version]}`).join("\n")}`,
          fixes: []
        });
      }
    }
  })
});

// src/diagnostics/effectGenUsesAdapter.ts
var effectGenUsesAdapter = createDiagnostic({
  name: "effectGenUsesAdapter",
  code: 23,
  severity: "warning",
  apply: fn("effectGenUsesAdapter.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.effectGen(node),
          map4(({ generatorFunction }) => {
            if (generatorFunction.parameters.length > 0) {
              const adapter = generatorFunction.parameters[0];
              report({
                location: adapter,
                messageText: `The adapter of Effect.gen is not required anymore, it is now just an alias of pipe.`,
                fixes: []
              });
            }
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/effectInVoidSuccess.ts
var effectInVoidSuccess = createDiagnostic({
  name: "effectInVoidSuccess",
  code: 14,
  severity: "warning",
  apply: fn("effectInVoidSuccess.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForEffectInVoid = fn("effectInVoidSuccess.checkForEffectInVoid")(function* (node, expectedType, valueNode, realType) {
      const expectedEffect = yield* typeParser.effectType(expectedType, node);
      const realEffect = yield* typeParser.effectType(realType, valueNode);
      if (expectedEffect.A.flags & ts.TypeFlags.Void) {
        const voidValueTypes = typeCheckerUtils.unrollUnionMembers(realEffect.A);
        const voidedEffect = yield* firstSuccessOf(
          voidValueTypes.map((_) => map4(typeParser.strictEffectType(_, node), () => _))
        );
        return { voidedEffect };
      }
      return yield* fail(typeParserIssue("expectedEffect success is not void"));
    });
    const entries = typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForEffectInVoid(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map4(({ voidedEffect }) => {
            report(
              {
                location: node,
                messageText: `There is a nested '${typeChecker.typeToString(voidedEffect)}' in the 'void' success channel, beware that this could lead to nested Effect<Effect<...>> that won't be executed.`,
                fixes: []
              }
            );
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/floatingEffect.ts
var floatingEffect = createDiagnostic({
  name: "floatingEffect",
  code: 3,
  severity: "error",
  apply: fn("floatingEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    function isFloatingExpression(node) {
      if (!ts.isExpressionStatement(node)) return false;
      if (!(ts.isBlock(node.parent) || ts.isSourceFile(node.parent))) return false;
      const expression = node.expression;
      if (ts.isBinaryExpression(expression) && expression.operatorToken && (expression.operatorToken.kind === ts.SyntaxKind.EqualsToken || expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandEqualsToken || expression.operatorToken.kind === ts.SyntaxKind.BarBarEqualsToken)) return false;
      return true;
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (!isFloatingExpression(node)) continue;
      const type = typeChecker.getTypeAtLocation(node.expression);
      const effect = yield* option(typeParser.effectType(type, node.expression));
      if (isSome2(effect)) {
        const allowedFloatingEffects = yield* pipe(
          typeParser.fiberType(type, node.expression),
          orElse2(() => typeParser.effectSubtype(type, node.expression)),
          option
        );
        if (isNone2(allowedFloatingEffects)) {
          const isStrictEffect = yield* option(typeParser.strictEffectType(type, node.expression));
          const name = isSome2(isStrictEffect) ? "Effect" : "Effect-able " + typeChecker.typeToString(type);
          report({
            location: node,
            messageText: `${name} must be yielded or assigned to a variable.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/genericEffectServices.ts
var genericEffectServices = createDiagnostic({
  name: "genericEffectServices",
  code: 10,
  severity: "warning",
  apply: fn("genericEffectServices.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isClassDeclaration(node) && node.name && node.typeParameters && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type, node),
          map4(() => {
            report({
              location: reportAt,
              messageText: `Effect Services with type parameters are not supported because they cannot be properly discriminated at runtime, which may cause unexpected behavior.`,
              fixes: []
            });
          }),
          orElse2(() => sync(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/importFromBarrel.ts
var importFromBarrel = createDiagnostic({
  name: "importFromBarrel",
  code: 12,
  severity: "off",
  apply: fn("importFromBarrel.apply")(function* (sourceFile, report) {
    const languageServicePluginOptions = yield* service(LanguageServicePluginOptions);
    if (languageServicePluginOptions.namespaceImportPackages.length === 0) return;
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const program = yield* service(TypeScriptProgram);
    const getModuleSpecifier = makeGetModuleSpecifier(ts);
    const resolveExternalModuleName = makeResolveExternalModuleName(typeChecker);
    const packageNamesToCheck = flatten(
      languageServicePluginOptions.namespaceImportPackages.map(
        (packageName) => tsUtils.resolveModulePattern(program, sourceFile, packageName)
      )
    );
    const isImportedFromBarrelExport = (element) => {
      if (!(getModuleSpecifier && resolveExternalModuleName)) return;
      const importDeclaration = ts.findAncestor(element, (node) => ts.isImportDeclaration(node));
      if (!importDeclaration) return;
      if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) return;
      const importClause = importDeclaration.importClause;
      if (!importClause) return;
      const namedBindings = importClause.namedBindings;
      if (!namedBindings) return;
      if (!ts.isNamedImports(namedBindings)) return;
      const barrelModuleName = importDeclaration.moduleSpecifier.text;
      if (packageNamesToCheck.indexOf(barrelModuleName.toLowerCase()) === -1) return;
      const moduleSymbol = resolveExternalModuleName(importDeclaration.moduleSpecifier);
      if (!moduleSymbol) return;
      if (!moduleSymbol.exports) return;
      const sourceFile2 = tsUtils.getSourceFileOfNode(importDeclaration);
      if (!sourceFile2) return;
      const nodeForSymbol = element.propertyName || element.name;
      const aliasSymbol = element.name || element.propertyName;
      const aliasedName = ts.idText(aliasSymbol);
      if (!ts.isIdentifier(nodeForSymbol)) return;
      const importedName = ts.idText(nodeForSymbol);
      if (!importedName) return;
      const reexportedSymbol = moduleSymbol.exports.get(ts.escapeLeadingUnderscores(importedName));
      if (!reexportedSymbol) return;
      if (!(reexportedSymbol.declarations && reexportedSymbol.declarations.length === 1)) return;
      const namespaceExport = reexportedSymbol.declarations[0];
      if (!ts.isNamespaceExport(namespaceExport)) return;
      const exportDeclaration = namespaceExport.parent;
      if (!ts.isExportDeclaration(exportDeclaration)) return;
      if (!exportDeclaration.moduleSpecifier) return;
      const originalModuleSymbol = resolveExternalModuleName(exportDeclaration.moduleSpecifier);
      if (!originalModuleSymbol) return;
      if (!originalModuleSymbol.valueDeclaration) return;
      const originalSourceFile = tsUtils.getSourceFileOfNode(originalModuleSymbol.valueDeclaration);
      if (!originalSourceFile) return;
      const unbarrelledFileName = getModuleSpecifier(
        program.getCompilerOptions(),
        sourceFile2,
        sourceFile2.fileName,
        originalSourceFile.fileName,
        program
      );
      if (unbarrelledFileName.toLowerCase().indexOf(barrelModuleName.toLowerCase() + "/") === -1) return;
      return {
        unbarrelledFileName,
        importedName,
        barrelModuleName,
        importClause,
        namedBindings,
        importDeclaration,
        aliasedName
      };
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const parent = node.parent;
      if (!(ts.isImportSpecifier(node) && ts.isNamedImports(parent))) {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      const result = isImportedFromBarrelExport(node);
      if (!result) continue;
      const {
        aliasedName,
        barrelModuleName,
        importClause,
        importDeclaration,
        namedBindings,
        unbarrelledFileName
      } = result;
      report({
        location: node,
        messageText: `Importing from barrel module ${barrelModuleName} is not allowed.`,
        fixes: [
          {
            fixName: "replaceWithUnbarrelledImport",
            description: `Import * as ${aliasedName} from ${unbarrelledFileName}`,
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              const newImport = ts.factory.createImportDeclaration(
                void 0,
                ts.factory.createImportClause(
                  importClause.isTypeOnly || node.isTypeOnly,
                  void 0,
                  ts.factory.createNamespaceImport(ts.factory.createIdentifier(aliasedName))
                ),
                ts.factory.createStringLiteral(unbarrelledFileName)
              );
              if (namedBindings.elements.length === 1) {
                changeTracker.replaceNode(
                  sourceFile,
                  importDeclaration,
                  newImport
                );
              } else {
                changeTracker.insertNodeAfter(sourceFile, importDeclaration, newImport);
                changeTracker.replaceNode(
                  sourceFile,
                  namedBindings,
                  ts.factory.updateNamedImports(
                    namedBindings,
                    namedBindings.elements.filter((e) => e !== node)
                  )
                );
              }
            })
          }
        ]
      });
    }
  })
});

// src/diagnostics/leakingRequirements.ts
var leakingRequirements = createDiagnostic({
  name: "leakingRequirements",
  code: 8,
  severity: "suggestion",
  apply: fn("leakingRequirements.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const parseLeakedRequirements = cachedBy(
      fn("leakingServices.checkServiceLeaking")(
        function* (service2, atLocation) {
          const properties = typeChecker.getPropertiesOfType(service2);
          if (properties.length < 1) return [];
          const memory = /* @__PURE__ */ new Map();
          let sharedRequirementsKeys = void 0;
          let effectMembers = 0;
          for (const property of properties) {
            const servicePropertyType = typeChecker.getTypeOfSymbolAtLocation(property, atLocation);
            let effectContextType = void 0;
            yield* pipe(
              typeParser.effectType(servicePropertyType, atLocation),
              map4((_) => effectContextType = _.R),
              orElse2(() => {
                const servicePropertyCallSignatures = typeChecker.getSignaturesOfType(
                  servicePropertyType,
                  ts.SignatureKind.Call
                );
                if (servicePropertyCallSignatures.length === 1) {
                  return pipe(
                    typeParser.effectType(
                      typeChecker.getReturnTypeOfSignature(servicePropertyCallSignatures[0]),
                      atLocation
                    ),
                    map4((_) => {
                      effectContextType = _.R;
                    })
                  );
                }
                return void_;
              }),
              ignore
            );
            if (effectContextType) {
              effectMembers++;
              const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                memory,
                effectContextType,
                (type) => {
                  if (type.flags & ts.TypeFlags.Never) return succeed(true);
                  return pipe(
                    typeParser.scopeType(type, atLocation),
                    map4(() => true),
                    orElse2(() => succeed(false))
                  );
                }
              );
              if (!sharedRequirementsKeys) {
                sharedRequirementsKeys = allIndexes;
              } else {
                sharedRequirementsKeys = intersection(sharedRequirementsKeys, allIndexes);
                if (sharedRequirementsKeys.length === 0) return [];
              }
            }
          }
          if (sharedRequirementsKeys && sharedRequirementsKeys.length > 0 && effectMembers >= 2) {
            return sharedRequirementsKeys.map((key) => memory.get(key)).filter(
              (type) => {
                let symbol3 = type.symbol;
                if (symbol3 && symbol3.flags & ts.SymbolFlags.Alias) {
                  symbol3 = typeChecker.getAliasedSymbol(symbol3);
                }
                return !(symbol3.declarations || []).some((declaration) => {
                  const declarationSource = tsUtils.getSourceFileOfNode(declaration);
                  if (!declarationSource) return false;
                  return declarationSource.text.substring(declaration.pos, declaration.end).toLowerCase().indexOf(
                    "@effect-leakable-service"
                  ) > -1;
                });
              }
            );
          }
          return [];
        }
      ),
      "leakingServices.checkServiceLeaking",
      (_, service2) => service2
    );
    function reportLeakingRequirements(node, requirements) {
      if (requirements.length === 0) return;
      report({
        location: node,
        messageText: `This Service is leaking the ${requirements.map((_) => typeChecker.typeToString(_)).join(" | ")} requirement.
If these requirements cannot be cached and are expected to be provided per method invocation (e.g. HttpServerRequest), you can either safely disable this diagnostic for this line through quickfixes or mark the service declaration with a JSDoc @effect-leakable-service.
More info at https://effect.website/docs/requirements-management/layers/#avoiding-requirement-leakage`,
        fixes: []
      });
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const typesToCheck = [];
      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) && ts.idText(node.expression.name) === "GenericTag") {
        typesToCheck.push([typeChecker.getTypeAtLocation(node), node]);
      } else if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const type = typeChecker.getTypeOfSymbol(classSym);
          typesToCheck.push([type, node.name]);
        }
      } else {
        ts.forEachChild(node, appendNodeToVisit);
        continue;
      }
      for (const [type, reportAt] of typesToCheck) {
        yield* pipe(
          typeParser.contextTag(type, node),
          flatMap2(
            ({ Service }) => pipe(
              parseLeakedRequirements(Service, node),
              map4(
                (requirements) => reportLeakingRequirements(reportAt, sort(requirements, typeCheckerUtils.deterministicTypeOrder))
              )
            )
          ),
          orElse2(() => sync(() => ts.forEachChild(node, appendNodeToVisit))),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missedPipeableOpportunity.ts
var missedPipeableOpportunity = createDiagnostic({
  name: "missedPipeableOpportunity",
  code: 26,
  severity: "off",
  apply: fn("missedPipeableOpportunity.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const options = yield* service(LanguageServicePluginOptions);
    const nodeToVisit = [sourceFile];
    const prependNodeToVisit = (node) => {
      nodeToVisit.unshift(node);
      return void 0;
    };
    const callChainNodes = /* @__PURE__ */ new WeakMap();
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isCallExpression(node) && node.arguments.length === 1 && node.parent) {
        const parentChain = callChainNodes.get(node.parent) || [];
        callChainNodes.set(node, parentChain.concat(node));
      } else if (node.parent && callChainNodes.has(node.parent) && ts.isExpression(node)) {
        const parentChain = callChainNodes.get(node.parent) || [];
        const originalParentChain = parentChain.slice();
        parentChain.push(node);
        while (parentChain.length > options.pipeableMinArgCount) {
          const subject = parentChain.pop();
          const resultType = typeChecker.getTypeAtLocation(subject);
          const pipeableType = yield* pipe(typeParser.pipeableType(resultType, subject), orElse2(() => void_));
          if (pipeableType) {
            report({
              location: parentChain[0],
              messageText: `Nested function calls can be converted to pipeable style for better readability.`,
              fixes: [{
                fixName: "missedPipeableOpportunity_fix",
                description: "Convert to pipe style",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  changeTracker.replaceNode(
                    sourceFile,
                    parentChain[0],
                    ts.factory.createCallExpression(
                      ts.factory.createPropertyAccessExpression(
                        subject,
                        "pipe"
                      ),
                      void 0,
                      pipe(
                        parentChain,
                        filter(ts.isCallExpression),
                        map3((call) => call.expression),
                        reverse
                      )
                    )
                  );
                })
              }]
            });
            originalParentChain.forEach((node2) => callChainNodes.delete(node2));
            break;
          }
        }
      }
      ts.forEachChild(node, prependNodeToVisit);
    }
  })
});

// src/diagnostics/missingEffectContext.ts
var missingEffectContext = createDiagnostic({
  name: "missingEffectContext",
  code: 1,
  severity: "error",
  apply: fn("missingEffectContext.apply")(function* (sourceFile, report) {
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const checkForMissingContextTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map4(
        ([expectedEffect, realEffect]) => typeCheckerUtils.getMissingTypeEntriesInTargetType(
          realEffect.R,
          expectedEffect.R
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingContextTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map4(
            (missingTypes) => missingTypes.length > 0 ? report(
              {
                location: node,
                messageText: `Missing '${sortTypes(missingTypes).map((_) => typeChecker.typeToString(_)).join(" | ")}' in the expected Effect context.`,
                fixes: []
              }
            ) : void 0
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingEffectError.ts
var missingEffectError = createDiagnostic({
  name: "missingEffectError",
  code: 1,
  severity: "error",
  apply: fn("missingEffectError.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const createDieMessage = (message) => ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectModuleIdentifier),
        "dieMessage"
      ),
      void 0,
      [ts.factory.createStringLiteral(message)]
    );
    const checkForMissingErrorTypes = (node, expectedType, valueNode, realType) => pipe(
      all(
        typeParser.effectType(expectedType, node),
        typeParser.effectType(realType, valueNode)
      ),
      map4(
        ([expectedEffect, realEffect]) => pipe(
          typeCheckerUtils.getMissingTypeEntriesInTargetType(
            realEffect.E,
            expectedEffect.E
          ),
          (missingErrorTypes) => ({ missingErrorTypes, expectedErrorType: expectedEffect.E })
        )
      )
    );
    const sortTypes = sort(typeCheckerUtils.deterministicTypeOrder);
    const entries = getEffectLspPatchSourceFileMetadata(sourceFile)?.relationErrors || typeCheckerUtils.expectedAndRealType(sourceFile);
    for (const [node, expectedType, valueNode, realType] of entries) {
      if (expectedType !== realType) {
        yield* pipe(
          checkForMissingErrorTypes(
            node,
            expectedType,
            valueNode,
            realType
          ),
          map4((result) => {
            if (result.missingErrorTypes.length === 0) return;
            const fixes = [];
            if (ts.isExpression(valueNode) && result.expectedErrorType.flags & ts.TypeFlags.Never) {
              fixes.push({
                fixName: "missingEffectError_catchAll",
                description: "Catch all errors with Effect.catchAll",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  changeTracker.insertText(
                    sourceFile,
                    ts.getTokenPosOfNode(valueNode, sourceFile),
                    effectModuleIdentifier + ".catchAll("
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ", () => ");
                  changeTracker.insertNodeAt(
                    sourceFile,
                    valueNode.end,
                    createDieMessage("TODO: catchAll not implemented")
                  );
                  changeTracker.insertText(sourceFile, valueNode.end, ")");
                })
              });
            }
            if (ts.isExpression(valueNode)) {
              const propertyAssignments = pipe(
                result.missingErrorTypes,
                map3((_) => typeChecker.getPropertyOfType(_, "_tag")),
                filter((_) => !!_),
                map3((_) => typeChecker.getTypeOfSymbolAtLocation(_, valueNode)),
                filter((_) => !!(_.flags & ts.TypeFlags.Literal)),
                map3((_) => typeChecker.typeToTypeNode(_, void 0, ts.NodeBuilderFlags.NoTruncation)),
                filter((_) => !!_ && ts.isLiteralTypeNode(_)),
                map3((_) => _.literal),
                filter((_) => ts.isLiteralExpression(_)),
                map3((_) => _.text),
                sort(string2),
                map3(
                  (_) => ts.factory.createPropertyAssignment(
                    ts.factory.createIdentifier(_),
                    ts.factory.createArrowFunction(
                      void 0,
                      void 0,
                      [],
                      void 0,
                      void 0,
                      createDieMessage(`TODO: catchTags() not implemented for ${_}`)
                    )
                  )
                )
              );
              if (propertyAssignments.length === result.missingErrorTypes.length) {
                fixes.push({
                  fixName: "missingEffectError_tagged",
                  description: "Catch unexpected errors with Effect.catchTag",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.insertText(
                      sourceFile,
                      ts.getTokenPosOfNode(valueNode, sourceFile),
                      effectModuleIdentifier + ".catchTags("
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ", ");
                    changeTracker.insertNodeAt(
                      sourceFile,
                      valueNode.end,
                      ts.factory.createObjectLiteralExpression(propertyAssignments)
                    );
                    changeTracker.insertText(sourceFile, valueNode.end, ")");
                  })
                });
              }
            }
            const typeNames = sortTypes(result.missingErrorTypes).map((_) => typeChecker.typeToString(_));
            report(
              {
                location: node,
                messageText: `Missing '${typeNames.join(" | ")}' in the expected Effect errors.`,
                fixes
              }
            );
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/missingEffectServiceDependency.ts
var missingEffectServiceDependency = createDiagnostic({
  name: "missingEffectServiceDependency",
  code: 22,
  severity: "off",
  apply: fn("missingEffectServiceDependency.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => void_)
        );
        if (serviceResult) {
          const { className, options } = serviceResult;
          const classSymbol = typeChecker.getSymbolAtLocation(className);
          if (classSymbol) {
            const classType = typeChecker.getTypeOfSymbol(classSymbol);
            const defaultWithoutDepsProperty = typeChecker.getPropertyOfType(classType, "DefaultWithoutDependencies");
            const defaultProperty = defaultWithoutDepsProperty || typeChecker.getPropertyOfType(classType, "Default");
            if (defaultProperty) {
              const defaultType = typeChecker.getTypeOfSymbolAtLocation(defaultProperty, node);
              const layerResult = yield* pipe(
                typeParser.layerType(defaultType, node),
                orElse2(() => void_)
              );
              if (layerResult) {
                const servicesMemory = /* @__PURE__ */ new Map();
                const excludeNever = (type) => succeed((type.flags & ts.TypeFlags.Never) !== 0);
                const { allIndexes: requiredIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                  servicesMemory,
                  layerResult.RIn,
                  excludeNever
                );
                const providedIndexes = /* @__PURE__ */ new Set();
                const optionsType = typeChecker.getTypeAtLocation(options);
                const dependenciesProperty = typeChecker.getPropertyOfType(optionsType, "dependencies");
                let types = [];
                if (dependenciesProperty) {
                  const dependenciesTypes = typeChecker.getTypeOfSymbolAtLocation(dependenciesProperty, options);
                  const numberIndexType = typeChecker.getIndexTypeOfType(dependenciesTypes, ts.IndexKind.Number);
                  types = numberIndexType ? typeCheckerUtils.unrollUnionMembers(numberIndexType) : [];
                }
                for (const depType of types) {
                  const depLayerResult = yield* pipe(
                    typeParser.layerType(depType, options),
                    orElse2(() => void_)
                  );
                  if (depLayerResult) {
                    const { allIndexes } = yield* typeCheckerUtils.appendToUniqueTypesMap(
                      servicesMemory,
                      depLayerResult.ROut,
                      excludeNever
                    );
                    for (const index of allIndexes) {
                      providedIndexes.add(index);
                    }
                  }
                }
                const missingIndexes = requiredIndexes.filter((index) => !providedIndexes.has(index));
                if (missingIndexes.length > 0) {
                  const missingTypes = missingIndexes.map((index) => servicesMemory.get(index));
                  const missingTypeNames = missingTypes.map((t) => typeChecker.typeToString(t));
                  const message = missingTypeNames.length === 1 ? `Service '${missingTypeNames[0]}' is required but not provided by dependencies` : `Services ${missingTypeNames.map((s) => `'${s}'`).join(", ")} are required but not provided by dependencies`;
                  report({
                    location: className,
                    messageText: message,
                    fixes: []
                  });
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/missingReturnYieldStar.ts
var missingReturnYieldStar = createDiagnostic({
  name: "missingReturnYieldStar",
  code: 7,
  severity: "error",
  apply: fn("missingReturnYieldStar.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken) {
        const type = typeChecker.getTypeAtLocation(node.expression);
        const maybeEffect = yield* option(typeParser.effectType(type, node.expression));
        if (isSome2(maybeEffect) && maybeEffect.value.A.flags & ts.TypeFlags.Never) {
          const generatorFunctionOrReturnStatement = ts.findAncestor(
            node,
            (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isReturnStatement(_) || ts.isThrowStatement(_)
          );
          if (generatorFunctionOrReturnStatement && !ts.isReturnStatement(generatorFunctionOrReturnStatement) && !ts.isThrowStatement(generatorFunctionOrReturnStatement)) {
            if (generatorFunctionOrReturnStatement && generatorFunctionOrReturnStatement.parent) {
              const effectGenNode = generatorFunctionOrReturnStatement.parent;
              const effectGenLike = yield* pipe(
                typeParser.effectGen(effectGenNode),
                orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
                orElse2(() => typeParser.effectFnGen(effectGenNode)),
                option
              );
              if (isSome2(effectGenLike)) {
                const fix = node.expression ? [{
                  fixName: "missingReturnYieldStar_fix",
                  description: "Add return statement",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.replaceNode(
                      sourceFile,
                      node,
                      ts.factory.createReturnStatement(
                        node
                      )
                    );
                  })
                }] : [];
                report({
                  location: node,
                  messageText: `It is recommended to use return yield* for Effects that never succeed to signal a definitive exit point for type narrowing and tooling support.`,
                  fixes: fix
                });
              }
            }
          }
        }
      }
    }
  })
});

// src/diagnostics/missingStarInYieldEffectGen.ts
var missingStarInYieldEffectGen = createDiagnostic({
  name: "missingStarInYieldEffectGen",
  code: 4,
  severity: "error",
  apply: fn("missingStarInYieldEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const tsUtils = yield* service(TypeScriptUtils);
    const brokenGenerators = /* @__PURE__ */ new Set();
    const brokenYields = /* @__PURE__ */ new Set();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isYieldExpression(node) && node.expression && node.asteriskToken === void 0) {
        const functionStarNode = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_)
        );
        if (functionStarNode && functionStarNode.parent) {
          const effectGenNode = functionStarNode.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse2(() => typeParser.effectFnGen(effectGenNode)),
            map4(({ generatorFunction }) => {
              if (generatorFunction) {
                brokenGenerators.add(ts.getTokenPosOfNode(generatorFunction, tsUtils.getSourceFileOfNode(node)));
              }
              brokenYields.add(node);
            }),
            ignore
          );
        }
      }
    }
    brokenGenerators.forEach(
      (pos) => report({
        location: { pos, end: pos + "function".length },
        messageText: `Seems like you used yield instead of yield* inside this Effect.gen.`,
        fixes: []
      })
    );
    brokenYields.forEach((node) => {
      const fix = node.expression ? [{
        fixName: "missingStarInYieldEffectGen_fix",
        description: "Replace yield with yield*",
        apply: gen(function* () {
          const changeTracker = yield* service(ChangeTracker);
          changeTracker.replaceNode(
            sourceFile,
            node,
            ts.factory.createYieldExpression(
              ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
              node.expression
            )
          );
        })
      }] : [];
      report({
        location: node,
        messageText: `When yielding Effects inside Effect.gen, you should use yield* instead of yield.`,
        fixes: fix
      });
    });
  })
});

// src/diagnostics/multipleEffectProvide.ts
var multipleEffectProvide = createDiagnostic({
  name: "multipleEffectProvide",
  code: 18,
  severity: "warning",
  apply: fn("multipleEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const effectModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Effect"
    ) || "Effect";
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    const parseEffectProvideLayer = (node) => {
      if (ts.isCallExpression(node) && node.arguments.length > 0) {
        const layer = node.arguments[0];
        const type = typeChecker.getTypeAtLocation(layer);
        return pipe(
          typeParser.isNodeReferenceToEffectModuleApi("provide")(node.expression),
          flatMap2(() => typeParser.layerType(type, layer)),
          map4(() => ({ layer, node })),
          orElse2(() => void_)
        );
      }
      return void_;
    };
    const parsePipeCall = (node) => gen(function* () {
      const { args: args2 } = yield* typeParser.pipeCall(node);
      let currentChunk = 0;
      const previousLayers = [[]];
      for (const pipeArg of args2) {
        const parsedProvide = yield* parseEffectProvideLayer(pipeArg);
        if (parsedProvide) {
          previousLayers[currentChunk].push(parsedProvide);
        } else {
          currentChunk++;
          previousLayers.push([]);
        }
      }
      for (const chunk of previousLayers) {
        if (chunk.length < 2) continue;
        report({
          location: chunk[0].node,
          messageText: "Avoid chaining Effect.provide calls, as this can lead to service lifecycle issues. Instead, merge layers and provide them in a single call.",
          fixes: [{
            fixName: "multipleEffectProvide_fix",
            description: "Combine into a single provide",
            apply: gen(function* () {
              const changeTracker = yield* service(ChangeTracker);
              changeTracker.deleteRange(sourceFile, {
                pos: ts.getTokenPosOfNode(chunk[0].node, sourceFile),
                end: chunk[chunk.length - 1].node.end
              });
              const newNode = ts.factory.createCallExpression(
                ts.factory.createPropertyAccessExpression(
                  ts.factory.createIdentifier(effectModuleIdentifier),
                  ts.factory.createIdentifier("provide")
                ),
                void 0,
                [ts.factory.createCallExpression(
                  ts.factory.createPropertyAccessExpression(
                    ts.factory.createIdentifier(layerModuleIdentifier),
                    ts.factory.createIdentifier("mergeAll")
                  ),
                  void 0,
                  chunk.map((c) => c.layer)
                )]
              );
              changeTracker.insertNodeAt(sourceFile, ts.getTokenPosOfNode(chunk[0].node, sourceFile), newNode);
            })
          }]
        });
      }
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(parsePipeCall(node), ignore);
      }
    }
  })
});

// src/diagnostics/nonObjectEffectServiceType.ts
var nonObjectEffectServiceType = createDiagnostic({
  name: "nonObjectEffectServiceType",
  code: 24,
  severity: "error",
  apply: fn("nonObjectEffectServiceType.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const typeParser = yield* service(TypeParser);
    function isPrimitiveType(type) {
      return typeCheckerUtils.unrollUnionMembers(type).some(
        (type2) => !!(type2.flags & ts.TypeFlags.String || type2.flags & ts.TypeFlags.Number || type2.flags & ts.TypeFlags.Boolean || type2.flags & ts.TypeFlags.StringLiteral || type2.flags & ts.TypeFlags.NumberLiteral || type2.flags & ts.TypeFlags.BooleanLiteral || type2.flags & ts.TypeFlags.Undefined || type2.flags & ts.TypeFlags.Null)
      );
    }
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const serviceResult = yield* pipe(
          typeParser.extendsEffectService(node),
          orElse2(() => void_)
        );
        if (serviceResult && serviceResult.options && ts.isObjectLiteralExpression(serviceResult.options)) {
          const options = serviceResult.options;
          for (const property of options.properties) {
            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {
              continue;
            }
            const propertyName = ts.idText(property.name);
            const propertyValue = property.initializer;
            const errorToReport = {
              location: property.name,
              messageText: "Effect.Service requires the service type to be an object {} and not a primitive type. \nConsider wrapping the value in an object, or manually using Context.Tag or Effect.Tag if you want to use a primitive instead.",
              fixes: []
            };
            if (propertyName === "succeed") {
              const valueType = typeChecker.getTypeAtLocation(propertyValue);
              if (isPrimitiveType(valueType)) {
                report(errorToReport);
              }
            } else if (propertyName === "sync") {
              const valueType = typeChecker.getTypeAtLocation(propertyValue);
              const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
              for (const signature of signatures) {
                const returnType = typeChecker.getReturnTypeOfSignature(signature);
                if (isPrimitiveType(returnType)) {
                  report(errorToReport);
                  break;
                }
              }
            } else if (propertyName === "effect" || propertyName === "scoped") {
              const valueType = typeChecker.getTypeAtLocation(propertyValue);
              const effectResult = yield* pipe(
                typeParser.effectType(valueType, propertyValue),
                orElse2(() => void_)
              );
              if (effectResult) {
                if (isPrimitiveType(effectResult.A)) {
                  report(errorToReport);
                  continue;
                }
              } else {
                const signatures = typeChecker.getSignaturesOfType(valueType, ts.SignatureKind.Call);
                for (const signature of signatures) {
                  const returnType = typeChecker.getReturnTypeOfSignature(signature);
                  const effectReturnResult = yield* pipe(
                    typeParser.effectType(returnType, propertyValue),
                    orElse2(() => void_)
                  );
                  if (effectReturnResult && isPrimitiveType(effectReturnResult.A)) {
                    report(errorToReport);
                    break;
                  }
                }
              }
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/refactors/writeTagClassAccessors.ts
var generate = fn("writeTagClassAccessors.generate")(function* (sourceFile, service2, className, atLocation, involvedMembers) {
  const ts = yield* service(TypeScriptApi);
  const tsUtils = yield* service(TypeScriptUtils);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const changeTracker = yield* service(ChangeTracker);
  const insertLocation = atLocation.members.length > 0 ? atLocation.members[0].pos : atLocation.end - 1;
  const effectIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
    sourceFile,
    "effect",
    "Effect"
  ) || "Effect";
  const createFunctionProperty = (className2, propertyName, type, forceAny) => {
    const arrowBody = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier(effectIdentifier),
        "andThen"
      ),
      void 0,
      [
        ts.factory.createIdentifier(ts.idText(className2)),
        ts.factory.createArrowFunction(
          void 0,
          void 0,
          [ts.factory.createParameterDeclaration(
            void 0,
            void 0,
            "_",
            void 0,
            forceAny ? ts.factory.createTypeReferenceNode("any") : void 0
          )],
          void 0,
          void 0,
          ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(
              ts.factory.createIdentifier("_"),
              propertyName
            ),
            void 0,
            [
              ts.factory.createSpreadElement(ts.factory.createIdentifier("args"))
            ]
          )
        )
      ]
    );
    return ts.factory.createPropertyDeclaration(
      [
        ts.factory.createModifier(ts.SyntaxKind.StaticKeyword),
        ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword)
      ],
      propertyName,
      void 0,
      type,
      ts.factory.createArrowFunction(
        void 0,
        void 0,
        [ts.factory.createParameterDeclaration(
          void 0,
          ts.factory.createToken(ts.SyntaxKind.DotDotDotToken),
          "args",
          void 0,
          forceAny ? ts.factory.createArrayTypeNode(ts.factory.createTypeReferenceNode("any")) : void 0
        )],
        void 0,
        void 0,
        forceAny ? ts.factory.createAsExpression(arrowBody, ts.factory.createTypeReferenceNode("any")) : arrowBody
      )
    );
  };
  const generateReturnType = (type, atLocation2, className2) => pipe(
    typeParser.effectType(type, atLocation2),
    flatMap2((returnedEffect) => {
      const contextType = returnedEffect.R.flags & ts.TypeFlags.Never ? ts.factory.createTypeReferenceNode(ts.idText(className2)) : ts.factory.createUnionTypeNode(
        [
          ts.factory.createTypeReferenceNode(ts.idText(className2)),
          typeChecker.typeToTypeNode(returnedEffect.R, atLocation2, ts.NodeBuilderFlags.NoTruncation)
        ]
      );
      const successType = typeChecker.typeToTypeNode(
        returnedEffect.A,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!successType) return fail("error generating success type");
      const failureType = typeChecker.typeToTypeNode(
        returnedEffect.E,
        atLocation2,
        ts.NodeBuilderFlags.NoTruncation
      );
      if (!failureType) return fail("error generating failure type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [successType, failureType, contextType]
      );
      return succeed(typeNode);
    }),
    orElse2(
      () => pipe(
        typeParser.promiseLike(type, atLocation2),
        flatMap2(({ type: type2 }) => {
          const successType = typeChecker.typeToTypeNode(
            type2,
            atLocation2,
            ts.NodeBuilderFlags.NoTruncation
          );
          if (!successType) return fail("error generating success type");
          return succeed(ts.factory.createTypeReferenceNode(
            ts.factory.createQualifiedName(
              ts.factory.createIdentifier(effectIdentifier),
              ts.factory.createIdentifier("Effect")
            ),
            [
              successType,
              ts.factory.createTypeReferenceNode(
                ts.factory.createQualifiedName(
                  ts.factory.createIdentifier("Cause"),
                  ts.factory.createIdentifier("UnknownException")
                )
              ),
              ts.factory.createTypeReferenceNode(ts.idText(className2))
            ]
          ));
        })
      )
    ),
    orElse2(() => {
      const successType = typeChecker.typeToTypeNode(type, atLocation2, ts.NodeBuilderFlags.NoTruncation);
      if (!successType) return fail("error generating success type");
      const typeNode = ts.factory.createTypeReferenceNode(
        ts.factory.createQualifiedName(
          ts.factory.createIdentifier(effectIdentifier),
          ts.factory.createIdentifier("Effect")
        ),
        [
          successType,
          ts.factory.createTypeReferenceNode("never"),
          ts.factory.createTypeReferenceNode(ts.idText(className2))
        ]
      );
      return succeed(typeNode);
    })
  );
  const proxySignature = (signature, atLocation2, className2) => gen(function* () {
    const signatureDeclaration = typeChecker.signatureToSignatureDeclaration(
      signature,
      ts.SyntaxKind.FunctionType,
      atLocation2,
      ts.NodeBuilderFlags.NoTruncation
    );
    if (!signatureDeclaration) return yield* fail("error generating signature");
    const returnType = yield* generateReturnType(
      typeChecker.getReturnTypeOfSignature(signature),
      atLocation2,
      className2
    );
    return ts.factory.createFunctionTypeNode(
      signatureDeclaration.typeParameters,
      signatureDeclaration.parameters,
      returnType
    );
  });
  for (const { property, propertyType } of involvedMembers) {
    const callSignatures = [];
    let propertyDeclaration = void 0;
    for (const signature of typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call)) {
      yield* pipe(
        proxySignature(signature, atLocation, className),
        map4((sig) => {
          callSignatures.push(sig);
        }),
        ignore
      );
    }
    const allSignatures = ts.factory.createIntersectionTypeNode(callSignatures);
    const type = tsUtils.simplifyTypeNode(allSignatures);
    propertyDeclaration = createFunctionProperty(className, ts.symbolName(property), type, callSignatures.length > 1);
    const oldProperty = atLocation.members.filter(ts.isPropertyDeclaration).find((p) => {
      const symbol3 = typeChecker.getSymbolAtLocation(p.name);
      return symbol3 && ts.symbolName(symbol3) === ts.symbolName(property);
    });
    if (oldProperty) {
      const start = ts.getTokenPosOfNode(oldProperty, sourceFile);
      changeTracker.deleteRange(sourceFile, {
        pos: start,
        end: oldProperty.end
      });
      changeTracker.insertNodeAt(sourceFile, start, propertyDeclaration);
    } else {
      changeTracker.insertNodeAt(sourceFile, insertLocation, propertyDeclaration, { suffix: "\n" });
    }
  }
});
var parse2 = fn("writeTagClassAccessors.parse")(function* (node) {
  const ts = yield* service(TypeScriptApi);
  const typeChecker = yield* service(TypeCheckerApi);
  const typeParser = yield* service(TypeParser);
  const typeCheckerUtils = yield* service(TypeCheckerUtils);
  if (!ts.isClassDeclaration(node)) return yield* fail("not a class declaration");
  const { Service, accessors: accessors2, className } = yield* pipe(
    typeParser.extendsEffectService(node),
    orElse2(() => map4(typeParser.extendsEffectTag(node), (_) => ({ accessors: true, ..._ }))),
    orElse2(() => fail("not a class extending Effect.Service call"))
  );
  if (accessors2 !== true) return yield* fail("accessors are not enabled in the Effect.Service call");
  const involvedMembers = [];
  const nonPrimitiveServices = typeCheckerUtils.unrollUnionMembers(Service).filter(
    (_) => !(_.flags & ts.TypeFlags.Number || _.flags & ts.TypeFlags.String || _.flags & ts.TypeFlags.Boolean || _.flags & ts.TypeFlags.Literal)
  );
  if (nonPrimitiveServices.length === 0) return yield* fail("Service type is a primitive type");
  for (const serviceShape of nonPrimitiveServices) {
    for (const property of typeChecker.getPropertiesOfType(serviceShape)) {
      const propertyType = typeChecker.getTypeOfSymbolAtLocation(property, node);
      const callSignatures = typeChecker.getSignaturesOfType(propertyType, ts.SignatureKind.Call);
      if (callSignatures.length > 0) {
        const withTypeParameters = callSignatures.filter((_) => _.typeParameters && _.typeParameters.length > 0);
        if (callSignatures.length > 1 || withTypeParameters.length > 0) involvedMembers.push({ property, propertyType });
      }
    }
  }
  const hash2 = involvedMembers.map(({ property, propertyType }) => {
    return ts.symbolName(property) + ": " + typeChecker.typeToString(propertyType);
  }).concat([ts.idText(className)]).join("\n");
  return { Service, className, atLocation: node, hash: cyrb53(hash2), involvedMembers };
});
var writeTagClassAccessors = createRefactor({
  name: "writeTagClassAccessors",
  description: "Implement accessors methods with generics or multiple signatures",
  apply: fn("writeTagClassAccessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const parseNode = (node) => pipe(
      parse2(node),
      map4(({ Service, atLocation, className, involvedMembers }) => ({
        kind: "refactor.rewrite.effect.writeTagClassAccessors",
        description: "Implement Service accessors",
        apply: pipe(
          generate(sourceFile, Service, className, atLocation, involvedMembers),
          provideService(TypeScriptUtils, tsUtils),
          provideService(TypeParser, typeParser),
          provideService(TypeCheckerApi, typeChecker),
          provideService(TypeScriptApi, ts)
        )
      }))
    );
    const parentNodes = tsUtils.getAncestorNodesInRange(sourceFile, textRange);
    return yield* pipe(
      firstSuccessOf(parentNodes.map(parseNode)),
      orElse2(() => fail(new RefactorNotApplicableError()))
    );
  })
});

// src/codegens/accessors.ts
var accessors = createCodegen({
  name: "accessors",
  apply: fn("accessors.apply")(function* (sourceFile, textRange) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const nodeAndCommentRange = tsUtils.findNodeWithLeadingCommentAtPosition(sourceFile, textRange.pos);
    if (!nodeAndCommentRange) return yield* fail(new CodegenNotApplicableError("no node and comment range"));
    return yield* pipe(
      parse2(nodeAndCommentRange.node),
      map4(
        (_) => ({
          hash: _.hash,
          description: "Generate accessors for the service",
          apply: pipe(
            generate(sourceFile, _.Service, _.className, _.atLocation, _.involvedMembers),
            provideService(TypeScriptApi, ts),
            provideService(TypeScriptUtils, tsUtils),
            provideService(TypeCheckerApi, typeChecker),
            provideService(TypeParser, typeParser),
            provideService(TypeCheckerUtils, typeCheckerUtils)
          )
        })
      ),
      orElse2((cause) => fail(new CodegenNotApplicableError(cause)))
    );
  })
});

// src/codegens.ts
var codegens = [accessors];

// src/diagnostics/outdatedEffectCodegen.ts
var outdatedEffectCodegen = createDiagnostic({
  name: "outdatedEffectCodegen",
  code: 19,
  severity: "warning",
  apply: fn("outdatedEffectCodegen.apply")(function* (sourceFile, _report) {
    const codegensWithRanges = yield* getCodegensForSourceFile(codegens, sourceFile);
    for (const { codegen, hash: hash2, range } of codegensWithRanges) {
      yield* pipe(
        getEditsForCodegen([codegen], sourceFile, range),
        map4((applicable) => {
          if (applicable.hash !== hash2) {
            _report({
              location: range,
              messageText: `Codegen ${codegen.name} result is outdated`,
              fixes: [
                {
                  fixName: "outdatedEffectCodegen_fix",
                  description: `Re-run ${codegen.name}`,
                  apply: applicable.apply
                },
                {
                  fixName: "outdatedEffectCodegen_ignore",
                  description: `Ignore this ${codegen.name} update`,
                  apply: applicable.ignore
                }
              ]
            });
          }
        }),
        orElse2(
          (e) => sync(() => {
            _report({
              location: range,
              messageText: `Codegen ${codegen.name} is not applicable here: ${e.cause}`,
              fixes: []
            });
          })
        ),
        ignore
      );
    }
  })
});

// src/diagnostics/overriddenSchemaConstructor.ts
var overriddenSchemaConstructor = createDiagnostic({
  name: "overriddenSchemaConstructor",
  code: 30,
  severity: "error",
  apply: fn("overriddenSchemaConstructor.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const typeChecker = yield* service(TypeCheckerApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      if (ts.isClassDeclaration(node) && node.heritageClauses) {
        let extendsSchema = false;
        for (const heritageClause of node.heritageClauses) {
          if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
            for (const type of heritageClause.types) {
              const typeAtLocation = typeChecker.getTypeAtLocation(type.expression);
              const isSchema = yield* pipe(
                typeParser.effectSchemaType(typeAtLocation, type.expression),
                map4(() => true),
                orElse2(() => succeed(false))
              );
              if (isSchema) {
                extendsSchema = true;
                break;
              }
            }
          }
          if (extendsSchema) break;
        }
        if (extendsSchema) {
          const members = node.members;
          for (const member of members) {
            if (ts.isConstructorDeclaration(member)) {
              const fixAsStaticNew = {
                fixName: "overriddenSchemaConstructor_static",
                description: "Rewrite using the static 'new' pattern",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const visitor = (node2) => {
                    if (ts.isExpressionStatement(node2) && ts.isCallExpression(node2.expression) && ts.isToken(node2.expression.expression) && node2.expression.expression.kind === ts.SyntaxKind.SuperKeyword) {
                      const constructThis = ts.factory.createNewExpression(
                        ts.factory.createIdentifier("this"),
                        void 0,
                        node2.expression.arguments
                      );
                      return ts.factory.createVariableStatement(
                        void 0,
                        ts.factory.createVariableDeclarationList(
                          [ts.factory.createVariableDeclaration(
                            "_this",
                            void 0,
                            void 0,
                            constructThis
                          )],
                          ts.NodeFlags.Const
                        )
                      );
                    }
                    if (ts.isToken(node2) && node2.kind === ts.SyntaxKind.ThisKeyword) {
                      return ts.factory.createIdentifier("_this");
                    }
                    return ts.visitEachChild(node2, visitor, ts.nullTransformationContext);
                  };
                  const newBody = visitor(member.body);
                  const bodyWithReturn = ts.factory.updateBlock(
                    newBody,
                    newBody.statements.concat([
                      ts.factory.createReturnStatement(ts.factory.createIdentifier("_this"))
                    ])
                  );
                  const newMethod = ts.factory.createMethodDeclaration(
                    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Public | ts.ModifierFlags.Static),
                    void 0,
                    "new",
                    void 0,
                    member.typeParameters,
                    member.parameters,
                    member.type,
                    bodyWithReturn
                  );
                  changeTracker.replaceNode(sourceFile, member, newMethod);
                })
              };
              report({
                location: member,
                messageText: "Classes extending Schema must not override the constructor; this is because it silently breaks the schema decoding behaviour. If that's needed, we recommend instead to use a static 'new' method that constructs the instance.",
                fixes: (member.body ? [fixAsStaticNew] : []).concat([{
                  fixName: "overriddenSchemaConstructor_fix",
                  description: "Remove the constructor override",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.delete(sourceFile, member);
                  })
                }])
              });
              break;
            }
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/returnEffectInGen.ts
var returnEffectInGen = createDiagnostic({
  name: "returnEffectInGen",
  code: 11,
  severity: "suggestion",
  apply: fn("returnEffectInGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isReturnStatement(node) && node.expression) {
        if (ts.isYieldExpression(node.expression)) continue;
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        const type = typeChecker.getTypeAtLocation(node.expression);
        const maybeEffect = yield* option(typeParser.strictEffectType(type, node.expression));
        if (isSome2(maybeEffect)) {
          if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
            const effectGenNode = generatorOrRegularFunction.parent;
            yield* pipe(
              typeParser.effectGen(effectGenNode),
              orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
              orElse2(() => typeParser.effectFnGen(effectGenNode)),
              map4(() => {
                const fix = node.expression ? [{
                  fixName: "returnEffectInGen_fix",
                  description: "Add yield* statement",
                  apply: gen(function* () {
                    const changeTracker = yield* service(ChangeTracker);
                    changeTracker.replaceNode(
                      sourceFile,
                      node.expression,
                      ts.factory.createYieldExpression(
                        ts.factory.createToken(ts.SyntaxKind.AsteriskToken),
                        node.expression
                      )
                    );
                  })
                }] : [];
                report({
                  location: node,
                  messageText: `You are returning an Effect-able type inside a generator function, and will result in nested Effect<Effect<...>>.
Maybe you wanted to return yield* instead?
Nested Effect-able types may be intended if you plan to later manually flatten or unwrap this Effect, if so you can safely disable this diagnostic for this line through quickfixes.`,
                  fixes: fix
                });
              }),
              ignore
            );
          }
        }
      }
    }
  })
});

// src/diagnostics/scopeInLayerEffect.ts
var scopeInLayerEffect = createDiagnostic({
  name: "scopeInLayerEffect",
  code: 13,
  severity: "warning",
  apply: fn("scopeInLayerEffect.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const tsUtils = yield* service(TypeScriptUtils);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const layerModuleIdentifier = tsUtils.findImportedModuleIdentifierByPackageAndNameOrBarrel(
      sourceFile,
      "effect",
      "Layer"
    ) || "Layer";
    function parseLayerEffectApiCall(node) {
      if (!ts.isCallExpression(node)) return;
      const expression = node.expression;
      if (!ts.isPropertyAccessExpression(expression)) return;
      const calledModule = expression.expression;
      if (!(ts.isIdentifier(calledModule) && ts.idText(calledModule) === layerModuleIdentifier)) return;
      const methodIdentifier = expression.name;
      if (!(ts.isIdentifier(methodIdentifier) && ts.idText(methodIdentifier).toLowerCase().startsWith("effect"))) return;
      return { methodIdentifier };
    }
    const reportIfLayerRequireScope = (type, node, methodIdentifier) => {
      const entries = typeCheckerUtils.unrollUnionMembers(type);
      return pipe(
        firstSuccessOf(entries.map((type2) => typeParser.scopeType(type2, node))),
        map4(
          () => report({
            location: node,
            messageText: `Seems like you are constructing a layer with a scope in the requirements.
Consider using "scoped" instead to get rid of the scope in the requirements.`,
            fixes: methodIdentifier ? [{
              fixName: "scopeInLayerEffect_scoped",
              description: "Use scoped for Layer creation",
              apply: gen(function* () {
                const changeTracker = yield* service(ChangeTracker);
                changeTracker.replaceNode(
                  sourceFile,
                  methodIdentifier,
                  ts.factory.createIdentifier("scoped")
                );
              })
            }] : []
          })
        ),
        ignore
      );
    };
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      const layerEffectApiCall = parseLayerEffectApiCall(node);
      if (layerEffectApiCall) {
        const type = typeChecker.getTypeAtLocation(node);
        yield* pipe(
          typeParser.layerType(type, node),
          flatMap2(({ RIn }) => reportIfLayerRequireScope(RIn, node, layerEffectApiCall.methodIdentifier)),
          ignore
        );
        continue;
      }
      if (ts.isClassDeclaration(node) && node.name && node.heritageClauses) {
        const classSym = typeChecker.getSymbolAtLocation(node.name);
        if (classSym) {
          const classType = typeChecker.getTypeOfSymbol(classSym);
          const defaultLayer = typeChecker.getPropertyOfType(classType, "Default");
          if (defaultLayer) {
            const type = typeChecker.getTypeOfSymbolAtLocation(defaultLayer, node);
            yield* pipe(
              typeParser.layerType(type, node),
              flatMap2(({ RIn }) => reportIfLayerRequireScope(RIn, node, void 0)),
              ignore
            );
            continue;
          }
        }
      }
      ts.forEachChild(node, appendNodeToVisit);
    }
  })
});

// src/diagnostics/strictBooleanExpressions.ts
var strictBooleanExpressions = createDiagnostic({
  name: "strictBooleanExpressions",
  code: 17,
  severity: "off",
  apply: fn("strictBooleanExpressions.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeCheckerUtils = yield* service(TypeCheckerUtils);
    const conditionChecks = /* @__PURE__ */ new WeakMap();
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      const nodes = [];
      if (ts.isIfStatement(node)) {
        conditionChecks.set(node, true);
        nodes.push(node.expression);
      } else if (ts.isWhileStatement(node)) {
        conditionChecks.set(node, true);
        nodes.push(node.expression);
      } else if (ts.isConditionalExpression(node)) {
        conditionChecks.set(node, true);
        nodes.push(node.condition);
      } else if (ts.isPrefixUnaryExpression(node) && node.operator === ts.SyntaxKind.ExclamationToken) {
        conditionChecks.set(node, true);
        nodes.push(node.operand);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes.push(node.left);
        nodes.push(node.right);
      } else if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {
        if (conditionChecks.has(node.parent)) conditionChecks.set(node, true);
        nodes.push(node.left);
        nodes.push(node.right);
      }
      for (const nodeToCheck of nodes) {
        if (!nodeToCheck) continue;
        if (!conditionChecks.has(nodeToCheck.parent)) continue;
        const nodeType = typeChecker.getTypeAtLocation(nodeToCheck);
        const constrainedType = typeChecker.getBaseConstraintOfType(nodeType);
        let typesToCheck = [constrainedType || nodeType];
        while (typesToCheck.length > 0) {
          const type = typesToCheck.pop();
          if (typeCheckerUtils.isUnion(type)) {
            typesToCheck = typesToCheck.concat(type.types);
            continue;
          }
          if (type.flags & ts.TypeFlags.Boolean) continue;
          if (type.flags & ts.TypeFlags.Never) continue;
          if (type.flags & ts.TypeFlags.BooleanLiteral) continue;
          const typeName = typeChecker.typeToString(type);
          report({
            location: nodeToCheck,
            messageText: `Unexpected \`${typeName}\` type in condition, expected strictly a boolean instead.`,
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/strictEffectProvide.ts
var strictEffectProvide = createDiagnostic({
  name: "strictEffectProvide",
  code: 27,
  severity: "off",
  apply: fn("strictEffectProvide.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeChecker = yield* service(TypeCheckerApi);
    const typeParser = yield* service(TypeParser);
    const parseEffectProvideWithLayer = (node) => gen(function* () {
      if (!ts.isCallExpression(node) || node.arguments.length === 0) {
        return yield* typeParserIssue("Not an Effect.provide call");
      }
      yield* typeParser.isNodeReferenceToEffectModuleApi("provide")(node.expression);
      return yield* firstSuccessOf(
        node.arguments.map((arg) => {
          const argType = typeChecker.getTypeAtLocation(arg);
          return typeParser.layerType(argType, arg);
        })
      );
    });
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        const layerCheck = yield* pipe(parseEffectProvideWithLayer(node), option);
        if (isSome2(layerCheck)) {
          report({
            location: node,
            messageText: "Effect.provide with a Layer should only be used at application entry points. If this is an entry point, you can safely disable this diagnostic. Otherwise, using Effect.provide may break scope lifetimes. Compose all layers at your entry point and provide them at once.",
            fixes: []
          });
        }
      }
    }
  })
});

// src/diagnostics/tryCatchInEffectGen.ts
var tryCatchInEffectGen = createDiagnostic({
  name: "tryCatchInEffectGen",
  code: 15,
  severity: "suggestion",
  apply: fn("tryCatchInEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isTryStatement(node) && node.catchClause) {
        const generatorOrRegularFunction = ts.findAncestor(
          node,
          (_) => ts.isFunctionExpression(_) || ts.isFunctionDeclaration(_) || ts.isMethodDeclaration(_) || ts.isArrowFunction(_) || ts.isGetAccessor(_) || ts.isFunctionLike(_)
        );
        if (!(generatorOrRegularFunction && "asteriskToken" in generatorOrRegularFunction && generatorOrRegularFunction.asteriskToken)) continue;
        if (!generatorOrRegularFunction) continue;
        if (generatorOrRegularFunction && generatorOrRegularFunction.parent) {
          const effectGenNode = generatorOrRegularFunction.parent;
          yield* pipe(
            typeParser.effectGen(effectGenNode),
            orElse2(() => typeParser.effectFnUntracedGen(effectGenNode)),
            orElse2(() => typeParser.effectFnGen(effectGenNode)),
            map4(() => {
              report({
                location: node,
                messageText: "Avoid using try/catch inside Effect generators. Use Effect's error handling mechanisms instead (e.g., Effect.try, Effect.tryPromise, Effect.catchAll, Effect.catchTag).",
                fixes: []
              });
            }),
            ignore
          );
        }
      }
    }
  })
});

// src/diagnostics/unnecessaryEffectGen.ts
var unnecessaryEffectGen = createDiagnostic({
  name: "unnecessaryEffectGen",
  code: 5,
  severity: "suggestion",
  apply: fn("unnecessaryEffectGen.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.unnecessaryEffectGen(node),
          map4(
            ({ replacementNode }) => report({
              location: node,
              messageText: `This Effect.gen contains a single return statement.`,
              fixes: [{
                fixName: "unnecessaryEffectGen_fix",
                description: "Remove the Effect.gen, and keep the body",
                apply: gen(function* () {
                  const textChanges = yield* service(
                    ChangeTracker
                  );
                  textChanges.replaceNode(sourceFile, node, yield* replacementNode);
                })
              }]
            })
          ),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipe.ts
var unnecessaryPipe = createDiagnostic({
  name: "unnecessaryPipe",
  code: 9,
  severity: "suggestion",
  apply: fn("unnecessaryPipe.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          map4(({ args: args2, subject }) => {
            if (args2.length === 0) {
              report({
                location: node,
                messageText: `This pipe call contains no arguments.`,
                fixes: [{
                  fixName: "unnecessaryPipe_fix",
                  description: "Remove the pipe call",
                  apply: gen(function* () {
                    const textChanges = yield* service(
                      ChangeTracker
                    );
                    textChanges.replaceNode(sourceFile, node, subject);
                  })
                }]
              });
            }
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unnecessaryPipeChain.ts
var unnecessaryPipeChain = createDiagnostic({
  name: "unnecessaryPipeChain",
  code: 16,
  severity: "suggestion",
  apply: fn("unnecessaryPipeChain.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const typeParser = yield* service(TypeParser);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isCallExpression(node)) {
        yield* pipe(
          typeParser.pipeCall(node),
          flatMap2(
            (pipeCall) => map4(typeParser.pipeCall(pipeCall.subject), (innerCall) => ({ pipeCall, innerCall }))
          ),
          map4(({ innerCall, pipeCall }) => {
            report({
              location: node,
              messageText: `Chained pipe calls can be simplified to a single pipe call`,
              fixes: [{
                fixName: "unnecessaryPipeChain_fix",
                description: "Rewrite as single pipe call",
                apply: gen(function* () {
                  const changeTracker = yield* service(
                    ChangeTracker
                  );
                  switch (innerCall.kind) {
                    case "pipe": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createIdentifier("pipe"),
                          void 0,
                          [innerCall.subject, ...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                    case "pipeable": {
                      changeTracker.replaceNode(
                        sourceFile,
                        node,
                        ts.factory.createCallExpression(
                          ts.factory.createPropertyAccessExpression(
                            innerCall.subject,
                            "pipe"
                          ),
                          void 0,
                          [...innerCall.args, ...pipeCall.args]
                        )
                      );
                      break;
                    }
                  }
                })
              }]
            });
          }),
          ignore
        );
      }
    }
  })
});

// src/diagnostics/unsupportedServiceAccessors.ts
var unsupportedServiceAccessors = createDiagnostic({
  name: "unsupportedServiceAccessors",
  code: 21,
  severity: "warning",
  apply: fn("unsupportedServiceAccessors.apply")(function* (sourceFile, report) {
    const ts = yield* service(TypeScriptApi);
    const nodeToVisit = [];
    const appendNodeToVisit = (node) => {
      nodeToVisit.push(node);
      return void 0;
    };
    ts.forEachChild(sourceFile, appendNodeToVisit);
    while (nodeToVisit.length > 0) {
      const node = nodeToVisit.shift();
      ts.forEachChild(node, appendNodeToVisit);
      if (ts.isClassDeclaration(node)) {
        const parseResult = yield* pipe(
          parse2(node),
          orElse2(() => succeed(null))
        );
        if (parseResult && parseResult.involvedMembers.length > 0) {
          const existingStaticMembers = /* @__PURE__ */ new Set();
          node.members?.forEach((member) => {
            if (ts.isPropertyDeclaration(member) && member.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.StaticKeyword)) {
              if (member.name && ts.isIdentifier(member.name)) {
                existingStaticMembers.add(ts.idText(member.name));
              }
            }
          });
          const missingMembers = parseResult.involvedMembers.filter(
            ({ property }) => !existingStaticMembers.has(ts.symbolName(property))
          );
          if (missingMembers.length > 0) {
            const memberNames = missingMembers.map(({ property }) => `'${ts.symbolName(property)}'`).join(", ");
            report({
              location: parseResult.className,
              messageText: `Even if accessors are enabled, accessors for ${memberNames} won't be available because the signature have generic type parameters or multiple call signatures.`,
              fixes: [{
                fixName: "unsupportedServiceAccessors_enableCodegen",
                description: "Enable accessors codegen",
                apply: gen(function* () {
                  const changeTracker = yield* service(ChangeTracker);
                  const comment = "// @effect-codegens accessors\n";
                  changeTracker.insertText(sourceFile, ts.getTokenPosOfNode(node, sourceFile), comment);
                })
              }]
            });
          }
        }
      }
    }
  })
});

// src/diagnostics.ts
var diagnostics = [
  catchUnfailableEffect,
  classSelfMismatch,
  duplicatePackage,
  effectGenUsesAdapter,
  missingEffectContext,
  missingEffectError,
  missingEffectServiceDependency,
  floatingEffect,
  missingStarInYieldEffectGen,
  unnecessaryEffectGen,
  missingReturnYieldStar,
  leakingRequirements,
  unnecessaryPipe,
  genericEffectServices,
  returnEffectInGen,
  tryCatchInEffectGen,
  importFromBarrel,
  scopeInLayerEffect,
  effectInVoidSuccess,
  unnecessaryPipeChain,
  strictBooleanExpressions,
  multipleEffectProvide,
  outdatedEffectCodegen,
  overriddenSchemaConstructor,
  unsupportedServiceAccessors,
  nonObjectEffectServiceType,
  deterministicKeys,
  missedPipeableOpportunity,
  strictEffectProvide
];

// src/transform.ts
function transform_default(program, pluginConfig, { addDiagnostic, ts: tsInstance }) {
  return (_) => {
    return (sourceFile) => {
      pipe(
        getSemanticDiagnosticsWithCodeFixes(diagnostics, sourceFile),
        nanoLayer3,
        nanoLayer2,
        nanoLayer,
        provideService(TypeCheckerApi, program.getTypeChecker()),
        provideService(TypeScriptProgram, program),
        provideService(TypeScriptApi, tsInstance),
        provideService(
          LanguageServicePluginOptions,
          parse(pluginConfig)
        ),
        run,
        map((_2) => _2.diagnostics),
        map(
          filter(
            (_2) => _2.category === tsInstance.DiagnosticCategory.Error || _2.category === tsInstance.DiagnosticCategory.Warning
          )
        ),
        getOrElse(() => []),
        map3(addDiagnostic)
      );
      return sourceFile;
    };
  };
}
//# sourceMappingURL=transform.js.map